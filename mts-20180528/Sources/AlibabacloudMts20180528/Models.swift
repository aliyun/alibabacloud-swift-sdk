import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class ActivateMediaWorkflowRequest : Tea.TeaModel {
    public var mediaWorkflowId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowId != nil {
            map["MediaWorkflowId"] = self.mediaWorkflowId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowId") {
            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ActivateMediaWorkflowResponseBody : Tea.TeaModel {
    public class MediaWorkflow : Tea.TeaModel {
        public var creationTime: String?

        public var mediaWorkflowId: String?

        public var name: String?

        public var state: String?

        public var topology: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.mediaWorkflowId != nil {
                map["MediaWorkflowId"] = self.mediaWorkflowId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.topology != nil {
                map["Topology"] = self.topology!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("MediaWorkflowId") {
                self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Topology") {
                self.topology = dict["Topology"] as! String
            }
        }
    }
    public var mediaWorkflow: ActivateMediaWorkflowResponseBody.MediaWorkflow?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflow?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflow != nil {
            map["MediaWorkflow"] = self.mediaWorkflow?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflow") {
            var model = ActivateMediaWorkflowResponseBody.MediaWorkflow()
            model.fromMap(dict["MediaWorkflow"] as! [String: Any])
            self.mediaWorkflow = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ActivateMediaWorkflowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ActivateMediaWorkflowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ActivateMediaWorkflowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddCategoryRequest : Tea.TeaModel {
    public var cateName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var parentId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateName != nil {
            map["CateName"] = self.cateName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateName") {
            self.cateName = dict["CateName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ParentId") {
            self.parentId = dict["ParentId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AddCategoryResponseBody : Tea.TeaModel {
    public class Category : Tea.TeaModel {
        public var cateId: String?

        public var cateName: String?

        public var level: String?

        public var parentId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.cateName != nil {
                map["CateName"] = self.cateName!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! String
            }
            if dict.keys.contains("CateName") {
                self.cateName = dict["CateName"] as! String
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! String
            }
            if dict.keys.contains("ParentId") {
                self.parentId = dict["ParentId"] as! String
            }
        }
    }
    public var category: AddCategoryResponseBody.Category?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.category?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            var model = AddCategoryResponseBody.Category()
            model.fromMap(dict["Category"] as! [String: Any])
            self.category = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMediaRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var coverURL: String?

    public var description_: String?

    public var fileURL: String?

    public var inputUnbind: Bool?

    public var mediaWorkflowId: String?

    public var mediaWorkflowUserData: String?

    public var overrideParams: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.inputUnbind != nil {
            map["InputUnbind"] = self.inputUnbind!
        }
        if self.mediaWorkflowId != nil {
            map["MediaWorkflowId"] = self.mediaWorkflowId!
        }
        if self.mediaWorkflowUserData != nil {
            map["MediaWorkflowUserData"] = self.mediaWorkflowUserData!
        }
        if self.overrideParams != nil {
            map["OverrideParams"] = self.overrideParams!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("FileURL") {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("InputUnbind") {
            self.inputUnbind = dict["InputUnbind"] as! Bool
        }
        if dict.keys.contains("MediaWorkflowId") {
            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
        }
        if dict.keys.contains("MediaWorkflowUserData") {
            self.mediaWorkflowUserData = dict["MediaWorkflowUserData"] as! String
        }
        if dict.keys.contains("OverrideParams") {
            self.overrideParams = dict["OverrideParams"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class AddMediaResponseBody : Tea.TeaModel {
    public class Media : Tea.TeaModel {
        public class File : Tea.TeaModel {
            public var state: String?

            public var URL: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.URL != nil {
                    map["URL"] = self.URL!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("URL") {
                    self.URL = dict["URL"] as! String
                }
            }
        }
        public class RunIdList : Tea.TeaModel {
            public var runId: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.runId != nil {
                    map["RunId"] = self.runId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RunId") {
                    self.runId = dict["RunId"] as! [String]
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var tag: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Tag") {
                    self.tag = dict["Tag"] as! [String]
                }
            }
        }
        public var bitrate: String?

        public var cateId: Int64?

        public var censorState: String?

        public var coverURL: String?

        public var creationTime: String?

        public var description_: String?

        public var duration: String?

        public var file: AddMediaResponseBody.Media.File?

        public var format: String?

        public var fps: String?

        public var height: String?

        public var mediaId: String?

        public var publishState: String?

        public var runIdList: AddMediaResponseBody.Media.RunIdList?

        public var size: String?

        public var tags: AddMediaResponseBody.Media.Tags?

        public var title: String?

        public var width: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.file?.validate()
            try self.runIdList?.validate()
            try self.tags?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bitrate != nil {
                map["Bitrate"] = self.bitrate!
            }
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.censorState != nil {
                map["CensorState"] = self.censorState!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.file != nil {
                map["File"] = self.file?.toMap()
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.fps != nil {
                map["Fps"] = self.fps!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.publishState != nil {
                map["PublishState"] = self.publishState!
            }
            if self.runIdList != nil {
                map["RunIdList"] = self.runIdList?.toMap()
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.tags != nil {
                map["Tags"] = self.tags?.toMap()
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bitrate") {
                self.bitrate = dict["Bitrate"] as! String
            }
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CensorState") {
                self.censorState = dict["CensorState"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("File") {
                var model = AddMediaResponseBody.Media.File()
                model.fromMap(dict["File"] as! [String: Any])
                self.file = model
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("Fps") {
                self.fps = dict["Fps"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("PublishState") {
                self.publishState = dict["PublishState"] as! String
            }
            if dict.keys.contains("RunIdList") {
                var model = AddMediaResponseBody.Media.RunIdList()
                model.fromMap(dict["RunIdList"] as! [String: Any])
                self.runIdList = model
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! String
            }
            if dict.keys.contains("Tags") {
                var model = AddMediaResponseBody.Media.Tags()
                model.fromMap(dict["Tags"] as! [String: Any])
                self.tags = model
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! String
            }
        }
    }
    public var media: AddMediaResponseBody.Media?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.media?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.media != nil {
            map["Media"] = self.media?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Media") {
            var model = AddMediaResponseBody.Media()
            model.fromMap(dict["Media"] as! [String: Any])
            self.media = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMediaTagRequest : Tea.TeaModel {
    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! String
        }
    }
}

public class AddMediaTagResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddMediaTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMediaTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddMediaTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMediaWorkflowRequest : Tea.TeaModel {
    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var topology: String?

    public var triggerMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.topology != nil {
            map["Topology"] = self.topology!
        }
        if self.triggerMode != nil {
            map["TriggerMode"] = self.triggerMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Topology") {
            self.topology = dict["Topology"] as! String
        }
        if dict.keys.contains("TriggerMode") {
            self.triggerMode = dict["TriggerMode"] as! String
        }
    }
}

public class AddMediaWorkflowResponseBody : Tea.TeaModel {
    public class MediaWorkflow : Tea.TeaModel {
        public var creationTime: String?

        public var mediaWorkflowId: String?

        public var name: String?

        public var state: String?

        public var topology: String?

        public var triggerMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.mediaWorkflowId != nil {
                map["MediaWorkflowId"] = self.mediaWorkflowId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.topology != nil {
                map["Topology"] = self.topology!
            }
            if self.triggerMode != nil {
                map["TriggerMode"] = self.triggerMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("MediaWorkflowId") {
                self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Topology") {
                self.topology = dict["Topology"] as! String
            }
            if dict.keys.contains("TriggerMode") {
                self.triggerMode = dict["TriggerMode"] as! String
            }
        }
    }
    public var mediaWorkflow: AddMediaWorkflowResponseBody.MediaWorkflow?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflow?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflow != nil {
            map["MediaWorkflow"] = self.mediaWorkflow?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflow") {
            var model = AddMediaWorkflowResponseBody.MediaWorkflow()
            model.fromMap(dict["MediaWorkflow"] as! [String: Any])
            self.mediaWorkflow = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddMediaWorkflowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMediaWorkflowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddMediaWorkflowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPipelineRequest : Tea.TeaModel {
    public var name: String?

    public var notifyConfig: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var role: String?

    public var speed: String?

    public var speedLevel: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifyConfig != nil {
            map["NotifyConfig"] = self.notifyConfig!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.speed != nil {
            map["Speed"] = self.speed!
        }
        if self.speedLevel != nil {
            map["SpeedLevel"] = self.speedLevel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NotifyConfig") {
            self.notifyConfig = dict["NotifyConfig"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! String
        }
        if dict.keys.contains("Speed") {
            self.speed = dict["Speed"] as! String
        }
        if dict.keys.contains("SpeedLevel") {
            self.speedLevel = dict["SpeedLevel"] as! Int64
        }
    }
}

public class AddPipelineResponseBody : Tea.TeaModel {
    public class Pipeline : Tea.TeaModel {
        public class NotifyConfig : Tea.TeaModel {
            public var queueName: String?

            public var topic: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.queueName != nil {
                    map["QueueName"] = self.queueName!
                }
                if self.topic != nil {
                    map["Topic"] = self.topic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("QueueName") {
                    self.queueName = dict["QueueName"] as! String
                }
                if dict.keys.contains("Topic") {
                    self.topic = dict["Topic"] as! String
                }
            }
        }
        public var id: String?

        public var name: String?

        public var notifyConfig: AddPipelineResponseBody.Pipeline.NotifyConfig?

        public var role: String?

        public var speed: String?

        public var speedLevel: Int64?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.notifyConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifyConfig != nil {
                map["NotifyConfig"] = self.notifyConfig?.toMap()
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.speed != nil {
                map["Speed"] = self.speed!
            }
            if self.speedLevel != nil {
                map["SpeedLevel"] = self.speedLevel!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NotifyConfig") {
                var model = AddPipelineResponseBody.Pipeline.NotifyConfig()
                model.fromMap(dict["NotifyConfig"] as! [String: Any])
                self.notifyConfig = model
            }
            if dict.keys.contains("Role") {
                self.role = dict["Role"] as! String
            }
            if dict.keys.contains("Speed") {
                self.speed = dict["Speed"] as! String
            }
            if dict.keys.contains("SpeedLevel") {
                self.speedLevel = dict["SpeedLevel"] as! Int64
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var pipeline: AddPipelineResponseBody.Pipeline?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipeline != nil {
            map["Pipeline"] = self.pipeline?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pipeline") {
            var model = AddPipelineResponseBody.Pipeline()
            model.fromMap(dict["Pipeline"] as! [String: Any])
            self.pipeline = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddPipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddPipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddTemplateRequest : Tea.TeaModel {
    public var audio: String?

    public var container: String?

    public var muxConfig: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var transConfig: String?

    public var video: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audio != nil {
            map["Audio"] = self.audio!
        }
        if self.container != nil {
            map["Container"] = self.container!
        }
        if self.muxConfig != nil {
            map["MuxConfig"] = self.muxConfig!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.transConfig != nil {
            map["TransConfig"] = self.transConfig!
        }
        if self.video != nil {
            map["Video"] = self.video!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Audio") {
            self.audio = dict["Audio"] as! String
        }
        if dict.keys.contains("Container") {
            self.container = dict["Container"] as! String
        }
        if dict.keys.contains("MuxConfig") {
            self.muxConfig = dict["MuxConfig"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TransConfig") {
            self.transConfig = dict["TransConfig"] as! String
        }
        if dict.keys.contains("Video") {
            self.video = dict["Video"] as! String
        }
    }
}

public class AddTemplateResponseBody : Tea.TeaModel {
    public class Template : Tea.TeaModel {
        public class Audio : Tea.TeaModel {
            public class Volume : Tea.TeaModel {
                public var level: String?

                public var method: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.method != nil {
                        map["Method"] = self.method!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("Method") {
                        self.method = dict["Method"] as! String
                    }
                }
            }
            public var bitrate: String?

            public var channels: String?

            public var codec: String?

            public var profile: String?

            public var qscale: String?

            public var remove: String?

            public var samplerate: String?

            public var volume: AddTemplateResponseBody.Template.Audio.Volume?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.volume?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.qscale != nil {
                    map["Qscale"] = self.qscale!
                }
                if self.remove != nil {
                    map["Remove"] = self.remove!
                }
                if self.samplerate != nil {
                    map["Samplerate"] = self.samplerate!
                }
                if self.volume != nil {
                    map["Volume"] = self.volume?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Channels") {
                    self.channels = dict["Channels"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Qscale") {
                    self.qscale = dict["Qscale"] as! String
                }
                if dict.keys.contains("Remove") {
                    self.remove = dict["Remove"] as! String
                }
                if dict.keys.contains("Samplerate") {
                    self.samplerate = dict["Samplerate"] as! String
                }
                if dict.keys.contains("Volume") {
                    var model = AddTemplateResponseBody.Template.Audio.Volume()
                    model.fromMap(dict["Volume"] as! [String: Any])
                    self.volume = model
                }
            }
        }
        public class Container : Tea.TeaModel {
            public var format: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.format != nil {
                    map["Format"] = self.format!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
            }
        }
        public class MuxConfig : Tea.TeaModel {
            public class Gif : Tea.TeaModel {
                public var ditherMode: String?

                public var finalDelay: String?

                public var isCustomPalette: String?

                public var loop: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ditherMode != nil {
                        map["DitherMode"] = self.ditherMode!
                    }
                    if self.finalDelay != nil {
                        map["FinalDelay"] = self.finalDelay!
                    }
                    if self.isCustomPalette != nil {
                        map["IsCustomPalette"] = self.isCustomPalette!
                    }
                    if self.loop != nil {
                        map["Loop"] = self.loop!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DitherMode") {
                        self.ditherMode = dict["DitherMode"] as! String
                    }
                    if dict.keys.contains("FinalDelay") {
                        self.finalDelay = dict["FinalDelay"] as! String
                    }
                    if dict.keys.contains("IsCustomPalette") {
                        self.isCustomPalette = dict["IsCustomPalette"] as! String
                    }
                    if dict.keys.contains("Loop") {
                        self.loop = dict["Loop"] as! String
                    }
                }
            }
            public class Segment : Tea.TeaModel {
                public var duration: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                }
            }
            public class Webp : Tea.TeaModel {
                public var loop: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.loop != nil {
                        map["Loop"] = self.loop!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Loop") {
                        self.loop = dict["Loop"] as! String
                    }
                }
            }
            public var gif: AddTemplateResponseBody.Template.MuxConfig.Gif?

            public var segment: AddTemplateResponseBody.Template.MuxConfig.Segment?

            public var webp: AddTemplateResponseBody.Template.MuxConfig.Webp?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.gif?.validate()
                try self.segment?.validate()
                try self.webp?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gif != nil {
                    map["Gif"] = self.gif?.toMap()
                }
                if self.segment != nil {
                    map["Segment"] = self.segment?.toMap()
                }
                if self.webp != nil {
                    map["Webp"] = self.webp?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Gif") {
                    var model = AddTemplateResponseBody.Template.MuxConfig.Gif()
                    model.fromMap(dict["Gif"] as! [String: Any])
                    self.gif = model
                }
                if dict.keys.contains("Segment") {
                    var model = AddTemplateResponseBody.Template.MuxConfig.Segment()
                    model.fromMap(dict["Segment"] as! [String: Any])
                    self.segment = model
                }
                if dict.keys.contains("Webp") {
                    var model = AddTemplateResponseBody.Template.MuxConfig.Webp()
                    model.fromMap(dict["Webp"] as! [String: Any])
                    self.webp = model
                }
            }
        }
        public class TransConfig : Tea.TeaModel {
            public var adjDarMethod: String?

            public var isCheckAudioBitrate: String?

            public var isCheckAudioBitrateFail: String?

            public var isCheckReso: String?

            public var isCheckResoFail: String?

            public var isCheckVideoBitrate: String?

            public var isCheckVideoBitrateFail: String?

            public var transMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adjDarMethod != nil {
                    map["AdjDarMethod"] = self.adjDarMethod!
                }
                if self.isCheckAudioBitrate != nil {
                    map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                }
                if self.isCheckAudioBitrateFail != nil {
                    map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                }
                if self.isCheckReso != nil {
                    map["IsCheckReso"] = self.isCheckReso!
                }
                if self.isCheckResoFail != nil {
                    map["IsCheckResoFail"] = self.isCheckResoFail!
                }
                if self.isCheckVideoBitrate != nil {
                    map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                }
                if self.isCheckVideoBitrateFail != nil {
                    map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                }
                if self.transMode != nil {
                    map["TransMode"] = self.transMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdjDarMethod") {
                    self.adjDarMethod = dict["AdjDarMethod"] as! String
                }
                if dict.keys.contains("IsCheckAudioBitrate") {
                    self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                }
                if dict.keys.contains("IsCheckAudioBitrateFail") {
                    self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                }
                if dict.keys.contains("IsCheckReso") {
                    self.isCheckReso = dict["IsCheckReso"] as! String
                }
                if dict.keys.contains("IsCheckResoFail") {
                    self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                }
                if dict.keys.contains("IsCheckVideoBitrate") {
                    self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                }
                if dict.keys.contains("IsCheckVideoBitrateFail") {
                    self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                }
                if dict.keys.contains("TransMode") {
                    self.transMode = dict["TransMode"] as! String
                }
            }
        }
        public class Video : Tea.TeaModel {
            public class BitrateBnd : Tea.TeaModel {
                public var max: String?

                public var min: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.max != nil {
                        map["Max"] = self.max!
                    }
                    if self.min != nil {
                        map["Min"] = self.min!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Max") {
                        self.max = dict["Max"] as! String
                    }
                    if dict.keys.contains("Min") {
                        self.min = dict["Min"] as! String
                    }
                }
            }
            public var bitrate: String?

            public var bitrateBnd: AddTemplateResponseBody.Template.Video.BitrateBnd?

            public var bufsize: String?

            public var codec: String?

            public var crf: String?

            public var crop: String?

            public var degrain: String?

            public var fps: String?

            public var gop: String?

            public var height: String?

            public var maxFps: String?

            public var maxrate: String?

            public var pad: String?

            public var pixFmt: String?

            public var preset: String?

            public var profile: String?

            public var qscale: String?

            public var remove: String?

            public var resoPriority: String?

            public var scanMode: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.bitrateBnd?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.bitrateBnd != nil {
                    map["BitrateBnd"] = self.bitrateBnd?.toMap()
                }
                if self.bufsize != nil {
                    map["Bufsize"] = self.bufsize!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.crf != nil {
                    map["Crf"] = self.crf!
                }
                if self.crop != nil {
                    map["Crop"] = self.crop!
                }
                if self.degrain != nil {
                    map["Degrain"] = self.degrain!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.gop != nil {
                    map["Gop"] = self.gop!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.maxFps != nil {
                    map["MaxFps"] = self.maxFps!
                }
                if self.maxrate != nil {
                    map["Maxrate"] = self.maxrate!
                }
                if self.pad != nil {
                    map["Pad"] = self.pad!
                }
                if self.pixFmt != nil {
                    map["PixFmt"] = self.pixFmt!
                }
                if self.preset != nil {
                    map["Preset"] = self.preset!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.qscale != nil {
                    map["Qscale"] = self.qscale!
                }
                if self.remove != nil {
                    map["Remove"] = self.remove!
                }
                if self.resoPriority != nil {
                    map["ResoPriority"] = self.resoPriority!
                }
                if self.scanMode != nil {
                    map["ScanMode"] = self.scanMode!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("BitrateBnd") {
                    var model = AddTemplateResponseBody.Template.Video.BitrateBnd()
                    model.fromMap(dict["BitrateBnd"] as! [String: Any])
                    self.bitrateBnd = model
                }
                if dict.keys.contains("Bufsize") {
                    self.bufsize = dict["Bufsize"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Crf") {
                    self.crf = dict["Crf"] as! String
                }
                if dict.keys.contains("Crop") {
                    self.crop = dict["Crop"] as! String
                }
                if dict.keys.contains("Degrain") {
                    self.degrain = dict["Degrain"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Gop") {
                    self.gop = dict["Gop"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("MaxFps") {
                    self.maxFps = dict["MaxFps"] as! String
                }
                if dict.keys.contains("Maxrate") {
                    self.maxrate = dict["Maxrate"] as! String
                }
                if dict.keys.contains("Pad") {
                    self.pad = dict["Pad"] as! String
                }
                if dict.keys.contains("PixFmt") {
                    self.pixFmt = dict["PixFmt"] as! String
                }
                if dict.keys.contains("Preset") {
                    self.preset = dict["Preset"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Qscale") {
                    self.qscale = dict["Qscale"] as! String
                }
                if dict.keys.contains("Remove") {
                    self.remove = dict["Remove"] as! String
                }
                if dict.keys.contains("ResoPriority") {
                    self.resoPriority = dict["ResoPriority"] as! String
                }
                if dict.keys.contains("ScanMode") {
                    self.scanMode = dict["ScanMode"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var audio: AddTemplateResponseBody.Template.Audio?

        public var container: AddTemplateResponseBody.Template.Container?

        public var id: String?

        public var muxConfig: AddTemplateResponseBody.Template.MuxConfig?

        public var name: String?

        public var state: String?

        public var transConfig: AddTemplateResponseBody.Template.TransConfig?

        public var video: AddTemplateResponseBody.Template.Video?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.audio?.validate()
            try self.container?.validate()
            try self.muxConfig?.validate()
            try self.transConfig?.validate()
            try self.video?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audio != nil {
                map["Audio"] = self.audio?.toMap()
            }
            if self.container != nil {
                map["Container"] = self.container?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.muxConfig != nil {
                map["MuxConfig"] = self.muxConfig?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.transConfig != nil {
                map["TransConfig"] = self.transConfig?.toMap()
            }
            if self.video != nil {
                map["Video"] = self.video?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Audio") {
                var model = AddTemplateResponseBody.Template.Audio()
                model.fromMap(dict["Audio"] as! [String: Any])
                self.audio = model
            }
            if dict.keys.contains("Container") {
                var model = AddTemplateResponseBody.Template.Container()
                model.fromMap(dict["Container"] as! [String: Any])
                self.container = model
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MuxConfig") {
                var model = AddTemplateResponseBody.Template.MuxConfig()
                model.fromMap(dict["MuxConfig"] as! [String: Any])
                self.muxConfig = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("TransConfig") {
                var model = AddTemplateResponseBody.Template.TransConfig()
                model.fromMap(dict["TransConfig"] as! [String: Any])
                self.transConfig = model
            }
            if dict.keys.contains("Video") {
                var model = AddTemplateResponseBody.Template.Video()
                model.fromMap(dict["Video"] as! [String: Any])
                self.video = model
            }
        }
    }
    public var requestId: String?

    public var template: AddTemplateResponseBody.Template?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.template != nil {
            map["Template"] = self.template?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Template") {
            var model = AddTemplateResponseBody.Template()
            model.fromMap(dict["Template"] as! [String: Any])
            self.template = model
        }
    }
}

public class AddTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddWaterMarkTemplateRequest : Tea.TeaModel {
    public var config: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AddWaterMarkTemplateResponseBody : Tea.TeaModel {
    public class WaterMarkTemplate : Tea.TeaModel {
        public class RatioRefer : Tea.TeaModel {
            public var dx: String?

            public var dy: String?

            public var height: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dx != nil {
                    map["Dx"] = self.dx!
                }
                if self.dy != nil {
                    map["Dy"] = self.dy!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Dx") {
                    self.dx = dict["Dx"] as! String
                }
                if dict.keys.contains("Dy") {
                    self.dy = dict["Dy"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public class Timeline : Tea.TeaModel {
            public var duration: String?

            public var start: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.start != nil {
                    map["Start"] = self.start!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("Start") {
                    self.start = dict["Start"] as! String
                }
            }
        }
        public var dx: String?

        public var dy: String?

        public var height: String?

        public var id: String?

        public var name: String?

        public var ratioRefer: AddWaterMarkTemplateResponseBody.WaterMarkTemplate.RatioRefer?

        public var referPos: String?

        public var state: String?

        public var timeline: AddWaterMarkTemplateResponseBody.WaterMarkTemplate.Timeline?

        public var type: String?

        public var width: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ratioRefer?.validate()
            try self.timeline?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dx != nil {
                map["Dx"] = self.dx!
            }
            if self.dy != nil {
                map["Dy"] = self.dy!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ratioRefer != nil {
                map["RatioRefer"] = self.ratioRefer?.toMap()
            }
            if self.referPos != nil {
                map["ReferPos"] = self.referPos!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Dx") {
                self.dx = dict["Dx"] as! String
            }
            if dict.keys.contains("Dy") {
                self.dy = dict["Dy"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RatioRefer") {
                var model = AddWaterMarkTemplateResponseBody.WaterMarkTemplate.RatioRefer()
                model.fromMap(dict["RatioRefer"] as! [String: Any])
                self.ratioRefer = model
            }
            if dict.keys.contains("ReferPos") {
                self.referPos = dict["ReferPos"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Timeline") {
                var model = AddWaterMarkTemplateResponseBody.WaterMarkTemplate.Timeline()
                model.fromMap(dict["Timeline"] as! [String: Any])
                self.timeline = model
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! String
            }
        }
    }
    public var requestId: String?

    public var waterMarkTemplate: AddWaterMarkTemplateResponseBody.WaterMarkTemplate?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.waterMarkTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.waterMarkTemplate != nil {
            map["WaterMarkTemplate"] = self.waterMarkTemplate?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WaterMarkTemplate") {
            var model = AddWaterMarkTemplateResponseBody.WaterMarkTemplate()
            model.fromMap(dict["WaterMarkTemplate"] as! [String: Any])
            self.waterMarkTemplate = model
        }
    }
}

public class AddWaterMarkTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddWaterMarkTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddWaterMarkTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindInputBucketRequest : Tea.TeaModel {
    public var bucket: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var roleArn: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucket != nil {
            map["Bucket"] = self.bucket!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.roleArn != nil {
            map["RoleArn"] = self.roleArn!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bucket") {
            self.bucket = dict["Bucket"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RoleArn") {
            self.roleArn = dict["RoleArn"] as! String
        }
    }
}

public class BindInputBucketResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BindInputBucketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindInputBucketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BindInputBucketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindOutputBucketRequest : Tea.TeaModel {
    public var bucket: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var roleArn: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucket != nil {
            map["Bucket"] = self.bucket!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.roleArn != nil {
            map["RoleArn"] = self.roleArn!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bucket") {
            self.bucket = dict["Bucket"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RoleArn") {
            self.roleArn = dict["RoleArn"] as! String
        }
    }
}

public class BindOutputBucketResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BindOutputBucketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindOutputBucketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BindOutputBucketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelJobRequest : Tea.TeaModel {
    public var jobId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CancelJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CategoryTreeRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CategoryTreeResponseBody : Tea.TeaModel {
    public var categoryTree: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryTree != nil {
            map["CategoryTree"] = self.categoryTree!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CategoryTree") {
            self.categoryTree = dict["CategoryTree"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CategoryTreeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CategoryTreeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CategoryTreeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeactivateMediaWorkflowRequest : Tea.TeaModel {
    public var mediaWorkflowId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowId != nil {
            map["MediaWorkflowId"] = self.mediaWorkflowId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowId") {
            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeactivateMediaWorkflowResponseBody : Tea.TeaModel {
    public class MediaWorkflow : Tea.TeaModel {
        public var creationTime: String?

        public var mediaWorkflowId: String?

        public var name: String?

        public var state: String?

        public var topology: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.mediaWorkflowId != nil {
                map["MediaWorkflowId"] = self.mediaWorkflowId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.topology != nil {
                map["Topology"] = self.topology!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("MediaWorkflowId") {
                self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Topology") {
                self.topology = dict["Topology"] as! String
            }
        }
    }
    public var mediaWorkflow: DeactivateMediaWorkflowResponseBody.MediaWorkflow?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflow?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflow != nil {
            map["MediaWorkflow"] = self.mediaWorkflow?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflow") {
            var model = DeactivateMediaWorkflowResponseBody.MediaWorkflow()
            model.fromMap(dict["MediaWorkflow"] as! [String: Any])
            self.mediaWorkflow = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeactivateMediaWorkflowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeactivateMediaWorkflowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeactivateMediaWorkflowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCategoryRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteCategoryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaRequest : Tea.TeaModel {
    public var mediaIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteMediaResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaTagRequest : Tea.TeaModel {
    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! String
        }
    }
}

public class DeleteMediaTagResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMediaTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaWorkflowRequest : Tea.TeaModel {
    public var mediaWorkflowId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowId != nil {
            map["MediaWorkflowId"] = self.mediaWorkflowId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowId") {
            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteMediaWorkflowResponseBody : Tea.TeaModel {
    public class MediaWorkflow : Tea.TeaModel {
        public var creationTime: String?

        public var mediaWorkflowId: String?

        public var name: String?

        public var state: String?

        public var topology: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.mediaWorkflowId != nil {
                map["MediaWorkflowId"] = self.mediaWorkflowId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.topology != nil {
                map["Topology"] = self.topology!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("MediaWorkflowId") {
                self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Topology") {
                self.topology = dict["Topology"] as! String
            }
        }
    }
    public var mediaWorkflow: DeleteMediaWorkflowResponseBody.MediaWorkflow?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflow?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflow != nil {
            map["MediaWorkflow"] = self.mediaWorkflow?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflow") {
            var model = DeleteMediaWorkflowResponseBody.MediaWorkflow()
            model.fromMap(dict["MediaWorkflow"] as! [String: Any])
            self.mediaWorkflow = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMediaWorkflowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaWorkflowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaWorkflowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePipelineRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeletePipelineResponseBody : Tea.TeaModel {
    public var pipelineId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTemplateRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteWaterMarkTemplateRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var waterMarkTemplateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.waterMarkTemplateId != nil {
            map["WaterMarkTemplateId"] = self.waterMarkTemplateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("WaterMarkTemplateId") {
            self.waterMarkTemplateId = dict["WaterMarkTemplateId"] as! String
        }
    }
}

public class DeleteWaterMarkTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var waterMarkTemplateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.waterMarkTemplateId != nil {
            map["WaterMarkTemplateId"] = self.waterMarkTemplateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WaterMarkTemplateId") {
            self.waterMarkTemplateId = dict["WaterMarkTemplateId"] as! String
        }
    }
}

public class DeleteWaterMarkTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWaterMarkTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteWaterMarkTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMtsUserResourcePackageRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var securityToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
    }
}

public class DescribeMtsUserResourcePackageResponseBody : Tea.TeaModel {
    public class ResourcePackageInfos : Tea.TeaModel {
        public class ResourcePackageInfo : Tea.TeaModel {
            public var commodityCode: String?

            public var currCapacity: String?

            public var displayName: String?

            public var initCapacity: String?

            public var instanceId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.commodityCode != nil {
                    map["CommodityCode"] = self.commodityCode!
                }
                if self.currCapacity != nil {
                    map["CurrCapacity"] = self.currCapacity!
                }
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.initCapacity != nil {
                    map["InitCapacity"] = self.initCapacity!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CommodityCode") {
                    self.commodityCode = dict["CommodityCode"] as! String
                }
                if dict.keys.contains("CurrCapacity") {
                    self.currCapacity = dict["CurrCapacity"] as! String
                }
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("InitCapacity") {
                    self.initCapacity = dict["InitCapacity"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var resourcePackageInfo: [DescribeMtsUserResourcePackageResponseBody.ResourcePackageInfos.ResourcePackageInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourcePackageInfo != nil {
                var tmp : [Any] = []
                for k in self.resourcePackageInfo! {
                    tmp.append(k.toMap())
                }
                map["ResourcePackageInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourcePackageInfo") {
                var tmp : [DescribeMtsUserResourcePackageResponseBody.ResourcePackageInfos.ResourcePackageInfo] = []
                for v in dict["ResourcePackageInfo"] as! [Any] {
                    var model = DescribeMtsUserResourcePackageResponseBody.ResourcePackageInfos.ResourcePackageInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resourcePackageInfo = tmp
            }
        }
    }
    public var requestId: String?

    public var resourcePackageInfos: DescribeMtsUserResourcePackageResponseBody.ResourcePackageInfos?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourcePackageInfos?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourcePackageInfos != nil {
            map["ResourcePackageInfos"] = self.resourcePackageInfos?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourcePackageInfos") {
            var model = DescribeMtsUserResourcePackageResponseBody.ResourcePackageInfos()
            model.fromMap(dict["ResourcePackageInfos"] as! [String: Any])
            self.resourcePackageInfos = model
        }
    }
}

public class DescribeMtsUserResourcePackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMtsUserResourcePackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMtsUserResourcePackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAllCategoryRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListAllCategoryResponseBody : Tea.TeaModel {
    public class CategoryList : Tea.TeaModel {
        public class Category : Tea.TeaModel {
            public var cateId: String?

            public var cateName: String?

            public var level: String?

            public var parentId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.cateName != nil {
                    map["CateName"] = self.cateName!
                }
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! String
                }
                if dict.keys.contains("CateName") {
                    self.cateName = dict["CateName"] as! String
                }
                if dict.keys.contains("Level") {
                    self.level = dict["Level"] as! String
                }
                if dict.keys.contains("ParentId") {
                    self.parentId = dict["ParentId"] as! String
                }
            }
        }
        public var category: [ListAllCategoryResponseBody.CategoryList.Category]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                var tmp : [Any] = []
                for k in self.category! {
                    tmp.append(k.toMap())
                }
                map["Category"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                var tmp : [ListAllCategoryResponseBody.CategoryList.Category] = []
                for v in dict["Category"] as! [Any] {
                    var model = ListAllCategoryResponseBody.CategoryList.Category()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.category = tmp
            }
        }
    }
    public var categoryList: ListAllCategoryResponseBody.CategoryList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.categoryList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryList != nil {
            map["CategoryList"] = self.categoryList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CategoryList") {
            var model = ListAllCategoryResponseBody.CategoryList()
            model.fromMap(dict["CategoryList"] as! [String: Any])
            self.categoryList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAllCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAllCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAllCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAllMediaBucketRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListAllMediaBucketResponseBody : Tea.TeaModel {
    public class MediaBucketList : Tea.TeaModel {
        public class MediaBucket : Tea.TeaModel {
            public var bucket: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var mediaBucket: [ListAllMediaBucketResponseBody.MediaBucketList.MediaBucket]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaBucket != nil {
                var tmp : [Any] = []
                for k in self.mediaBucket! {
                    tmp.append(k.toMap())
                }
                map["MediaBucket"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaBucket") {
                var tmp : [ListAllMediaBucketResponseBody.MediaBucketList.MediaBucket] = []
                for v in dict["MediaBucket"] as! [Any] {
                    var model = ListAllMediaBucketResponseBody.MediaBucketList.MediaBucket()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaBucket = tmp
            }
        }
    }
    public var mediaBucketList: ListAllMediaBucketResponseBody.MediaBucketList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaBucketList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaBucketList != nil {
            map["MediaBucketList"] = self.mediaBucketList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaBucketList") {
            var model = ListAllMediaBucketResponseBody.MediaBucketList()
            model.fromMap(dict["MediaBucketList"] as! [String: Any])
            self.mediaBucketList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAllMediaBucketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAllMediaBucketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAllMediaBucketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListJobRequest : Tea.TeaModel {
    public var endOfJobCreatedTimeRange: String?

    public var maximumPageSize: Int64?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startOfJobCreatedTimeRange: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfJobCreatedTimeRange != nil {
            map["EndOfJobCreatedTimeRange"] = self.endOfJobCreatedTimeRange!
        }
        if self.maximumPageSize != nil {
            map["MaximumPageSize"] = self.maximumPageSize!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startOfJobCreatedTimeRange != nil {
            map["StartOfJobCreatedTimeRange"] = self.startOfJobCreatedTimeRange!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfJobCreatedTimeRange") {
            self.endOfJobCreatedTimeRange = dict["EndOfJobCreatedTimeRange"] as! String
        }
        if dict.keys.contains("MaximumPageSize") {
            self.maximumPageSize = dict["MaximumPageSize"] as! Int64
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartOfJobCreatedTimeRange") {
            self.startOfJobCreatedTimeRange = dict["StartOfJobCreatedTimeRange"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class ListJobResponseBody : Tea.TeaModel {
    public class JobList : Tea.TeaModel {
        public class Job : Tea.TeaModel {
            public class Input : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public class MNSMessageResult : Tea.TeaModel {
                public var errorCode: String?

                public var errorMessage: String?

                public var messageId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.messageId != nil {
                        map["MessageId"] = self.messageId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("MessageId") {
                        self.messageId = dict["MessageId"] as! String
                    }
                }
            }
            public class Output : Tea.TeaModel {
                public class AmixList : Tea.TeaModel {
                    public class Amix : Tea.TeaModel {
                        public var amixURL: String?

                        public var duration: String?

                        public var map: String?

                        public var mixDurMode: String?

                        public var start: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.amixURL != nil {
                                map["AmixURL"] = self.amixURL!
                            }
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.map != nil {
                                map["Map"] = self.map!
                            }
                            if self.mixDurMode != nil {
                                map["MixDurMode"] = self.mixDurMode!
                            }
                            if self.start != nil {
                                map["Start"] = self.start!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AmixURL") {
                                self.amixURL = dict["AmixURL"] as! String
                            }
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("Map") {
                                self.map = dict["Map"] as! String
                            }
                            if dict.keys.contains("MixDurMode") {
                                self.mixDurMode = dict["MixDurMode"] as! String
                            }
                            if dict.keys.contains("Start") {
                                self.start = dict["Start"] as! String
                            }
                        }
                    }
                    public var amix: [ListJobResponseBody.JobList.Job.Output.AmixList.Amix]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.amix != nil {
                            var tmp : [Any] = []
                            for k in self.amix! {
                                tmp.append(k.toMap())
                            }
                            map["Amix"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Amix") {
                            var tmp : [ListJobResponseBody.JobList.Job.Output.AmixList.Amix] = []
                            for v in dict["Amix"] as! [Any] {
                                var model = ListJobResponseBody.JobList.Job.Output.AmixList.Amix()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.amix = tmp
                        }
                    }
                }
                public class Audio : Tea.TeaModel {
                    public class Volume : Tea.TeaModel {
                        public var level: String?

                        public var method: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.level != nil {
                                map["Level"] = self.level!
                            }
                            if self.method != nil {
                                map["Method"] = self.method!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Level") {
                                self.level = dict["Level"] as! String
                            }
                            if dict.keys.contains("Method") {
                                self.method = dict["Method"] as! String
                            }
                        }
                    }
                    public var bitrate: String?

                    public var channels: String?

                    public var codec: String?

                    public var profile: String?

                    public var qscale: String?

                    public var samplerate: String?

                    public var volume: ListJobResponseBody.JobList.Job.Output.Audio.Volume?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.volume?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        if self.codec != nil {
                            map["Codec"] = self.codec!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.qscale != nil {
                            map["Qscale"] = self.qscale!
                        }
                        if self.samplerate != nil {
                            map["Samplerate"] = self.samplerate!
                        }
                        if self.volume != nil {
                            map["Volume"] = self.volume?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Channels") {
                            self.channels = dict["Channels"] as! String
                        }
                        if dict.keys.contains("Codec") {
                            self.codec = dict["Codec"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Qscale") {
                            self.qscale = dict["Qscale"] as! String
                        }
                        if dict.keys.contains("Samplerate") {
                            self.samplerate = dict["Samplerate"] as! String
                        }
                        if dict.keys.contains("Volume") {
                            var model = ListJobResponseBody.JobList.Job.Output.Audio.Volume()
                            model.fromMap(dict["Volume"] as! [String: Any])
                            self.volume = model
                        }
                    }
                }
                public class Clip : Tea.TeaModel {
                    public class TimeSpan : Tea.TeaModel {
                        public var duration: String?

                        public var seek: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.seek != nil {
                                map["Seek"] = self.seek!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("Seek") {
                                self.seek = dict["Seek"] as! String
                            }
                        }
                    }
                    public var timeSpan: ListJobResponseBody.JobList.Job.Output.Clip.TimeSpan?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.timeSpan?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.timeSpan != nil {
                            map["TimeSpan"] = self.timeSpan?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TimeSpan") {
                            var model = ListJobResponseBody.JobList.Job.Output.Clip.TimeSpan()
                            model.fromMap(dict["TimeSpan"] as! [String: Any])
                            self.timeSpan = model
                        }
                    }
                }
                public class Container : Tea.TeaModel {
                    public var format: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var id: String?

                    public var key: String?

                    public var keyType: String?

                    public var keyUri: String?

                    public var skipCnt: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.keyType != nil {
                            map["KeyType"] = self.keyType!
                        }
                        if self.keyUri != nil {
                            map["KeyUri"] = self.keyUri!
                        }
                        if self.skipCnt != nil {
                            map["SkipCnt"] = self.skipCnt!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("KeyType") {
                            self.keyType = dict["KeyType"] as! String
                        }
                        if dict.keys.contains("KeyUri") {
                            self.keyUri = dict["KeyUri"] as! String
                        }
                        if dict.keys.contains("SkipCnt") {
                            self.skipCnt = dict["SkipCnt"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public class M3U8NonStandardSupport : Tea.TeaModel {
                    public class TS : Tea.TeaModel {
                        public var md5Support: Bool?

                        public var sizeSupport: Bool?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.md5Support != nil {
                                map["Md5Support"] = self.md5Support!
                            }
                            if self.sizeSupport != nil {
                                map["SizeSupport"] = self.sizeSupport!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Md5Support") {
                                self.md5Support = dict["Md5Support"] as! Bool
                            }
                            if dict.keys.contains("SizeSupport") {
                                self.sizeSupport = dict["SizeSupport"] as! Bool
                            }
                        }
                    }
                    public var TS: ListJobResponseBody.JobList.Job.Output.M3U8NonStandardSupport.TS?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.TS?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.TS != nil {
                            map["TS"] = self.TS?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TS") {
                            var model = ListJobResponseBody.JobList.Job.Output.M3U8NonStandardSupport.TS()
                            model.fromMap(dict["TS"] as! [String: Any])
                            self.TS = model
                        }
                    }
                }
                public class MergeList : Tea.TeaModel {
                    public class Merge : Tea.TeaModel {
                        public var duration: String?

                        public var mergeURL: String?

                        public var roleArn: String?

                        public var start: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.mergeURL != nil {
                                map["MergeURL"] = self.mergeURL!
                            }
                            if self.roleArn != nil {
                                map["RoleArn"] = self.roleArn!
                            }
                            if self.start != nil {
                                map["Start"] = self.start!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("MergeURL") {
                                self.mergeURL = dict["MergeURL"] as! String
                            }
                            if dict.keys.contains("RoleArn") {
                                self.roleArn = dict["RoleArn"] as! String
                            }
                            if dict.keys.contains("Start") {
                                self.start = dict["Start"] as! String
                            }
                        }
                    }
                    public var merge: [ListJobResponseBody.JobList.Job.Output.MergeList.Merge]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.merge != nil {
                            var tmp : [Any] = []
                            for k in self.merge! {
                                tmp.append(k.toMap())
                            }
                            map["Merge"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Merge") {
                            var tmp : [ListJobResponseBody.JobList.Job.Output.MergeList.Merge] = []
                            for v in dict["Merge"] as! [Any] {
                                var model = ListJobResponseBody.JobList.Job.Output.MergeList.Merge()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.merge = tmp
                        }
                    }
                }
                public class MuxConfig : Tea.TeaModel {
                    public class Gif : Tea.TeaModel {
                        public var ditherMode: String?

                        public var finalDelay: String?

                        public var isCustomPalette: String?

                        public var loop: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.ditherMode != nil {
                                map["DitherMode"] = self.ditherMode!
                            }
                            if self.finalDelay != nil {
                                map["FinalDelay"] = self.finalDelay!
                            }
                            if self.isCustomPalette != nil {
                                map["IsCustomPalette"] = self.isCustomPalette!
                            }
                            if self.loop != nil {
                                map["Loop"] = self.loop!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("DitherMode") {
                                self.ditherMode = dict["DitherMode"] as! String
                            }
                            if dict.keys.contains("FinalDelay") {
                                self.finalDelay = dict["FinalDelay"] as! String
                            }
                            if dict.keys.contains("IsCustomPalette") {
                                self.isCustomPalette = dict["IsCustomPalette"] as! String
                            }
                            if dict.keys.contains("Loop") {
                                self.loop = dict["Loop"] as! String
                            }
                        }
                    }
                    public class Segment : Tea.TeaModel {
                        public var duration: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                        }
                    }
                    public class Webp : Tea.TeaModel {
                        public var loop: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.loop != nil {
                                map["Loop"] = self.loop!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Loop") {
                                self.loop = dict["Loop"] as! String
                            }
                        }
                    }
                    public var gif: ListJobResponseBody.JobList.Job.Output.MuxConfig.Gif?

                    public var segment: ListJobResponseBody.JobList.Job.Output.MuxConfig.Segment?

                    public var webp: ListJobResponseBody.JobList.Job.Output.MuxConfig.Webp?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.gif?.validate()
                        try self.segment?.validate()
                        try self.webp?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.gif != nil {
                            map["Gif"] = self.gif?.toMap()
                        }
                        if self.segment != nil {
                            map["Segment"] = self.segment?.toMap()
                        }
                        if self.webp != nil {
                            map["Webp"] = self.webp?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Gif") {
                            var model = ListJobResponseBody.JobList.Job.Output.MuxConfig.Gif()
                            model.fromMap(dict["Gif"] as! [String: Any])
                            self.gif = model
                        }
                        if dict.keys.contains("Segment") {
                            var model = ListJobResponseBody.JobList.Job.Output.MuxConfig.Segment()
                            model.fromMap(dict["Segment"] as! [String: Any])
                            self.segment = model
                        }
                        if dict.keys.contains("Webp") {
                            var model = ListJobResponseBody.JobList.Job.Output.MuxConfig.Webp()
                            model.fromMap(dict["Webp"] as! [String: Any])
                            self.webp = model
                        }
                    }
                }
                public class OpeningList : Tea.TeaModel {
                    public class Opening : Tea.TeaModel {
                        public var height: String?

                        public var start: String?

                        public var width: String?

                        public var openUrl: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.start != nil {
                                map["Start"] = self.start!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            if self.openUrl != nil {
                                map["openUrl"] = self.openUrl!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("Start") {
                                self.start = dict["Start"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                            if dict.keys.contains("openUrl") {
                                self.openUrl = dict["openUrl"] as! String
                            }
                        }
                    }
                    public var opening: [ListJobResponseBody.JobList.Job.Output.OpeningList.Opening]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.opening != nil {
                            var tmp : [Any] = []
                            for k in self.opening! {
                                tmp.append(k.toMap())
                            }
                            map["Opening"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Opening") {
                            var tmp : [ListJobResponseBody.JobList.Job.Output.OpeningList.Opening] = []
                            for v in dict["Opening"] as! [Any] {
                                var model = ListJobResponseBody.JobList.Job.Output.OpeningList.Opening()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.opening = tmp
                        }
                    }
                }
                public class OutSubtitleList : Tea.TeaModel {
                    public class OutSubtitle : Tea.TeaModel {
                        public class OutSubtitleFile : Tea.TeaModel {
                            public var bucket: String?

                            public var location: String?

                            public var object: String?

                            public var roleArn: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bucket != nil {
                                    map["Bucket"] = self.bucket!
                                }
                                if self.location != nil {
                                    map["Location"] = self.location!
                                }
                                if self.object != nil {
                                    map["Object"] = self.object!
                                }
                                if self.roleArn != nil {
                                    map["RoleArn"] = self.roleArn!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bucket") {
                                    self.bucket = dict["Bucket"] as! String
                                }
                                if dict.keys.contains("Location") {
                                    self.location = dict["Location"] as! String
                                }
                                if dict.keys.contains("Object") {
                                    self.object = dict["Object"] as! String
                                }
                                if dict.keys.contains("RoleArn") {
                                    self.roleArn = dict["RoleArn"] as! String
                                }
                            }
                        }
                        public var map: String?

                        public var message: String?

                        public var outSubtitleFile: ListJobResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle.OutSubtitleFile?

                        public var success: Bool?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.outSubtitleFile?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.map != nil {
                                map["Map"] = self.map!
                            }
                            if self.message != nil {
                                map["Message"] = self.message!
                            }
                            if self.outSubtitleFile != nil {
                                map["OutSubtitleFile"] = self.outSubtitleFile?.toMap()
                            }
                            if self.success != nil {
                                map["Success"] = self.success!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Map") {
                                self.map = dict["Map"] as! String
                            }
                            if dict.keys.contains("Message") {
                                self.message = dict["Message"] as! String
                            }
                            if dict.keys.contains("OutSubtitleFile") {
                                var model = ListJobResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle.OutSubtitleFile()
                                model.fromMap(dict["OutSubtitleFile"] as! [String: Any])
                                self.outSubtitleFile = model
                            }
                            if dict.keys.contains("Success") {
                                self.success = dict["Success"] as! Bool
                            }
                        }
                    }
                    public var outSubtitle: [ListJobResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.outSubtitle != nil {
                            var tmp : [Any] = []
                            for k in self.outSubtitle! {
                                tmp.append(k.toMap())
                            }
                            map["OutSubtitle"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OutSubtitle") {
                            var tmp : [ListJobResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle] = []
                            for v in dict["OutSubtitle"] as! [Any] {
                                var model = ListJobResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.outSubtitle = tmp
                        }
                    }
                }
                public class OutputFile : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public var roleArn: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        if self.roleArn != nil {
                            map["RoleArn"] = self.roleArn!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                        if dict.keys.contains("RoleArn") {
                            self.roleArn = dict["RoleArn"] as! String
                        }
                    }
                }
                public class Properties : Tea.TeaModel {
                    public class Format : Tea.TeaModel {
                        public var bitrate: String?

                        public var duration: String?

                        public var formatLongName: String?

                        public var formatName: String?

                        public var numPrograms: String?

                        public var numStreams: String?

                        public var size: String?

                        public var startTime: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.formatLongName != nil {
                                map["FormatLongName"] = self.formatLongName!
                            }
                            if self.formatName != nil {
                                map["FormatName"] = self.formatName!
                            }
                            if self.numPrograms != nil {
                                map["NumPrograms"] = self.numPrograms!
                            }
                            if self.numStreams != nil {
                                map["NumStreams"] = self.numStreams!
                            }
                            if self.size != nil {
                                map["Size"] = self.size!
                            }
                            if self.startTime != nil {
                                map["StartTime"] = self.startTime!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("FormatLongName") {
                                self.formatLongName = dict["FormatLongName"] as! String
                            }
                            if dict.keys.contains("FormatName") {
                                self.formatName = dict["FormatName"] as! String
                            }
                            if dict.keys.contains("NumPrograms") {
                                self.numPrograms = dict["NumPrograms"] as! String
                            }
                            if dict.keys.contains("NumStreams") {
                                self.numStreams = dict["NumStreams"] as! String
                            }
                            if dict.keys.contains("Size") {
                                self.size = dict["Size"] as! String
                            }
                            if dict.keys.contains("StartTime") {
                                self.startTime = dict["StartTime"] as! String
                            }
                        }
                    }
                    public class Streams : Tea.TeaModel {
                        public class AudioStreamList : Tea.TeaModel {
                            public class AudioStream : Tea.TeaModel {
                                public var bitrate: String?

                                public var channelLayout: String?

                                public var channels: String?

                                public var codecLongName: String?

                                public var codecName: String?

                                public var codecTag: String?

                                public var codecTagString: String?

                                public var codecTimeBase: String?

                                public var duration: String?

                                public var index: String?

                                public var lang: String?

                                public var numFrames: String?

                                public var sampleFmt: String?

                                public var samplerate: String?

                                public var startTime: String?

                                public var timebase: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.bitrate != nil {
                                        map["Bitrate"] = self.bitrate!
                                    }
                                    if self.channelLayout != nil {
                                        map["ChannelLayout"] = self.channelLayout!
                                    }
                                    if self.channels != nil {
                                        map["Channels"] = self.channels!
                                    }
                                    if self.codecLongName != nil {
                                        map["CodecLongName"] = self.codecLongName!
                                    }
                                    if self.codecName != nil {
                                        map["CodecName"] = self.codecName!
                                    }
                                    if self.codecTag != nil {
                                        map["CodecTag"] = self.codecTag!
                                    }
                                    if self.codecTagString != nil {
                                        map["CodecTagString"] = self.codecTagString!
                                    }
                                    if self.codecTimeBase != nil {
                                        map["CodecTimeBase"] = self.codecTimeBase!
                                    }
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.index != nil {
                                        map["Index"] = self.index!
                                    }
                                    if self.lang != nil {
                                        map["Lang"] = self.lang!
                                    }
                                    if self.numFrames != nil {
                                        map["NumFrames"] = self.numFrames!
                                    }
                                    if self.sampleFmt != nil {
                                        map["SampleFmt"] = self.sampleFmt!
                                    }
                                    if self.samplerate != nil {
                                        map["Samplerate"] = self.samplerate!
                                    }
                                    if self.startTime != nil {
                                        map["StartTime"] = self.startTime!
                                    }
                                    if self.timebase != nil {
                                        map["Timebase"] = self.timebase!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Bitrate") {
                                        self.bitrate = dict["Bitrate"] as! String
                                    }
                                    if dict.keys.contains("ChannelLayout") {
                                        self.channelLayout = dict["ChannelLayout"] as! String
                                    }
                                    if dict.keys.contains("Channels") {
                                        self.channels = dict["Channels"] as! String
                                    }
                                    if dict.keys.contains("CodecLongName") {
                                        self.codecLongName = dict["CodecLongName"] as! String
                                    }
                                    if dict.keys.contains("CodecName") {
                                        self.codecName = dict["CodecName"] as! String
                                    }
                                    if dict.keys.contains("CodecTag") {
                                        self.codecTag = dict["CodecTag"] as! String
                                    }
                                    if dict.keys.contains("CodecTagString") {
                                        self.codecTagString = dict["CodecTagString"] as! String
                                    }
                                    if dict.keys.contains("CodecTimeBase") {
                                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                                    }
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("Index") {
                                        self.index = dict["Index"] as! String
                                    }
                                    if dict.keys.contains("Lang") {
                                        self.lang = dict["Lang"] as! String
                                    }
                                    if dict.keys.contains("NumFrames") {
                                        self.numFrames = dict["NumFrames"] as! String
                                    }
                                    if dict.keys.contains("SampleFmt") {
                                        self.sampleFmt = dict["SampleFmt"] as! String
                                    }
                                    if dict.keys.contains("Samplerate") {
                                        self.samplerate = dict["Samplerate"] as! String
                                    }
                                    if dict.keys.contains("StartTime") {
                                        self.startTime = dict["StartTime"] as! String
                                    }
                                    if dict.keys.contains("Timebase") {
                                        self.timebase = dict["Timebase"] as! String
                                    }
                                }
                            }
                            public var audioStream: [ListJobResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList.AudioStream]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.audioStream != nil {
                                    var tmp : [Any] = []
                                    for k in self.audioStream! {
                                        tmp.append(k.toMap())
                                    }
                                    map["AudioStream"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AudioStream") {
                                    var tmp : [ListJobResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList.AudioStream] = []
                                    for v in dict["AudioStream"] as! [Any] {
                                        var model = ListJobResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList.AudioStream()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.audioStream = tmp
                                }
                            }
                        }
                        public class SubtitleStreamList : Tea.TeaModel {
                            public class SubtitleStream : Tea.TeaModel {
                                public var index: String?

                                public var lang: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.index != nil {
                                        map["Index"] = self.index!
                                    }
                                    if self.lang != nil {
                                        map["Lang"] = self.lang!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Index") {
                                        self.index = dict["Index"] as! String
                                    }
                                    if dict.keys.contains("Lang") {
                                        self.lang = dict["Lang"] as! String
                                    }
                                }
                            }
                            public var subtitleStream: [ListJobResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList.SubtitleStream]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.subtitleStream != nil {
                                    var tmp : [Any] = []
                                    for k in self.subtitleStream! {
                                        tmp.append(k.toMap())
                                    }
                                    map["SubtitleStream"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("SubtitleStream") {
                                    var tmp : [ListJobResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList.SubtitleStream] = []
                                    for v in dict["SubtitleStream"] as! [Any] {
                                        var model = ListJobResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList.SubtitleStream()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.subtitleStream = tmp
                                }
                            }
                        }
                        public class VideoStreamList : Tea.TeaModel {
                            public class VideoStream : Tea.TeaModel {
                                public class NetworkCost : Tea.TeaModel {
                                    public var avgBitrate: String?

                                    public var costBandwidth: String?

                                    public var preloadTime: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.avgBitrate != nil {
                                            map["AvgBitrate"] = self.avgBitrate!
                                        }
                                        if self.costBandwidth != nil {
                                            map["CostBandwidth"] = self.costBandwidth!
                                        }
                                        if self.preloadTime != nil {
                                            map["PreloadTime"] = self.preloadTime!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("AvgBitrate") {
                                            self.avgBitrate = dict["AvgBitrate"] as! String
                                        }
                                        if dict.keys.contains("CostBandwidth") {
                                            self.costBandwidth = dict["CostBandwidth"] as! String
                                        }
                                        if dict.keys.contains("PreloadTime") {
                                            self.preloadTime = dict["PreloadTime"] as! String
                                        }
                                    }
                                }
                                public var avgFPS: String?

                                public var bitrate: String?

                                public var codecLongName: String?

                                public var codecName: String?

                                public var codecTag: String?

                                public var codecTagString: String?

                                public var codecTimeBase: String?

                                public var dar: String?

                                public var duration: String?

                                public var fps: String?

                                public var hasBFrames: String?

                                public var height: String?

                                public var index: String?

                                public var lang: String?

                                public var level: String?

                                public var networkCost: ListJobResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream.NetworkCost?

                                public var numFrames: String?

                                public var pixFmt: String?

                                public var profile: String?

                                public var sar: String?

                                public var startTime: String?

                                public var timebase: String?

                                public var width: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                    try self.networkCost?.validate()
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.avgFPS != nil {
                                        map["AvgFPS"] = self.avgFPS!
                                    }
                                    if self.bitrate != nil {
                                        map["Bitrate"] = self.bitrate!
                                    }
                                    if self.codecLongName != nil {
                                        map["CodecLongName"] = self.codecLongName!
                                    }
                                    if self.codecName != nil {
                                        map["CodecName"] = self.codecName!
                                    }
                                    if self.codecTag != nil {
                                        map["CodecTag"] = self.codecTag!
                                    }
                                    if self.codecTagString != nil {
                                        map["CodecTagString"] = self.codecTagString!
                                    }
                                    if self.codecTimeBase != nil {
                                        map["CodecTimeBase"] = self.codecTimeBase!
                                    }
                                    if self.dar != nil {
                                        map["Dar"] = self.dar!
                                    }
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.fps != nil {
                                        map["Fps"] = self.fps!
                                    }
                                    if self.hasBFrames != nil {
                                        map["HasBFrames"] = self.hasBFrames!
                                    }
                                    if self.height != nil {
                                        map["Height"] = self.height!
                                    }
                                    if self.index != nil {
                                        map["Index"] = self.index!
                                    }
                                    if self.lang != nil {
                                        map["Lang"] = self.lang!
                                    }
                                    if self.level != nil {
                                        map["Level"] = self.level!
                                    }
                                    if self.networkCost != nil {
                                        map["NetworkCost"] = self.networkCost?.toMap()
                                    }
                                    if self.numFrames != nil {
                                        map["NumFrames"] = self.numFrames!
                                    }
                                    if self.pixFmt != nil {
                                        map["PixFmt"] = self.pixFmt!
                                    }
                                    if self.profile != nil {
                                        map["Profile"] = self.profile!
                                    }
                                    if self.sar != nil {
                                        map["Sar"] = self.sar!
                                    }
                                    if self.startTime != nil {
                                        map["StartTime"] = self.startTime!
                                    }
                                    if self.timebase != nil {
                                        map["Timebase"] = self.timebase!
                                    }
                                    if self.width != nil {
                                        map["Width"] = self.width!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("AvgFPS") {
                                        self.avgFPS = dict["AvgFPS"] as! String
                                    }
                                    if dict.keys.contains("Bitrate") {
                                        self.bitrate = dict["Bitrate"] as! String
                                    }
                                    if dict.keys.contains("CodecLongName") {
                                        self.codecLongName = dict["CodecLongName"] as! String
                                    }
                                    if dict.keys.contains("CodecName") {
                                        self.codecName = dict["CodecName"] as! String
                                    }
                                    if dict.keys.contains("CodecTag") {
                                        self.codecTag = dict["CodecTag"] as! String
                                    }
                                    if dict.keys.contains("CodecTagString") {
                                        self.codecTagString = dict["CodecTagString"] as! String
                                    }
                                    if dict.keys.contains("CodecTimeBase") {
                                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                                    }
                                    if dict.keys.contains("Dar") {
                                        self.dar = dict["Dar"] as! String
                                    }
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("Fps") {
                                        self.fps = dict["Fps"] as! String
                                    }
                                    if dict.keys.contains("HasBFrames") {
                                        self.hasBFrames = dict["HasBFrames"] as! String
                                    }
                                    if dict.keys.contains("Height") {
                                        self.height = dict["Height"] as! String
                                    }
                                    if dict.keys.contains("Index") {
                                        self.index = dict["Index"] as! String
                                    }
                                    if dict.keys.contains("Lang") {
                                        self.lang = dict["Lang"] as! String
                                    }
                                    if dict.keys.contains("Level") {
                                        self.level = dict["Level"] as! String
                                    }
                                    if dict.keys.contains("NetworkCost") {
                                        var model = ListJobResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream.NetworkCost()
                                        model.fromMap(dict["NetworkCost"] as! [String: Any])
                                        self.networkCost = model
                                    }
                                    if dict.keys.contains("NumFrames") {
                                        self.numFrames = dict["NumFrames"] as! String
                                    }
                                    if dict.keys.contains("PixFmt") {
                                        self.pixFmt = dict["PixFmt"] as! String
                                    }
                                    if dict.keys.contains("Profile") {
                                        self.profile = dict["Profile"] as! String
                                    }
                                    if dict.keys.contains("Sar") {
                                        self.sar = dict["Sar"] as! String
                                    }
                                    if dict.keys.contains("StartTime") {
                                        self.startTime = dict["StartTime"] as! String
                                    }
                                    if dict.keys.contains("Timebase") {
                                        self.timebase = dict["Timebase"] as! String
                                    }
                                    if dict.keys.contains("Width") {
                                        self.width = dict["Width"] as! String
                                    }
                                }
                            }
                            public var videoStream: [ListJobResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.videoStream != nil {
                                    var tmp : [Any] = []
                                    for k in self.videoStream! {
                                        tmp.append(k.toMap())
                                    }
                                    map["VideoStream"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("VideoStream") {
                                    var tmp : [ListJobResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream] = []
                                    for v in dict["VideoStream"] as! [Any] {
                                        var model = ListJobResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.videoStream = tmp
                                }
                            }
                        }
                        public var audioStreamList: ListJobResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList?

                        public var subtitleStreamList: ListJobResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList?

                        public var videoStreamList: ListJobResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audioStreamList?.validate()
                            try self.subtitleStreamList?.validate()
                            try self.videoStreamList?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audioStreamList != nil {
                                map["AudioStreamList"] = self.audioStreamList?.toMap()
                            }
                            if self.subtitleStreamList != nil {
                                map["SubtitleStreamList"] = self.subtitleStreamList?.toMap()
                            }
                            if self.videoStreamList != nil {
                                map["VideoStreamList"] = self.videoStreamList?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AudioStreamList") {
                                var model = ListJobResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList()
                                model.fromMap(dict["AudioStreamList"] as! [String: Any])
                                self.audioStreamList = model
                            }
                            if dict.keys.contains("SubtitleStreamList") {
                                var model = ListJobResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList()
                                model.fromMap(dict["SubtitleStreamList"] as! [String: Any])
                                self.subtitleStreamList = model
                            }
                            if dict.keys.contains("VideoStreamList") {
                                var model = ListJobResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList()
                                model.fromMap(dict["VideoStreamList"] as! [String: Any])
                                self.videoStreamList = model
                            }
                        }
                    }
                    public var bitrate: String?

                    public var duration: String?

                    public var fileFormat: String?

                    public var fileSize: String?

                    public var format: ListJobResponseBody.JobList.Job.Output.Properties.Format?

                    public var fps: String?

                    public var height: String?

                    public var streams: ListJobResponseBody.JobList.Job.Output.Properties.Streams?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.format?.validate()
                        try self.streams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fileFormat != nil {
                            map["FileFormat"] = self.fileFormat!
                        }
                        if self.fileSize != nil {
                            map["FileSize"] = self.fileSize!
                        }
                        if self.format != nil {
                            map["Format"] = self.format?.toMap()
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.streams != nil {
                            map["Streams"] = self.streams?.toMap()
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("FileFormat") {
                            self.fileFormat = dict["FileFormat"] as! String
                        }
                        if dict.keys.contains("FileSize") {
                            self.fileSize = dict["FileSize"] as! String
                        }
                        if dict.keys.contains("Format") {
                            var model = ListJobResponseBody.JobList.Job.Output.Properties.Format()
                            model.fromMap(dict["Format"] as! [String: Any])
                            self.format = model
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("Streams") {
                            var model = ListJobResponseBody.JobList.Job.Output.Properties.Streams()
                            model.fromMap(dict["Streams"] as! [String: Any])
                            self.streams = model
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public class SubtitleConfig : Tea.TeaModel {
                    public class ExtSubtitleList : Tea.TeaModel {
                        public class ExtSubtitle : Tea.TeaModel {
                            public class Input : Tea.TeaModel {
                                public var bucket: String?

                                public var location: String?

                                public var object: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.bucket != nil {
                                        map["Bucket"] = self.bucket!
                                    }
                                    if self.location != nil {
                                        map["Location"] = self.location!
                                    }
                                    if self.object != nil {
                                        map["Object"] = self.object!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Bucket") {
                                        self.bucket = dict["Bucket"] as! String
                                    }
                                    if dict.keys.contains("Location") {
                                        self.location = dict["Location"] as! String
                                    }
                                    if dict.keys.contains("Object") {
                                        self.object = dict["Object"] as! String
                                    }
                                }
                            }
                            public var charEnc: String?

                            public var fontName: String?

                            public var input: ListJobResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle.Input?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.input?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.charEnc != nil {
                                    map["CharEnc"] = self.charEnc!
                                }
                                if self.fontName != nil {
                                    map["FontName"] = self.fontName!
                                }
                                if self.input != nil {
                                    map["Input"] = self.input?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("CharEnc") {
                                    self.charEnc = dict["CharEnc"] as! String
                                }
                                if dict.keys.contains("FontName") {
                                    self.fontName = dict["FontName"] as! String
                                }
                                if dict.keys.contains("Input") {
                                    var model = ListJobResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle.Input()
                                    model.fromMap(dict["Input"] as! [String: Any])
                                    self.input = model
                                }
                            }
                        }
                        public var extSubtitle: [ListJobResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.extSubtitle != nil {
                                var tmp : [Any] = []
                                for k in self.extSubtitle! {
                                    tmp.append(k.toMap())
                                }
                                map["ExtSubtitle"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ExtSubtitle") {
                                var tmp : [ListJobResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle] = []
                                for v in dict["ExtSubtitle"] as! [Any] {
                                    var model = ListJobResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.extSubtitle = tmp
                            }
                        }
                    }
                    public class SubtitleList : Tea.TeaModel {
                        public class Subtitle : Tea.TeaModel {
                            public var map: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.map != nil {
                                    map["Map"] = self.map!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Map") {
                                    self.map = dict["Map"] as! String
                                }
                            }
                        }
                        public var subtitle: [ListJobResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList.Subtitle]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.subtitle != nil {
                                var tmp : [Any] = []
                                for k in self.subtitle! {
                                    tmp.append(k.toMap())
                                }
                                map["Subtitle"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Subtitle") {
                                var tmp : [ListJobResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList.Subtitle] = []
                                for v in dict["Subtitle"] as! [Any] {
                                    var model = ListJobResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList.Subtitle()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.subtitle = tmp
                            }
                        }
                    }
                    public var extSubtitleList: ListJobResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList?

                    public var subtitleList: ListJobResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.extSubtitleList?.validate()
                        try self.subtitleList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.extSubtitleList != nil {
                            map["ExtSubtitleList"] = self.extSubtitleList?.toMap()
                        }
                        if self.subtitleList != nil {
                            map["SubtitleList"] = self.subtitleList?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ExtSubtitleList") {
                            var model = ListJobResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList()
                            model.fromMap(dict["ExtSubtitleList"] as! [String: Any])
                            self.extSubtitleList = model
                        }
                        if dict.keys.contains("SubtitleList") {
                            var model = ListJobResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList()
                            model.fromMap(dict["SubtitleList"] as! [String: Any])
                            self.subtitleList = model
                        }
                    }
                }
                public class SuperReso : Tea.TeaModel {
                    public var isHalfSample: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.isHalfSample != nil {
                            map["IsHalfSample"] = self.isHalfSample!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IsHalfSample") {
                            self.isHalfSample = dict["IsHalfSample"] as! String
                        }
                    }
                }
                public class TailSlateList : Tea.TeaModel {
                    public class TailSlate : Tea.TeaModel {
                        public var bgColor: String?

                        public var blendDuration: String?

                        public var height: String?

                        public var isMergeAudio: Bool?

                        public var start: String?

                        public var tailUrl: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bgColor != nil {
                                map["BgColor"] = self.bgColor!
                            }
                            if self.blendDuration != nil {
                                map["BlendDuration"] = self.blendDuration!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.isMergeAudio != nil {
                                map["IsMergeAudio"] = self.isMergeAudio!
                            }
                            if self.start != nil {
                                map["Start"] = self.start!
                            }
                            if self.tailUrl != nil {
                                map["TailUrl"] = self.tailUrl!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("BgColor") {
                                self.bgColor = dict["BgColor"] as! String
                            }
                            if dict.keys.contains("BlendDuration") {
                                self.blendDuration = dict["BlendDuration"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("IsMergeAudio") {
                                self.isMergeAudio = dict["IsMergeAudio"] as! Bool
                            }
                            if dict.keys.contains("Start") {
                                self.start = dict["Start"] as! String
                            }
                            if dict.keys.contains("TailUrl") {
                                self.tailUrl = dict["TailUrl"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var tailSlate: [ListJobResponseBody.JobList.Job.Output.TailSlateList.TailSlate]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tailSlate != nil {
                            var tmp : [Any] = []
                            for k in self.tailSlate! {
                                tmp.append(k.toMap())
                            }
                            map["TailSlate"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TailSlate") {
                            var tmp : [ListJobResponseBody.JobList.Job.Output.TailSlateList.TailSlate] = []
                            for v in dict["TailSlate"] as! [Any] {
                                var model = ListJobResponseBody.JobList.Job.Output.TailSlateList.TailSlate()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.tailSlate = tmp
                        }
                    }
                }
                public class TransConfig : Tea.TeaModel {
                    public var adjDarMethod: String?

                    public var isCheckAudioBitrate: String?

                    public var isCheckAudioBitrateFail: String?

                    public var isCheckReso: String?

                    public var isCheckResoFail: String?

                    public var isCheckVideoBitrate: String?

                    public var isCheckVideoBitrateFail: String?

                    public var transMode: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.adjDarMethod != nil {
                            map["AdjDarMethod"] = self.adjDarMethod!
                        }
                        if self.isCheckAudioBitrate != nil {
                            map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                        }
                        if self.isCheckAudioBitrateFail != nil {
                            map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                        }
                        if self.isCheckReso != nil {
                            map["IsCheckReso"] = self.isCheckReso!
                        }
                        if self.isCheckResoFail != nil {
                            map["IsCheckResoFail"] = self.isCheckResoFail!
                        }
                        if self.isCheckVideoBitrate != nil {
                            map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                        }
                        if self.isCheckVideoBitrateFail != nil {
                            map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                        }
                        if self.transMode != nil {
                            map["TransMode"] = self.transMode!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AdjDarMethod") {
                            self.adjDarMethod = dict["AdjDarMethod"] as! String
                        }
                        if dict.keys.contains("IsCheckAudioBitrate") {
                            self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                        }
                        if dict.keys.contains("IsCheckAudioBitrateFail") {
                            self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                        }
                        if dict.keys.contains("IsCheckReso") {
                            self.isCheckReso = dict["IsCheckReso"] as! String
                        }
                        if dict.keys.contains("IsCheckResoFail") {
                            self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                        }
                        if dict.keys.contains("IsCheckVideoBitrate") {
                            self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                        }
                        if dict.keys.contains("IsCheckVideoBitrateFail") {
                            self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                        }
                        if dict.keys.contains("TransMode") {
                            self.transMode = dict["TransMode"] as! String
                        }
                    }
                }
                public class Video : Tea.TeaModel {
                    public class BitrateBnd : Tea.TeaModel {
                        public var max: String?

                        public var min: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.max != nil {
                                map["Max"] = self.max!
                            }
                            if self.min != nil {
                                map["Min"] = self.min!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Max") {
                                self.max = dict["Max"] as! String
                            }
                            if dict.keys.contains("Min") {
                                self.min = dict["Min"] as! String
                            }
                        }
                    }
                    public var bitrate: String?

                    public var bitrateBnd: ListJobResponseBody.JobList.Job.Output.Video.BitrateBnd?

                    public var bufsize: String?

                    public var codec: String?

                    public var crf: String?

                    public var crop: String?

                    public var degrain: String?

                    public var fps: String?

                    public var gop: String?

                    public var height: String?

                    public var maxFps: String?

                    public var maxrate: String?

                    public var pad: String?

                    public var pixFmt: String?

                    public var preset: String?

                    public var profile: String?

                    public var qscale: String?

                    public var resoPriority: String?

                    public var scanMode: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.bitrateBnd?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.bitrateBnd != nil {
                            map["BitrateBnd"] = self.bitrateBnd?.toMap()
                        }
                        if self.bufsize != nil {
                            map["Bufsize"] = self.bufsize!
                        }
                        if self.codec != nil {
                            map["Codec"] = self.codec!
                        }
                        if self.crf != nil {
                            map["Crf"] = self.crf!
                        }
                        if self.crop != nil {
                            map["Crop"] = self.crop!
                        }
                        if self.degrain != nil {
                            map["Degrain"] = self.degrain!
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.gop != nil {
                            map["Gop"] = self.gop!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.maxFps != nil {
                            map["MaxFps"] = self.maxFps!
                        }
                        if self.maxrate != nil {
                            map["Maxrate"] = self.maxrate!
                        }
                        if self.pad != nil {
                            map["Pad"] = self.pad!
                        }
                        if self.pixFmt != nil {
                            map["PixFmt"] = self.pixFmt!
                        }
                        if self.preset != nil {
                            map["Preset"] = self.preset!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.qscale != nil {
                            map["Qscale"] = self.qscale!
                        }
                        if self.resoPriority != nil {
                            map["ResoPriority"] = self.resoPriority!
                        }
                        if self.scanMode != nil {
                            map["ScanMode"] = self.scanMode!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("BitrateBnd") {
                            var model = ListJobResponseBody.JobList.Job.Output.Video.BitrateBnd()
                            model.fromMap(dict["BitrateBnd"] as! [String: Any])
                            self.bitrateBnd = model
                        }
                        if dict.keys.contains("Bufsize") {
                            self.bufsize = dict["Bufsize"] as! String
                        }
                        if dict.keys.contains("Codec") {
                            self.codec = dict["Codec"] as! String
                        }
                        if dict.keys.contains("Crf") {
                            self.crf = dict["Crf"] as! String
                        }
                        if dict.keys.contains("Crop") {
                            self.crop = dict["Crop"] as! String
                        }
                        if dict.keys.contains("Degrain") {
                            self.degrain = dict["Degrain"] as! String
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Gop") {
                            self.gop = dict["Gop"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("MaxFps") {
                            self.maxFps = dict["MaxFps"] as! String
                        }
                        if dict.keys.contains("Maxrate") {
                            self.maxrate = dict["Maxrate"] as! String
                        }
                        if dict.keys.contains("Pad") {
                            self.pad = dict["Pad"] as! String
                        }
                        if dict.keys.contains("PixFmt") {
                            self.pixFmt = dict["PixFmt"] as! String
                        }
                        if dict.keys.contains("Preset") {
                            self.preset = dict["Preset"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Qscale") {
                            self.qscale = dict["Qscale"] as! String
                        }
                        if dict.keys.contains("ResoPriority") {
                            self.resoPriority = dict["ResoPriority"] as! String
                        }
                        if dict.keys.contains("ScanMode") {
                            self.scanMode = dict["ScanMode"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public class WaterMarkList : Tea.TeaModel {
                    public class WaterMark : Tea.TeaModel {
                        public class InputFile : Tea.TeaModel {
                            public var bucket: String?

                            public var location: String?

                            public var object: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bucket != nil {
                                    map["Bucket"] = self.bucket!
                                }
                                if self.location != nil {
                                    map["Location"] = self.location!
                                }
                                if self.object != nil {
                                    map["Object"] = self.object!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bucket") {
                                    self.bucket = dict["Bucket"] as! String
                                }
                                if dict.keys.contains("Location") {
                                    self.location = dict["Location"] as! String
                                }
                                if dict.keys.contains("Object") {
                                    self.object = dict["Object"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var height: String?

                        public var inputFile: ListJobResponseBody.JobList.Job.Output.WaterMarkList.WaterMark.InputFile?

                        public var referPos: String?

                        public var type: String?

                        public var waterMarkTemplateId: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.inputFile?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.inputFile != nil {
                                map["InputFile"] = self.inputFile?.toMap()
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            if self.waterMarkTemplateId != nil {
                                map["WaterMarkTemplateId"] = self.waterMarkTemplateId!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("InputFile") {
                                var model = ListJobResponseBody.JobList.Job.Output.WaterMarkList.WaterMark.InputFile()
                                model.fromMap(dict["InputFile"] as! [String: Any])
                                self.inputFile = model
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Type") {
                                self.type = dict["Type"] as! String
                            }
                            if dict.keys.contains("WaterMarkTemplateId") {
                                self.waterMarkTemplateId = dict["WaterMarkTemplateId"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var waterMark: [ListJobResponseBody.JobList.Job.Output.WaterMarkList.WaterMark]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.waterMark != nil {
                            var tmp : [Any] = []
                            for k in self.waterMark! {
                                tmp.append(k.toMap())
                            }
                            map["WaterMark"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("WaterMark") {
                            var tmp : [ListJobResponseBody.JobList.Job.Output.WaterMarkList.WaterMark] = []
                            for v in dict["WaterMark"] as! [Any] {
                                var model = ListJobResponseBody.JobList.Job.Output.WaterMarkList.WaterMark()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.waterMark = tmp
                        }
                    }
                }
                public var amixList: ListJobResponseBody.JobList.Job.Output.AmixList?

                public var audio: ListJobResponseBody.JobList.Job.Output.Audio?

                public var audioStreamMap: String?

                public var clip: ListJobResponseBody.JobList.Job.Output.Clip?

                public var container: ListJobResponseBody.JobList.Job.Output.Container?

                public var deWatermark: String?

                public var encryption: ListJobResponseBody.JobList.Job.Output.Encryption?

                public var m3U8NonStandardSupport: ListJobResponseBody.JobList.Job.Output.M3U8NonStandardSupport?

                public var mergeConfigUrl: String?

                public var mergeList: ListJobResponseBody.JobList.Job.Output.MergeList?

                public var muxConfig: ListJobResponseBody.JobList.Job.Output.MuxConfig?

                public var openingList: ListJobResponseBody.JobList.Job.Output.OpeningList?

                public var outSubtitleList: ListJobResponseBody.JobList.Job.Output.OutSubtitleList?

                public var outputFile: ListJobResponseBody.JobList.Job.Output.OutputFile?

                public var priority: String?

                public var properties: ListJobResponseBody.JobList.Job.Output.Properties?

                public var rotate: String?

                public var subtitleConfig: ListJobResponseBody.JobList.Job.Output.SubtitleConfig?

                public var superReso: ListJobResponseBody.JobList.Job.Output.SuperReso?

                public var tailSlateList: ListJobResponseBody.JobList.Job.Output.TailSlateList?

                public var templateId: String?

                public var transConfig: ListJobResponseBody.JobList.Job.Output.TransConfig?

                public var userData: String?

                public var video: ListJobResponseBody.JobList.Job.Output.Video?

                public var videoStreamMap: String?

                public var waterMarkConfigUrl: String?

                public var waterMarkList: ListJobResponseBody.JobList.Job.Output.WaterMarkList?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.amixList?.validate()
                    try self.audio?.validate()
                    try self.clip?.validate()
                    try self.container?.validate()
                    try self.encryption?.validate()
                    try self.m3U8NonStandardSupport?.validate()
                    try self.mergeList?.validate()
                    try self.muxConfig?.validate()
                    try self.openingList?.validate()
                    try self.outSubtitleList?.validate()
                    try self.outputFile?.validate()
                    try self.properties?.validate()
                    try self.subtitleConfig?.validate()
                    try self.superReso?.validate()
                    try self.tailSlateList?.validate()
                    try self.transConfig?.validate()
                    try self.video?.validate()
                    try self.waterMarkList?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.amixList != nil {
                        map["AmixList"] = self.amixList?.toMap()
                    }
                    if self.audio != nil {
                        map["Audio"] = self.audio?.toMap()
                    }
                    if self.audioStreamMap != nil {
                        map["AudioStreamMap"] = self.audioStreamMap!
                    }
                    if self.clip != nil {
                        map["Clip"] = self.clip?.toMap()
                    }
                    if self.container != nil {
                        map["Container"] = self.container?.toMap()
                    }
                    if self.deWatermark != nil {
                        map["DeWatermark"] = self.deWatermark!
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.m3U8NonStandardSupport != nil {
                        map["M3U8NonStandardSupport"] = self.m3U8NonStandardSupport?.toMap()
                    }
                    if self.mergeConfigUrl != nil {
                        map["MergeConfigUrl"] = self.mergeConfigUrl!
                    }
                    if self.mergeList != nil {
                        map["MergeList"] = self.mergeList?.toMap()
                    }
                    if self.muxConfig != nil {
                        map["MuxConfig"] = self.muxConfig?.toMap()
                    }
                    if self.openingList != nil {
                        map["OpeningList"] = self.openingList?.toMap()
                    }
                    if self.outSubtitleList != nil {
                        map["OutSubtitleList"] = self.outSubtitleList?.toMap()
                    }
                    if self.outputFile != nil {
                        map["OutputFile"] = self.outputFile?.toMap()
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    if self.properties != nil {
                        map["Properties"] = self.properties?.toMap()
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.subtitleConfig != nil {
                        map["SubtitleConfig"] = self.subtitleConfig?.toMap()
                    }
                    if self.superReso != nil {
                        map["SuperReso"] = self.superReso?.toMap()
                    }
                    if self.tailSlateList != nil {
                        map["TailSlateList"] = self.tailSlateList?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    if self.transConfig != nil {
                        map["TransConfig"] = self.transConfig?.toMap()
                    }
                    if self.userData != nil {
                        map["UserData"] = self.userData!
                    }
                    if self.video != nil {
                        map["Video"] = self.video?.toMap()
                    }
                    if self.videoStreamMap != nil {
                        map["VideoStreamMap"] = self.videoStreamMap!
                    }
                    if self.waterMarkConfigUrl != nil {
                        map["WaterMarkConfigUrl"] = self.waterMarkConfigUrl!
                    }
                    if self.waterMarkList != nil {
                        map["WaterMarkList"] = self.waterMarkList?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AmixList") {
                        var model = ListJobResponseBody.JobList.Job.Output.AmixList()
                        model.fromMap(dict["AmixList"] as! [String: Any])
                        self.amixList = model
                    }
                    if dict.keys.contains("Audio") {
                        var model = ListJobResponseBody.JobList.Job.Output.Audio()
                        model.fromMap(dict["Audio"] as! [String: Any])
                        self.audio = model
                    }
                    if dict.keys.contains("AudioStreamMap") {
                        self.audioStreamMap = dict["AudioStreamMap"] as! String
                    }
                    if dict.keys.contains("Clip") {
                        var model = ListJobResponseBody.JobList.Job.Output.Clip()
                        model.fromMap(dict["Clip"] as! [String: Any])
                        self.clip = model
                    }
                    if dict.keys.contains("Container") {
                        var model = ListJobResponseBody.JobList.Job.Output.Container()
                        model.fromMap(dict["Container"] as! [String: Any])
                        self.container = model
                    }
                    if dict.keys.contains("DeWatermark") {
                        self.deWatermark = dict["DeWatermark"] as! String
                    }
                    if dict.keys.contains("Encryption") {
                        var model = ListJobResponseBody.JobList.Job.Output.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("M3U8NonStandardSupport") {
                        var model = ListJobResponseBody.JobList.Job.Output.M3U8NonStandardSupport()
                        model.fromMap(dict["M3U8NonStandardSupport"] as! [String: Any])
                        self.m3U8NonStandardSupport = model
                    }
                    if dict.keys.contains("MergeConfigUrl") {
                        self.mergeConfigUrl = dict["MergeConfigUrl"] as! String
                    }
                    if dict.keys.contains("MergeList") {
                        var model = ListJobResponseBody.JobList.Job.Output.MergeList()
                        model.fromMap(dict["MergeList"] as! [String: Any])
                        self.mergeList = model
                    }
                    if dict.keys.contains("MuxConfig") {
                        var model = ListJobResponseBody.JobList.Job.Output.MuxConfig()
                        model.fromMap(dict["MuxConfig"] as! [String: Any])
                        self.muxConfig = model
                    }
                    if dict.keys.contains("OpeningList") {
                        var model = ListJobResponseBody.JobList.Job.Output.OpeningList()
                        model.fromMap(dict["OpeningList"] as! [String: Any])
                        self.openingList = model
                    }
                    if dict.keys.contains("OutSubtitleList") {
                        var model = ListJobResponseBody.JobList.Job.Output.OutSubtitleList()
                        model.fromMap(dict["OutSubtitleList"] as! [String: Any])
                        self.outSubtitleList = model
                    }
                    if dict.keys.contains("OutputFile") {
                        var model = ListJobResponseBody.JobList.Job.Output.OutputFile()
                        model.fromMap(dict["OutputFile"] as! [String: Any])
                        self.outputFile = model
                    }
                    if dict.keys.contains("Priority") {
                        self.priority = dict["Priority"] as! String
                    }
                    if dict.keys.contains("Properties") {
                        var model = ListJobResponseBody.JobList.Job.Output.Properties()
                        model.fromMap(dict["Properties"] as! [String: Any])
                        self.properties = model
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("SubtitleConfig") {
                        var model = ListJobResponseBody.JobList.Job.Output.SubtitleConfig()
                        model.fromMap(dict["SubtitleConfig"] as! [String: Any])
                        self.subtitleConfig = model
                    }
                    if dict.keys.contains("SuperReso") {
                        var model = ListJobResponseBody.JobList.Job.Output.SuperReso()
                        model.fromMap(dict["SuperReso"] as! [String: Any])
                        self.superReso = model
                    }
                    if dict.keys.contains("TailSlateList") {
                        var model = ListJobResponseBody.JobList.Job.Output.TailSlateList()
                        model.fromMap(dict["TailSlateList"] as! [String: Any])
                        self.tailSlateList = model
                    }
                    if dict.keys.contains("TemplateId") {
                        self.templateId = dict["TemplateId"] as! String
                    }
                    if dict.keys.contains("TransConfig") {
                        var model = ListJobResponseBody.JobList.Job.Output.TransConfig()
                        model.fromMap(dict["TransConfig"] as! [String: Any])
                        self.transConfig = model
                    }
                    if dict.keys.contains("UserData") {
                        self.userData = dict["UserData"] as! String
                    }
                    if dict.keys.contains("Video") {
                        var model = ListJobResponseBody.JobList.Job.Output.Video()
                        model.fromMap(dict["Video"] as! [String: Any])
                        self.video = model
                    }
                    if dict.keys.contains("VideoStreamMap") {
                        self.videoStreamMap = dict["VideoStreamMap"] as! String
                    }
                    if dict.keys.contains("WaterMarkConfigUrl") {
                        self.waterMarkConfigUrl = dict["WaterMarkConfigUrl"] as! String
                    }
                    if dict.keys.contains("WaterMarkList") {
                        var model = ListJobResponseBody.JobList.Job.Output.WaterMarkList()
                        model.fromMap(dict["WaterMarkList"] as! [String: Any])
                        self.waterMarkList = model
                    }
                }
            }
            public var code: String?

            public var creationTime: String?

            public var finishTime: String?

            public var input: ListJobResponseBody.JobList.Job.Input?

            public var jobId: String?

            public var MNSMessageResult: ListJobResponseBody.JobList.Job.MNSMessageResult?

            public var message: String?

            public var output: ListJobResponseBody.JobList.Job.Output?

            public var percent: Int64?

            public var pipelineId: String?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.input?.validate()
                try self.MNSMessageResult?.validate()
                try self.output?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.MNSMessageResult != nil {
                    map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("Input") {
                    var model = ListJobResponseBody.JobList.Job.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("MNSMessageResult") {
                    var model = ListJobResponseBody.JobList.Job.MNSMessageResult()
                    model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                    self.MNSMessageResult = model
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Output") {
                    var model = ListJobResponseBody.JobList.Job.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! Int64
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
            }
        }
        public var job: [ListJobResponseBody.JobList.Job]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.job != nil {
                var tmp : [Any] = []
                for k in self.job! {
                    tmp.append(k.toMap())
                }
                map["Job"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Job") {
                var tmp : [ListJobResponseBody.JobList.Job] = []
                for v in dict["Job"] as! [Any] {
                    var model = ListJobResponseBody.JobList.Job()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.job = tmp
            }
        }
    }
    public var jobList: ListJobResponseBody.JobList?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobList != nil {
            map["JobList"] = self.jobList?.toMap()
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobList") {
            var model = ListJobResponseBody.JobList()
            model.fromMap(dict["JobList"] as! [String: Any])
            self.jobList = model
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaRequest : Tea.TeaModel {
    public var from: String?

    public var maximumPageSize: Int64?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var to: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.from != nil {
            map["From"] = self.from!
        }
        if self.maximumPageSize != nil {
            map["MaximumPageSize"] = self.maximumPageSize!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.to != nil {
            map["To"] = self.to!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("From") {
            self.from = dict["From"] as! String
        }
        if dict.keys.contains("MaximumPageSize") {
            self.maximumPageSize = dict["MaximumPageSize"] as! Int64
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("To") {
            self.to = dict["To"] as! String
        }
    }
}

public class ListMediaResponseBody : Tea.TeaModel {
    public class MediaList : Tea.TeaModel {
        public class Media : Tea.TeaModel {
            public class File : Tea.TeaModel {
                public var state: String?

                public var URL: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    if self.URL != nil {
                        map["URL"] = self.URL!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! String
                    }
                    if dict.keys.contains("URL") {
                        self.URL = dict["URL"] as! String
                    }
                }
            }
            public class RunIdList : Tea.TeaModel {
                public var runId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.runId != nil {
                        map["RunId"] = self.runId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RunId") {
                        self.runId = dict["RunId"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var tag: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        map["Tag"] = self.tag!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        self.tag = dict["Tag"] as! [String]
                    }
                }
            }
            public var bitrate: String?

            public var cateId: Int64?

            public var censorState: String?

            public var coverURL: String?

            public var creationTime: String?

            public var description_: String?

            public var duration: String?

            public var file: ListMediaResponseBody.MediaList.Media.File?

            public var format: String?

            public var fps: String?

            public var height: String?

            public var mediaId: String?

            public var publishState: String?

            public var runIdList: ListMediaResponseBody.MediaList.Media.RunIdList?

            public var size: String?

            public var tags: ListMediaResponseBody.MediaList.Media.Tags?

            public var title: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.file?.validate()
                try self.runIdList?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.censorState != nil {
                    map["CensorState"] = self.censorState!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.file != nil {
                    map["File"] = self.file?.toMap()
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.publishState != nil {
                    map["PublishState"] = self.publishState!
                }
                if self.runIdList != nil {
                    map["RunIdList"] = self.runIdList?.toMap()
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CensorState") {
                    self.censorState = dict["CensorState"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("File") {
                    var model = ListMediaResponseBody.MediaList.Media.File()
                    model.fromMap(dict["File"] as! [String: Any])
                    self.file = model
                }
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("PublishState") {
                    self.publishState = dict["PublishState"] as! String
                }
                if dict.keys.contains("RunIdList") {
                    var model = ListMediaResponseBody.MediaList.Media.RunIdList()
                    model.fromMap(dict["RunIdList"] as! [String: Any])
                    self.runIdList = model
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = ListMediaResponseBody.MediaList.Media.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var media: [ListMediaResponseBody.MediaList.Media]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                var tmp : [Any] = []
                for k in self.media! {
                    tmp.append(k.toMap())
                }
                map["Media"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                var tmp : [ListMediaResponseBody.MediaList.Media] = []
                for v in dict["Media"] as! [Any] {
                    var model = ListMediaResponseBody.MediaList.Media()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.media = tmp
            }
        }
    }
    public var mediaList: ListMediaResponseBody.MediaList?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaList != nil {
            map["MediaList"] = self.mediaList?.toMap()
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaList") {
            var model = ListMediaResponseBody.MediaList()
            model.fromMap(dict["MediaList"] as! [String: Any])
            self.mediaList = model
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaWorkflowExecutionsRequest : Tea.TeaModel {
    public var inputFileURL: String?

    public var maximumPageSize: Int64?

    public var mediaWorkflowId: String?

    public var mediaWorkflowName: String?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputFileURL != nil {
            map["InputFileURL"] = self.inputFileURL!
        }
        if self.maximumPageSize != nil {
            map["MaximumPageSize"] = self.maximumPageSize!
        }
        if self.mediaWorkflowId != nil {
            map["MediaWorkflowId"] = self.mediaWorkflowId!
        }
        if self.mediaWorkflowName != nil {
            map["MediaWorkflowName"] = self.mediaWorkflowName!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputFileURL") {
            self.inputFileURL = dict["InputFileURL"] as! String
        }
        if dict.keys.contains("MaximumPageSize") {
            self.maximumPageSize = dict["MaximumPageSize"] as! Int64
        }
        if dict.keys.contains("MediaWorkflowId") {
            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
        }
        if dict.keys.contains("MediaWorkflowName") {
            self.mediaWorkflowName = dict["MediaWorkflowName"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListMediaWorkflowExecutionsResponseBody : Tea.TeaModel {
    public class MediaWorkflowExecutionList : Tea.TeaModel {
        public class MediaWorkflowExecution : Tea.TeaModel {
            public class ActivityList : Tea.TeaModel {
                public class Activity : Tea.TeaModel {
                    public class MNSMessageResult : Tea.TeaModel {
                        public var errorCode: String?

                        public var errorMessage: String?

                        public var messageId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.errorCode != nil {
                                map["ErrorCode"] = self.errorCode!
                            }
                            if self.errorMessage != nil {
                                map["ErrorMessage"] = self.errorMessage!
                            }
                            if self.messageId != nil {
                                map["MessageId"] = self.messageId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ErrorCode") {
                                self.errorCode = dict["ErrorCode"] as! String
                            }
                            if dict.keys.contains("ErrorMessage") {
                                self.errorMessage = dict["ErrorMessage"] as! String
                            }
                            if dict.keys.contains("MessageId") {
                                self.messageId = dict["MessageId"] as! String
                            }
                        }
                    }
                    public var code: String?

                    public var endTime: String?

                    public var jobId: String?

                    public var MNSMessageResult: ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity.MNSMessageResult?

                    public var message: String?

                    public var name: String?

                    public var startTime: String?

                    public var state: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.MNSMessageResult?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.code != nil {
                            map["Code"] = self.code!
                        }
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.jobId != nil {
                            map["JobId"] = self.jobId!
                        }
                        if self.MNSMessageResult != nil {
                            map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
                        }
                        if self.message != nil {
                            map["Message"] = self.message!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.state != nil {
                            map["State"] = self.state!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Code") {
                            self.code = dict["Code"] as! String
                        }
                        if dict.keys.contains("EndTime") {
                            self.endTime = dict["EndTime"] as! String
                        }
                        if dict.keys.contains("JobId") {
                            self.jobId = dict["JobId"] as! String
                        }
                        if dict.keys.contains("MNSMessageResult") {
                            var model = ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity.MNSMessageResult()
                            model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                            self.MNSMessageResult = model
                        }
                        if dict.keys.contains("Message") {
                            self.message = dict["Message"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                        if dict.keys.contains("State") {
                            self.state = dict["State"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var activity: [ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.activity != nil {
                        var tmp : [Any] = []
                        for k in self.activity! {
                            tmp.append(k.toMap())
                        }
                        map["Activity"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Activity") {
                        var tmp : [ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity] = []
                        for v in dict["Activity"] as! [Any] {
                            var model = ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.activity = tmp
                    }
                }
            }
            public class Input : Tea.TeaModel {
                public class InputFile : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                    }
                }
                public var inputFile: ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.Input.InputFile?

                public var userData: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.inputFile?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.inputFile != nil {
                        map["InputFile"] = self.inputFile?.toMap()
                    }
                    if self.userData != nil {
                        map["UserData"] = self.userData!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InputFile") {
                        var model = ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.Input.InputFile()
                        model.fromMap(dict["InputFile"] as! [String: Any])
                        self.inputFile = model
                    }
                    if dict.keys.contains("UserData") {
                        self.userData = dict["UserData"] as! String
                    }
                }
            }
            public var activityList: ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList?

            public var creationTime: String?

            public var input: ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.Input?

            public var mediaId: String?

            public var mediaWorkflowId: String?

            public var name: String?

            public var runId: String?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.activityList?.validate()
                try self.input?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activityList != nil {
                    map["ActivityList"] = self.activityList?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaWorkflowId != nil {
                    map["MediaWorkflowId"] = self.mediaWorkflowId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.runId != nil {
                    map["RunId"] = self.runId!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActivityList") {
                    var model = ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList()
                    model.fromMap(dict["ActivityList"] as! [String: Any])
                    self.activityList = model
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Input") {
                    var model = ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaWorkflowId") {
                    self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RunId") {
                    self.runId = dict["RunId"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
            }
        }
        public var mediaWorkflowExecution: [ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaWorkflowExecution != nil {
                var tmp : [Any] = []
                for k in self.mediaWorkflowExecution! {
                    tmp.append(k.toMap())
                }
                map["MediaWorkflowExecution"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaWorkflowExecution") {
                var tmp : [ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution] = []
                for v in dict["MediaWorkflowExecution"] as! [Any] {
                    var model = ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaWorkflowExecution = tmp
            }
        }
    }
    public var mediaWorkflowExecutionList: ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflowExecutionList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowExecutionList != nil {
            map["MediaWorkflowExecutionList"] = self.mediaWorkflowExecutionList?.toMap()
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowExecutionList") {
            var model = ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList()
            model.fromMap(dict["MediaWorkflowExecutionList"] as! [String: Any])
            self.mediaWorkflowExecutionList = model
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMediaWorkflowExecutionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaWorkflowExecutionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMediaWorkflowExecutionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAnalysisJobListRequest : Tea.TeaModel {
    public var analysisJobIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.analysisJobIds != nil {
            map["AnalysisJobIds"] = self.analysisJobIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AnalysisJobIds") {
            self.analysisJobIds = dict["AnalysisJobIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryAnalysisJobListResponseBody : Tea.TeaModel {
    public class AnalysisJobList : Tea.TeaModel {
        public class AnalysisJob : Tea.TeaModel {
            public class AnalysisConfig : Tea.TeaModel {
                public class PropertiesControl : Tea.TeaModel {
                    public class Crop : Tea.TeaModel {
                        public var height: String?

                        public var left_: String?

                        public var mode: String?

                        public var top: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.mode != nil {
                                map["Mode"] = self.mode!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("Left") {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Mode") {
                                self.mode = dict["Mode"] as! String
                            }
                            if dict.keys.contains("Top") {
                                self.top = dict["Top"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var crop: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.AnalysisConfig.PropertiesControl.Crop?

                    public var deinterlace: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.crop?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.crop != nil {
                            map["Crop"] = self.crop?.toMap()
                        }
                        if self.deinterlace != nil {
                            map["Deinterlace"] = self.deinterlace!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Crop") {
                            var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.AnalysisConfig.PropertiesControl.Crop()
                            model.fromMap(dict["Crop"] as! [String: Any])
                            self.crop = model
                        }
                        if dict.keys.contains("Deinterlace") {
                            self.deinterlace = dict["Deinterlace"] as! String
                        }
                    }
                }
                public class QualityControl : Tea.TeaModel {
                    public var methodStreaming: String?

                    public var rateQuality: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.methodStreaming != nil {
                            map["MethodStreaming"] = self.methodStreaming!
                        }
                        if self.rateQuality != nil {
                            map["RateQuality"] = self.rateQuality!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("MethodStreaming") {
                            self.methodStreaming = dict["MethodStreaming"] as! String
                        }
                        if dict.keys.contains("RateQuality") {
                            self.rateQuality = dict["RateQuality"] as! String
                        }
                    }
                }
                public var propertiesControl: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.AnalysisConfig.PropertiesControl?

                public var qualityControl: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.AnalysisConfig.QualityControl?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.propertiesControl?.validate()
                    try self.qualityControl?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.propertiesControl != nil {
                        map["PropertiesControl"] = self.propertiesControl?.toMap()
                    }
                    if self.qualityControl != nil {
                        map["QualityControl"] = self.qualityControl?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PropertiesControl") {
                        var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.AnalysisConfig.PropertiesControl()
                        model.fromMap(dict["PropertiesControl"] as! [String: Any])
                        self.propertiesControl = model
                    }
                    if dict.keys.contains("QualityControl") {
                        var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.AnalysisConfig.QualityControl()
                        model.fromMap(dict["QualityControl"] as! [String: Any])
                        self.qualityControl = model
                    }
                }
            }
            public class InputFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public class MNSMessageResult : Tea.TeaModel {
                public var errorCode: String?

                public var errorMessage: String?

                public var messageId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.messageId != nil {
                        map["MessageId"] = self.messageId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("MessageId") {
                        self.messageId = dict["MessageId"] as! String
                    }
                }
            }
            public class TemplateList : Tea.TeaModel {
                public class Template : Tea.TeaModel {
                    public class Audio : Tea.TeaModel {
                        public var bitrate: String?

                        public var channels: String?

                        public var codec: String?

                        public var profile: String?

                        public var qscale: String?

                        public var samplerate: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.channels != nil {
                                map["Channels"] = self.channels!
                            }
                            if self.codec != nil {
                                map["Codec"] = self.codec!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.qscale != nil {
                                map["Qscale"] = self.qscale!
                            }
                            if self.samplerate != nil {
                                map["Samplerate"] = self.samplerate!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Channels") {
                                self.channels = dict["Channels"] as! String
                            }
                            if dict.keys.contains("Codec") {
                                self.codec = dict["Codec"] as! String
                            }
                            if dict.keys.contains("Profile") {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Qscale") {
                                self.qscale = dict["Qscale"] as! String
                            }
                            if dict.keys.contains("Samplerate") {
                                self.samplerate = dict["Samplerate"] as! String
                            }
                        }
                    }
                    public class Container : Tea.TeaModel {
                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public class MuxConfig : Tea.TeaModel {
                        public class Gif : Tea.TeaModel {
                            public var finalDelay: String?

                            public var loop: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.finalDelay != nil {
                                    map["FinalDelay"] = self.finalDelay!
                                }
                                if self.loop != nil {
                                    map["Loop"] = self.loop!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("FinalDelay") {
                                    self.finalDelay = dict["FinalDelay"] as! String
                                }
                                if dict.keys.contains("Loop") {
                                    self.loop = dict["Loop"] as! String
                                }
                            }
                        }
                        public class Segment : Tea.TeaModel {
                            public var duration: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                            }
                        }
                        public var gif: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.MuxConfig.Gif?

                        public var segment: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.MuxConfig.Segment?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.gif?.validate()
                            try self.segment?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.gif != nil {
                                map["Gif"] = self.gif?.toMap()
                            }
                            if self.segment != nil {
                                map["Segment"] = self.segment?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Gif") {
                                var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.MuxConfig.Gif()
                                model.fromMap(dict["Gif"] as! [String: Any])
                                self.gif = model
                            }
                            if dict.keys.contains("Segment") {
                                var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.MuxConfig.Segment()
                                model.fromMap(dict["Segment"] as! [String: Any])
                                self.segment = model
                            }
                        }
                    }
                    public class TransConfig : Tea.TeaModel {
                        public var transMode: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.transMode != nil {
                                map["TransMode"] = self.transMode!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("TransMode") {
                                self.transMode = dict["TransMode"] as! String
                            }
                        }
                    }
                    public class Video : Tea.TeaModel {
                        public class BitrateBnd : Tea.TeaModel {
                            public var max: String?

                            public var min: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.max != nil {
                                    map["Max"] = self.max!
                                }
                                if self.min != nil {
                                    map["Min"] = self.min!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Max") {
                                    self.max = dict["Max"] as! String
                                }
                                if dict.keys.contains("Min") {
                                    self.min = dict["Min"] as! String
                                }
                            }
                        }
                        public var bitrate: String?

                        public var bitrateBnd: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.Video.BitrateBnd?

                        public var bufsize: String?

                        public var codec: String?

                        public var crf: String?

                        public var degrain: String?

                        public var fps: String?

                        public var gop: String?

                        public var height: String?

                        public var maxrate: String?

                        public var pixFmt: String?

                        public var preset: String?

                        public var profile: String?

                        public var qscale: String?

                        public var scanMode: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.bitrateBnd?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.bitrateBnd != nil {
                                map["BitrateBnd"] = self.bitrateBnd?.toMap()
                            }
                            if self.bufsize != nil {
                                map["Bufsize"] = self.bufsize!
                            }
                            if self.codec != nil {
                                map["Codec"] = self.codec!
                            }
                            if self.crf != nil {
                                map["Crf"] = self.crf!
                            }
                            if self.degrain != nil {
                                map["Degrain"] = self.degrain!
                            }
                            if self.fps != nil {
                                map["Fps"] = self.fps!
                            }
                            if self.gop != nil {
                                map["Gop"] = self.gop!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.maxrate != nil {
                                map["Maxrate"] = self.maxrate!
                            }
                            if self.pixFmt != nil {
                                map["PixFmt"] = self.pixFmt!
                            }
                            if self.preset != nil {
                                map["Preset"] = self.preset!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.qscale != nil {
                                map["Qscale"] = self.qscale!
                            }
                            if self.scanMode != nil {
                                map["ScanMode"] = self.scanMode!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("BitrateBnd") {
                                var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.Video.BitrateBnd()
                                model.fromMap(dict["BitrateBnd"] as! [String: Any])
                                self.bitrateBnd = model
                            }
                            if dict.keys.contains("Bufsize") {
                                self.bufsize = dict["Bufsize"] as! String
                            }
                            if dict.keys.contains("Codec") {
                                self.codec = dict["Codec"] as! String
                            }
                            if dict.keys.contains("Crf") {
                                self.crf = dict["Crf"] as! String
                            }
                            if dict.keys.contains("Degrain") {
                                self.degrain = dict["Degrain"] as! String
                            }
                            if dict.keys.contains("Fps") {
                                self.fps = dict["Fps"] as! String
                            }
                            if dict.keys.contains("Gop") {
                                self.gop = dict["Gop"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("Maxrate") {
                                self.maxrate = dict["Maxrate"] as! String
                            }
                            if dict.keys.contains("PixFmt") {
                                self.pixFmt = dict["PixFmt"] as! String
                            }
                            if dict.keys.contains("Preset") {
                                self.preset = dict["Preset"] as! String
                            }
                            if dict.keys.contains("Profile") {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Qscale") {
                                self.qscale = dict["Qscale"] as! String
                            }
                            if dict.keys.contains("ScanMode") {
                                self.scanMode = dict["ScanMode"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var audio: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.Audio?

                    public var container: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.Container?

                    public var id: String?

                    public var muxConfig: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.MuxConfig?

                    public var name: String?

                    public var state: String?

                    public var transConfig: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.TransConfig?

                    public var video: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.Video?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.audio?.validate()
                        try self.container?.validate()
                        try self.muxConfig?.validate()
                        try self.transConfig?.validate()
                        try self.video?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audio != nil {
                            map["Audio"] = self.audio?.toMap()
                        }
                        if self.container != nil {
                            map["Container"] = self.container?.toMap()
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.muxConfig != nil {
                            map["MuxConfig"] = self.muxConfig?.toMap()
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.state != nil {
                            map["State"] = self.state!
                        }
                        if self.transConfig != nil {
                            map["TransConfig"] = self.transConfig?.toMap()
                        }
                        if self.video != nil {
                            map["Video"] = self.video?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Audio") {
                            var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.Audio()
                            model.fromMap(dict["Audio"] as! [String: Any])
                            self.audio = model
                        }
                        if dict.keys.contains("Container") {
                            var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.Container()
                            model.fromMap(dict["Container"] as! [String: Any])
                            self.container = model
                        }
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("MuxConfig") {
                            var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.MuxConfig()
                            model.fromMap(dict["MuxConfig"] as! [String: Any])
                            self.muxConfig = model
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("State") {
                            self.state = dict["State"] as! String
                        }
                        if dict.keys.contains("TransConfig") {
                            var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.TransConfig()
                            model.fromMap(dict["TransConfig"] as! [String: Any])
                            self.transConfig = model
                        }
                        if dict.keys.contains("Video") {
                            var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.Video()
                            model.fromMap(dict["Video"] as! [String: Any])
                            self.video = model
                        }
                    }
                }
                public var template: [QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.template != nil {
                        var tmp : [Any] = []
                        for k in self.template! {
                            tmp.append(k.toMap())
                        }
                        map["Template"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Template") {
                        var tmp : [QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template] = []
                        for v in dict["Template"] as! [Any] {
                            var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.template = tmp
                    }
                }
            }
            public var analysisConfig: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.AnalysisConfig?

            public var code: String?

            public var creationTime: String?

            public var id: String?

            public var inputFile: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.InputFile?

            public var MNSMessageResult: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.MNSMessageResult?

            public var message: String?

            public var percent: Int64?

            public var pipelineId: String?

            public var priority: String?

            public var state: String?

            public var templateList: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.analysisConfig?.validate()
                try self.inputFile?.validate()
                try self.MNSMessageResult?.validate()
                try self.templateList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.analysisConfig != nil {
                    map["AnalysisConfig"] = self.analysisConfig?.toMap()
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.inputFile != nil {
                    map["InputFile"] = self.inputFile?.toMap()
                }
                if self.MNSMessageResult != nil {
                    map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.templateList != nil {
                    map["TemplateList"] = self.templateList?.toMap()
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AnalysisConfig") {
                    var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.AnalysisConfig()
                    model.fromMap(dict["AnalysisConfig"] as! [String: Any])
                    self.analysisConfig = model
                }
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("InputFile") {
                    var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.InputFile()
                    model.fromMap(dict["InputFile"] as! [String: Any])
                    self.inputFile = model
                }
                if dict.keys.contains("MNSMessageResult") {
                    var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.MNSMessageResult()
                    model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                    self.MNSMessageResult = model
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! Int64
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("TemplateList") {
                    var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList()
                    model.fromMap(dict["TemplateList"] as! [String: Any])
                    self.templateList = model
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var analysisJob: [QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.analysisJob != nil {
                var tmp : [Any] = []
                for k in self.analysisJob! {
                    tmp.append(k.toMap())
                }
                map["AnalysisJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AnalysisJob") {
                var tmp : [QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob] = []
                for v in dict["AnalysisJob"] as! [Any] {
                    var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.analysisJob = tmp
            }
        }
    }
    public class NonExistAnalysisJobIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public var analysisJobList: QueryAnalysisJobListResponseBody.AnalysisJobList?

    public var nonExistAnalysisJobIds: QueryAnalysisJobListResponseBody.NonExistAnalysisJobIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.analysisJobList?.validate()
        try self.nonExistAnalysisJobIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.analysisJobList != nil {
            map["AnalysisJobList"] = self.analysisJobList?.toMap()
        }
        if self.nonExistAnalysisJobIds != nil {
            map["NonExistAnalysisJobIds"] = self.nonExistAnalysisJobIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AnalysisJobList") {
            var model = QueryAnalysisJobListResponseBody.AnalysisJobList()
            model.fromMap(dict["AnalysisJobList"] as! [String: Any])
            self.analysisJobList = model
        }
        if dict.keys.contains("NonExistAnalysisJobIds") {
            var model = QueryAnalysisJobListResponseBody.NonExistAnalysisJobIds()
            model.fromMap(dict["NonExistAnalysisJobIds"] as! [String: Any])
            self.nonExistAnalysisJobIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryAnalysisJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAnalysisJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryAnalysisJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryEditingJobListRequest : Tea.TeaModel {
    public var jobIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryEditingJobListResponseBody : Tea.TeaModel {
    public class JobList : Tea.TeaModel {
        public class Job : Tea.TeaModel {
            public class EditingConfig : Tea.TeaModel {
                public class Audio : Tea.TeaModel {
                    public class Volume : Tea.TeaModel {
                        public var level: String?

                        public var method: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.level != nil {
                                map["Level"] = self.level!
                            }
                            if self.method != nil {
                                map["Method"] = self.method!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Level") {
                                self.level = dict["Level"] as! String
                            }
                            if dict.keys.contains("Method") {
                                self.method = dict["Method"] as! String
                            }
                        }
                    }
                    public var bitrate: String?

                    public var channels: String?

                    public var codec: String?

                    public var profile: String?

                    public var qscale: String?

                    public var samplerate: String?

                    public var volume: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Audio.Volume?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.volume?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        if self.codec != nil {
                            map["Codec"] = self.codec!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.qscale != nil {
                            map["Qscale"] = self.qscale!
                        }
                        if self.samplerate != nil {
                            map["Samplerate"] = self.samplerate!
                        }
                        if self.volume != nil {
                            map["Volume"] = self.volume?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Channels") {
                            self.channels = dict["Channels"] as! String
                        }
                        if dict.keys.contains("Codec") {
                            self.codec = dict["Codec"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Qscale") {
                            self.qscale = dict["Qscale"] as! String
                        }
                        if dict.keys.contains("Samplerate") {
                            self.samplerate = dict["Samplerate"] as! String
                        }
                        if dict.keys.contains("Volume") {
                            var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Audio.Volume()
                            model.fromMap(dict["Volume"] as! [String: Any])
                            self.volume = model
                        }
                    }
                }
                public class Clip : Tea.TeaModel {
                    public class TimeSpan : Tea.TeaModel {
                        public var duration: String?

                        public var seek: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.seek != nil {
                                map["Seek"] = self.seek!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("Seek") {
                                self.seek = dict["Seek"] as! String
                            }
                        }
                    }
                    public var timeSpan: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Clip.TimeSpan?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.timeSpan?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.timeSpan != nil {
                            map["TimeSpan"] = self.timeSpan?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TimeSpan") {
                            var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Clip.TimeSpan()
                            model.fromMap(dict["TimeSpan"] as! [String: Any])
                            self.timeSpan = model
                        }
                    }
                }
                public class Container : Tea.TeaModel {
                    public var format: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                    }
                }
                public class DigiWaterMark : Tea.TeaModel {
                    public class InputFile : Tea.TeaModel {
                        public var bucket: String?

                        public var location: String?

                        public var object: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bucket != nil {
                                map["Bucket"] = self.bucket!
                            }
                            if self.location != nil {
                                map["Location"] = self.location!
                            }
                            if self.object != nil {
                                map["Object"] = self.object!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bucket") {
                                self.bucket = dict["Bucket"] as! String
                            }
                            if dict.keys.contains("Location") {
                                self.location = dict["Location"] as! String
                            }
                            if dict.keys.contains("Object") {
                                self.object = dict["Object"] as! String
                            }
                        }
                    }
                    public var alpha: String?

                    public var inputFile: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.DigiWaterMark.InputFile?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.inputFile?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.alpha != nil {
                            map["Alpha"] = self.alpha!
                        }
                        if self.inputFile != nil {
                            map["InputFile"] = self.inputFile?.toMap()
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Alpha") {
                            self.alpha = dict["Alpha"] as! String
                        }
                        if dict.keys.contains("InputFile") {
                            var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.DigiWaterMark.InputFile()
                            model.fromMap(dict["InputFile"] as! [String: Any])
                            self.inputFile = model
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public class Editing : Tea.TeaModel {
                    public class ClipList : Tea.TeaModel {
                        public class Clip : Tea.TeaModel {
                            public class Effects : Tea.TeaModel {
                                public class Effect : Tea.TeaModel {
                                    public var effect: String?

                                    public var effectConfig: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.effect != nil {
                                            map["Effect"] = self.effect!
                                        }
                                        if self.effectConfig != nil {
                                            map["EffectConfig"] = self.effectConfig!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Effect") {
                                            self.effect = dict["Effect"] as! String
                                        }
                                        if dict.keys.contains("EffectConfig") {
                                            self.effectConfig = dict["EffectConfig"] as! String
                                        }
                                    }
                                }
                                public var effect: [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.ClipList.Clip.Effects.Effect]?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.effect != nil {
                                        var tmp : [Any] = []
                                        for k in self.effect! {
                                            tmp.append(k.toMap())
                                        }
                                        map["Effect"] = tmp
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Effect") {
                                        var tmp : [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.ClipList.Clip.Effects.Effect] = []
                                        for v in dict["Effect"] as! [Any] {
                                            var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.ClipList.Clip.Effects.Effect()
                                            if v != nil {
                                                model.fromMap(v as! [String: Any])
                                            }
                                            tmp.append(model)
                                        }
                                        self.effect = tmp
                                    }
                                }
                            }
                            public var effects: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.ClipList.Clip.Effects?

                            public var id: String?

                            public var in_: String?

                            public var out: String?

                            public var sourceID: String?

                            public var sourceStrmMap: String?

                            public var sourceType: String?

                            public var type: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.effects?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.effects != nil {
                                    map["Effects"] = self.effects?.toMap()
                                }
                                if self.id != nil {
                                    map["Id"] = self.id!
                                }
                                if self.in_ != nil {
                                    map["In"] = self.in_!
                                }
                                if self.out != nil {
                                    map["Out"] = self.out!
                                }
                                if self.sourceID != nil {
                                    map["SourceID"] = self.sourceID!
                                }
                                if self.sourceStrmMap != nil {
                                    map["SourceStrmMap"] = self.sourceStrmMap!
                                }
                                if self.sourceType != nil {
                                    map["SourceType"] = self.sourceType!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Effects") {
                                    var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.ClipList.Clip.Effects()
                                    model.fromMap(dict["Effects"] as! [String: Any])
                                    self.effects = model
                                }
                                if dict.keys.contains("Id") {
                                    self.id = dict["Id"] as! String
                                }
                                if dict.keys.contains("In") {
                                    self.in_ = dict["In"] as! String
                                }
                                if dict.keys.contains("Out") {
                                    self.out = dict["Out"] as! String
                                }
                                if dict.keys.contains("SourceID") {
                                    self.sourceID = dict["SourceID"] as! String
                                }
                                if dict.keys.contains("SourceStrmMap") {
                                    self.sourceStrmMap = dict["SourceStrmMap"] as! String
                                }
                                if dict.keys.contains("SourceType") {
                                    self.sourceType = dict["SourceType"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                            }
                        }
                        public var clip: [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.ClipList.Clip]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.clip != nil {
                                var tmp : [Any] = []
                                for k in self.clip! {
                                    tmp.append(k.toMap())
                                }
                                map["Clip"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Clip") {
                                var tmp : [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.ClipList.Clip] = []
                                for v in dict["Clip"] as! [Any] {
                                    var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.ClipList.Clip()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.clip = tmp
                            }
                        }
                    }
                    public class Timeline : Tea.TeaModel {
                        public class TimelineConfig : Tea.TeaModel {
                            public class TimelineConfigAudio : Tea.TeaModel {
                                public var channelLayout: String?

                                public var channels: String?

                                public var samplerate: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.channelLayout != nil {
                                        map["ChannelLayout"] = self.channelLayout!
                                    }
                                    if self.channels != nil {
                                        map["Channels"] = self.channels!
                                    }
                                    if self.samplerate != nil {
                                        map["Samplerate"] = self.samplerate!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("ChannelLayout") {
                                        self.channelLayout = dict["ChannelLayout"] as! String
                                    }
                                    if dict.keys.contains("Channels") {
                                        self.channels = dict["Channels"] as! String
                                    }
                                    if dict.keys.contains("Samplerate") {
                                        self.samplerate = dict["Samplerate"] as! String
                                    }
                                }
                            }
                            public class TimelineConfigVideo : Tea.TeaModel {
                                public var bgColor: String?

                                public var fps: String?

                                public var height: String?

                                public var isGpuData: String?

                                public var isOneTrackData: String?

                                public var reclosePrec: String?

                                public var renderRatio: String?

                                public var width: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.bgColor != nil {
                                        map["BgColor"] = self.bgColor!
                                    }
                                    if self.fps != nil {
                                        map["Fps"] = self.fps!
                                    }
                                    if self.height != nil {
                                        map["Height"] = self.height!
                                    }
                                    if self.isGpuData != nil {
                                        map["IsGpuData"] = self.isGpuData!
                                    }
                                    if self.isOneTrackData != nil {
                                        map["IsOneTrackData"] = self.isOneTrackData!
                                    }
                                    if self.reclosePrec != nil {
                                        map["ReclosePrec"] = self.reclosePrec!
                                    }
                                    if self.renderRatio != nil {
                                        map["RenderRatio"] = self.renderRatio!
                                    }
                                    if self.width != nil {
                                        map["Width"] = self.width!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("BgColor") {
                                        self.bgColor = dict["BgColor"] as! String
                                    }
                                    if dict.keys.contains("Fps") {
                                        self.fps = dict["Fps"] as! String
                                    }
                                    if dict.keys.contains("Height") {
                                        self.height = dict["Height"] as! String
                                    }
                                    if dict.keys.contains("IsGpuData") {
                                        self.isGpuData = dict["IsGpuData"] as! String
                                    }
                                    if dict.keys.contains("IsOneTrackData") {
                                        self.isOneTrackData = dict["IsOneTrackData"] as! String
                                    }
                                    if dict.keys.contains("ReclosePrec") {
                                        self.reclosePrec = dict["ReclosePrec"] as! String
                                    }
                                    if dict.keys.contains("RenderRatio") {
                                        self.renderRatio = dict["RenderRatio"] as! String
                                    }
                                    if dict.keys.contains("Width") {
                                        self.width = dict["Width"] as! String
                                    }
                                }
                            }
                            public var timelineConfigAudio: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TimelineConfig.TimelineConfigAudio?

                            public var timelineConfigVideo: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TimelineConfig.TimelineConfigVideo?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.timelineConfigAudio?.validate()
                                try self.timelineConfigVideo?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.timelineConfigAudio != nil {
                                    map["TimelineConfigAudio"] = self.timelineConfigAudio?.toMap()
                                }
                                if self.timelineConfigVideo != nil {
                                    map["TimelineConfigVideo"] = self.timelineConfigVideo?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("TimelineConfigAudio") {
                                    var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TimelineConfig.TimelineConfigAudio()
                                    model.fromMap(dict["TimelineConfigAudio"] as! [String: Any])
                                    self.timelineConfigAudio = model
                                }
                                if dict.keys.contains("TimelineConfigVideo") {
                                    var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TimelineConfig.TimelineConfigVideo()
                                    model.fromMap(dict["TimelineConfigVideo"] as! [String: Any])
                                    self.timelineConfigVideo = model
                                }
                            }
                        }
                        public class TrackList : Tea.TeaModel {
                            public class Track : Tea.TeaModel {
                                public class Clips : Tea.TeaModel {
                                    public class Clip : Tea.TeaModel {
                                        public class ClipsConfig : Tea.TeaModel {
                                            public class ClipsConfigVideo : Tea.TeaModel {
                                                public var l: String?

                                                public var t: String?

                                                public override init() {
                                                    super.init()
                                                }

                                                public init(_ dict: [String: Any]) {
                                                    super.init()
                                                    self.fromMap(dict)
                                                }

                                                public override func validate() throws -> Void {
                                                }

                                                public override func toMap() -> [String : Any] {
                                                    var map = super.toMap()
                                                    if self.l != nil {
                                                        map["L"] = self.l!
                                                    }
                                                    if self.t != nil {
                                                        map["T"] = self.t!
                                                    }
                                                    return map
                                                }

                                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                                    if dict.keys.contains("L") {
                                                        self.l = dict["L"] as! String
                                                    }
                                                    if dict.keys.contains("T") {
                                                        self.t = dict["T"] as! String
                                                    }
                                                }
                                            }
                                            public var clipsConfigVideo: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TrackList.Track.Clips.Clip.ClipsConfig.ClipsConfigVideo?

                                            public override init() {
                                                super.init()
                                            }

                                            public init(_ dict: [String: Any]) {
                                                super.init()
                                                self.fromMap(dict)
                                            }

                                            public override func validate() throws -> Void {
                                                try self.clipsConfigVideo?.validate()
                                            }

                                            public override func toMap() -> [String : Any] {
                                                var map = super.toMap()
                                                if self.clipsConfigVideo != nil {
                                                    map["ClipsConfigVideo"] = self.clipsConfigVideo?.toMap()
                                                }
                                                return map
                                            }

                                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                                if dict.keys.contains("ClipsConfigVideo") {
                                                    var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TrackList.Track.Clips.Clip.ClipsConfig.ClipsConfigVideo()
                                                    model.fromMap(dict["ClipsConfigVideo"] as! [String: Any])
                                                    self.clipsConfigVideo = model
                                                }
                                            }
                                        }
                                        public var clipsConfig: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TrackList.Track.Clips.Clip.ClipsConfig?

                                        public var in_: String?

                                        public var out: String?

                                        public var clipID: String?

                                        public override init() {
                                            super.init()
                                        }

                                        public init(_ dict: [String: Any]) {
                                            super.init()
                                            self.fromMap(dict)
                                        }

                                        public override func validate() throws -> Void {
                                            try self.clipsConfig?.validate()
                                        }

                                        public override func toMap() -> [String : Any] {
                                            var map = super.toMap()
                                            if self.clipsConfig != nil {
                                                map["ClipsConfig"] = self.clipsConfig?.toMap()
                                            }
                                            if self.in_ != nil {
                                                map["In"] = self.in_!
                                            }
                                            if self.out != nil {
                                                map["Out"] = self.out!
                                            }
                                            if self.clipID != nil {
                                                map["clipID"] = self.clipID!
                                            }
                                            return map
                                        }

                                        public override func fromMap(_ dict: [String: Any]) -> Void {
                                            if dict.keys.contains("ClipsConfig") {
                                                var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TrackList.Track.Clips.Clip.ClipsConfig()
                                                model.fromMap(dict["ClipsConfig"] as! [String: Any])
                                                self.clipsConfig = model
                                            }
                                            if dict.keys.contains("In") {
                                                self.in_ = dict["In"] as! String
                                            }
                                            if dict.keys.contains("Out") {
                                                self.out = dict["Out"] as! String
                                            }
                                            if dict.keys.contains("clipID") {
                                                self.clipID = dict["clipID"] as! String
                                            }
                                        }
                                    }
                                    public var clip: [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TrackList.Track.Clips.Clip]?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.clip != nil {
                                            var tmp : [Any] = []
                                            for k in self.clip! {
                                                tmp.append(k.toMap())
                                            }
                                            map["Clip"] = tmp
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Clip") {
                                            var tmp : [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TrackList.Track.Clips.Clip] = []
                                            for v in dict["Clip"] as! [Any] {
                                                var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TrackList.Track.Clips.Clip()
                                                if v != nil {
                                                    model.fromMap(v as! [String: Any])
                                                }
                                                tmp.append(model)
                                            }
                                            self.clip = tmp
                                        }
                                    }
                                }
                                public var clips: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TrackList.Track.Clips?

                                public var id: String?

                                public var order: String?

                                public var type: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                    try self.clips?.validate()
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.clips != nil {
                                        map["Clips"] = self.clips?.toMap()
                                    }
                                    if self.id != nil {
                                        map["Id"] = self.id!
                                    }
                                    if self.order != nil {
                                        map["Order"] = self.order!
                                    }
                                    if self.type != nil {
                                        map["Type"] = self.type!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Clips") {
                                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TrackList.Track.Clips()
                                        model.fromMap(dict["Clips"] as! [String: Any])
                                        self.clips = model
                                    }
                                    if dict.keys.contains("Id") {
                                        self.id = dict["Id"] as! String
                                    }
                                    if dict.keys.contains("Order") {
                                        self.order = dict["Order"] as! String
                                    }
                                    if dict.keys.contains("Type") {
                                        self.type = dict["Type"] as! String
                                    }
                                }
                            }
                            public var track: [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TrackList.Track]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.track != nil {
                                    var tmp : [Any] = []
                                    for k in self.track! {
                                        tmp.append(k.toMap())
                                    }
                                    map["Track"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Track") {
                                    var tmp : [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TrackList.Track] = []
                                    for v in dict["Track"] as! [Any] {
                                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TrackList.Track()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.track = tmp
                                }
                            }
                        }
                        public var timelineConfig: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TimelineConfig?

                        public var trackList: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TrackList?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.timelineConfig?.validate()
                            try self.trackList?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.timelineConfig != nil {
                                map["TimelineConfig"] = self.timelineConfig?.toMap()
                            }
                            if self.trackList != nil {
                                map["TrackList"] = self.trackList?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("TimelineConfig") {
                                var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TimelineConfig()
                                model.fromMap(dict["TimelineConfig"] as! [String: Any])
                                self.timelineConfig = model
                            }
                            if dict.keys.contains("TrackList") {
                                var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline.TrackList()
                                model.fromMap(dict["TrackList"] as! [String: Any])
                                self.trackList = model
                            }
                        }
                    }
                    public var clipList: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.ClipList?

                    public var timeline: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.clipList?.validate()
                        try self.timeline?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.clipList != nil {
                            map["ClipList"] = self.clipList?.toMap()
                        }
                        if self.timeline != nil {
                            map["Timeline"] = self.timeline?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ClipList") {
                            var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.ClipList()
                            model.fromMap(dict["ClipList"] as! [String: Any])
                            self.clipList = model
                        }
                        if dict.keys.contains("Timeline") {
                            var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing.Timeline()
                            model.fromMap(dict["Timeline"] as! [String: Any])
                            self.timeline = model
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var id: String?

                    public var key: String?

                    public var keyType: String?

                    public var keyUri: String?

                    public var skipCnt: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.keyType != nil {
                            map["KeyType"] = self.keyType!
                        }
                        if self.keyUri != nil {
                            map["KeyUri"] = self.keyUri!
                        }
                        if self.skipCnt != nil {
                            map["SkipCnt"] = self.skipCnt!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("KeyType") {
                            self.keyType = dict["KeyType"] as! String
                        }
                        if dict.keys.contains("KeyUri") {
                            self.keyUri = dict["KeyUri"] as! String
                        }
                        if dict.keys.contains("SkipCnt") {
                            self.skipCnt = dict["SkipCnt"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public class M3U8NonStandardSupport : Tea.TeaModel {
                    public class TS : Tea.TeaModel {
                        public var md5Support: Bool?

                        public var sizeSupport: Bool?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.md5Support != nil {
                                map["Md5Support"] = self.md5Support!
                            }
                            if self.sizeSupport != nil {
                                map["SizeSupport"] = self.sizeSupport!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Md5Support") {
                                self.md5Support = dict["Md5Support"] as! Bool
                            }
                            if dict.keys.contains("SizeSupport") {
                                self.sizeSupport = dict["SizeSupport"] as! Bool
                            }
                        }
                    }
                    public var TS: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.M3U8NonStandardSupport.TS?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.TS?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.TS != nil {
                            map["TS"] = self.TS?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TS") {
                            var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.M3U8NonStandardSupport.TS()
                            model.fromMap(dict["TS"] as! [String: Any])
                            self.TS = model
                        }
                    }
                }
                public class MergeList : Tea.TeaModel {
                    public class Merge : Tea.TeaModel {
                        public var duration: String?

                        public var mergeURL: String?

                        public var roleArn: String?

                        public var start: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.mergeURL != nil {
                                map["MergeURL"] = self.mergeURL!
                            }
                            if self.roleArn != nil {
                                map["RoleArn"] = self.roleArn!
                            }
                            if self.start != nil {
                                map["Start"] = self.start!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("MergeURL") {
                                self.mergeURL = dict["MergeURL"] as! String
                            }
                            if dict.keys.contains("RoleArn") {
                                self.roleArn = dict["RoleArn"] as! String
                            }
                            if dict.keys.contains("Start") {
                                self.start = dict["Start"] as! String
                            }
                        }
                    }
                    public var merge: [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.MergeList.Merge]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.merge != nil {
                            var tmp : [Any] = []
                            for k in self.merge! {
                                tmp.append(k.toMap())
                            }
                            map["Merge"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Merge") {
                            var tmp : [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.MergeList.Merge] = []
                            for v in dict["Merge"] as! [Any] {
                                var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.MergeList.Merge()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.merge = tmp
                        }
                    }
                }
                public class MuxConfig : Tea.TeaModel {
                    public class Gif : Tea.TeaModel {
                        public var ditherMode: String?

                        public var finalDelay: String?

                        public var isCustomPalette: String?

                        public var loop: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.ditherMode != nil {
                                map["DitherMode"] = self.ditherMode!
                            }
                            if self.finalDelay != nil {
                                map["FinalDelay"] = self.finalDelay!
                            }
                            if self.isCustomPalette != nil {
                                map["IsCustomPalette"] = self.isCustomPalette!
                            }
                            if self.loop != nil {
                                map["Loop"] = self.loop!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("DitherMode") {
                                self.ditherMode = dict["DitherMode"] as! String
                            }
                            if dict.keys.contains("FinalDelay") {
                                self.finalDelay = dict["FinalDelay"] as! String
                            }
                            if dict.keys.contains("IsCustomPalette") {
                                self.isCustomPalette = dict["IsCustomPalette"] as! String
                            }
                            if dict.keys.contains("Loop") {
                                self.loop = dict["Loop"] as! String
                            }
                        }
                    }
                    public class Segment : Tea.TeaModel {
                        public var duration: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                        }
                    }
                    public var gif: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.MuxConfig.Gif?

                    public var segment: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.MuxConfig.Segment?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.gif?.validate()
                        try self.segment?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.gif != nil {
                            map["Gif"] = self.gif?.toMap()
                        }
                        if self.segment != nil {
                            map["Segment"] = self.segment?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Gif") {
                            var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.MuxConfig.Gif()
                            model.fromMap(dict["Gif"] as! [String: Any])
                            self.gif = model
                        }
                        if dict.keys.contains("Segment") {
                            var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.MuxConfig.Segment()
                            model.fromMap(dict["Segment"] as! [String: Any])
                            self.segment = model
                        }
                    }
                }
                public class OutputFile : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public var roleArn: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        if self.roleArn != nil {
                            map["RoleArn"] = self.roleArn!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                        if dict.keys.contains("RoleArn") {
                            self.roleArn = dict["RoleArn"] as! String
                        }
                    }
                }
                public class Properties : Tea.TeaModel {
                    public class Format : Tea.TeaModel {
                        public var bitrate: String?

                        public var duration: String?

                        public var formatLongName: String?

                        public var formatName: String?

                        public var numPrograms: String?

                        public var numStreams: String?

                        public var size: String?

                        public var startTime: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.formatLongName != nil {
                                map["FormatLongName"] = self.formatLongName!
                            }
                            if self.formatName != nil {
                                map["FormatName"] = self.formatName!
                            }
                            if self.numPrograms != nil {
                                map["NumPrograms"] = self.numPrograms!
                            }
                            if self.numStreams != nil {
                                map["NumStreams"] = self.numStreams!
                            }
                            if self.size != nil {
                                map["Size"] = self.size!
                            }
                            if self.startTime != nil {
                                map["StartTime"] = self.startTime!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("FormatLongName") {
                                self.formatLongName = dict["FormatLongName"] as! String
                            }
                            if dict.keys.contains("FormatName") {
                                self.formatName = dict["FormatName"] as! String
                            }
                            if dict.keys.contains("NumPrograms") {
                                self.numPrograms = dict["NumPrograms"] as! String
                            }
                            if dict.keys.contains("NumStreams") {
                                self.numStreams = dict["NumStreams"] as! String
                            }
                            if dict.keys.contains("Size") {
                                self.size = dict["Size"] as! String
                            }
                            if dict.keys.contains("StartTime") {
                                self.startTime = dict["StartTime"] as! String
                            }
                        }
                    }
                    public class Streams : Tea.TeaModel {
                        public class AudioStreamList : Tea.TeaModel {
                            public class AudioStream : Tea.TeaModel {
                                public var bitrate: String?

                                public var channelLayout: String?

                                public var channels: String?

                                public var codecLongName: String?

                                public var codecName: String?

                                public var codecTag: String?

                                public var codecTagString: String?

                                public var codecTimeBase: String?

                                public var duration: String?

                                public var index: String?

                                public var lang: String?

                                public var numFrames: String?

                                public var sampleFmt: String?

                                public var samplerate: String?

                                public var startTime: String?

                                public var timebase: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.bitrate != nil {
                                        map["Bitrate"] = self.bitrate!
                                    }
                                    if self.channelLayout != nil {
                                        map["ChannelLayout"] = self.channelLayout!
                                    }
                                    if self.channels != nil {
                                        map["Channels"] = self.channels!
                                    }
                                    if self.codecLongName != nil {
                                        map["CodecLongName"] = self.codecLongName!
                                    }
                                    if self.codecName != nil {
                                        map["CodecName"] = self.codecName!
                                    }
                                    if self.codecTag != nil {
                                        map["CodecTag"] = self.codecTag!
                                    }
                                    if self.codecTagString != nil {
                                        map["CodecTagString"] = self.codecTagString!
                                    }
                                    if self.codecTimeBase != nil {
                                        map["CodecTimeBase"] = self.codecTimeBase!
                                    }
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.index != nil {
                                        map["Index"] = self.index!
                                    }
                                    if self.lang != nil {
                                        map["Lang"] = self.lang!
                                    }
                                    if self.numFrames != nil {
                                        map["NumFrames"] = self.numFrames!
                                    }
                                    if self.sampleFmt != nil {
                                        map["SampleFmt"] = self.sampleFmt!
                                    }
                                    if self.samplerate != nil {
                                        map["Samplerate"] = self.samplerate!
                                    }
                                    if self.startTime != nil {
                                        map["StartTime"] = self.startTime!
                                    }
                                    if self.timebase != nil {
                                        map["Timebase"] = self.timebase!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Bitrate") {
                                        self.bitrate = dict["Bitrate"] as! String
                                    }
                                    if dict.keys.contains("ChannelLayout") {
                                        self.channelLayout = dict["ChannelLayout"] as! String
                                    }
                                    if dict.keys.contains("Channels") {
                                        self.channels = dict["Channels"] as! String
                                    }
                                    if dict.keys.contains("CodecLongName") {
                                        self.codecLongName = dict["CodecLongName"] as! String
                                    }
                                    if dict.keys.contains("CodecName") {
                                        self.codecName = dict["CodecName"] as! String
                                    }
                                    if dict.keys.contains("CodecTag") {
                                        self.codecTag = dict["CodecTag"] as! String
                                    }
                                    if dict.keys.contains("CodecTagString") {
                                        self.codecTagString = dict["CodecTagString"] as! String
                                    }
                                    if dict.keys.contains("CodecTimeBase") {
                                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                                    }
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("Index") {
                                        self.index = dict["Index"] as! String
                                    }
                                    if dict.keys.contains("Lang") {
                                        self.lang = dict["Lang"] as! String
                                    }
                                    if dict.keys.contains("NumFrames") {
                                        self.numFrames = dict["NumFrames"] as! String
                                    }
                                    if dict.keys.contains("SampleFmt") {
                                        self.sampleFmt = dict["SampleFmt"] as! String
                                    }
                                    if dict.keys.contains("Samplerate") {
                                        self.samplerate = dict["Samplerate"] as! String
                                    }
                                    if dict.keys.contains("StartTime") {
                                        self.startTime = dict["StartTime"] as! String
                                    }
                                    if dict.keys.contains("Timebase") {
                                        self.timebase = dict["Timebase"] as! String
                                    }
                                }
                            }
                            public var audioStream: [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Streams.AudioStreamList.AudioStream]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.audioStream != nil {
                                    var tmp : [Any] = []
                                    for k in self.audioStream! {
                                        tmp.append(k.toMap())
                                    }
                                    map["AudioStream"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AudioStream") {
                                    var tmp : [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Streams.AudioStreamList.AudioStream] = []
                                    for v in dict["AudioStream"] as! [Any] {
                                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Streams.AudioStreamList.AudioStream()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.audioStream = tmp
                                }
                            }
                        }
                        public class SubtitleStreamList : Tea.TeaModel {
                            public class SubtitleStream : Tea.TeaModel {
                                public var index: String?

                                public var lang: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.index != nil {
                                        map["Index"] = self.index!
                                    }
                                    if self.lang != nil {
                                        map["Lang"] = self.lang!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Index") {
                                        self.index = dict["Index"] as! String
                                    }
                                    if dict.keys.contains("Lang") {
                                        self.lang = dict["Lang"] as! String
                                    }
                                }
                            }
                            public var subtitleStream: [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Streams.SubtitleStreamList.SubtitleStream]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.subtitleStream != nil {
                                    var tmp : [Any] = []
                                    for k in self.subtitleStream! {
                                        tmp.append(k.toMap())
                                    }
                                    map["SubtitleStream"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("SubtitleStream") {
                                    var tmp : [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Streams.SubtitleStreamList.SubtitleStream] = []
                                    for v in dict["SubtitleStream"] as! [Any] {
                                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Streams.SubtitleStreamList.SubtitleStream()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.subtitleStream = tmp
                                }
                            }
                        }
                        public class VideoStreamList : Tea.TeaModel {
                            public class VideoStream : Tea.TeaModel {
                                public class NetworkCost : Tea.TeaModel {
                                    public var avgBitrate: String?

                                    public var costBandwidth: String?

                                    public var preloadTime: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.avgBitrate != nil {
                                            map["AvgBitrate"] = self.avgBitrate!
                                        }
                                        if self.costBandwidth != nil {
                                            map["CostBandwidth"] = self.costBandwidth!
                                        }
                                        if self.preloadTime != nil {
                                            map["PreloadTime"] = self.preloadTime!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("AvgBitrate") {
                                            self.avgBitrate = dict["AvgBitrate"] as! String
                                        }
                                        if dict.keys.contains("CostBandwidth") {
                                            self.costBandwidth = dict["CostBandwidth"] as! String
                                        }
                                        if dict.keys.contains("PreloadTime") {
                                            self.preloadTime = dict["PreloadTime"] as! String
                                        }
                                    }
                                }
                                public var avgFPS: String?

                                public var bitrate: String?

                                public var codecLongName: String?

                                public var codecName: String?

                                public var codecTag: String?

                                public var codecTagString: String?

                                public var codecTimeBase: String?

                                public var dar: String?

                                public var duration: String?

                                public var fps: String?

                                public var hasBFrames: String?

                                public var height: String?

                                public var index: String?

                                public var lang: String?

                                public var level: String?

                                public var networkCost: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Streams.VideoStreamList.VideoStream.NetworkCost?

                                public var numFrames: String?

                                public var pixFmt: String?

                                public var profile: String?

                                public var sar: String?

                                public var startTime: String?

                                public var timebase: String?

                                public var width: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                    try self.networkCost?.validate()
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.avgFPS != nil {
                                        map["AvgFPS"] = self.avgFPS!
                                    }
                                    if self.bitrate != nil {
                                        map["Bitrate"] = self.bitrate!
                                    }
                                    if self.codecLongName != nil {
                                        map["CodecLongName"] = self.codecLongName!
                                    }
                                    if self.codecName != nil {
                                        map["CodecName"] = self.codecName!
                                    }
                                    if self.codecTag != nil {
                                        map["CodecTag"] = self.codecTag!
                                    }
                                    if self.codecTagString != nil {
                                        map["CodecTagString"] = self.codecTagString!
                                    }
                                    if self.codecTimeBase != nil {
                                        map["CodecTimeBase"] = self.codecTimeBase!
                                    }
                                    if self.dar != nil {
                                        map["Dar"] = self.dar!
                                    }
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.fps != nil {
                                        map["Fps"] = self.fps!
                                    }
                                    if self.hasBFrames != nil {
                                        map["HasBFrames"] = self.hasBFrames!
                                    }
                                    if self.height != nil {
                                        map["Height"] = self.height!
                                    }
                                    if self.index != nil {
                                        map["Index"] = self.index!
                                    }
                                    if self.lang != nil {
                                        map["Lang"] = self.lang!
                                    }
                                    if self.level != nil {
                                        map["Level"] = self.level!
                                    }
                                    if self.networkCost != nil {
                                        map["NetworkCost"] = self.networkCost?.toMap()
                                    }
                                    if self.numFrames != nil {
                                        map["NumFrames"] = self.numFrames!
                                    }
                                    if self.pixFmt != nil {
                                        map["PixFmt"] = self.pixFmt!
                                    }
                                    if self.profile != nil {
                                        map["Profile"] = self.profile!
                                    }
                                    if self.sar != nil {
                                        map["Sar"] = self.sar!
                                    }
                                    if self.startTime != nil {
                                        map["StartTime"] = self.startTime!
                                    }
                                    if self.timebase != nil {
                                        map["Timebase"] = self.timebase!
                                    }
                                    if self.width != nil {
                                        map["Width"] = self.width!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("AvgFPS") {
                                        self.avgFPS = dict["AvgFPS"] as! String
                                    }
                                    if dict.keys.contains("Bitrate") {
                                        self.bitrate = dict["Bitrate"] as! String
                                    }
                                    if dict.keys.contains("CodecLongName") {
                                        self.codecLongName = dict["CodecLongName"] as! String
                                    }
                                    if dict.keys.contains("CodecName") {
                                        self.codecName = dict["CodecName"] as! String
                                    }
                                    if dict.keys.contains("CodecTag") {
                                        self.codecTag = dict["CodecTag"] as! String
                                    }
                                    if dict.keys.contains("CodecTagString") {
                                        self.codecTagString = dict["CodecTagString"] as! String
                                    }
                                    if dict.keys.contains("CodecTimeBase") {
                                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                                    }
                                    if dict.keys.contains("Dar") {
                                        self.dar = dict["Dar"] as! String
                                    }
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("Fps") {
                                        self.fps = dict["Fps"] as! String
                                    }
                                    if dict.keys.contains("HasBFrames") {
                                        self.hasBFrames = dict["HasBFrames"] as! String
                                    }
                                    if dict.keys.contains("Height") {
                                        self.height = dict["Height"] as! String
                                    }
                                    if dict.keys.contains("Index") {
                                        self.index = dict["Index"] as! String
                                    }
                                    if dict.keys.contains("Lang") {
                                        self.lang = dict["Lang"] as! String
                                    }
                                    if dict.keys.contains("Level") {
                                        self.level = dict["Level"] as! String
                                    }
                                    if dict.keys.contains("NetworkCost") {
                                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Streams.VideoStreamList.VideoStream.NetworkCost()
                                        model.fromMap(dict["NetworkCost"] as! [String: Any])
                                        self.networkCost = model
                                    }
                                    if dict.keys.contains("NumFrames") {
                                        self.numFrames = dict["NumFrames"] as! String
                                    }
                                    if dict.keys.contains("PixFmt") {
                                        self.pixFmt = dict["PixFmt"] as! String
                                    }
                                    if dict.keys.contains("Profile") {
                                        self.profile = dict["Profile"] as! String
                                    }
                                    if dict.keys.contains("Sar") {
                                        self.sar = dict["Sar"] as! String
                                    }
                                    if dict.keys.contains("StartTime") {
                                        self.startTime = dict["StartTime"] as! String
                                    }
                                    if dict.keys.contains("Timebase") {
                                        self.timebase = dict["Timebase"] as! String
                                    }
                                    if dict.keys.contains("Width") {
                                        self.width = dict["Width"] as! String
                                    }
                                }
                            }
                            public var videoStream: [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Streams.VideoStreamList.VideoStream]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.videoStream != nil {
                                    var tmp : [Any] = []
                                    for k in self.videoStream! {
                                        tmp.append(k.toMap())
                                    }
                                    map["VideoStream"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("VideoStream") {
                                    var tmp : [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Streams.VideoStreamList.VideoStream] = []
                                    for v in dict["VideoStream"] as! [Any] {
                                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Streams.VideoStreamList.VideoStream()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.videoStream = tmp
                                }
                            }
                        }
                        public var audioStreamList: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Streams.AudioStreamList?

                        public var subtitleStreamList: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Streams.SubtitleStreamList?

                        public var videoStreamList: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Streams.VideoStreamList?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audioStreamList?.validate()
                            try self.subtitleStreamList?.validate()
                            try self.videoStreamList?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audioStreamList != nil {
                                map["AudioStreamList"] = self.audioStreamList?.toMap()
                            }
                            if self.subtitleStreamList != nil {
                                map["SubtitleStreamList"] = self.subtitleStreamList?.toMap()
                            }
                            if self.videoStreamList != nil {
                                map["VideoStreamList"] = self.videoStreamList?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AudioStreamList") {
                                var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Streams.AudioStreamList()
                                model.fromMap(dict["AudioStreamList"] as! [String: Any])
                                self.audioStreamList = model
                            }
                            if dict.keys.contains("SubtitleStreamList") {
                                var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Streams.SubtitleStreamList()
                                model.fromMap(dict["SubtitleStreamList"] as! [String: Any])
                                self.subtitleStreamList = model
                            }
                            if dict.keys.contains("VideoStreamList") {
                                var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Streams.VideoStreamList()
                                model.fromMap(dict["VideoStreamList"] as! [String: Any])
                                self.videoStreamList = model
                            }
                        }
                    }
                    public var bitrate: String?

                    public var duration: String?

                    public var fileFormat: String?

                    public var fileSize: String?

                    public var format: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Format?

                    public var fps: String?

                    public var height: String?

                    public var streams: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Streams?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.format?.validate()
                        try self.streams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fileFormat != nil {
                            map["FileFormat"] = self.fileFormat!
                        }
                        if self.fileSize != nil {
                            map["FileSize"] = self.fileSize!
                        }
                        if self.format != nil {
                            map["Format"] = self.format?.toMap()
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.streams != nil {
                            map["Streams"] = self.streams?.toMap()
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("FileFormat") {
                            self.fileFormat = dict["FileFormat"] as! String
                        }
                        if dict.keys.contains("FileSize") {
                            self.fileSize = dict["FileSize"] as! String
                        }
                        if dict.keys.contains("Format") {
                            var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Format()
                            model.fromMap(dict["Format"] as! [String: Any])
                            self.format = model
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("Streams") {
                            var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties.Streams()
                            model.fromMap(dict["Streams"] as! [String: Any])
                            self.streams = model
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public class SubtitleConfig : Tea.TeaModel {
                    public class ExtSubtitleList : Tea.TeaModel {
                        public class ExtSubtitle : Tea.TeaModel {
                            public class Input : Tea.TeaModel {
                                public var bucket: String?

                                public var location: String?

                                public var object: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.bucket != nil {
                                        map["Bucket"] = self.bucket!
                                    }
                                    if self.location != nil {
                                        map["Location"] = self.location!
                                    }
                                    if self.object != nil {
                                        map["Object"] = self.object!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Bucket") {
                                        self.bucket = dict["Bucket"] as! String
                                    }
                                    if dict.keys.contains("Location") {
                                        self.location = dict["Location"] as! String
                                    }
                                    if dict.keys.contains("Object") {
                                        self.object = dict["Object"] as! String
                                    }
                                }
                            }
                            public var charEnc: String?

                            public var fontName: String?

                            public var input: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.SubtitleConfig.ExtSubtitleList.ExtSubtitle.Input?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.input?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.charEnc != nil {
                                    map["CharEnc"] = self.charEnc!
                                }
                                if self.fontName != nil {
                                    map["FontName"] = self.fontName!
                                }
                                if self.input != nil {
                                    map["Input"] = self.input?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("CharEnc") {
                                    self.charEnc = dict["CharEnc"] as! String
                                }
                                if dict.keys.contains("FontName") {
                                    self.fontName = dict["FontName"] as! String
                                }
                                if dict.keys.contains("Input") {
                                    var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.SubtitleConfig.ExtSubtitleList.ExtSubtitle.Input()
                                    model.fromMap(dict["Input"] as! [String: Any])
                                    self.input = model
                                }
                            }
                        }
                        public var extSubtitle: [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.SubtitleConfig.ExtSubtitleList.ExtSubtitle]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.extSubtitle != nil {
                                var tmp : [Any] = []
                                for k in self.extSubtitle! {
                                    tmp.append(k.toMap())
                                }
                                map["ExtSubtitle"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ExtSubtitle") {
                                var tmp : [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.SubtitleConfig.ExtSubtitleList.ExtSubtitle] = []
                                for v in dict["ExtSubtitle"] as! [Any] {
                                    var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.SubtitleConfig.ExtSubtitleList.ExtSubtitle()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.extSubtitle = tmp
                            }
                        }
                    }
                    public class SubtitleList : Tea.TeaModel {
                        public class Subtitle : Tea.TeaModel {
                            public var map: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.map != nil {
                                    map["Map"] = self.map!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Map") {
                                    self.map = dict["Map"] as! String
                                }
                            }
                        }
                        public var subtitle: [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.SubtitleConfig.SubtitleList.Subtitle]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.subtitle != nil {
                                var tmp : [Any] = []
                                for k in self.subtitle! {
                                    tmp.append(k.toMap())
                                }
                                map["Subtitle"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Subtitle") {
                                var tmp : [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.SubtitleConfig.SubtitleList.Subtitle] = []
                                for v in dict["Subtitle"] as! [Any] {
                                    var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.SubtitleConfig.SubtitleList.Subtitle()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.subtitle = tmp
                            }
                        }
                    }
                    public var extSubtitleList: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.SubtitleConfig.ExtSubtitleList?

                    public var subtitleList: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.SubtitleConfig.SubtitleList?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.extSubtitleList?.validate()
                        try self.subtitleList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.extSubtitleList != nil {
                            map["ExtSubtitleList"] = self.extSubtitleList?.toMap()
                        }
                        if self.subtitleList != nil {
                            map["SubtitleList"] = self.subtitleList?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ExtSubtitleList") {
                            var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.SubtitleConfig.ExtSubtitleList()
                            model.fromMap(dict["ExtSubtitleList"] as! [String: Any])
                            self.extSubtitleList = model
                        }
                        if dict.keys.contains("SubtitleList") {
                            var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.SubtitleConfig.SubtitleList()
                            model.fromMap(dict["SubtitleList"] as! [String: Any])
                            self.subtitleList = model
                        }
                    }
                }
                public class SuperReso : Tea.TeaModel {
                    public var isHalfSample: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.isHalfSample != nil {
                            map["IsHalfSample"] = self.isHalfSample!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IsHalfSample") {
                            self.isHalfSample = dict["IsHalfSample"] as! String
                        }
                    }
                }
                public class TransConfig : Tea.TeaModel {
                    public var adjDarMethod: String?

                    public var duration: String?

                    public var isCheckAudioBitrate: String?

                    public var isCheckAudioBitrateFail: String?

                    public var isCheckReso: String?

                    public var isCheckResoFail: String?

                    public var isCheckVideoBitrate: String?

                    public var isCheckVideoBitrateFail: String?

                    public var transMode: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.adjDarMethod != nil {
                            map["AdjDarMethod"] = self.adjDarMethod!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.isCheckAudioBitrate != nil {
                            map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                        }
                        if self.isCheckAudioBitrateFail != nil {
                            map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                        }
                        if self.isCheckReso != nil {
                            map["IsCheckReso"] = self.isCheckReso!
                        }
                        if self.isCheckResoFail != nil {
                            map["IsCheckResoFail"] = self.isCheckResoFail!
                        }
                        if self.isCheckVideoBitrate != nil {
                            map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                        }
                        if self.isCheckVideoBitrateFail != nil {
                            map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                        }
                        if self.transMode != nil {
                            map["TransMode"] = self.transMode!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AdjDarMethod") {
                            self.adjDarMethod = dict["AdjDarMethod"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("IsCheckAudioBitrate") {
                            self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                        }
                        if dict.keys.contains("IsCheckAudioBitrateFail") {
                            self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                        }
                        if dict.keys.contains("IsCheckReso") {
                            self.isCheckReso = dict["IsCheckReso"] as! String
                        }
                        if dict.keys.contains("IsCheckResoFail") {
                            self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                        }
                        if dict.keys.contains("IsCheckVideoBitrate") {
                            self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                        }
                        if dict.keys.contains("IsCheckVideoBitrateFail") {
                            self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                        }
                        if dict.keys.contains("TransMode") {
                            self.transMode = dict["TransMode"] as! String
                        }
                    }
                }
                public class Video : Tea.TeaModel {
                    public class BitrateBnd : Tea.TeaModel {
                        public var max: String?

                        public var min: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.max != nil {
                                map["Max"] = self.max!
                            }
                            if self.min != nil {
                                map["Min"] = self.min!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Max") {
                                self.max = dict["Max"] as! String
                            }
                            if dict.keys.contains("Min") {
                                self.min = dict["Min"] as! String
                            }
                        }
                    }
                    public var bitrate: String?

                    public var bitrateBnd: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Video.BitrateBnd?

                    public var bufsize: String?

                    public var codec: String?

                    public var crf: String?

                    public var crop: String?

                    public var degrain: String?

                    public var fps: String?

                    public var gop: String?

                    public var height: String?

                    public var maxFps: String?

                    public var maxrate: String?

                    public var pad: String?

                    public var pixFmt: String?

                    public var preset: String?

                    public var profile: String?

                    public var qscale: String?

                    public var scanMode: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.bitrateBnd?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.bitrateBnd != nil {
                            map["BitrateBnd"] = self.bitrateBnd?.toMap()
                        }
                        if self.bufsize != nil {
                            map["Bufsize"] = self.bufsize!
                        }
                        if self.codec != nil {
                            map["Codec"] = self.codec!
                        }
                        if self.crf != nil {
                            map["Crf"] = self.crf!
                        }
                        if self.crop != nil {
                            map["Crop"] = self.crop!
                        }
                        if self.degrain != nil {
                            map["Degrain"] = self.degrain!
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.gop != nil {
                            map["Gop"] = self.gop!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.maxFps != nil {
                            map["MaxFps"] = self.maxFps!
                        }
                        if self.maxrate != nil {
                            map["Maxrate"] = self.maxrate!
                        }
                        if self.pad != nil {
                            map["Pad"] = self.pad!
                        }
                        if self.pixFmt != nil {
                            map["PixFmt"] = self.pixFmt!
                        }
                        if self.preset != nil {
                            map["Preset"] = self.preset!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.qscale != nil {
                            map["Qscale"] = self.qscale!
                        }
                        if self.scanMode != nil {
                            map["ScanMode"] = self.scanMode!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("BitrateBnd") {
                            var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Video.BitrateBnd()
                            model.fromMap(dict["BitrateBnd"] as! [String: Any])
                            self.bitrateBnd = model
                        }
                        if dict.keys.contains("Bufsize") {
                            self.bufsize = dict["Bufsize"] as! String
                        }
                        if dict.keys.contains("Codec") {
                            self.codec = dict["Codec"] as! String
                        }
                        if dict.keys.contains("Crf") {
                            self.crf = dict["Crf"] as! String
                        }
                        if dict.keys.contains("Crop") {
                            self.crop = dict["Crop"] as! String
                        }
                        if dict.keys.contains("Degrain") {
                            self.degrain = dict["Degrain"] as! String
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Gop") {
                            self.gop = dict["Gop"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("MaxFps") {
                            self.maxFps = dict["MaxFps"] as! String
                        }
                        if dict.keys.contains("Maxrate") {
                            self.maxrate = dict["Maxrate"] as! String
                        }
                        if dict.keys.contains("Pad") {
                            self.pad = dict["Pad"] as! String
                        }
                        if dict.keys.contains("PixFmt") {
                            self.pixFmt = dict["PixFmt"] as! String
                        }
                        if dict.keys.contains("Preset") {
                            self.preset = dict["Preset"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Qscale") {
                            self.qscale = dict["Qscale"] as! String
                        }
                        if dict.keys.contains("ScanMode") {
                            self.scanMode = dict["ScanMode"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public class WaterMarkList : Tea.TeaModel {
                    public class WaterMark : Tea.TeaModel {
                        public class InputFile : Tea.TeaModel {
                            public var bucket: String?

                            public var location: String?

                            public var object: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bucket != nil {
                                    map["Bucket"] = self.bucket!
                                }
                                if self.location != nil {
                                    map["Location"] = self.location!
                                }
                                if self.object != nil {
                                    map["Object"] = self.object!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bucket") {
                                    self.bucket = dict["Bucket"] as! String
                                }
                                if dict.keys.contains("Location") {
                                    self.location = dict["Location"] as! String
                                }
                                if dict.keys.contains("Object") {
                                    self.object = dict["Object"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var height: String?

                        public var inputFile: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.WaterMarkList.WaterMark.InputFile?

                        public var referPos: String?

                        public var type: String?

                        public var waterMarkTemplateId: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.inputFile?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.inputFile != nil {
                                map["InputFile"] = self.inputFile?.toMap()
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            if self.waterMarkTemplateId != nil {
                                map["WaterMarkTemplateId"] = self.waterMarkTemplateId!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("InputFile") {
                                var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.WaterMarkList.WaterMark.InputFile()
                                model.fromMap(dict["InputFile"] as! [String: Any])
                                self.inputFile = model
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Type") {
                                self.type = dict["Type"] as! String
                            }
                            if dict.keys.contains("WaterMarkTemplateId") {
                                self.waterMarkTemplateId = dict["WaterMarkTemplateId"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var waterMark: [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.WaterMarkList.WaterMark]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.waterMark != nil {
                            var tmp : [Any] = []
                            for k in self.waterMark! {
                                tmp.append(k.toMap())
                            }
                            map["WaterMark"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("WaterMark") {
                            var tmp : [QueryEditingJobListResponseBody.JobList.Job.EditingConfig.WaterMarkList.WaterMark] = []
                            for v in dict["WaterMark"] as! [Any] {
                                var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.WaterMarkList.WaterMark()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.waterMark = tmp
                        }
                    }
                }
                public var audio: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Audio?

                public var audioStreamMap: String?

                public var clip: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Clip?

                public var container: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Container?

                public var deWatermark: String?

                public var digiWaterMark: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.DigiWaterMark?

                public var editing: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing?

                public var encryption: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Encryption?

                public var m3U8NonStandardSupport: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.M3U8NonStandardSupport?

                public var mergeConfigUrl: String?

                public var mergeList: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.MergeList?

                public var muxConfig: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.MuxConfig?

                public var outputFile: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.OutputFile?

                public var priority: String?

                public var properties: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties?

                public var rotate: String?

                public var subtitleConfig: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.SubtitleConfig?

                public var superReso: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.SuperReso?

                public var templateId: String?

                public var transConfig: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.TransConfig?

                public var userData: String?

                public var video: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Video?

                public var videoStreamMap: String?

                public var waterMarkConfigUrl: String?

                public var waterMarkList: QueryEditingJobListResponseBody.JobList.Job.EditingConfig.WaterMarkList?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.audio?.validate()
                    try self.clip?.validate()
                    try self.container?.validate()
                    try self.digiWaterMark?.validate()
                    try self.editing?.validate()
                    try self.encryption?.validate()
                    try self.m3U8NonStandardSupport?.validate()
                    try self.mergeList?.validate()
                    try self.muxConfig?.validate()
                    try self.outputFile?.validate()
                    try self.properties?.validate()
                    try self.subtitleConfig?.validate()
                    try self.superReso?.validate()
                    try self.transConfig?.validate()
                    try self.video?.validate()
                    try self.waterMarkList?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audio != nil {
                        map["Audio"] = self.audio?.toMap()
                    }
                    if self.audioStreamMap != nil {
                        map["AudioStreamMap"] = self.audioStreamMap!
                    }
                    if self.clip != nil {
                        map["Clip"] = self.clip?.toMap()
                    }
                    if self.container != nil {
                        map["Container"] = self.container?.toMap()
                    }
                    if self.deWatermark != nil {
                        map["DeWatermark"] = self.deWatermark!
                    }
                    if self.digiWaterMark != nil {
                        map["DigiWaterMark"] = self.digiWaterMark?.toMap()
                    }
                    if self.editing != nil {
                        map["Editing"] = self.editing?.toMap()
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.m3U8NonStandardSupport != nil {
                        map["M3U8NonStandardSupport"] = self.m3U8NonStandardSupport?.toMap()
                    }
                    if self.mergeConfigUrl != nil {
                        map["MergeConfigUrl"] = self.mergeConfigUrl!
                    }
                    if self.mergeList != nil {
                        map["MergeList"] = self.mergeList?.toMap()
                    }
                    if self.muxConfig != nil {
                        map["MuxConfig"] = self.muxConfig?.toMap()
                    }
                    if self.outputFile != nil {
                        map["OutputFile"] = self.outputFile?.toMap()
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    if self.properties != nil {
                        map["Properties"] = self.properties?.toMap()
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.subtitleConfig != nil {
                        map["SubtitleConfig"] = self.subtitleConfig?.toMap()
                    }
                    if self.superReso != nil {
                        map["SuperReso"] = self.superReso?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    if self.transConfig != nil {
                        map["TransConfig"] = self.transConfig?.toMap()
                    }
                    if self.userData != nil {
                        map["UserData"] = self.userData!
                    }
                    if self.video != nil {
                        map["Video"] = self.video?.toMap()
                    }
                    if self.videoStreamMap != nil {
                        map["VideoStreamMap"] = self.videoStreamMap!
                    }
                    if self.waterMarkConfigUrl != nil {
                        map["WaterMarkConfigUrl"] = self.waterMarkConfigUrl!
                    }
                    if self.waterMarkList != nil {
                        map["WaterMarkList"] = self.waterMarkList?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Audio") {
                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Audio()
                        model.fromMap(dict["Audio"] as! [String: Any])
                        self.audio = model
                    }
                    if dict.keys.contains("AudioStreamMap") {
                        self.audioStreamMap = dict["AudioStreamMap"] as! String
                    }
                    if dict.keys.contains("Clip") {
                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Clip()
                        model.fromMap(dict["Clip"] as! [String: Any])
                        self.clip = model
                    }
                    if dict.keys.contains("Container") {
                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Container()
                        model.fromMap(dict["Container"] as! [String: Any])
                        self.container = model
                    }
                    if dict.keys.contains("DeWatermark") {
                        self.deWatermark = dict["DeWatermark"] as! String
                    }
                    if dict.keys.contains("DigiWaterMark") {
                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.DigiWaterMark()
                        model.fromMap(dict["DigiWaterMark"] as! [String: Any])
                        self.digiWaterMark = model
                    }
                    if dict.keys.contains("Editing") {
                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Editing()
                        model.fromMap(dict["Editing"] as! [String: Any])
                        self.editing = model
                    }
                    if dict.keys.contains("Encryption") {
                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("M3U8NonStandardSupport") {
                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.M3U8NonStandardSupport()
                        model.fromMap(dict["M3U8NonStandardSupport"] as! [String: Any])
                        self.m3U8NonStandardSupport = model
                    }
                    if dict.keys.contains("MergeConfigUrl") {
                        self.mergeConfigUrl = dict["MergeConfigUrl"] as! String
                    }
                    if dict.keys.contains("MergeList") {
                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.MergeList()
                        model.fromMap(dict["MergeList"] as! [String: Any])
                        self.mergeList = model
                    }
                    if dict.keys.contains("MuxConfig") {
                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.MuxConfig()
                        model.fromMap(dict["MuxConfig"] as! [String: Any])
                        self.muxConfig = model
                    }
                    if dict.keys.contains("OutputFile") {
                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.OutputFile()
                        model.fromMap(dict["OutputFile"] as! [String: Any])
                        self.outputFile = model
                    }
                    if dict.keys.contains("Priority") {
                        self.priority = dict["Priority"] as! String
                    }
                    if dict.keys.contains("Properties") {
                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Properties()
                        model.fromMap(dict["Properties"] as! [String: Any])
                        self.properties = model
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("SubtitleConfig") {
                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.SubtitleConfig()
                        model.fromMap(dict["SubtitleConfig"] as! [String: Any])
                        self.subtitleConfig = model
                    }
                    if dict.keys.contains("SuperReso") {
                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.SuperReso()
                        model.fromMap(dict["SuperReso"] as! [String: Any])
                        self.superReso = model
                    }
                    if dict.keys.contains("TemplateId") {
                        self.templateId = dict["TemplateId"] as! String
                    }
                    if dict.keys.contains("TransConfig") {
                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.TransConfig()
                        model.fromMap(dict["TransConfig"] as! [String: Any])
                        self.transConfig = model
                    }
                    if dict.keys.contains("UserData") {
                        self.userData = dict["UserData"] as! String
                    }
                    if dict.keys.contains("Video") {
                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.Video()
                        model.fromMap(dict["Video"] as! [String: Any])
                        self.video = model
                    }
                    if dict.keys.contains("VideoStreamMap") {
                        self.videoStreamMap = dict["VideoStreamMap"] as! String
                    }
                    if dict.keys.contains("WaterMarkConfigUrl") {
                        self.waterMarkConfigUrl = dict["WaterMarkConfigUrl"] as! String
                    }
                    if dict.keys.contains("WaterMarkList") {
                        var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig.WaterMarkList()
                        model.fromMap(dict["WaterMarkList"] as! [String: Any])
                        self.waterMarkList = model
                    }
                }
            }
            public class EditingInputs : Tea.TeaModel {
                public class EditingInput : Tea.TeaModel {
                    public class InputConfig : Tea.TeaModel {
                        public var deinterlaceMethod: String?

                        public var isNormalSar: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.deinterlaceMethod != nil {
                                map["DeinterlaceMethod"] = self.deinterlaceMethod!
                            }
                            if self.isNormalSar != nil {
                                map["IsNormalSar"] = self.isNormalSar!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("DeinterlaceMethod") {
                                self.deinterlaceMethod = dict["DeinterlaceMethod"] as! String
                            }
                            if dict.keys.contains("IsNormalSar") {
                                self.isNormalSar = dict["IsNormalSar"] as! String
                            }
                        }
                    }
                    public class InputFile : Tea.TeaModel {
                        public var bucket: String?

                        public var location: String?

                        public var object: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bucket != nil {
                                map["Bucket"] = self.bucket!
                            }
                            if self.location != nil {
                                map["Location"] = self.location!
                            }
                            if self.object != nil {
                                map["Object"] = self.object!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bucket") {
                                self.bucket = dict["Bucket"] as! String
                            }
                            if dict.keys.contains("Location") {
                                self.location = dict["Location"] as! String
                            }
                            if dict.keys.contains("Object") {
                                self.object = dict["Object"] as! String
                            }
                        }
                    }
                    public var id: String?

                    public var inputConfig: QueryEditingJobListResponseBody.JobList.Job.EditingInputs.EditingInput.InputConfig?

                    public var inputFile: QueryEditingJobListResponseBody.JobList.Job.EditingInputs.EditingInput.InputFile?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.inputConfig?.validate()
                        try self.inputFile?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.inputConfig != nil {
                            map["InputConfig"] = self.inputConfig?.toMap()
                        }
                        if self.inputFile != nil {
                            map["InputFile"] = self.inputFile?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("InputConfig") {
                            var model = QueryEditingJobListResponseBody.JobList.Job.EditingInputs.EditingInput.InputConfig()
                            model.fromMap(dict["InputConfig"] as! [String: Any])
                            self.inputConfig = model
                        }
                        if dict.keys.contains("InputFile") {
                            var model = QueryEditingJobListResponseBody.JobList.Job.EditingInputs.EditingInput.InputFile()
                            model.fromMap(dict["InputFile"] as! [String: Any])
                            self.inputFile = model
                        }
                    }
                }
                public var editingInput: [QueryEditingJobListResponseBody.JobList.Job.EditingInputs.EditingInput]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.editingInput != nil {
                        var tmp : [Any] = []
                        for k in self.editingInput! {
                            tmp.append(k.toMap())
                        }
                        map["EditingInput"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EditingInput") {
                        var tmp : [QueryEditingJobListResponseBody.JobList.Job.EditingInputs.EditingInput] = []
                        for v in dict["EditingInput"] as! [Any] {
                            var model = QueryEditingJobListResponseBody.JobList.Job.EditingInputs.EditingInput()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.editingInput = tmp
                    }
                }
            }
            public class MNSMessageResult : Tea.TeaModel {
                public var errorCode: String?

                public var errorMessage: String?

                public var messageId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.messageId != nil {
                        map["MessageId"] = self.messageId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("MessageId") {
                        self.messageId = dict["MessageId"] as! String
                    }
                }
            }
            public var code: String?

            public var creationTime: String?

            public var editingConfig: QueryEditingJobListResponseBody.JobList.Job.EditingConfig?

            public var editingInputs: QueryEditingJobListResponseBody.JobList.Job.EditingInputs?

            public var finishTime: String?

            public var jobId: String?

            public var MNSMessageResult: QueryEditingJobListResponseBody.JobList.Job.MNSMessageResult?

            public var message: String?

            public var percent: Int64?

            public var pipelineId: String?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.editingConfig?.validate()
                try self.editingInputs?.validate()
                try self.MNSMessageResult?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.editingConfig != nil {
                    map["EditingConfig"] = self.editingConfig?.toMap()
                }
                if self.editingInputs != nil {
                    map["EditingInputs"] = self.editingInputs?.toMap()
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.MNSMessageResult != nil {
                    map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("EditingConfig") {
                    var model = QueryEditingJobListResponseBody.JobList.Job.EditingConfig()
                    model.fromMap(dict["EditingConfig"] as! [String: Any])
                    self.editingConfig = model
                }
                if dict.keys.contains("EditingInputs") {
                    var model = QueryEditingJobListResponseBody.JobList.Job.EditingInputs()
                    model.fromMap(dict["EditingInputs"] as! [String: Any])
                    self.editingInputs = model
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("MNSMessageResult") {
                    var model = QueryEditingJobListResponseBody.JobList.Job.MNSMessageResult()
                    model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                    self.MNSMessageResult = model
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! Int64
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
            }
        }
        public var job: [QueryEditingJobListResponseBody.JobList.Job]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.job != nil {
                var tmp : [Any] = []
                for k in self.job! {
                    tmp.append(k.toMap())
                }
                map["Job"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Job") {
                var tmp : [QueryEditingJobListResponseBody.JobList.Job] = []
                for v in dict["Job"] as! [Any] {
                    var model = QueryEditingJobListResponseBody.JobList.Job()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.job = tmp
            }
        }
    }
    public class NonExistJobIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public var jobList: QueryEditingJobListResponseBody.JobList?

    public var nonExistJobIds: QueryEditingJobListResponseBody.NonExistJobIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobList?.validate()
        try self.nonExistJobIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobList != nil {
            map["JobList"] = self.jobList?.toMap()
        }
        if self.nonExistJobIds != nil {
            map["NonExistJobIds"] = self.nonExistJobIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobList") {
            var model = QueryEditingJobListResponseBody.JobList()
            model.fromMap(dict["JobList"] as! [String: Any])
            self.jobList = model
        }
        if dict.keys.contains("NonExistJobIds") {
            var model = QueryEditingJobListResponseBody.NonExistJobIds()
            model.fromMap(dict["NonExistJobIds"] as! [String: Any])
            self.nonExistJobIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryEditingJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryEditingJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryEditingJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryJobListRequest : Tea.TeaModel {
    public var jobIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryJobListResponseBody : Tea.TeaModel {
    public class JobList : Tea.TeaModel {
        public class Job : Tea.TeaModel {
            public class Input : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public class MNSMessageResult : Tea.TeaModel {
                public var errorCode: String?

                public var errorMessage: String?

                public var messageId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.messageId != nil {
                        map["MessageId"] = self.messageId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("MessageId") {
                        self.messageId = dict["MessageId"] as! String
                    }
                }
            }
            public class Output : Tea.TeaModel {
                public class AmixList : Tea.TeaModel {
                    public class Amix : Tea.TeaModel {
                        public var amixURL: String?

                        public var duration: String?

                        public var map: String?

                        public var mixDurMode: String?

                        public var start: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.amixURL != nil {
                                map["AmixURL"] = self.amixURL!
                            }
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.map != nil {
                                map["Map"] = self.map!
                            }
                            if self.mixDurMode != nil {
                                map["MixDurMode"] = self.mixDurMode!
                            }
                            if self.start != nil {
                                map["Start"] = self.start!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AmixURL") {
                                self.amixURL = dict["AmixURL"] as! String
                            }
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("Map") {
                                self.map = dict["Map"] as! String
                            }
                            if dict.keys.contains("MixDurMode") {
                                self.mixDurMode = dict["MixDurMode"] as! String
                            }
                            if dict.keys.contains("Start") {
                                self.start = dict["Start"] as! String
                            }
                        }
                    }
                    public var amix: [QueryJobListResponseBody.JobList.Job.Output.AmixList.Amix]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.amix != nil {
                            var tmp : [Any] = []
                            for k in self.amix! {
                                tmp.append(k.toMap())
                            }
                            map["Amix"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Amix") {
                            var tmp : [QueryJobListResponseBody.JobList.Job.Output.AmixList.Amix] = []
                            for v in dict["Amix"] as! [Any] {
                                var model = QueryJobListResponseBody.JobList.Job.Output.AmixList.Amix()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.amix = tmp
                        }
                    }
                }
                public class Audio : Tea.TeaModel {
                    public class Volume : Tea.TeaModel {
                        public var level: String?

                        public var method: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.level != nil {
                                map["Level"] = self.level!
                            }
                            if self.method != nil {
                                map["Method"] = self.method!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Level") {
                                self.level = dict["Level"] as! String
                            }
                            if dict.keys.contains("Method") {
                                self.method = dict["Method"] as! String
                            }
                        }
                    }
                    public var bitrate: String?

                    public var channels: String?

                    public var codec: String?

                    public var profile: String?

                    public var qscale: String?

                    public var samplerate: String?

                    public var volume: QueryJobListResponseBody.JobList.Job.Output.Audio.Volume?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.volume?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        if self.codec != nil {
                            map["Codec"] = self.codec!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.qscale != nil {
                            map["Qscale"] = self.qscale!
                        }
                        if self.samplerate != nil {
                            map["Samplerate"] = self.samplerate!
                        }
                        if self.volume != nil {
                            map["Volume"] = self.volume?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Channels") {
                            self.channels = dict["Channels"] as! String
                        }
                        if dict.keys.contains("Codec") {
                            self.codec = dict["Codec"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Qscale") {
                            self.qscale = dict["Qscale"] as! String
                        }
                        if dict.keys.contains("Samplerate") {
                            self.samplerate = dict["Samplerate"] as! String
                        }
                        if dict.keys.contains("Volume") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.Audio.Volume()
                            model.fromMap(dict["Volume"] as! [String: Any])
                            self.volume = model
                        }
                    }
                }
                public class Clip : Tea.TeaModel {
                    public class TimeSpan : Tea.TeaModel {
                        public var duration: String?

                        public var seek: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.seek != nil {
                                map["Seek"] = self.seek!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("Seek") {
                                self.seek = dict["Seek"] as! String
                            }
                        }
                    }
                    public var timeSpan: QueryJobListResponseBody.JobList.Job.Output.Clip.TimeSpan?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.timeSpan?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.timeSpan != nil {
                            map["TimeSpan"] = self.timeSpan?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TimeSpan") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.Clip.TimeSpan()
                            model.fromMap(dict["TimeSpan"] as! [String: Any])
                            self.timeSpan = model
                        }
                    }
                }
                public class Container : Tea.TeaModel {
                    public var format: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var id: String?

                    public var key: String?

                    public var keyType: String?

                    public var keyUri: String?

                    public var skipCnt: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.keyType != nil {
                            map["KeyType"] = self.keyType!
                        }
                        if self.keyUri != nil {
                            map["KeyUri"] = self.keyUri!
                        }
                        if self.skipCnt != nil {
                            map["SkipCnt"] = self.skipCnt!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("KeyType") {
                            self.keyType = dict["KeyType"] as! String
                        }
                        if dict.keys.contains("KeyUri") {
                            self.keyUri = dict["KeyUri"] as! String
                        }
                        if dict.keys.contains("SkipCnt") {
                            self.skipCnt = dict["SkipCnt"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public class M3U8NonStandardSupport : Tea.TeaModel {
                    public class TS : Tea.TeaModel {
                        public var md5Support: Bool?

                        public var sizeSupport: Bool?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.md5Support != nil {
                                map["Md5Support"] = self.md5Support!
                            }
                            if self.sizeSupport != nil {
                                map["SizeSupport"] = self.sizeSupport!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Md5Support") {
                                self.md5Support = dict["Md5Support"] as! Bool
                            }
                            if dict.keys.contains("SizeSupport") {
                                self.sizeSupport = dict["SizeSupport"] as! Bool
                            }
                        }
                    }
                    public var TS: QueryJobListResponseBody.JobList.Job.Output.M3U8NonStandardSupport.TS?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.TS?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.TS != nil {
                            map["TS"] = self.TS?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TS") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.M3U8NonStandardSupport.TS()
                            model.fromMap(dict["TS"] as! [String: Any])
                            self.TS = model
                        }
                    }
                }
                public class MergeList : Tea.TeaModel {
                    public class Merge : Tea.TeaModel {
                        public var duration: String?

                        public var mergeURL: String?

                        public var roleArn: String?

                        public var start: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.mergeURL != nil {
                                map["MergeURL"] = self.mergeURL!
                            }
                            if self.roleArn != nil {
                                map["RoleArn"] = self.roleArn!
                            }
                            if self.start != nil {
                                map["Start"] = self.start!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("MergeURL") {
                                self.mergeURL = dict["MergeURL"] as! String
                            }
                            if dict.keys.contains("RoleArn") {
                                self.roleArn = dict["RoleArn"] as! String
                            }
                            if dict.keys.contains("Start") {
                                self.start = dict["Start"] as! String
                            }
                        }
                    }
                    public var merge: [QueryJobListResponseBody.JobList.Job.Output.MergeList.Merge]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.merge != nil {
                            var tmp : [Any] = []
                            for k in self.merge! {
                                tmp.append(k.toMap())
                            }
                            map["Merge"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Merge") {
                            var tmp : [QueryJobListResponseBody.JobList.Job.Output.MergeList.Merge] = []
                            for v in dict["Merge"] as! [Any] {
                                var model = QueryJobListResponseBody.JobList.Job.Output.MergeList.Merge()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.merge = tmp
                        }
                    }
                }
                public class MuxConfig : Tea.TeaModel {
                    public class Gif : Tea.TeaModel {
                        public var ditherMode: String?

                        public var finalDelay: String?

                        public var isCustomPalette: String?

                        public var loop: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.ditherMode != nil {
                                map["DitherMode"] = self.ditherMode!
                            }
                            if self.finalDelay != nil {
                                map["FinalDelay"] = self.finalDelay!
                            }
                            if self.isCustomPalette != nil {
                                map["IsCustomPalette"] = self.isCustomPalette!
                            }
                            if self.loop != nil {
                                map["Loop"] = self.loop!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("DitherMode") {
                                self.ditherMode = dict["DitherMode"] as! String
                            }
                            if dict.keys.contains("FinalDelay") {
                                self.finalDelay = dict["FinalDelay"] as! String
                            }
                            if dict.keys.contains("IsCustomPalette") {
                                self.isCustomPalette = dict["IsCustomPalette"] as! String
                            }
                            if dict.keys.contains("Loop") {
                                self.loop = dict["Loop"] as! String
                            }
                        }
                    }
                    public class Segment : Tea.TeaModel {
                        public var duration: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                        }
                    }
                    public class Webp : Tea.TeaModel {
                        public var loop: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.loop != nil {
                                map["Loop"] = self.loop!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Loop") {
                                self.loop = dict["Loop"] as! String
                            }
                        }
                    }
                    public var gif: QueryJobListResponseBody.JobList.Job.Output.MuxConfig.Gif?

                    public var segment: QueryJobListResponseBody.JobList.Job.Output.MuxConfig.Segment?

                    public var webp: QueryJobListResponseBody.JobList.Job.Output.MuxConfig.Webp?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.gif?.validate()
                        try self.segment?.validate()
                        try self.webp?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.gif != nil {
                            map["Gif"] = self.gif?.toMap()
                        }
                        if self.segment != nil {
                            map["Segment"] = self.segment?.toMap()
                        }
                        if self.webp != nil {
                            map["Webp"] = self.webp?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Gif") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.MuxConfig.Gif()
                            model.fromMap(dict["Gif"] as! [String: Any])
                            self.gif = model
                        }
                        if dict.keys.contains("Segment") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.MuxConfig.Segment()
                            model.fromMap(dict["Segment"] as! [String: Any])
                            self.segment = model
                        }
                        if dict.keys.contains("Webp") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.MuxConfig.Webp()
                            model.fromMap(dict["Webp"] as! [String: Any])
                            self.webp = model
                        }
                    }
                }
                public class OpeningList : Tea.TeaModel {
                    public class Opening : Tea.TeaModel {
                        public var height: String?

                        public var start: String?

                        public var width: String?

                        public var openUrl: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.start != nil {
                                map["Start"] = self.start!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            if self.openUrl != nil {
                                map["openUrl"] = self.openUrl!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("Start") {
                                self.start = dict["Start"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                            if dict.keys.contains("openUrl") {
                                self.openUrl = dict["openUrl"] as! String
                            }
                        }
                    }
                    public var opening: [QueryJobListResponseBody.JobList.Job.Output.OpeningList.Opening]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.opening != nil {
                            var tmp : [Any] = []
                            for k in self.opening! {
                                tmp.append(k.toMap())
                            }
                            map["Opening"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Opening") {
                            var tmp : [QueryJobListResponseBody.JobList.Job.Output.OpeningList.Opening] = []
                            for v in dict["Opening"] as! [Any] {
                                var model = QueryJobListResponseBody.JobList.Job.Output.OpeningList.Opening()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.opening = tmp
                        }
                    }
                }
                public class OutSubtitleList : Tea.TeaModel {
                    public class OutSubtitle : Tea.TeaModel {
                        public class OutSubtitleFile : Tea.TeaModel {
                            public var bucket: String?

                            public var location: String?

                            public var object: String?

                            public var roleArn: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bucket != nil {
                                    map["Bucket"] = self.bucket!
                                }
                                if self.location != nil {
                                    map["Location"] = self.location!
                                }
                                if self.object != nil {
                                    map["Object"] = self.object!
                                }
                                if self.roleArn != nil {
                                    map["RoleArn"] = self.roleArn!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bucket") {
                                    self.bucket = dict["Bucket"] as! String
                                }
                                if dict.keys.contains("Location") {
                                    self.location = dict["Location"] as! String
                                }
                                if dict.keys.contains("Object") {
                                    self.object = dict["Object"] as! String
                                }
                                if dict.keys.contains("RoleArn") {
                                    self.roleArn = dict["RoleArn"] as! String
                                }
                            }
                        }
                        public var map: String?

                        public var message: String?

                        public var outSubtitleFile: QueryJobListResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle.OutSubtitleFile?

                        public var success: Bool?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.outSubtitleFile?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.map != nil {
                                map["Map"] = self.map!
                            }
                            if self.message != nil {
                                map["Message"] = self.message!
                            }
                            if self.outSubtitleFile != nil {
                                map["OutSubtitleFile"] = self.outSubtitleFile?.toMap()
                            }
                            if self.success != nil {
                                map["Success"] = self.success!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Map") {
                                self.map = dict["Map"] as! String
                            }
                            if dict.keys.contains("Message") {
                                self.message = dict["Message"] as! String
                            }
                            if dict.keys.contains("OutSubtitleFile") {
                                var model = QueryJobListResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle.OutSubtitleFile()
                                model.fromMap(dict["OutSubtitleFile"] as! [String: Any])
                                self.outSubtitleFile = model
                            }
                            if dict.keys.contains("Success") {
                                self.success = dict["Success"] as! Bool
                            }
                        }
                    }
                    public var outSubtitle: [QueryJobListResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.outSubtitle != nil {
                            var tmp : [Any] = []
                            for k in self.outSubtitle! {
                                tmp.append(k.toMap())
                            }
                            map["OutSubtitle"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OutSubtitle") {
                            var tmp : [QueryJobListResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle] = []
                            for v in dict["OutSubtitle"] as! [Any] {
                                var model = QueryJobListResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.outSubtitle = tmp
                        }
                    }
                }
                public class OutputFile : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public var roleArn: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        if self.roleArn != nil {
                            map["RoleArn"] = self.roleArn!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                        if dict.keys.contains("RoleArn") {
                            self.roleArn = dict["RoleArn"] as! String
                        }
                    }
                }
                public class Properties : Tea.TeaModel {
                    public class Format : Tea.TeaModel {
                        public var bitrate: String?

                        public var duration: String?

                        public var formatLongName: String?

                        public var formatName: String?

                        public var numPrograms: String?

                        public var numStreams: String?

                        public var size: String?

                        public var startTime: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.formatLongName != nil {
                                map["FormatLongName"] = self.formatLongName!
                            }
                            if self.formatName != nil {
                                map["FormatName"] = self.formatName!
                            }
                            if self.numPrograms != nil {
                                map["NumPrograms"] = self.numPrograms!
                            }
                            if self.numStreams != nil {
                                map["NumStreams"] = self.numStreams!
                            }
                            if self.size != nil {
                                map["Size"] = self.size!
                            }
                            if self.startTime != nil {
                                map["StartTime"] = self.startTime!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("FormatLongName") {
                                self.formatLongName = dict["FormatLongName"] as! String
                            }
                            if dict.keys.contains("FormatName") {
                                self.formatName = dict["FormatName"] as! String
                            }
                            if dict.keys.contains("NumPrograms") {
                                self.numPrograms = dict["NumPrograms"] as! String
                            }
                            if dict.keys.contains("NumStreams") {
                                self.numStreams = dict["NumStreams"] as! String
                            }
                            if dict.keys.contains("Size") {
                                self.size = dict["Size"] as! String
                            }
                            if dict.keys.contains("StartTime") {
                                self.startTime = dict["StartTime"] as! String
                            }
                        }
                    }
                    public class SourceLogos : Tea.TeaModel {
                        public class SourceLogo : Tea.TeaModel {
                            public var source: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.source != nil {
                                    map["Source"] = self.source!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Source") {
                                    self.source = dict["Source"] as! String
                                }
                            }
                        }
                        public var sourceLogo: [QueryJobListResponseBody.JobList.Job.Output.Properties.SourceLogos.SourceLogo]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.sourceLogo != nil {
                                var tmp : [Any] = []
                                for k in self.sourceLogo! {
                                    tmp.append(k.toMap())
                                }
                                map["SourceLogo"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("SourceLogo") {
                                var tmp : [QueryJobListResponseBody.JobList.Job.Output.Properties.SourceLogos.SourceLogo] = []
                                for v in dict["SourceLogo"] as! [Any] {
                                    var model = QueryJobListResponseBody.JobList.Job.Output.Properties.SourceLogos.SourceLogo()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.sourceLogo = tmp
                            }
                        }
                    }
                    public class Streams : Tea.TeaModel {
                        public class AudioStreamList : Tea.TeaModel {
                            public class AudioStream : Tea.TeaModel {
                                public var bitrate: String?

                                public var channelLayout: String?

                                public var channels: String?

                                public var codecLongName: String?

                                public var codecName: String?

                                public var codecTag: String?

                                public var codecTagString: String?

                                public var codecTimeBase: String?

                                public var duration: String?

                                public var index: String?

                                public var lang: String?

                                public var numFrames: String?

                                public var sampleFmt: String?

                                public var samplerate: String?

                                public var startTime: String?

                                public var timebase: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.bitrate != nil {
                                        map["Bitrate"] = self.bitrate!
                                    }
                                    if self.channelLayout != nil {
                                        map["ChannelLayout"] = self.channelLayout!
                                    }
                                    if self.channels != nil {
                                        map["Channels"] = self.channels!
                                    }
                                    if self.codecLongName != nil {
                                        map["CodecLongName"] = self.codecLongName!
                                    }
                                    if self.codecName != nil {
                                        map["CodecName"] = self.codecName!
                                    }
                                    if self.codecTag != nil {
                                        map["CodecTag"] = self.codecTag!
                                    }
                                    if self.codecTagString != nil {
                                        map["CodecTagString"] = self.codecTagString!
                                    }
                                    if self.codecTimeBase != nil {
                                        map["CodecTimeBase"] = self.codecTimeBase!
                                    }
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.index != nil {
                                        map["Index"] = self.index!
                                    }
                                    if self.lang != nil {
                                        map["Lang"] = self.lang!
                                    }
                                    if self.numFrames != nil {
                                        map["NumFrames"] = self.numFrames!
                                    }
                                    if self.sampleFmt != nil {
                                        map["SampleFmt"] = self.sampleFmt!
                                    }
                                    if self.samplerate != nil {
                                        map["Samplerate"] = self.samplerate!
                                    }
                                    if self.startTime != nil {
                                        map["StartTime"] = self.startTime!
                                    }
                                    if self.timebase != nil {
                                        map["Timebase"] = self.timebase!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Bitrate") {
                                        self.bitrate = dict["Bitrate"] as! String
                                    }
                                    if dict.keys.contains("ChannelLayout") {
                                        self.channelLayout = dict["ChannelLayout"] as! String
                                    }
                                    if dict.keys.contains("Channels") {
                                        self.channels = dict["Channels"] as! String
                                    }
                                    if dict.keys.contains("CodecLongName") {
                                        self.codecLongName = dict["CodecLongName"] as! String
                                    }
                                    if dict.keys.contains("CodecName") {
                                        self.codecName = dict["CodecName"] as! String
                                    }
                                    if dict.keys.contains("CodecTag") {
                                        self.codecTag = dict["CodecTag"] as! String
                                    }
                                    if dict.keys.contains("CodecTagString") {
                                        self.codecTagString = dict["CodecTagString"] as! String
                                    }
                                    if dict.keys.contains("CodecTimeBase") {
                                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                                    }
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("Index") {
                                        self.index = dict["Index"] as! String
                                    }
                                    if dict.keys.contains("Lang") {
                                        self.lang = dict["Lang"] as! String
                                    }
                                    if dict.keys.contains("NumFrames") {
                                        self.numFrames = dict["NumFrames"] as! String
                                    }
                                    if dict.keys.contains("SampleFmt") {
                                        self.sampleFmt = dict["SampleFmt"] as! String
                                    }
                                    if dict.keys.contains("Samplerate") {
                                        self.samplerate = dict["Samplerate"] as! String
                                    }
                                    if dict.keys.contains("StartTime") {
                                        self.startTime = dict["StartTime"] as! String
                                    }
                                    if dict.keys.contains("Timebase") {
                                        self.timebase = dict["Timebase"] as! String
                                    }
                                }
                            }
                            public var audioStream: [QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList.AudioStream]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.audioStream != nil {
                                    var tmp : [Any] = []
                                    for k in self.audioStream! {
                                        tmp.append(k.toMap())
                                    }
                                    map["AudioStream"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AudioStream") {
                                    var tmp : [QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList.AudioStream] = []
                                    for v in dict["AudioStream"] as! [Any] {
                                        var model = QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList.AudioStream()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.audioStream = tmp
                                }
                            }
                        }
                        public class SubtitleStreamList : Tea.TeaModel {
                            public class SubtitleStream : Tea.TeaModel {
                                public var index: String?

                                public var lang: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.index != nil {
                                        map["Index"] = self.index!
                                    }
                                    if self.lang != nil {
                                        map["Lang"] = self.lang!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Index") {
                                        self.index = dict["Index"] as! String
                                    }
                                    if dict.keys.contains("Lang") {
                                        self.lang = dict["Lang"] as! String
                                    }
                                }
                            }
                            public var subtitleStream: [QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList.SubtitleStream]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.subtitleStream != nil {
                                    var tmp : [Any] = []
                                    for k in self.subtitleStream! {
                                        tmp.append(k.toMap())
                                    }
                                    map["SubtitleStream"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("SubtitleStream") {
                                    var tmp : [QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList.SubtitleStream] = []
                                    for v in dict["SubtitleStream"] as! [Any] {
                                        var model = QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList.SubtitleStream()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.subtitleStream = tmp
                                }
                            }
                        }
                        public class VideoStreamList : Tea.TeaModel {
                            public class VideoStream : Tea.TeaModel {
                                public class NetworkCost : Tea.TeaModel {
                                    public var avgBitrate: String?

                                    public var costBandwidth: String?

                                    public var preloadTime: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.avgBitrate != nil {
                                            map["AvgBitrate"] = self.avgBitrate!
                                        }
                                        if self.costBandwidth != nil {
                                            map["CostBandwidth"] = self.costBandwidth!
                                        }
                                        if self.preloadTime != nil {
                                            map["PreloadTime"] = self.preloadTime!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("AvgBitrate") {
                                            self.avgBitrate = dict["AvgBitrate"] as! String
                                        }
                                        if dict.keys.contains("CostBandwidth") {
                                            self.costBandwidth = dict["CostBandwidth"] as! String
                                        }
                                        if dict.keys.contains("PreloadTime") {
                                            self.preloadTime = dict["PreloadTime"] as! String
                                        }
                                    }
                                }
                                public var avgFPS: String?

                                public var bitrate: String?

                                public var codecLongName: String?

                                public var codecName: String?

                                public var codecTag: String?

                                public var codecTagString: String?

                                public var codecTimeBase: String?

                                public var dar: String?

                                public var duration: String?

                                public var fps: String?

                                public var hasBFrames: String?

                                public var height: String?

                                public var index: String?

                                public var lang: String?

                                public var level: String?

                                public var networkCost: QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream.NetworkCost?

                                public var numFrames: String?

                                public var pixFmt: String?

                                public var profile: String?

                                public var sar: String?

                                public var startTime: String?

                                public var timebase: String?

                                public var width: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                    try self.networkCost?.validate()
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.avgFPS != nil {
                                        map["AvgFPS"] = self.avgFPS!
                                    }
                                    if self.bitrate != nil {
                                        map["Bitrate"] = self.bitrate!
                                    }
                                    if self.codecLongName != nil {
                                        map["CodecLongName"] = self.codecLongName!
                                    }
                                    if self.codecName != nil {
                                        map["CodecName"] = self.codecName!
                                    }
                                    if self.codecTag != nil {
                                        map["CodecTag"] = self.codecTag!
                                    }
                                    if self.codecTagString != nil {
                                        map["CodecTagString"] = self.codecTagString!
                                    }
                                    if self.codecTimeBase != nil {
                                        map["CodecTimeBase"] = self.codecTimeBase!
                                    }
                                    if self.dar != nil {
                                        map["Dar"] = self.dar!
                                    }
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.fps != nil {
                                        map["Fps"] = self.fps!
                                    }
                                    if self.hasBFrames != nil {
                                        map["HasBFrames"] = self.hasBFrames!
                                    }
                                    if self.height != nil {
                                        map["Height"] = self.height!
                                    }
                                    if self.index != nil {
                                        map["Index"] = self.index!
                                    }
                                    if self.lang != nil {
                                        map["Lang"] = self.lang!
                                    }
                                    if self.level != nil {
                                        map["Level"] = self.level!
                                    }
                                    if self.networkCost != nil {
                                        map["NetworkCost"] = self.networkCost?.toMap()
                                    }
                                    if self.numFrames != nil {
                                        map["NumFrames"] = self.numFrames!
                                    }
                                    if self.pixFmt != nil {
                                        map["PixFmt"] = self.pixFmt!
                                    }
                                    if self.profile != nil {
                                        map["Profile"] = self.profile!
                                    }
                                    if self.sar != nil {
                                        map["Sar"] = self.sar!
                                    }
                                    if self.startTime != nil {
                                        map["StartTime"] = self.startTime!
                                    }
                                    if self.timebase != nil {
                                        map["Timebase"] = self.timebase!
                                    }
                                    if self.width != nil {
                                        map["Width"] = self.width!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("AvgFPS") {
                                        self.avgFPS = dict["AvgFPS"] as! String
                                    }
                                    if dict.keys.contains("Bitrate") {
                                        self.bitrate = dict["Bitrate"] as! String
                                    }
                                    if dict.keys.contains("CodecLongName") {
                                        self.codecLongName = dict["CodecLongName"] as! String
                                    }
                                    if dict.keys.contains("CodecName") {
                                        self.codecName = dict["CodecName"] as! String
                                    }
                                    if dict.keys.contains("CodecTag") {
                                        self.codecTag = dict["CodecTag"] as! String
                                    }
                                    if dict.keys.contains("CodecTagString") {
                                        self.codecTagString = dict["CodecTagString"] as! String
                                    }
                                    if dict.keys.contains("CodecTimeBase") {
                                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                                    }
                                    if dict.keys.contains("Dar") {
                                        self.dar = dict["Dar"] as! String
                                    }
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("Fps") {
                                        self.fps = dict["Fps"] as! String
                                    }
                                    if dict.keys.contains("HasBFrames") {
                                        self.hasBFrames = dict["HasBFrames"] as! String
                                    }
                                    if dict.keys.contains("Height") {
                                        self.height = dict["Height"] as! String
                                    }
                                    if dict.keys.contains("Index") {
                                        self.index = dict["Index"] as! String
                                    }
                                    if dict.keys.contains("Lang") {
                                        self.lang = dict["Lang"] as! String
                                    }
                                    if dict.keys.contains("Level") {
                                        self.level = dict["Level"] as! String
                                    }
                                    if dict.keys.contains("NetworkCost") {
                                        var model = QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream.NetworkCost()
                                        model.fromMap(dict["NetworkCost"] as! [String: Any])
                                        self.networkCost = model
                                    }
                                    if dict.keys.contains("NumFrames") {
                                        self.numFrames = dict["NumFrames"] as! String
                                    }
                                    if dict.keys.contains("PixFmt") {
                                        self.pixFmt = dict["PixFmt"] as! String
                                    }
                                    if dict.keys.contains("Profile") {
                                        self.profile = dict["Profile"] as! String
                                    }
                                    if dict.keys.contains("Sar") {
                                        self.sar = dict["Sar"] as! String
                                    }
                                    if dict.keys.contains("StartTime") {
                                        self.startTime = dict["StartTime"] as! String
                                    }
                                    if dict.keys.contains("Timebase") {
                                        self.timebase = dict["Timebase"] as! String
                                    }
                                    if dict.keys.contains("Width") {
                                        self.width = dict["Width"] as! String
                                    }
                                }
                            }
                            public var videoStream: [QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.videoStream != nil {
                                    var tmp : [Any] = []
                                    for k in self.videoStream! {
                                        tmp.append(k.toMap())
                                    }
                                    map["VideoStream"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("VideoStream") {
                                    var tmp : [QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream] = []
                                    for v in dict["VideoStream"] as! [Any] {
                                        var model = QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.videoStream = tmp
                                }
                            }
                        }
                        public var audioStreamList: QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList?

                        public var subtitleStreamList: QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList?

                        public var videoStreamList: QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audioStreamList?.validate()
                            try self.subtitleStreamList?.validate()
                            try self.videoStreamList?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audioStreamList != nil {
                                map["AudioStreamList"] = self.audioStreamList?.toMap()
                            }
                            if self.subtitleStreamList != nil {
                                map["SubtitleStreamList"] = self.subtitleStreamList?.toMap()
                            }
                            if self.videoStreamList != nil {
                                map["VideoStreamList"] = self.videoStreamList?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AudioStreamList") {
                                var model = QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList()
                                model.fromMap(dict["AudioStreamList"] as! [String: Any])
                                self.audioStreamList = model
                            }
                            if dict.keys.contains("SubtitleStreamList") {
                                var model = QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList()
                                model.fromMap(dict["SubtitleStreamList"] as! [String: Any])
                                self.subtitleStreamList = model
                            }
                            if dict.keys.contains("VideoStreamList") {
                                var model = QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList()
                                model.fromMap(dict["VideoStreamList"] as! [String: Any])
                                self.videoStreamList = model
                            }
                        }
                    }
                    public var bitrate: String?

                    public var duration: String?

                    public var fileFormat: String?

                    public var fileSize: String?

                    public var format: QueryJobListResponseBody.JobList.Job.Output.Properties.Format?

                    public var fps: String?

                    public var height: String?

                    public var sourceLogos: QueryJobListResponseBody.JobList.Job.Output.Properties.SourceLogos?

                    public var streams: QueryJobListResponseBody.JobList.Job.Output.Properties.Streams?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.format?.validate()
                        try self.sourceLogos?.validate()
                        try self.streams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fileFormat != nil {
                            map["FileFormat"] = self.fileFormat!
                        }
                        if self.fileSize != nil {
                            map["FileSize"] = self.fileSize!
                        }
                        if self.format != nil {
                            map["Format"] = self.format?.toMap()
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.sourceLogos != nil {
                            map["SourceLogos"] = self.sourceLogos?.toMap()
                        }
                        if self.streams != nil {
                            map["Streams"] = self.streams?.toMap()
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("FileFormat") {
                            self.fileFormat = dict["FileFormat"] as! String
                        }
                        if dict.keys.contains("FileSize") {
                            self.fileSize = dict["FileSize"] as! String
                        }
                        if dict.keys.contains("Format") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.Properties.Format()
                            model.fromMap(dict["Format"] as! [String: Any])
                            self.format = model
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("SourceLogos") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.Properties.SourceLogos()
                            model.fromMap(dict["SourceLogos"] as! [String: Any])
                            self.sourceLogos = model
                        }
                        if dict.keys.contains("Streams") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.Properties.Streams()
                            model.fromMap(dict["Streams"] as! [String: Any])
                            self.streams = model
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public class SubtitleConfig : Tea.TeaModel {
                    public class ExtSubtitleList : Tea.TeaModel {
                        public class ExtSubtitle : Tea.TeaModel {
                            public class Input : Tea.TeaModel {
                                public var bucket: String?

                                public var location: String?

                                public var object: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.bucket != nil {
                                        map["Bucket"] = self.bucket!
                                    }
                                    if self.location != nil {
                                        map["Location"] = self.location!
                                    }
                                    if self.object != nil {
                                        map["Object"] = self.object!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Bucket") {
                                        self.bucket = dict["Bucket"] as! String
                                    }
                                    if dict.keys.contains("Location") {
                                        self.location = dict["Location"] as! String
                                    }
                                    if dict.keys.contains("Object") {
                                        self.object = dict["Object"] as! String
                                    }
                                }
                            }
                            public var charEnc: String?

                            public var fontName: String?

                            public var input: QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle.Input?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.input?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.charEnc != nil {
                                    map["CharEnc"] = self.charEnc!
                                }
                                if self.fontName != nil {
                                    map["FontName"] = self.fontName!
                                }
                                if self.input != nil {
                                    map["Input"] = self.input?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("CharEnc") {
                                    self.charEnc = dict["CharEnc"] as! String
                                }
                                if dict.keys.contains("FontName") {
                                    self.fontName = dict["FontName"] as! String
                                }
                                if dict.keys.contains("Input") {
                                    var model = QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle.Input()
                                    model.fromMap(dict["Input"] as! [String: Any])
                                    self.input = model
                                }
                            }
                        }
                        public var extSubtitle: [QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.extSubtitle != nil {
                                var tmp : [Any] = []
                                for k in self.extSubtitle! {
                                    tmp.append(k.toMap())
                                }
                                map["ExtSubtitle"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ExtSubtitle") {
                                var tmp : [QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle] = []
                                for v in dict["ExtSubtitle"] as! [Any] {
                                    var model = QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.extSubtitle = tmp
                            }
                        }
                    }
                    public class SubtitleList : Tea.TeaModel {
                        public class Subtitle : Tea.TeaModel {
                            public var map: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.map != nil {
                                    map["Map"] = self.map!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Map") {
                                    self.map = dict["Map"] as! String
                                }
                            }
                        }
                        public var subtitle: [QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList.Subtitle]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.subtitle != nil {
                                var tmp : [Any] = []
                                for k in self.subtitle! {
                                    tmp.append(k.toMap())
                                }
                                map["Subtitle"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Subtitle") {
                                var tmp : [QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList.Subtitle] = []
                                for v in dict["Subtitle"] as! [Any] {
                                    var model = QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList.Subtitle()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.subtitle = tmp
                            }
                        }
                    }
                    public var extSubtitleList: QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList?

                    public var subtitleList: QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.extSubtitleList?.validate()
                        try self.subtitleList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.extSubtitleList != nil {
                            map["ExtSubtitleList"] = self.extSubtitleList?.toMap()
                        }
                        if self.subtitleList != nil {
                            map["SubtitleList"] = self.subtitleList?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ExtSubtitleList") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList()
                            model.fromMap(dict["ExtSubtitleList"] as! [String: Any])
                            self.extSubtitleList = model
                        }
                        if dict.keys.contains("SubtitleList") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList()
                            model.fromMap(dict["SubtitleList"] as! [String: Any])
                            self.subtitleList = model
                        }
                    }
                }
                public class SuperReso : Tea.TeaModel {
                    public var isHalfSample: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.isHalfSample != nil {
                            map["IsHalfSample"] = self.isHalfSample!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IsHalfSample") {
                            self.isHalfSample = dict["IsHalfSample"] as! String
                        }
                    }
                }
                public class TailSlateList : Tea.TeaModel {
                    public class TailSlate : Tea.TeaModel {
                        public var bgColor: String?

                        public var blendDuration: String?

                        public var height: String?

                        public var isMergeAudio: Bool?

                        public var start: String?

                        public var tailUrl: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bgColor != nil {
                                map["BgColor"] = self.bgColor!
                            }
                            if self.blendDuration != nil {
                                map["BlendDuration"] = self.blendDuration!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.isMergeAudio != nil {
                                map["IsMergeAudio"] = self.isMergeAudio!
                            }
                            if self.start != nil {
                                map["Start"] = self.start!
                            }
                            if self.tailUrl != nil {
                                map["TailUrl"] = self.tailUrl!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("BgColor") {
                                self.bgColor = dict["BgColor"] as! String
                            }
                            if dict.keys.contains("BlendDuration") {
                                self.blendDuration = dict["BlendDuration"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("IsMergeAudio") {
                                self.isMergeAudio = dict["IsMergeAudio"] as! Bool
                            }
                            if dict.keys.contains("Start") {
                                self.start = dict["Start"] as! String
                            }
                            if dict.keys.contains("TailUrl") {
                                self.tailUrl = dict["TailUrl"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var tailSlate: [QueryJobListResponseBody.JobList.Job.Output.TailSlateList.TailSlate]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tailSlate != nil {
                            var tmp : [Any] = []
                            for k in self.tailSlate! {
                                tmp.append(k.toMap())
                            }
                            map["TailSlate"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TailSlate") {
                            var tmp : [QueryJobListResponseBody.JobList.Job.Output.TailSlateList.TailSlate] = []
                            for v in dict["TailSlate"] as! [Any] {
                                var model = QueryJobListResponseBody.JobList.Job.Output.TailSlateList.TailSlate()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.tailSlate = tmp
                        }
                    }
                }
                public class TransConfig : Tea.TeaModel {
                    public var adjDarMethod: String?

                    public var isCheckAudioBitrate: String?

                    public var isCheckAudioBitrateFail: String?

                    public var isCheckReso: String?

                    public var isCheckResoFail: String?

                    public var isCheckVideoBitrate: String?

                    public var isCheckVideoBitrateFail: String?

                    public var transMode: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.adjDarMethod != nil {
                            map["AdjDarMethod"] = self.adjDarMethod!
                        }
                        if self.isCheckAudioBitrate != nil {
                            map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                        }
                        if self.isCheckAudioBitrateFail != nil {
                            map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                        }
                        if self.isCheckReso != nil {
                            map["IsCheckReso"] = self.isCheckReso!
                        }
                        if self.isCheckResoFail != nil {
                            map["IsCheckResoFail"] = self.isCheckResoFail!
                        }
                        if self.isCheckVideoBitrate != nil {
                            map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                        }
                        if self.isCheckVideoBitrateFail != nil {
                            map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                        }
                        if self.transMode != nil {
                            map["TransMode"] = self.transMode!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AdjDarMethod") {
                            self.adjDarMethod = dict["AdjDarMethod"] as! String
                        }
                        if dict.keys.contains("IsCheckAudioBitrate") {
                            self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                        }
                        if dict.keys.contains("IsCheckAudioBitrateFail") {
                            self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                        }
                        if dict.keys.contains("IsCheckReso") {
                            self.isCheckReso = dict["IsCheckReso"] as! String
                        }
                        if dict.keys.contains("IsCheckResoFail") {
                            self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                        }
                        if dict.keys.contains("IsCheckVideoBitrate") {
                            self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                        }
                        if dict.keys.contains("IsCheckVideoBitrateFail") {
                            self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                        }
                        if dict.keys.contains("TransMode") {
                            self.transMode = dict["TransMode"] as! String
                        }
                    }
                }
                public class Video : Tea.TeaModel {
                    public class BitrateBnd : Tea.TeaModel {
                        public var max: String?

                        public var min: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.max != nil {
                                map["Max"] = self.max!
                            }
                            if self.min != nil {
                                map["Min"] = self.min!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Max") {
                                self.max = dict["Max"] as! String
                            }
                            if dict.keys.contains("Min") {
                                self.min = dict["Min"] as! String
                            }
                        }
                    }
                    public var bitrate: String?

                    public var bitrateBnd: QueryJobListResponseBody.JobList.Job.Output.Video.BitrateBnd?

                    public var bufsize: String?

                    public var codec: String?

                    public var crf: String?

                    public var crop: String?

                    public var degrain: String?

                    public var fps: String?

                    public var gop: String?

                    public var height: String?

                    public var maxFps: String?

                    public var maxrate: String?

                    public var pad: String?

                    public var pixFmt: String?

                    public var preset: String?

                    public var profile: String?

                    public var qscale: String?

                    public var resoPriority: String?

                    public var scanMode: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.bitrateBnd?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.bitrateBnd != nil {
                            map["BitrateBnd"] = self.bitrateBnd?.toMap()
                        }
                        if self.bufsize != nil {
                            map["Bufsize"] = self.bufsize!
                        }
                        if self.codec != nil {
                            map["Codec"] = self.codec!
                        }
                        if self.crf != nil {
                            map["Crf"] = self.crf!
                        }
                        if self.crop != nil {
                            map["Crop"] = self.crop!
                        }
                        if self.degrain != nil {
                            map["Degrain"] = self.degrain!
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.gop != nil {
                            map["Gop"] = self.gop!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.maxFps != nil {
                            map["MaxFps"] = self.maxFps!
                        }
                        if self.maxrate != nil {
                            map["Maxrate"] = self.maxrate!
                        }
                        if self.pad != nil {
                            map["Pad"] = self.pad!
                        }
                        if self.pixFmt != nil {
                            map["PixFmt"] = self.pixFmt!
                        }
                        if self.preset != nil {
                            map["Preset"] = self.preset!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.qscale != nil {
                            map["Qscale"] = self.qscale!
                        }
                        if self.resoPriority != nil {
                            map["ResoPriority"] = self.resoPriority!
                        }
                        if self.scanMode != nil {
                            map["ScanMode"] = self.scanMode!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("BitrateBnd") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.Video.BitrateBnd()
                            model.fromMap(dict["BitrateBnd"] as! [String: Any])
                            self.bitrateBnd = model
                        }
                        if dict.keys.contains("Bufsize") {
                            self.bufsize = dict["Bufsize"] as! String
                        }
                        if dict.keys.contains("Codec") {
                            self.codec = dict["Codec"] as! String
                        }
                        if dict.keys.contains("Crf") {
                            self.crf = dict["Crf"] as! String
                        }
                        if dict.keys.contains("Crop") {
                            self.crop = dict["Crop"] as! String
                        }
                        if dict.keys.contains("Degrain") {
                            self.degrain = dict["Degrain"] as! String
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Gop") {
                            self.gop = dict["Gop"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("MaxFps") {
                            self.maxFps = dict["MaxFps"] as! String
                        }
                        if dict.keys.contains("Maxrate") {
                            self.maxrate = dict["Maxrate"] as! String
                        }
                        if dict.keys.contains("Pad") {
                            self.pad = dict["Pad"] as! String
                        }
                        if dict.keys.contains("PixFmt") {
                            self.pixFmt = dict["PixFmt"] as! String
                        }
                        if dict.keys.contains("Preset") {
                            self.preset = dict["Preset"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Qscale") {
                            self.qscale = dict["Qscale"] as! String
                        }
                        if dict.keys.contains("ResoPriority") {
                            self.resoPriority = dict["ResoPriority"] as! String
                        }
                        if dict.keys.contains("ScanMode") {
                            self.scanMode = dict["ScanMode"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public class WaterMarkList : Tea.TeaModel {
                    public class WaterMark : Tea.TeaModel {
                        public class InputFile : Tea.TeaModel {
                            public var bucket: String?

                            public var location: String?

                            public var object: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bucket != nil {
                                    map["Bucket"] = self.bucket!
                                }
                                if self.location != nil {
                                    map["Location"] = self.location!
                                }
                                if self.object != nil {
                                    map["Object"] = self.object!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bucket") {
                                    self.bucket = dict["Bucket"] as! String
                                }
                                if dict.keys.contains("Location") {
                                    self.location = dict["Location"] as! String
                                }
                                if dict.keys.contains("Object") {
                                    self.object = dict["Object"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var height: String?

                        public var inputFile: QueryJobListResponseBody.JobList.Job.Output.WaterMarkList.WaterMark.InputFile?

                        public var referPos: String?

                        public var type: String?

                        public var waterMarkTemplateId: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.inputFile?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.inputFile != nil {
                                map["InputFile"] = self.inputFile?.toMap()
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            if self.waterMarkTemplateId != nil {
                                map["WaterMarkTemplateId"] = self.waterMarkTemplateId!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("InputFile") {
                                var model = QueryJobListResponseBody.JobList.Job.Output.WaterMarkList.WaterMark.InputFile()
                                model.fromMap(dict["InputFile"] as! [String: Any])
                                self.inputFile = model
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Type") {
                                self.type = dict["Type"] as! String
                            }
                            if dict.keys.contains("WaterMarkTemplateId") {
                                self.waterMarkTemplateId = dict["WaterMarkTemplateId"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var waterMark: [QueryJobListResponseBody.JobList.Job.Output.WaterMarkList.WaterMark]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.waterMark != nil {
                            var tmp : [Any] = []
                            for k in self.waterMark! {
                                tmp.append(k.toMap())
                            }
                            map["WaterMark"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("WaterMark") {
                            var tmp : [QueryJobListResponseBody.JobList.Job.Output.WaterMarkList.WaterMark] = []
                            for v in dict["WaterMark"] as! [Any] {
                                var model = QueryJobListResponseBody.JobList.Job.Output.WaterMarkList.WaterMark()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.waterMark = tmp
                        }
                    }
                }
                public var amixList: QueryJobListResponseBody.JobList.Job.Output.AmixList?

                public var audio: QueryJobListResponseBody.JobList.Job.Output.Audio?

                public var audioStreamMap: String?

                public var clip: QueryJobListResponseBody.JobList.Job.Output.Clip?

                public var container: QueryJobListResponseBody.JobList.Job.Output.Container?

                public var deWatermark: String?

                public var encryption: QueryJobListResponseBody.JobList.Job.Output.Encryption?

                public var m3U8NonStandardSupport: QueryJobListResponseBody.JobList.Job.Output.M3U8NonStandardSupport?

                public var mergeConfigUrl: String?

                public var mergeList: QueryJobListResponseBody.JobList.Job.Output.MergeList?

                public var muxConfig: QueryJobListResponseBody.JobList.Job.Output.MuxConfig?

                public var openingList: QueryJobListResponseBody.JobList.Job.Output.OpeningList?

                public var outSubtitleList: QueryJobListResponseBody.JobList.Job.Output.OutSubtitleList?

                public var outputFile: QueryJobListResponseBody.JobList.Job.Output.OutputFile?

                public var priority: String?

                public var properties: QueryJobListResponseBody.JobList.Job.Output.Properties?

                public var rotate: String?

                public var subtitleConfig: QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig?

                public var superReso: QueryJobListResponseBody.JobList.Job.Output.SuperReso?

                public var tailSlateList: QueryJobListResponseBody.JobList.Job.Output.TailSlateList?

                public var templateId: String?

                public var transConfig: QueryJobListResponseBody.JobList.Job.Output.TransConfig?

                public var userData: String?

                public var video: QueryJobListResponseBody.JobList.Job.Output.Video?

                public var videoStreamMap: String?

                public var waterMarkConfigUrl: String?

                public var waterMarkList: QueryJobListResponseBody.JobList.Job.Output.WaterMarkList?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.amixList?.validate()
                    try self.audio?.validate()
                    try self.clip?.validate()
                    try self.container?.validate()
                    try self.encryption?.validate()
                    try self.m3U8NonStandardSupport?.validate()
                    try self.mergeList?.validate()
                    try self.muxConfig?.validate()
                    try self.openingList?.validate()
                    try self.outSubtitleList?.validate()
                    try self.outputFile?.validate()
                    try self.properties?.validate()
                    try self.subtitleConfig?.validate()
                    try self.superReso?.validate()
                    try self.tailSlateList?.validate()
                    try self.transConfig?.validate()
                    try self.video?.validate()
                    try self.waterMarkList?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.amixList != nil {
                        map["AmixList"] = self.amixList?.toMap()
                    }
                    if self.audio != nil {
                        map["Audio"] = self.audio?.toMap()
                    }
                    if self.audioStreamMap != nil {
                        map["AudioStreamMap"] = self.audioStreamMap!
                    }
                    if self.clip != nil {
                        map["Clip"] = self.clip?.toMap()
                    }
                    if self.container != nil {
                        map["Container"] = self.container?.toMap()
                    }
                    if self.deWatermark != nil {
                        map["DeWatermark"] = self.deWatermark!
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.m3U8NonStandardSupport != nil {
                        map["M3U8NonStandardSupport"] = self.m3U8NonStandardSupport?.toMap()
                    }
                    if self.mergeConfigUrl != nil {
                        map["MergeConfigUrl"] = self.mergeConfigUrl!
                    }
                    if self.mergeList != nil {
                        map["MergeList"] = self.mergeList?.toMap()
                    }
                    if self.muxConfig != nil {
                        map["MuxConfig"] = self.muxConfig?.toMap()
                    }
                    if self.openingList != nil {
                        map["OpeningList"] = self.openingList?.toMap()
                    }
                    if self.outSubtitleList != nil {
                        map["OutSubtitleList"] = self.outSubtitleList?.toMap()
                    }
                    if self.outputFile != nil {
                        map["OutputFile"] = self.outputFile?.toMap()
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    if self.properties != nil {
                        map["Properties"] = self.properties?.toMap()
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.subtitleConfig != nil {
                        map["SubtitleConfig"] = self.subtitleConfig?.toMap()
                    }
                    if self.superReso != nil {
                        map["SuperReso"] = self.superReso?.toMap()
                    }
                    if self.tailSlateList != nil {
                        map["TailSlateList"] = self.tailSlateList?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    if self.transConfig != nil {
                        map["TransConfig"] = self.transConfig?.toMap()
                    }
                    if self.userData != nil {
                        map["UserData"] = self.userData!
                    }
                    if self.video != nil {
                        map["Video"] = self.video?.toMap()
                    }
                    if self.videoStreamMap != nil {
                        map["VideoStreamMap"] = self.videoStreamMap!
                    }
                    if self.waterMarkConfigUrl != nil {
                        map["WaterMarkConfigUrl"] = self.waterMarkConfigUrl!
                    }
                    if self.waterMarkList != nil {
                        map["WaterMarkList"] = self.waterMarkList?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AmixList") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.AmixList()
                        model.fromMap(dict["AmixList"] as! [String: Any])
                        self.amixList = model
                    }
                    if dict.keys.contains("Audio") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.Audio()
                        model.fromMap(dict["Audio"] as! [String: Any])
                        self.audio = model
                    }
                    if dict.keys.contains("AudioStreamMap") {
                        self.audioStreamMap = dict["AudioStreamMap"] as! String
                    }
                    if dict.keys.contains("Clip") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.Clip()
                        model.fromMap(dict["Clip"] as! [String: Any])
                        self.clip = model
                    }
                    if dict.keys.contains("Container") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.Container()
                        model.fromMap(dict["Container"] as! [String: Any])
                        self.container = model
                    }
                    if dict.keys.contains("DeWatermark") {
                        self.deWatermark = dict["DeWatermark"] as! String
                    }
                    if dict.keys.contains("Encryption") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("M3U8NonStandardSupport") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.M3U8NonStandardSupport()
                        model.fromMap(dict["M3U8NonStandardSupport"] as! [String: Any])
                        self.m3U8NonStandardSupport = model
                    }
                    if dict.keys.contains("MergeConfigUrl") {
                        self.mergeConfigUrl = dict["MergeConfigUrl"] as! String
                    }
                    if dict.keys.contains("MergeList") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.MergeList()
                        model.fromMap(dict["MergeList"] as! [String: Any])
                        self.mergeList = model
                    }
                    if dict.keys.contains("MuxConfig") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.MuxConfig()
                        model.fromMap(dict["MuxConfig"] as! [String: Any])
                        self.muxConfig = model
                    }
                    if dict.keys.contains("OpeningList") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.OpeningList()
                        model.fromMap(dict["OpeningList"] as! [String: Any])
                        self.openingList = model
                    }
                    if dict.keys.contains("OutSubtitleList") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.OutSubtitleList()
                        model.fromMap(dict["OutSubtitleList"] as! [String: Any])
                        self.outSubtitleList = model
                    }
                    if dict.keys.contains("OutputFile") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.OutputFile()
                        model.fromMap(dict["OutputFile"] as! [String: Any])
                        self.outputFile = model
                    }
                    if dict.keys.contains("Priority") {
                        self.priority = dict["Priority"] as! String
                    }
                    if dict.keys.contains("Properties") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.Properties()
                        model.fromMap(dict["Properties"] as! [String: Any])
                        self.properties = model
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("SubtitleConfig") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig()
                        model.fromMap(dict["SubtitleConfig"] as! [String: Any])
                        self.subtitleConfig = model
                    }
                    if dict.keys.contains("SuperReso") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.SuperReso()
                        model.fromMap(dict["SuperReso"] as! [String: Any])
                        self.superReso = model
                    }
                    if dict.keys.contains("TailSlateList") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.TailSlateList()
                        model.fromMap(dict["TailSlateList"] as! [String: Any])
                        self.tailSlateList = model
                    }
                    if dict.keys.contains("TemplateId") {
                        self.templateId = dict["TemplateId"] as! String
                    }
                    if dict.keys.contains("TransConfig") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.TransConfig()
                        model.fromMap(dict["TransConfig"] as! [String: Any])
                        self.transConfig = model
                    }
                    if dict.keys.contains("UserData") {
                        self.userData = dict["UserData"] as! String
                    }
                    if dict.keys.contains("Video") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.Video()
                        model.fromMap(dict["Video"] as! [String: Any])
                        self.video = model
                    }
                    if dict.keys.contains("VideoStreamMap") {
                        self.videoStreamMap = dict["VideoStreamMap"] as! String
                    }
                    if dict.keys.contains("WaterMarkConfigUrl") {
                        self.waterMarkConfigUrl = dict["WaterMarkConfigUrl"] as! String
                    }
                    if dict.keys.contains("WaterMarkList") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.WaterMarkList()
                        model.fromMap(dict["WaterMarkList"] as! [String: Any])
                        self.waterMarkList = model
                    }
                }
            }
            public var code: String?

            public var creationTime: String?

            public var finishTime: String?

            public var input: QueryJobListResponseBody.JobList.Job.Input?

            public var jobId: String?

            public var MNSMessageResult: QueryJobListResponseBody.JobList.Job.MNSMessageResult?

            public var message: String?

            public var output: QueryJobListResponseBody.JobList.Job.Output?

            public var percent: Int64?

            public var pipelineId: String?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.input?.validate()
                try self.MNSMessageResult?.validate()
                try self.output?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.MNSMessageResult != nil {
                    map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("Input") {
                    var model = QueryJobListResponseBody.JobList.Job.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("MNSMessageResult") {
                    var model = QueryJobListResponseBody.JobList.Job.MNSMessageResult()
                    model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                    self.MNSMessageResult = model
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Output") {
                    var model = QueryJobListResponseBody.JobList.Job.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! Int64
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
            }
        }
        public var job: [QueryJobListResponseBody.JobList.Job]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.job != nil {
                var tmp : [Any] = []
                for k in self.job! {
                    tmp.append(k.toMap())
                }
                map["Job"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Job") {
                var tmp : [QueryJobListResponseBody.JobList.Job] = []
                for v in dict["Job"] as! [Any] {
                    var model = QueryJobListResponseBody.JobList.Job()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.job = tmp
            }
        }
    }
    public class NonExistJobIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public var jobList: QueryJobListResponseBody.JobList?

    public var nonExistJobIds: QueryJobListResponseBody.NonExistJobIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobList?.validate()
        try self.nonExistJobIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobList != nil {
            map["JobList"] = self.jobList?.toMap()
        }
        if self.nonExistJobIds != nil {
            map["NonExistJobIds"] = self.nonExistJobIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobList") {
            var model = QueryJobListResponseBody.JobList()
            model.fromMap(dict["JobList"] as! [String: Any])
            self.jobList = model
        }
        if dict.keys.contains("NonExistJobIds") {
            var model = QueryJobListResponseBody.NonExistJobIds()
            model.fromMap(dict["NonExistJobIds"] as! [String: Any])
            self.nonExistJobIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaInfoJobListRequest : Tea.TeaModel {
    public var mediaInfoJobIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfoJobIds != nil {
            map["MediaInfoJobIds"] = self.mediaInfoJobIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfoJobIds") {
            self.mediaInfoJobIds = dict["MediaInfoJobIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryMediaInfoJobListResponseBody : Tea.TeaModel {
    public class MediaInfoJobList : Tea.TeaModel {
        public class MediaInfoJob : Tea.TeaModel {
            public class Input : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public class MNSMessageResult : Tea.TeaModel {
                public var errorCode: String?

                public var errorMessage: String?

                public var messageId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.messageId != nil {
                        map["MessageId"] = self.messageId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("MessageId") {
                        self.messageId = dict["MessageId"] as! String
                    }
                }
            }
            public class Properties : Tea.TeaModel {
                public class Format : Tea.TeaModel {
                    public var bitrate: String?

                    public var duration: String?

                    public var formatLongName: String?

                    public var formatName: String?

                    public var numPrograms: String?

                    public var numStreams: String?

                    public var size: String?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.formatLongName != nil {
                            map["FormatLongName"] = self.formatLongName!
                        }
                        if self.formatName != nil {
                            map["FormatName"] = self.formatName!
                        }
                        if self.numPrograms != nil {
                            map["NumPrograms"] = self.numPrograms!
                        }
                        if self.numStreams != nil {
                            map["NumStreams"] = self.numStreams!
                        }
                        if self.size != nil {
                            map["Size"] = self.size!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("FormatLongName") {
                            self.formatLongName = dict["FormatLongName"] as! String
                        }
                        if dict.keys.contains("FormatName") {
                            self.formatName = dict["FormatName"] as! String
                        }
                        if dict.keys.contains("NumPrograms") {
                            self.numPrograms = dict["NumPrograms"] as! String
                        }
                        if dict.keys.contains("NumStreams") {
                            self.numStreams = dict["NumStreams"] as! String
                        }
                        if dict.keys.contains("Size") {
                            self.size = dict["Size"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                    }
                }
                public class Streams : Tea.TeaModel {
                    public class AudioStreamList : Tea.TeaModel {
                        public class AudioStream : Tea.TeaModel {
                            public var bitrate: String?

                            public var channelLayout: String?

                            public var channels: String?

                            public var codecLongName: String?

                            public var codecName: String?

                            public var codecTag: String?

                            public var codecTagString: String?

                            public var codecTimeBase: String?

                            public var duration: String?

                            public var index: String?

                            public var lang: String?

                            public var numFrames: String?

                            public var sampleFmt: String?

                            public var samplerate: String?

                            public var startTime: String?

                            public var timebase: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channelLayout != nil {
                                    map["ChannelLayout"] = self.channelLayout!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codecLongName != nil {
                                    map["CodecLongName"] = self.codecLongName!
                                }
                                if self.codecName != nil {
                                    map["CodecName"] = self.codecName!
                                }
                                if self.codecTag != nil {
                                    map["CodecTag"] = self.codecTag!
                                }
                                if self.codecTagString != nil {
                                    map["CodecTagString"] = self.codecTagString!
                                }
                                if self.codecTimeBase != nil {
                                    map["CodecTimeBase"] = self.codecTimeBase!
                                }
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.index != nil {
                                    map["Index"] = self.index!
                                }
                                if self.lang != nil {
                                    map["Lang"] = self.lang!
                                }
                                if self.numFrames != nil {
                                    map["NumFrames"] = self.numFrames!
                                }
                                if self.sampleFmt != nil {
                                    map["SampleFmt"] = self.sampleFmt!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                if self.timebase != nil {
                                    map["Timebase"] = self.timebase!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("ChannelLayout") {
                                    self.channelLayout = dict["ChannelLayout"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("CodecLongName") {
                                    self.codecLongName = dict["CodecLongName"] as! String
                                }
                                if dict.keys.contains("CodecName") {
                                    self.codecName = dict["CodecName"] as! String
                                }
                                if dict.keys.contains("CodecTag") {
                                    self.codecTag = dict["CodecTag"] as! String
                                }
                                if dict.keys.contains("CodecTagString") {
                                    self.codecTagString = dict["CodecTagString"] as! String
                                }
                                if dict.keys.contains("CodecTimeBase") {
                                    self.codecTimeBase = dict["CodecTimeBase"] as! String
                                }
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Index") {
                                    self.index = dict["Index"] as! String
                                }
                                if dict.keys.contains("Lang") {
                                    self.lang = dict["Lang"] as! String
                                }
                                if dict.keys.contains("NumFrames") {
                                    self.numFrames = dict["NumFrames"] as! String
                                }
                                if dict.keys.contains("SampleFmt") {
                                    self.sampleFmt = dict["SampleFmt"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("StartTime") {
                                    self.startTime = dict["StartTime"] as! String
                                }
                                if dict.keys.contains("Timebase") {
                                    self.timebase = dict["Timebase"] as! String
                                }
                            }
                        }
                        public var audioStream: [QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.AudioStreamList.AudioStream]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audioStream != nil {
                                var tmp : [Any] = []
                                for k in self.audioStream! {
                                    tmp.append(k.toMap())
                                }
                                map["AudioStream"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AudioStream") {
                                var tmp : [QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.AudioStreamList.AudioStream] = []
                                for v in dict["AudioStream"] as! [Any] {
                                    var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.AudioStreamList.AudioStream()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.audioStream = tmp
                            }
                        }
                    }
                    public class SubtitleStreamList : Tea.TeaModel {
                        public class SubtitleStream : Tea.TeaModel {
                            public var index: String?

                            public var lang: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.index != nil {
                                    map["Index"] = self.index!
                                }
                                if self.lang != nil {
                                    map["Lang"] = self.lang!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Index") {
                                    self.index = dict["Index"] as! String
                                }
                                if dict.keys.contains("Lang") {
                                    self.lang = dict["Lang"] as! String
                                }
                            }
                        }
                        public var subtitleStream: [QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.SubtitleStreamList.SubtitleStream]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.subtitleStream != nil {
                                var tmp : [Any] = []
                                for k in self.subtitleStream! {
                                    tmp.append(k.toMap())
                                }
                                map["SubtitleStream"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("SubtitleStream") {
                                var tmp : [QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.SubtitleStreamList.SubtitleStream] = []
                                for v in dict["SubtitleStream"] as! [Any] {
                                    var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.SubtitleStreamList.SubtitleStream()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.subtitleStream = tmp
                            }
                        }
                    }
                    public class VideoStreamList : Tea.TeaModel {
                        public class VideoStream : Tea.TeaModel {
                            public class NetworkCost : Tea.TeaModel {
                                public var avgBitrate: String?

                                public var costBandwidth: String?

                                public var preloadTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.avgBitrate != nil {
                                        map["AvgBitrate"] = self.avgBitrate!
                                    }
                                    if self.costBandwidth != nil {
                                        map["CostBandwidth"] = self.costBandwidth!
                                    }
                                    if self.preloadTime != nil {
                                        map["PreloadTime"] = self.preloadTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("AvgBitrate") {
                                        self.avgBitrate = dict["AvgBitrate"] as! String
                                    }
                                    if dict.keys.contains("CostBandwidth") {
                                        self.costBandwidth = dict["CostBandwidth"] as! String
                                    }
                                    if dict.keys.contains("PreloadTime") {
                                        self.preloadTime = dict["PreloadTime"] as! String
                                    }
                                }
                            }
                            public var avgFPS: String?

                            public var bitrate: String?

                            public var codecLongName: String?

                            public var codecName: String?

                            public var codecTag: String?

                            public var codecTagString: String?

                            public var codecTimeBase: String?

                            public var dar: String?

                            public var duration: String?

                            public var fps: String?

                            public var hasBFrames: String?

                            public var height: String?

                            public var index: String?

                            public var lang: String?

                            public var level: String?

                            public var networkCost: QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream.NetworkCost?

                            public var numFrames: String?

                            public var pixFmt: String?

                            public var profile: String?

                            public var rotate: String?

                            public var sar: String?

                            public var startTime: String?

                            public var timebase: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.networkCost?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.avgFPS != nil {
                                    map["AvgFPS"] = self.avgFPS!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.codecLongName != nil {
                                    map["CodecLongName"] = self.codecLongName!
                                }
                                if self.codecName != nil {
                                    map["CodecName"] = self.codecName!
                                }
                                if self.codecTag != nil {
                                    map["CodecTag"] = self.codecTag!
                                }
                                if self.codecTagString != nil {
                                    map["CodecTagString"] = self.codecTagString!
                                }
                                if self.codecTimeBase != nil {
                                    map["CodecTimeBase"] = self.codecTimeBase!
                                }
                                if self.dar != nil {
                                    map["Dar"] = self.dar!
                                }
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.hasBFrames != nil {
                                    map["HasBFrames"] = self.hasBFrames!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.index != nil {
                                    map["Index"] = self.index!
                                }
                                if self.lang != nil {
                                    map["Lang"] = self.lang!
                                }
                                if self.level != nil {
                                    map["Level"] = self.level!
                                }
                                if self.networkCost != nil {
                                    map["NetworkCost"] = self.networkCost?.toMap()
                                }
                                if self.numFrames != nil {
                                    map["NumFrames"] = self.numFrames!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.rotate != nil {
                                    map["Rotate"] = self.rotate!
                                }
                                if self.sar != nil {
                                    map["Sar"] = self.sar!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                if self.timebase != nil {
                                    map["Timebase"] = self.timebase!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AvgFPS") {
                                    self.avgFPS = dict["AvgFPS"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("CodecLongName") {
                                    self.codecLongName = dict["CodecLongName"] as! String
                                }
                                if dict.keys.contains("CodecName") {
                                    self.codecName = dict["CodecName"] as! String
                                }
                                if dict.keys.contains("CodecTag") {
                                    self.codecTag = dict["CodecTag"] as! String
                                }
                                if dict.keys.contains("CodecTagString") {
                                    self.codecTagString = dict["CodecTagString"] as! String
                                }
                                if dict.keys.contains("CodecTimeBase") {
                                    self.codecTimeBase = dict["CodecTimeBase"] as! String
                                }
                                if dict.keys.contains("Dar") {
                                    self.dar = dict["Dar"] as! String
                                }
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("HasBFrames") {
                                    self.hasBFrames = dict["HasBFrames"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("Index") {
                                    self.index = dict["Index"] as! String
                                }
                                if dict.keys.contains("Lang") {
                                    self.lang = dict["Lang"] as! String
                                }
                                if dict.keys.contains("Level") {
                                    self.level = dict["Level"] as! String
                                }
                                if dict.keys.contains("NetworkCost") {
                                    var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream.NetworkCost()
                                    model.fromMap(dict["NetworkCost"] as! [String: Any])
                                    self.networkCost = model
                                }
                                if dict.keys.contains("NumFrames") {
                                    self.numFrames = dict["NumFrames"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Rotate") {
                                    self.rotate = dict["Rotate"] as! String
                                }
                                if dict.keys.contains("Sar") {
                                    self.sar = dict["Sar"] as! String
                                }
                                if dict.keys.contains("StartTime") {
                                    self.startTime = dict["StartTime"] as! String
                                }
                                if dict.keys.contains("Timebase") {
                                    self.timebase = dict["Timebase"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var videoStream: [QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.videoStream != nil {
                                var tmp : [Any] = []
                                for k in self.videoStream! {
                                    tmp.append(k.toMap())
                                }
                                map["VideoStream"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("VideoStream") {
                                var tmp : [QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream] = []
                                for v in dict["VideoStream"] as! [Any] {
                                    var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.videoStream = tmp
                            }
                        }
                    }
                    public var audioStreamList: QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.AudioStreamList?

                    public var subtitleStreamList: QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.SubtitleStreamList?

                    public var videoStreamList: QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.VideoStreamList?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.audioStreamList?.validate()
                        try self.subtitleStreamList?.validate()
                        try self.videoStreamList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioStreamList != nil {
                            map["AudioStreamList"] = self.audioStreamList?.toMap()
                        }
                        if self.subtitleStreamList != nil {
                            map["SubtitleStreamList"] = self.subtitleStreamList?.toMap()
                        }
                        if self.videoStreamList != nil {
                            map["VideoStreamList"] = self.videoStreamList?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioStreamList") {
                            var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.AudioStreamList()
                            model.fromMap(dict["AudioStreamList"] as! [String: Any])
                            self.audioStreamList = model
                        }
                        if dict.keys.contains("SubtitleStreamList") {
                            var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.SubtitleStreamList()
                            model.fromMap(dict["SubtitleStreamList"] as! [String: Any])
                            self.subtitleStreamList = model
                        }
                        if dict.keys.contains("VideoStreamList") {
                            var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.VideoStreamList()
                            model.fromMap(dict["VideoStreamList"] as! [String: Any])
                            self.videoStreamList = model
                        }
                    }
                }
                public var bitrate: String?

                public var duration: String?

                public var fileFormat: String?

                public var fileSize: String?

                public var format: QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Format?

                public var fps: String?

                public var height: String?

                public var streams: QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.format?.validate()
                    try self.streams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileFormat != nil {
                        map["FileFormat"] = self.fileFormat!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.format != nil {
                        map["Format"] = self.format?.toMap()
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.streams != nil {
                        map["Streams"] = self.streams?.toMap()
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileFormat") {
                        self.fileFormat = dict["FileFormat"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("Format") {
                        var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Format()
                        model.fromMap(dict["Format"] as! [String: Any])
                        self.format = model
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Streams") {
                        var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams()
                        model.fromMap(dict["Streams"] as! [String: Any])
                        self.streams = model
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var async: Bool?

            public var code: String?

            public var creationTime: String?

            public var input: QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Input?

            public var jobId: String?

            public var MNSMessageResult: QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.MNSMessageResult?

            public var message: String?

            public var pipelineId: String?

            public var properties: QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties?

            public var state: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.input?.validate()
                try self.MNSMessageResult?.validate()
                try self.properties?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.async != nil {
                    map["Async"] = self.async!
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.MNSMessageResult != nil {
                    map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.properties != nil {
                    map["Properties"] = self.properties?.toMap()
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Async") {
                    self.async = dict["Async"] as! Bool
                }
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Input") {
                    var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("MNSMessageResult") {
                    var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.MNSMessageResult()
                    model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                    self.MNSMessageResult = model
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Properties") {
                    var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties()
                    model.fromMap(dict["Properties"] as! [String: Any])
                    self.properties = model
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var mediaInfoJob: [QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaInfoJob != nil {
                var tmp : [Any] = []
                for k in self.mediaInfoJob! {
                    tmp.append(k.toMap())
                }
                map["MediaInfoJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaInfoJob") {
                var tmp : [QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob] = []
                for v in dict["MediaInfoJob"] as! [Any] {
                    var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaInfoJob = tmp
            }
        }
    }
    public class NonExistMediaInfoJobIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public var mediaInfoJobList: QueryMediaInfoJobListResponseBody.MediaInfoJobList?

    public var nonExistMediaInfoJobIds: QueryMediaInfoJobListResponseBody.NonExistMediaInfoJobIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfoJobList?.validate()
        try self.nonExistMediaInfoJobIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfoJobList != nil {
            map["MediaInfoJobList"] = self.mediaInfoJobList?.toMap()
        }
        if self.nonExistMediaInfoJobIds != nil {
            map["NonExistMediaInfoJobIds"] = self.nonExistMediaInfoJobIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfoJobList") {
            var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList()
            model.fromMap(dict["MediaInfoJobList"] as! [String: Any])
            self.mediaInfoJobList = model
        }
        if dict.keys.contains("NonExistMediaInfoJobIds") {
            var model = QueryMediaInfoJobListResponseBody.NonExistMediaInfoJobIds()
            model.fromMap(dict["NonExistMediaInfoJobIds"] as! [String: Any])
            self.nonExistMediaInfoJobIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMediaInfoJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaInfoJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMediaInfoJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaListRequest : Tea.TeaModel {
    public var includeMediaInfo: Bool?

    public var includePlayList: Bool?

    public var includeSnapshotList: Bool?

    public var includeSummaryList: Bool?

    public var mediaIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.includeMediaInfo != nil {
            map["IncludeMediaInfo"] = self.includeMediaInfo!
        }
        if self.includePlayList != nil {
            map["IncludePlayList"] = self.includePlayList!
        }
        if self.includeSnapshotList != nil {
            map["IncludeSnapshotList"] = self.includeSnapshotList!
        }
        if self.includeSummaryList != nil {
            map["IncludeSummaryList"] = self.includeSummaryList!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IncludeMediaInfo") {
            self.includeMediaInfo = dict["IncludeMediaInfo"] as! Bool
        }
        if dict.keys.contains("IncludePlayList") {
            self.includePlayList = dict["IncludePlayList"] as! Bool
        }
        if dict.keys.contains("IncludeSnapshotList") {
            self.includeSnapshotList = dict["IncludeSnapshotList"] as! Bool
        }
        if dict.keys.contains("IncludeSummaryList") {
            self.includeSummaryList = dict["IncludeSummaryList"] as! Bool
        }
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryMediaListResponseBody : Tea.TeaModel {
    public class MediaList : Tea.TeaModel {
        public class Media : Tea.TeaModel {
            public class File : Tea.TeaModel {
                public var state: String?

                public var URL: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    if self.URL != nil {
                        map["URL"] = self.URL!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! String
                    }
                    if dict.keys.contains("URL") {
                        self.URL = dict["URL"] as! String
                    }
                }
            }
            public class MediaInfo : Tea.TeaModel {
                public class Format : Tea.TeaModel {
                    public var bitrate: String?

                    public var duration: String?

                    public var formatLongName: String?

                    public var formatName: String?

                    public var numPrograms: String?

                    public var numStreams: String?

                    public var size: String?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.formatLongName != nil {
                            map["FormatLongName"] = self.formatLongName!
                        }
                        if self.formatName != nil {
                            map["FormatName"] = self.formatName!
                        }
                        if self.numPrograms != nil {
                            map["NumPrograms"] = self.numPrograms!
                        }
                        if self.numStreams != nil {
                            map["NumStreams"] = self.numStreams!
                        }
                        if self.size != nil {
                            map["Size"] = self.size!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("FormatLongName") {
                            self.formatLongName = dict["FormatLongName"] as! String
                        }
                        if dict.keys.contains("FormatName") {
                            self.formatName = dict["FormatName"] as! String
                        }
                        if dict.keys.contains("NumPrograms") {
                            self.numPrograms = dict["NumPrograms"] as! String
                        }
                        if dict.keys.contains("NumStreams") {
                            self.numStreams = dict["NumStreams"] as! String
                        }
                        if dict.keys.contains("Size") {
                            self.size = dict["Size"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                    }
                }
                public class Streams : Tea.TeaModel {
                    public class AudioStreamList : Tea.TeaModel {
                        public class AudioStream : Tea.TeaModel {
                            public var bitrate: String?

                            public var channelLayout: String?

                            public var channels: String?

                            public var codecLongName: String?

                            public var codecName: String?

                            public var codecTag: String?

                            public var codecTagString: String?

                            public var codecTimeBase: String?

                            public var duration: String?

                            public var index: String?

                            public var lang: String?

                            public var numFrames: String?

                            public var sampleFmt: String?

                            public var samplerate: String?

                            public var startTime: String?

                            public var timebase: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channelLayout != nil {
                                    map["ChannelLayout"] = self.channelLayout!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codecLongName != nil {
                                    map["CodecLongName"] = self.codecLongName!
                                }
                                if self.codecName != nil {
                                    map["CodecName"] = self.codecName!
                                }
                                if self.codecTag != nil {
                                    map["CodecTag"] = self.codecTag!
                                }
                                if self.codecTagString != nil {
                                    map["CodecTagString"] = self.codecTagString!
                                }
                                if self.codecTimeBase != nil {
                                    map["CodecTimeBase"] = self.codecTimeBase!
                                }
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.index != nil {
                                    map["Index"] = self.index!
                                }
                                if self.lang != nil {
                                    map["Lang"] = self.lang!
                                }
                                if self.numFrames != nil {
                                    map["NumFrames"] = self.numFrames!
                                }
                                if self.sampleFmt != nil {
                                    map["SampleFmt"] = self.sampleFmt!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                if self.timebase != nil {
                                    map["Timebase"] = self.timebase!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("ChannelLayout") {
                                    self.channelLayout = dict["ChannelLayout"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("CodecLongName") {
                                    self.codecLongName = dict["CodecLongName"] as! String
                                }
                                if dict.keys.contains("CodecName") {
                                    self.codecName = dict["CodecName"] as! String
                                }
                                if dict.keys.contains("CodecTag") {
                                    self.codecTag = dict["CodecTag"] as! String
                                }
                                if dict.keys.contains("CodecTagString") {
                                    self.codecTagString = dict["CodecTagString"] as! String
                                }
                                if dict.keys.contains("CodecTimeBase") {
                                    self.codecTimeBase = dict["CodecTimeBase"] as! String
                                }
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Index") {
                                    self.index = dict["Index"] as! String
                                }
                                if dict.keys.contains("Lang") {
                                    self.lang = dict["Lang"] as! String
                                }
                                if dict.keys.contains("NumFrames") {
                                    self.numFrames = dict["NumFrames"] as! String
                                }
                                if dict.keys.contains("SampleFmt") {
                                    self.sampleFmt = dict["SampleFmt"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("StartTime") {
                                    self.startTime = dict["StartTime"] as! String
                                }
                                if dict.keys.contains("Timebase") {
                                    self.timebase = dict["Timebase"] as! String
                                }
                            }
                        }
                        public var audioStream: [QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList.AudioStream]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audioStream != nil {
                                var tmp : [Any] = []
                                for k in self.audioStream! {
                                    tmp.append(k.toMap())
                                }
                                map["AudioStream"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AudioStream") {
                                var tmp : [QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList.AudioStream] = []
                                for v in dict["AudioStream"] as! [Any] {
                                    var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList.AudioStream()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.audioStream = tmp
                            }
                        }
                    }
                    public class SubtitleStreamList : Tea.TeaModel {
                        public class SubtitleStream : Tea.TeaModel {
                            public var index: String?

                            public var lang: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.index != nil {
                                    map["Index"] = self.index!
                                }
                                if self.lang != nil {
                                    map["Lang"] = self.lang!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Index") {
                                    self.index = dict["Index"] as! String
                                }
                                if dict.keys.contains("Lang") {
                                    self.lang = dict["Lang"] as! String
                                }
                            }
                        }
                        public var subtitleStream: [QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList.SubtitleStream]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.subtitleStream != nil {
                                var tmp : [Any] = []
                                for k in self.subtitleStream! {
                                    tmp.append(k.toMap())
                                }
                                map["SubtitleStream"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("SubtitleStream") {
                                var tmp : [QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList.SubtitleStream] = []
                                for v in dict["SubtitleStream"] as! [Any] {
                                    var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList.SubtitleStream()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.subtitleStream = tmp
                            }
                        }
                    }
                    public class VideoStreamList : Tea.TeaModel {
                        public class VideoStream : Tea.TeaModel {
                            public class NetworkCost : Tea.TeaModel {
                                public var avgBitrate: String?

                                public var costBandwidth: String?

                                public var preloadTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.avgBitrate != nil {
                                        map["AvgBitrate"] = self.avgBitrate!
                                    }
                                    if self.costBandwidth != nil {
                                        map["CostBandwidth"] = self.costBandwidth!
                                    }
                                    if self.preloadTime != nil {
                                        map["PreloadTime"] = self.preloadTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("AvgBitrate") {
                                        self.avgBitrate = dict["AvgBitrate"] as! String
                                    }
                                    if dict.keys.contains("CostBandwidth") {
                                        self.costBandwidth = dict["CostBandwidth"] as! String
                                    }
                                    if dict.keys.contains("PreloadTime") {
                                        self.preloadTime = dict["PreloadTime"] as! String
                                    }
                                }
                            }
                            public var avgFPS: String?

                            public var bitrate: String?

                            public var codecLongName: String?

                            public var codecName: String?

                            public var codecTag: String?

                            public var codecTagString: String?

                            public var codecTimeBase: String?

                            public var dar: String?

                            public var duration: String?

                            public var fps: String?

                            public var hasBFrames: String?

                            public var height: String?

                            public var index: String?

                            public var lang: String?

                            public var level: String?

                            public var networkCost: QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream.NetworkCost?

                            public var numFrames: String?

                            public var pixFmt: String?

                            public var profile: String?

                            public var rotate: String?

                            public var sar: String?

                            public var startTime: String?

                            public var timebase: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.networkCost?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.avgFPS != nil {
                                    map["AvgFPS"] = self.avgFPS!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.codecLongName != nil {
                                    map["CodecLongName"] = self.codecLongName!
                                }
                                if self.codecName != nil {
                                    map["CodecName"] = self.codecName!
                                }
                                if self.codecTag != nil {
                                    map["CodecTag"] = self.codecTag!
                                }
                                if self.codecTagString != nil {
                                    map["CodecTagString"] = self.codecTagString!
                                }
                                if self.codecTimeBase != nil {
                                    map["CodecTimeBase"] = self.codecTimeBase!
                                }
                                if self.dar != nil {
                                    map["Dar"] = self.dar!
                                }
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.hasBFrames != nil {
                                    map["HasBFrames"] = self.hasBFrames!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.index != nil {
                                    map["Index"] = self.index!
                                }
                                if self.lang != nil {
                                    map["Lang"] = self.lang!
                                }
                                if self.level != nil {
                                    map["Level"] = self.level!
                                }
                                if self.networkCost != nil {
                                    map["NetworkCost"] = self.networkCost?.toMap()
                                }
                                if self.numFrames != nil {
                                    map["NumFrames"] = self.numFrames!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.rotate != nil {
                                    map["Rotate"] = self.rotate!
                                }
                                if self.sar != nil {
                                    map["Sar"] = self.sar!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                if self.timebase != nil {
                                    map["Timebase"] = self.timebase!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AvgFPS") {
                                    self.avgFPS = dict["AvgFPS"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("CodecLongName") {
                                    self.codecLongName = dict["CodecLongName"] as! String
                                }
                                if dict.keys.contains("CodecName") {
                                    self.codecName = dict["CodecName"] as! String
                                }
                                if dict.keys.contains("CodecTag") {
                                    self.codecTag = dict["CodecTag"] as! String
                                }
                                if dict.keys.contains("CodecTagString") {
                                    self.codecTagString = dict["CodecTagString"] as! String
                                }
                                if dict.keys.contains("CodecTimeBase") {
                                    self.codecTimeBase = dict["CodecTimeBase"] as! String
                                }
                                if dict.keys.contains("Dar") {
                                    self.dar = dict["Dar"] as! String
                                }
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("HasBFrames") {
                                    self.hasBFrames = dict["HasBFrames"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("Index") {
                                    self.index = dict["Index"] as! String
                                }
                                if dict.keys.contains("Lang") {
                                    self.lang = dict["Lang"] as! String
                                }
                                if dict.keys.contains("Level") {
                                    self.level = dict["Level"] as! String
                                }
                                if dict.keys.contains("NetworkCost") {
                                    var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream.NetworkCost()
                                    model.fromMap(dict["NetworkCost"] as! [String: Any])
                                    self.networkCost = model
                                }
                                if dict.keys.contains("NumFrames") {
                                    self.numFrames = dict["NumFrames"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Rotate") {
                                    self.rotate = dict["Rotate"] as! String
                                }
                                if dict.keys.contains("Sar") {
                                    self.sar = dict["Sar"] as! String
                                }
                                if dict.keys.contains("StartTime") {
                                    self.startTime = dict["StartTime"] as! String
                                }
                                if dict.keys.contains("Timebase") {
                                    self.timebase = dict["Timebase"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var videoStream: [QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.videoStream != nil {
                                var tmp : [Any] = []
                                for k in self.videoStream! {
                                    tmp.append(k.toMap())
                                }
                                map["VideoStream"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("VideoStream") {
                                var tmp : [QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream] = []
                                for v in dict["VideoStream"] as! [Any] {
                                    var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.videoStream = tmp
                            }
                        }
                    }
                    public var audioStreamList: QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList?

                    public var subtitleStreamList: QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList?

                    public var videoStreamList: QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.audioStreamList?.validate()
                        try self.subtitleStreamList?.validate()
                        try self.videoStreamList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioStreamList != nil {
                            map["AudioStreamList"] = self.audioStreamList?.toMap()
                        }
                        if self.subtitleStreamList != nil {
                            map["SubtitleStreamList"] = self.subtitleStreamList?.toMap()
                        }
                        if self.videoStreamList != nil {
                            map["VideoStreamList"] = self.videoStreamList?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioStreamList") {
                            var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList()
                            model.fromMap(dict["AudioStreamList"] as! [String: Any])
                            self.audioStreamList = model
                        }
                        if dict.keys.contains("SubtitleStreamList") {
                            var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList()
                            model.fromMap(dict["SubtitleStreamList"] as! [String: Any])
                            self.subtitleStreamList = model
                        }
                        if dict.keys.contains("VideoStreamList") {
                            var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList()
                            model.fromMap(dict["VideoStreamList"] as! [String: Any])
                            self.videoStreamList = model
                        }
                    }
                }
                public var format: QueryMediaListResponseBody.MediaList.Media.MediaInfo.Format?

                public var streams: QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.format?.validate()
                    try self.streams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.format != nil {
                        map["Format"] = self.format?.toMap()
                    }
                    if self.streams != nil {
                        map["Streams"] = self.streams?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Format") {
                        var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo.Format()
                        model.fromMap(dict["Format"] as! [String: Any])
                        self.format = model
                    }
                    if dict.keys.contains("Streams") {
                        var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams()
                        model.fromMap(dict["Streams"] as! [String: Any])
                        self.streams = model
                    }
                }
            }
            public class PlayList : Tea.TeaModel {
                public class Play : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var state: String?

                        public var URL: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.state != nil {
                                map["State"] = self.state!
                            }
                            if self.URL != nil {
                                map["URL"] = self.URL!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("State") {
                                self.state = dict["State"] as! String
                            }
                            if dict.keys.contains("URL") {
                                self.URL = dict["URL"] as! String
                            }
                        }
                    }
                    public var activityName: String?

                    public var bitrate: String?

                    public var duration: String?

                    public var encryption: String?

                    public var file: QueryMediaListResponseBody.MediaList.Media.PlayList.Play.File?

                    public var format: String?

                    public var fps: String?

                    public var height: String?

                    public var mediaWorkflowId: String?

                    public var mediaWorkflowName: String?

                    public var size: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.activityName != nil {
                            map["ActivityName"] = self.activityName!
                        }
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.encryption != nil {
                            map["Encryption"] = self.encryption!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.mediaWorkflowId != nil {
                            map["MediaWorkflowId"] = self.mediaWorkflowId!
                        }
                        if self.mediaWorkflowName != nil {
                            map["MediaWorkflowName"] = self.mediaWorkflowName!
                        }
                        if self.size != nil {
                            map["Size"] = self.size!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ActivityName") {
                            self.activityName = dict["ActivityName"] as! String
                        }
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Encryption") {
                            self.encryption = dict["Encryption"] as! String
                        }
                        if dict.keys.contains("File") {
                            var model = QueryMediaListResponseBody.MediaList.Media.PlayList.Play.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("MediaWorkflowId") {
                            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                        }
                        if dict.keys.contains("MediaWorkflowName") {
                            self.mediaWorkflowName = dict["MediaWorkflowName"] as! String
                        }
                        if dict.keys.contains("Size") {
                            self.size = dict["Size"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var play: [QueryMediaListResponseBody.MediaList.Media.PlayList.Play]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.play != nil {
                        var tmp : [Any] = []
                        for k in self.play! {
                            tmp.append(k.toMap())
                        }
                        map["Play"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Play") {
                        var tmp : [QueryMediaListResponseBody.MediaList.Media.PlayList.Play] = []
                        for v in dict["Play"] as! [Any] {
                            var model = QueryMediaListResponseBody.MediaList.Media.PlayList.Play()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.play = tmp
                    }
                }
            }
            public class RunIdList : Tea.TeaModel {
                public var runId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.runId != nil {
                        map["RunId"] = self.runId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RunId") {
                        self.runId = dict["RunId"] as! [String]
                    }
                }
            }
            public class SnapshotList : Tea.TeaModel {
                public class Snapshot : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var state: String?

                        public var URL: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.state != nil {
                                map["State"] = self.state!
                            }
                            if self.URL != nil {
                                map["URL"] = self.URL!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("State") {
                                self.state = dict["State"] as! String
                            }
                            if dict.keys.contains("URL") {
                                self.URL = dict["URL"] as! String
                            }
                        }
                    }
                    public var activityName: String?

                    public var count: String?

                    public var file: QueryMediaListResponseBody.MediaList.Media.SnapshotList.Snapshot.File?

                    public var mediaWorkflowId: String?

                    public var mediaWorkflowName: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.activityName != nil {
                            map["ActivityName"] = self.activityName!
                        }
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.mediaWorkflowId != nil {
                            map["MediaWorkflowId"] = self.mediaWorkflowId!
                        }
                        if self.mediaWorkflowName != nil {
                            map["MediaWorkflowName"] = self.mediaWorkflowName!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ActivityName") {
                            self.activityName = dict["ActivityName"] as! String
                        }
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! String
                        }
                        if dict.keys.contains("File") {
                            var model = QueryMediaListResponseBody.MediaList.Media.SnapshotList.Snapshot.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("MediaWorkflowId") {
                            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                        }
                        if dict.keys.contains("MediaWorkflowName") {
                            self.mediaWorkflowName = dict["MediaWorkflowName"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var snapshot: [QueryMediaListResponseBody.MediaList.Media.SnapshotList.Snapshot]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.snapshot != nil {
                        var tmp : [Any] = []
                        for k in self.snapshot! {
                            tmp.append(k.toMap())
                        }
                        map["Snapshot"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Snapshot") {
                        var tmp : [QueryMediaListResponseBody.MediaList.Media.SnapshotList.Snapshot] = []
                        for v in dict["Snapshot"] as! [Any] {
                            var model = QueryMediaListResponseBody.MediaList.Media.SnapshotList.Snapshot()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.snapshot = tmp
                    }
                }
            }
            public class SummaryList : Tea.TeaModel {
                public class Summary : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var state: String?

                        public var URL: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.state != nil {
                                map["State"] = self.state!
                            }
                            if self.URL != nil {
                                map["URL"] = self.URL!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("State") {
                                self.state = dict["State"] as! String
                            }
                            if dict.keys.contains("URL") {
                                self.URL = dict["URL"] as! String
                            }
                        }
                    }
                    public var activityName: String?

                    public var file: QueryMediaListResponseBody.MediaList.Media.SummaryList.Summary.File?

                    public var mediaWorkflowId: String?

                    public var mediaWorkflowName: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.activityName != nil {
                            map["ActivityName"] = self.activityName!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.mediaWorkflowId != nil {
                            map["MediaWorkflowId"] = self.mediaWorkflowId!
                        }
                        if self.mediaWorkflowName != nil {
                            map["MediaWorkflowName"] = self.mediaWorkflowName!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ActivityName") {
                            self.activityName = dict["ActivityName"] as! String
                        }
                        if dict.keys.contains("File") {
                            var model = QueryMediaListResponseBody.MediaList.Media.SummaryList.Summary.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("MediaWorkflowId") {
                            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                        }
                        if dict.keys.contains("MediaWorkflowName") {
                            self.mediaWorkflowName = dict["MediaWorkflowName"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var summary: [QueryMediaListResponseBody.MediaList.Media.SummaryList.Summary]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.summary != nil {
                        var tmp : [Any] = []
                        for k in self.summary! {
                            tmp.append(k.toMap())
                        }
                        map["Summary"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Summary") {
                        var tmp : [QueryMediaListResponseBody.MediaList.Media.SummaryList.Summary] = []
                        for v in dict["Summary"] as! [Any] {
                            var model = QueryMediaListResponseBody.MediaList.Media.SummaryList.Summary()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.summary = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var tag: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        map["Tag"] = self.tag!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        self.tag = dict["Tag"] as! [String]
                    }
                }
            }
            public var bitrate: String?

            public var cateId: Int64?

            public var censorState: String?

            public var coverURL: String?

            public var creationTime: String?

            public var description_: String?

            public var duration: String?

            public var file: QueryMediaListResponseBody.MediaList.Media.File?

            public var format: String?

            public var fps: String?

            public var height: String?

            public var mediaId: String?

            public var mediaInfo: QueryMediaListResponseBody.MediaList.Media.MediaInfo?

            public var playList: QueryMediaListResponseBody.MediaList.Media.PlayList?

            public var publishState: String?

            public var runIdList: QueryMediaListResponseBody.MediaList.Media.RunIdList?

            public var size: String?

            public var snapshotList: QueryMediaListResponseBody.MediaList.Media.SnapshotList?

            public var summaryList: QueryMediaListResponseBody.MediaList.Media.SummaryList?

            public var tags: QueryMediaListResponseBody.MediaList.Media.Tags?

            public var title: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.file?.validate()
                try self.mediaInfo?.validate()
                try self.playList?.validate()
                try self.runIdList?.validate()
                try self.snapshotList?.validate()
                try self.summaryList?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.censorState != nil {
                    map["CensorState"] = self.censorState!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.file != nil {
                    map["File"] = self.file?.toMap()
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaInfo != nil {
                    map["MediaInfo"] = self.mediaInfo?.toMap()
                }
                if self.playList != nil {
                    map["PlayList"] = self.playList?.toMap()
                }
                if self.publishState != nil {
                    map["PublishState"] = self.publishState!
                }
                if self.runIdList != nil {
                    map["RunIdList"] = self.runIdList?.toMap()
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshotList != nil {
                    map["SnapshotList"] = self.snapshotList?.toMap()
                }
                if self.summaryList != nil {
                    map["SummaryList"] = self.summaryList?.toMap()
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CensorState") {
                    self.censorState = dict["CensorState"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("File") {
                    var model = QueryMediaListResponseBody.MediaList.Media.File()
                    model.fromMap(dict["File"] as! [String: Any])
                    self.file = model
                }
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaInfo") {
                    var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo()
                    model.fromMap(dict["MediaInfo"] as! [String: Any])
                    self.mediaInfo = model
                }
                if dict.keys.contains("PlayList") {
                    var model = QueryMediaListResponseBody.MediaList.Media.PlayList()
                    model.fromMap(dict["PlayList"] as! [String: Any])
                    self.playList = model
                }
                if dict.keys.contains("PublishState") {
                    self.publishState = dict["PublishState"] as! String
                }
                if dict.keys.contains("RunIdList") {
                    var model = QueryMediaListResponseBody.MediaList.Media.RunIdList()
                    model.fromMap(dict["RunIdList"] as! [String: Any])
                    self.runIdList = model
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! String
                }
                if dict.keys.contains("SnapshotList") {
                    var model = QueryMediaListResponseBody.MediaList.Media.SnapshotList()
                    model.fromMap(dict["SnapshotList"] as! [String: Any])
                    self.snapshotList = model
                }
                if dict.keys.contains("SummaryList") {
                    var model = QueryMediaListResponseBody.MediaList.Media.SummaryList()
                    model.fromMap(dict["SummaryList"] as! [String: Any])
                    self.summaryList = model
                }
                if dict.keys.contains("Tags") {
                    var model = QueryMediaListResponseBody.MediaList.Media.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var media: [QueryMediaListResponseBody.MediaList.Media]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                var tmp : [Any] = []
                for k in self.media! {
                    tmp.append(k.toMap())
                }
                map["Media"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                var tmp : [QueryMediaListResponseBody.MediaList.Media] = []
                for v in dict["Media"] as! [Any] {
                    var model = QueryMediaListResponseBody.MediaList.Media()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.media = tmp
            }
        }
    }
    public class NonExistMediaIds : Tea.TeaModel {
        public var mediaId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! [String]
            }
        }
    }
    public var mediaList: QueryMediaListResponseBody.MediaList?

    public var nonExistMediaIds: QueryMediaListResponseBody.NonExistMediaIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaList?.validate()
        try self.nonExistMediaIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaList != nil {
            map["MediaList"] = self.mediaList?.toMap()
        }
        if self.nonExistMediaIds != nil {
            map["NonExistMediaIds"] = self.nonExistMediaIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaList") {
            var model = QueryMediaListResponseBody.MediaList()
            model.fromMap(dict["MediaList"] as! [String: Any])
            self.mediaList = model
        }
        if dict.keys.contains("NonExistMediaIds") {
            var model = QueryMediaListResponseBody.NonExistMediaIds()
            model.fromMap(dict["NonExistMediaIds"] as! [String: Any])
            self.nonExistMediaIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMediaListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMediaListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaListByURLRequest : Tea.TeaModel {
    public var fileURLs: String?

    public var includeMediaInfo: Bool?

    public var includePlayList: Bool?

    public var includeSnapshotList: Bool?

    public var includeSummaryList: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURLs != nil {
            map["FileURLs"] = self.fileURLs!
        }
        if self.includeMediaInfo != nil {
            map["IncludeMediaInfo"] = self.includeMediaInfo!
        }
        if self.includePlayList != nil {
            map["IncludePlayList"] = self.includePlayList!
        }
        if self.includeSnapshotList != nil {
            map["IncludeSnapshotList"] = self.includeSnapshotList!
        }
        if self.includeSummaryList != nil {
            map["IncludeSummaryList"] = self.includeSummaryList!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURLs") {
            self.fileURLs = dict["FileURLs"] as! String
        }
        if dict.keys.contains("IncludeMediaInfo") {
            self.includeMediaInfo = dict["IncludeMediaInfo"] as! Bool
        }
        if dict.keys.contains("IncludePlayList") {
            self.includePlayList = dict["IncludePlayList"] as! Bool
        }
        if dict.keys.contains("IncludeSnapshotList") {
            self.includeSnapshotList = dict["IncludeSnapshotList"] as! Bool
        }
        if dict.keys.contains("IncludeSummaryList") {
            self.includeSummaryList = dict["IncludeSummaryList"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryMediaListByURLResponseBody : Tea.TeaModel {
    public class MediaList : Tea.TeaModel {
        public class Media : Tea.TeaModel {
            public class File : Tea.TeaModel {
                public var state: String?

                public var URL: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    if self.URL != nil {
                        map["URL"] = self.URL!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! String
                    }
                    if dict.keys.contains("URL") {
                        self.URL = dict["URL"] as! String
                    }
                }
            }
            public class MediaInfo : Tea.TeaModel {
                public class Format : Tea.TeaModel {
                    public var bitrate: String?

                    public var duration: String?

                    public var formatLongName: String?

                    public var formatName: String?

                    public var numPrograms: String?

                    public var numStreams: String?

                    public var size: String?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.formatLongName != nil {
                            map["FormatLongName"] = self.formatLongName!
                        }
                        if self.formatName != nil {
                            map["FormatName"] = self.formatName!
                        }
                        if self.numPrograms != nil {
                            map["NumPrograms"] = self.numPrograms!
                        }
                        if self.numStreams != nil {
                            map["NumStreams"] = self.numStreams!
                        }
                        if self.size != nil {
                            map["Size"] = self.size!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("FormatLongName") {
                            self.formatLongName = dict["FormatLongName"] as! String
                        }
                        if dict.keys.contains("FormatName") {
                            self.formatName = dict["FormatName"] as! String
                        }
                        if dict.keys.contains("NumPrograms") {
                            self.numPrograms = dict["NumPrograms"] as! String
                        }
                        if dict.keys.contains("NumStreams") {
                            self.numStreams = dict["NumStreams"] as! String
                        }
                        if dict.keys.contains("Size") {
                            self.size = dict["Size"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                    }
                }
                public class Streams : Tea.TeaModel {
                    public class AudioStreamList : Tea.TeaModel {
                        public class AudioStream : Tea.TeaModel {
                            public var bitrate: String?

                            public var channelLayout: String?

                            public var channels: String?

                            public var codecLongName: String?

                            public var codecName: String?

                            public var codecTag: String?

                            public var codecTagString: String?

                            public var codecTimeBase: String?

                            public var duration: String?

                            public var index: String?

                            public var lang: String?

                            public var numFrames: String?

                            public var sampleFmt: String?

                            public var samplerate: String?

                            public var startTime: String?

                            public var timebase: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channelLayout != nil {
                                    map["ChannelLayout"] = self.channelLayout!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codecLongName != nil {
                                    map["CodecLongName"] = self.codecLongName!
                                }
                                if self.codecName != nil {
                                    map["CodecName"] = self.codecName!
                                }
                                if self.codecTag != nil {
                                    map["CodecTag"] = self.codecTag!
                                }
                                if self.codecTagString != nil {
                                    map["CodecTagString"] = self.codecTagString!
                                }
                                if self.codecTimeBase != nil {
                                    map["CodecTimeBase"] = self.codecTimeBase!
                                }
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.index != nil {
                                    map["Index"] = self.index!
                                }
                                if self.lang != nil {
                                    map["Lang"] = self.lang!
                                }
                                if self.numFrames != nil {
                                    map["NumFrames"] = self.numFrames!
                                }
                                if self.sampleFmt != nil {
                                    map["SampleFmt"] = self.sampleFmt!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                if self.timebase != nil {
                                    map["Timebase"] = self.timebase!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("ChannelLayout") {
                                    self.channelLayout = dict["ChannelLayout"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("CodecLongName") {
                                    self.codecLongName = dict["CodecLongName"] as! String
                                }
                                if dict.keys.contains("CodecName") {
                                    self.codecName = dict["CodecName"] as! String
                                }
                                if dict.keys.contains("CodecTag") {
                                    self.codecTag = dict["CodecTag"] as! String
                                }
                                if dict.keys.contains("CodecTagString") {
                                    self.codecTagString = dict["CodecTagString"] as! String
                                }
                                if dict.keys.contains("CodecTimeBase") {
                                    self.codecTimeBase = dict["CodecTimeBase"] as! String
                                }
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Index") {
                                    self.index = dict["Index"] as! String
                                }
                                if dict.keys.contains("Lang") {
                                    self.lang = dict["Lang"] as! String
                                }
                                if dict.keys.contains("NumFrames") {
                                    self.numFrames = dict["NumFrames"] as! String
                                }
                                if dict.keys.contains("SampleFmt") {
                                    self.sampleFmt = dict["SampleFmt"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("StartTime") {
                                    self.startTime = dict["StartTime"] as! String
                                }
                                if dict.keys.contains("Timebase") {
                                    self.timebase = dict["Timebase"] as! String
                                }
                            }
                        }
                        public var audioStream: [QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList.AudioStream]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audioStream != nil {
                                var tmp : [Any] = []
                                for k in self.audioStream! {
                                    tmp.append(k.toMap())
                                }
                                map["AudioStream"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AudioStream") {
                                var tmp : [QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList.AudioStream] = []
                                for v in dict["AudioStream"] as! [Any] {
                                    var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList.AudioStream()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.audioStream = tmp
                            }
                        }
                    }
                    public class SubtitleStreamList : Tea.TeaModel {
                        public class SubtitleStream : Tea.TeaModel {
                            public var index: String?

                            public var lang: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.index != nil {
                                    map["Index"] = self.index!
                                }
                                if self.lang != nil {
                                    map["Lang"] = self.lang!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Index") {
                                    self.index = dict["Index"] as! String
                                }
                                if dict.keys.contains("Lang") {
                                    self.lang = dict["Lang"] as! String
                                }
                            }
                        }
                        public var subtitleStream: [QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList.SubtitleStream]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.subtitleStream != nil {
                                var tmp : [Any] = []
                                for k in self.subtitleStream! {
                                    tmp.append(k.toMap())
                                }
                                map["SubtitleStream"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("SubtitleStream") {
                                var tmp : [QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList.SubtitleStream] = []
                                for v in dict["SubtitleStream"] as! [Any] {
                                    var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList.SubtitleStream()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.subtitleStream = tmp
                            }
                        }
                    }
                    public class VideoStreamList : Tea.TeaModel {
                        public class VideoStream : Tea.TeaModel {
                            public class NetworkCost : Tea.TeaModel {
                                public var avgBitrate: String?

                                public var costBandwidth: String?

                                public var preloadTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.avgBitrate != nil {
                                        map["AvgBitrate"] = self.avgBitrate!
                                    }
                                    if self.costBandwidth != nil {
                                        map["CostBandwidth"] = self.costBandwidth!
                                    }
                                    if self.preloadTime != nil {
                                        map["PreloadTime"] = self.preloadTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("AvgBitrate") {
                                        self.avgBitrate = dict["AvgBitrate"] as! String
                                    }
                                    if dict.keys.contains("CostBandwidth") {
                                        self.costBandwidth = dict["CostBandwidth"] as! String
                                    }
                                    if dict.keys.contains("PreloadTime") {
                                        self.preloadTime = dict["PreloadTime"] as! String
                                    }
                                }
                            }
                            public var avgFPS: String?

                            public var bitrate: String?

                            public var codecLongName: String?

                            public var codecName: String?

                            public var codecTag: String?

                            public var codecTagString: String?

                            public var codecTimeBase: String?

                            public var dar: String?

                            public var duration: String?

                            public var fps: String?

                            public var hasBFrames: String?

                            public var height: String?

                            public var index: String?

                            public var lang: String?

                            public var level: String?

                            public var networkCost: QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream.NetworkCost?

                            public var numFrames: String?

                            public var pixFmt: String?

                            public var profile: String?

                            public var rotate: String?

                            public var sar: String?

                            public var startTime: String?

                            public var timebase: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.networkCost?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.avgFPS != nil {
                                    map["AvgFPS"] = self.avgFPS!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.codecLongName != nil {
                                    map["CodecLongName"] = self.codecLongName!
                                }
                                if self.codecName != nil {
                                    map["CodecName"] = self.codecName!
                                }
                                if self.codecTag != nil {
                                    map["CodecTag"] = self.codecTag!
                                }
                                if self.codecTagString != nil {
                                    map["CodecTagString"] = self.codecTagString!
                                }
                                if self.codecTimeBase != nil {
                                    map["CodecTimeBase"] = self.codecTimeBase!
                                }
                                if self.dar != nil {
                                    map["Dar"] = self.dar!
                                }
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.hasBFrames != nil {
                                    map["HasBFrames"] = self.hasBFrames!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.index != nil {
                                    map["Index"] = self.index!
                                }
                                if self.lang != nil {
                                    map["Lang"] = self.lang!
                                }
                                if self.level != nil {
                                    map["Level"] = self.level!
                                }
                                if self.networkCost != nil {
                                    map["NetworkCost"] = self.networkCost?.toMap()
                                }
                                if self.numFrames != nil {
                                    map["NumFrames"] = self.numFrames!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.rotate != nil {
                                    map["Rotate"] = self.rotate!
                                }
                                if self.sar != nil {
                                    map["Sar"] = self.sar!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                if self.timebase != nil {
                                    map["Timebase"] = self.timebase!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AvgFPS") {
                                    self.avgFPS = dict["AvgFPS"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("CodecLongName") {
                                    self.codecLongName = dict["CodecLongName"] as! String
                                }
                                if dict.keys.contains("CodecName") {
                                    self.codecName = dict["CodecName"] as! String
                                }
                                if dict.keys.contains("CodecTag") {
                                    self.codecTag = dict["CodecTag"] as! String
                                }
                                if dict.keys.contains("CodecTagString") {
                                    self.codecTagString = dict["CodecTagString"] as! String
                                }
                                if dict.keys.contains("CodecTimeBase") {
                                    self.codecTimeBase = dict["CodecTimeBase"] as! String
                                }
                                if dict.keys.contains("Dar") {
                                    self.dar = dict["Dar"] as! String
                                }
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("HasBFrames") {
                                    self.hasBFrames = dict["HasBFrames"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("Index") {
                                    self.index = dict["Index"] as! String
                                }
                                if dict.keys.contains("Lang") {
                                    self.lang = dict["Lang"] as! String
                                }
                                if dict.keys.contains("Level") {
                                    self.level = dict["Level"] as! String
                                }
                                if dict.keys.contains("NetworkCost") {
                                    var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream.NetworkCost()
                                    model.fromMap(dict["NetworkCost"] as! [String: Any])
                                    self.networkCost = model
                                }
                                if dict.keys.contains("NumFrames") {
                                    self.numFrames = dict["NumFrames"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Rotate") {
                                    self.rotate = dict["Rotate"] as! String
                                }
                                if dict.keys.contains("Sar") {
                                    self.sar = dict["Sar"] as! String
                                }
                                if dict.keys.contains("StartTime") {
                                    self.startTime = dict["StartTime"] as! String
                                }
                                if dict.keys.contains("Timebase") {
                                    self.timebase = dict["Timebase"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var videoStream: [QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.videoStream != nil {
                                var tmp : [Any] = []
                                for k in self.videoStream! {
                                    tmp.append(k.toMap())
                                }
                                map["VideoStream"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("VideoStream") {
                                var tmp : [QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream] = []
                                for v in dict["VideoStream"] as! [Any] {
                                    var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.videoStream = tmp
                            }
                        }
                    }
                    public var audioStreamList: QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList?

                    public var subtitleStreamList: QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList?

                    public var videoStreamList: QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.audioStreamList?.validate()
                        try self.subtitleStreamList?.validate()
                        try self.videoStreamList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioStreamList != nil {
                            map["AudioStreamList"] = self.audioStreamList?.toMap()
                        }
                        if self.subtitleStreamList != nil {
                            map["SubtitleStreamList"] = self.subtitleStreamList?.toMap()
                        }
                        if self.videoStreamList != nil {
                            map["VideoStreamList"] = self.videoStreamList?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioStreamList") {
                            var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList()
                            model.fromMap(dict["AudioStreamList"] as! [String: Any])
                            self.audioStreamList = model
                        }
                        if dict.keys.contains("SubtitleStreamList") {
                            var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList()
                            model.fromMap(dict["SubtitleStreamList"] as! [String: Any])
                            self.subtitleStreamList = model
                        }
                        if dict.keys.contains("VideoStreamList") {
                            var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList()
                            model.fromMap(dict["VideoStreamList"] as! [String: Any])
                            self.videoStreamList = model
                        }
                    }
                }
                public var format: QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Format?

                public var streams: QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.format?.validate()
                    try self.streams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.format != nil {
                        map["Format"] = self.format?.toMap()
                    }
                    if self.streams != nil {
                        map["Streams"] = self.streams?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Format") {
                        var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Format()
                        model.fromMap(dict["Format"] as! [String: Any])
                        self.format = model
                    }
                    if dict.keys.contains("Streams") {
                        var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams()
                        model.fromMap(dict["Streams"] as! [String: Any])
                        self.streams = model
                    }
                }
            }
            public class PlayList : Tea.TeaModel {
                public class Play : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var state: String?

                        public var URL: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.state != nil {
                                map["State"] = self.state!
                            }
                            if self.URL != nil {
                                map["URL"] = self.URL!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("State") {
                                self.state = dict["State"] as! String
                            }
                            if dict.keys.contains("URL") {
                                self.URL = dict["URL"] as! String
                            }
                        }
                    }
                    public var activityName: String?

                    public var bitrate: String?

                    public var duration: String?

                    public var encryption: String?

                    public var file: QueryMediaListByURLResponseBody.MediaList.Media.PlayList.Play.File?

                    public var format: String?

                    public var fps: String?

                    public var height: String?

                    public var mediaWorkflowId: String?

                    public var mediaWorkflowName: String?

                    public var size: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.activityName != nil {
                            map["ActivityName"] = self.activityName!
                        }
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.encryption != nil {
                            map["Encryption"] = self.encryption!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.mediaWorkflowId != nil {
                            map["MediaWorkflowId"] = self.mediaWorkflowId!
                        }
                        if self.mediaWorkflowName != nil {
                            map["MediaWorkflowName"] = self.mediaWorkflowName!
                        }
                        if self.size != nil {
                            map["Size"] = self.size!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ActivityName") {
                            self.activityName = dict["ActivityName"] as! String
                        }
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Encryption") {
                            self.encryption = dict["Encryption"] as! String
                        }
                        if dict.keys.contains("File") {
                            var model = QueryMediaListByURLResponseBody.MediaList.Media.PlayList.Play.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("MediaWorkflowId") {
                            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                        }
                        if dict.keys.contains("MediaWorkflowName") {
                            self.mediaWorkflowName = dict["MediaWorkflowName"] as! String
                        }
                        if dict.keys.contains("Size") {
                            self.size = dict["Size"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var play: [QueryMediaListByURLResponseBody.MediaList.Media.PlayList.Play]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.play != nil {
                        var tmp : [Any] = []
                        for k in self.play! {
                            tmp.append(k.toMap())
                        }
                        map["Play"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Play") {
                        var tmp : [QueryMediaListByURLResponseBody.MediaList.Media.PlayList.Play] = []
                        for v in dict["Play"] as! [Any] {
                            var model = QueryMediaListByURLResponseBody.MediaList.Media.PlayList.Play()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.play = tmp
                    }
                }
            }
            public class RunIdList : Tea.TeaModel {
                public var runId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.runId != nil {
                        map["RunId"] = self.runId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RunId") {
                        self.runId = dict["RunId"] as! [String]
                    }
                }
            }
            public class SnapshotList : Tea.TeaModel {
                public class Snapshot : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var state: String?

                        public var URL: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.state != nil {
                                map["State"] = self.state!
                            }
                            if self.URL != nil {
                                map["URL"] = self.URL!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("State") {
                                self.state = dict["State"] as! String
                            }
                            if dict.keys.contains("URL") {
                                self.URL = dict["URL"] as! String
                            }
                        }
                    }
                    public var activityName: String?

                    public var count: String?

                    public var file: QueryMediaListByURLResponseBody.MediaList.Media.SnapshotList.Snapshot.File?

                    public var mediaWorkflowId: String?

                    public var mediaWorkflowName: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.activityName != nil {
                            map["ActivityName"] = self.activityName!
                        }
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.mediaWorkflowId != nil {
                            map["MediaWorkflowId"] = self.mediaWorkflowId!
                        }
                        if self.mediaWorkflowName != nil {
                            map["MediaWorkflowName"] = self.mediaWorkflowName!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ActivityName") {
                            self.activityName = dict["ActivityName"] as! String
                        }
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! String
                        }
                        if dict.keys.contains("File") {
                            var model = QueryMediaListByURLResponseBody.MediaList.Media.SnapshotList.Snapshot.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("MediaWorkflowId") {
                            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                        }
                        if dict.keys.contains("MediaWorkflowName") {
                            self.mediaWorkflowName = dict["MediaWorkflowName"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var snapshot: [QueryMediaListByURLResponseBody.MediaList.Media.SnapshotList.Snapshot]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.snapshot != nil {
                        var tmp : [Any] = []
                        for k in self.snapshot! {
                            tmp.append(k.toMap())
                        }
                        map["Snapshot"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Snapshot") {
                        var tmp : [QueryMediaListByURLResponseBody.MediaList.Media.SnapshotList.Snapshot] = []
                        for v in dict["Snapshot"] as! [Any] {
                            var model = QueryMediaListByURLResponseBody.MediaList.Media.SnapshotList.Snapshot()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.snapshot = tmp
                    }
                }
            }
            public class SummaryList : Tea.TeaModel {
                public class Summary : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var state: String?

                        public var URL: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.state != nil {
                                map["State"] = self.state!
                            }
                            if self.URL != nil {
                                map["URL"] = self.URL!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("State") {
                                self.state = dict["State"] as! String
                            }
                            if dict.keys.contains("URL") {
                                self.URL = dict["URL"] as! String
                            }
                        }
                    }
                    public var activityName: String?

                    public var file: QueryMediaListByURLResponseBody.MediaList.Media.SummaryList.Summary.File?

                    public var mediaWorkflowId: String?

                    public var mediaWorkflowName: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.activityName != nil {
                            map["ActivityName"] = self.activityName!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.mediaWorkflowId != nil {
                            map["MediaWorkflowId"] = self.mediaWorkflowId!
                        }
                        if self.mediaWorkflowName != nil {
                            map["MediaWorkflowName"] = self.mediaWorkflowName!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ActivityName") {
                            self.activityName = dict["ActivityName"] as! String
                        }
                        if dict.keys.contains("File") {
                            var model = QueryMediaListByURLResponseBody.MediaList.Media.SummaryList.Summary.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("MediaWorkflowId") {
                            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                        }
                        if dict.keys.contains("MediaWorkflowName") {
                            self.mediaWorkflowName = dict["MediaWorkflowName"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var summary: [QueryMediaListByURLResponseBody.MediaList.Media.SummaryList.Summary]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.summary != nil {
                        var tmp : [Any] = []
                        for k in self.summary! {
                            tmp.append(k.toMap())
                        }
                        map["Summary"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Summary") {
                        var tmp : [QueryMediaListByURLResponseBody.MediaList.Media.SummaryList.Summary] = []
                        for v in dict["Summary"] as! [Any] {
                            var model = QueryMediaListByURLResponseBody.MediaList.Media.SummaryList.Summary()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.summary = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var tag: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        map["Tag"] = self.tag!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        self.tag = dict["Tag"] as! [String]
                    }
                }
            }
            public var bitrate: String?

            public var cateId: Int64?

            public var censorState: String?

            public var coverURL: String?

            public var creationTime: String?

            public var description_: String?

            public var duration: String?

            public var file: QueryMediaListByURLResponseBody.MediaList.Media.File?

            public var format: String?

            public var fps: String?

            public var height: String?

            public var mediaId: String?

            public var mediaInfo: QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo?

            public var playList: QueryMediaListByURLResponseBody.MediaList.Media.PlayList?

            public var publishState: String?

            public var runIdList: QueryMediaListByURLResponseBody.MediaList.Media.RunIdList?

            public var size: String?

            public var snapshotList: QueryMediaListByURLResponseBody.MediaList.Media.SnapshotList?

            public var summaryList: QueryMediaListByURLResponseBody.MediaList.Media.SummaryList?

            public var tags: QueryMediaListByURLResponseBody.MediaList.Media.Tags?

            public var title: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.file?.validate()
                try self.mediaInfo?.validate()
                try self.playList?.validate()
                try self.runIdList?.validate()
                try self.snapshotList?.validate()
                try self.summaryList?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.censorState != nil {
                    map["CensorState"] = self.censorState!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.file != nil {
                    map["File"] = self.file?.toMap()
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaInfo != nil {
                    map["MediaInfo"] = self.mediaInfo?.toMap()
                }
                if self.playList != nil {
                    map["PlayList"] = self.playList?.toMap()
                }
                if self.publishState != nil {
                    map["PublishState"] = self.publishState!
                }
                if self.runIdList != nil {
                    map["RunIdList"] = self.runIdList?.toMap()
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshotList != nil {
                    map["SnapshotList"] = self.snapshotList?.toMap()
                }
                if self.summaryList != nil {
                    map["SummaryList"] = self.summaryList?.toMap()
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CensorState") {
                    self.censorState = dict["CensorState"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("File") {
                    var model = QueryMediaListByURLResponseBody.MediaList.Media.File()
                    model.fromMap(dict["File"] as! [String: Any])
                    self.file = model
                }
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaInfo") {
                    var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo()
                    model.fromMap(dict["MediaInfo"] as! [String: Any])
                    self.mediaInfo = model
                }
                if dict.keys.contains("PlayList") {
                    var model = QueryMediaListByURLResponseBody.MediaList.Media.PlayList()
                    model.fromMap(dict["PlayList"] as! [String: Any])
                    self.playList = model
                }
                if dict.keys.contains("PublishState") {
                    self.publishState = dict["PublishState"] as! String
                }
                if dict.keys.contains("RunIdList") {
                    var model = QueryMediaListByURLResponseBody.MediaList.Media.RunIdList()
                    model.fromMap(dict["RunIdList"] as! [String: Any])
                    self.runIdList = model
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! String
                }
                if dict.keys.contains("SnapshotList") {
                    var model = QueryMediaListByURLResponseBody.MediaList.Media.SnapshotList()
                    model.fromMap(dict["SnapshotList"] as! [String: Any])
                    self.snapshotList = model
                }
                if dict.keys.contains("SummaryList") {
                    var model = QueryMediaListByURLResponseBody.MediaList.Media.SummaryList()
                    model.fromMap(dict["SummaryList"] as! [String: Any])
                    self.summaryList = model
                }
                if dict.keys.contains("Tags") {
                    var model = QueryMediaListByURLResponseBody.MediaList.Media.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var media: [QueryMediaListByURLResponseBody.MediaList.Media]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                var tmp : [Any] = []
                for k in self.media! {
                    tmp.append(k.toMap())
                }
                map["Media"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                var tmp : [QueryMediaListByURLResponseBody.MediaList.Media] = []
                for v in dict["Media"] as! [Any] {
                    var model = QueryMediaListByURLResponseBody.MediaList.Media()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.media = tmp
            }
        }
    }
    public class NonExistFileURLs : Tea.TeaModel {
        public var fileURL: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileURL != nil {
                map["FileURL"] = self.fileURL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileURL") {
                self.fileURL = dict["FileURL"] as! [String]
            }
        }
    }
    public var mediaList: QueryMediaListByURLResponseBody.MediaList?

    public var nonExistFileURLs: QueryMediaListByURLResponseBody.NonExistFileURLs?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaList?.validate()
        try self.nonExistFileURLs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaList != nil {
            map["MediaList"] = self.mediaList?.toMap()
        }
        if self.nonExistFileURLs != nil {
            map["NonExistFileURLs"] = self.nonExistFileURLs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaList") {
            var model = QueryMediaListByURLResponseBody.MediaList()
            model.fromMap(dict["MediaList"] as! [String: Any])
            self.mediaList = model
        }
        if dict.keys.contains("NonExistFileURLs") {
            var model = QueryMediaListByURLResponseBody.NonExistFileURLs()
            model.fromMap(dict["NonExistFileURLs"] as! [String: Any])
            self.nonExistFileURLs = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMediaListByURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaListByURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMediaListByURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaWorkflowExecutionListRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var runIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.runIds != nil {
            map["RunIds"] = self.runIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RunIds") {
            self.runIds = dict["RunIds"] as! String
        }
    }
}

public class QueryMediaWorkflowExecutionListResponseBody : Tea.TeaModel {
    public class MediaWorkflowExecutionList : Tea.TeaModel {
        public class MediaWorkflowExecution : Tea.TeaModel {
            public class ActivityList : Tea.TeaModel {
                public class Activity : Tea.TeaModel {
                    public class MNSMessageResult : Tea.TeaModel {
                        public var errorCode: String?

                        public var errorMessage: String?

                        public var messageId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.errorCode != nil {
                                map["ErrorCode"] = self.errorCode!
                            }
                            if self.errorMessage != nil {
                                map["ErrorMessage"] = self.errorMessage!
                            }
                            if self.messageId != nil {
                                map["MessageId"] = self.messageId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ErrorCode") {
                                self.errorCode = dict["ErrorCode"] as! String
                            }
                            if dict.keys.contains("ErrorMessage") {
                                self.errorMessage = dict["ErrorMessage"] as! String
                            }
                            if dict.keys.contains("MessageId") {
                                self.messageId = dict["MessageId"] as! String
                            }
                        }
                    }
                    public var code: String?

                    public var endTime: String?

                    public var jobId: String?

                    public var MNSMessageResult: QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity.MNSMessageResult?

                    public var message: String?

                    public var name: String?

                    public var startTime: String?

                    public var state: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.MNSMessageResult?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.code != nil {
                            map["Code"] = self.code!
                        }
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.jobId != nil {
                            map["JobId"] = self.jobId!
                        }
                        if self.MNSMessageResult != nil {
                            map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
                        }
                        if self.message != nil {
                            map["Message"] = self.message!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.state != nil {
                            map["State"] = self.state!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Code") {
                            self.code = dict["Code"] as! String
                        }
                        if dict.keys.contains("EndTime") {
                            self.endTime = dict["EndTime"] as! String
                        }
                        if dict.keys.contains("JobId") {
                            self.jobId = dict["JobId"] as! String
                        }
                        if dict.keys.contains("MNSMessageResult") {
                            var model = QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity.MNSMessageResult()
                            model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                            self.MNSMessageResult = model
                        }
                        if dict.keys.contains("Message") {
                            self.message = dict["Message"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                        if dict.keys.contains("State") {
                            self.state = dict["State"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var activity: [QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.activity != nil {
                        var tmp : [Any] = []
                        for k in self.activity! {
                            tmp.append(k.toMap())
                        }
                        map["Activity"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Activity") {
                        var tmp : [QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity] = []
                        for v in dict["Activity"] as! [Any] {
                            var model = QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.activity = tmp
                    }
                }
            }
            public class Input : Tea.TeaModel {
                public class InputFile : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                    }
                }
                public var inputFile: QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.Input.InputFile?

                public var userData: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.inputFile?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.inputFile != nil {
                        map["InputFile"] = self.inputFile?.toMap()
                    }
                    if self.userData != nil {
                        map["UserData"] = self.userData!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InputFile") {
                        var model = QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.Input.InputFile()
                        model.fromMap(dict["InputFile"] as! [String: Any])
                        self.inputFile = model
                    }
                    if dict.keys.contains("UserData") {
                        self.userData = dict["UserData"] as! String
                    }
                }
            }
            public var activityList: QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList?

            public var creationTime: String?

            public var input: QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.Input?

            public var mediaId: String?

            public var mediaWorkflowId: String?

            public var name: String?

            public var runId: String?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.activityList?.validate()
                try self.input?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activityList != nil {
                    map["ActivityList"] = self.activityList?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaWorkflowId != nil {
                    map["MediaWorkflowId"] = self.mediaWorkflowId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.runId != nil {
                    map["RunId"] = self.runId!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActivityList") {
                    var model = QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList()
                    model.fromMap(dict["ActivityList"] as! [String: Any])
                    self.activityList = model
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Input") {
                    var model = QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaWorkflowId") {
                    self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RunId") {
                    self.runId = dict["RunId"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
            }
        }
        public var mediaWorkflowExecution: [QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaWorkflowExecution != nil {
                var tmp : [Any] = []
                for k in self.mediaWorkflowExecution! {
                    tmp.append(k.toMap())
                }
                map["MediaWorkflowExecution"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaWorkflowExecution") {
                var tmp : [QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution] = []
                for v in dict["MediaWorkflowExecution"] as! [Any] {
                    var model = QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaWorkflowExecution = tmp
            }
        }
    }
    public class NonExistRunIds : Tea.TeaModel {
        public var runId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.runId != nil {
                map["RunId"] = self.runId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RunId") {
                self.runId = dict["RunId"] as! [String]
            }
        }
    }
    public var mediaWorkflowExecutionList: QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList?

    public var nonExistRunIds: QueryMediaWorkflowExecutionListResponseBody.NonExistRunIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflowExecutionList?.validate()
        try self.nonExistRunIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowExecutionList != nil {
            map["MediaWorkflowExecutionList"] = self.mediaWorkflowExecutionList?.toMap()
        }
        if self.nonExistRunIds != nil {
            map["NonExistRunIds"] = self.nonExistRunIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowExecutionList") {
            var model = QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList()
            model.fromMap(dict["MediaWorkflowExecutionList"] as! [String: Any])
            self.mediaWorkflowExecutionList = model
        }
        if dict.keys.contains("NonExistRunIds") {
            var model = QueryMediaWorkflowExecutionListResponseBody.NonExistRunIds()
            model.fromMap(dict["NonExistRunIds"] as! [String: Any])
            self.nonExistRunIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMediaWorkflowExecutionListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaWorkflowExecutionListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMediaWorkflowExecutionListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaWorkflowListRequest : Tea.TeaModel {
    public var mediaWorkflowIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowIds != nil {
            map["MediaWorkflowIds"] = self.mediaWorkflowIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowIds") {
            self.mediaWorkflowIds = dict["MediaWorkflowIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryMediaWorkflowListResponseBody : Tea.TeaModel {
    public class MediaWorkflowList : Tea.TeaModel {
        public class MediaWorkflow : Tea.TeaModel {
            public var creationTime: String?

            public var mediaWorkflowId: String?

            public var name: String?

            public var state: String?

            public var topology: String?

            public var triggerMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.mediaWorkflowId != nil {
                    map["MediaWorkflowId"] = self.mediaWorkflowId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.topology != nil {
                    map["Topology"] = self.topology!
                }
                if self.triggerMode != nil {
                    map["TriggerMode"] = self.triggerMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("MediaWorkflowId") {
                    self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Topology") {
                    self.topology = dict["Topology"] as! String
                }
                if dict.keys.contains("TriggerMode") {
                    self.triggerMode = dict["TriggerMode"] as! String
                }
            }
        }
        public var mediaWorkflow: [QueryMediaWorkflowListResponseBody.MediaWorkflowList.MediaWorkflow]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaWorkflow != nil {
                var tmp : [Any] = []
                for k in self.mediaWorkflow! {
                    tmp.append(k.toMap())
                }
                map["MediaWorkflow"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaWorkflow") {
                var tmp : [QueryMediaWorkflowListResponseBody.MediaWorkflowList.MediaWorkflow] = []
                for v in dict["MediaWorkflow"] as! [Any] {
                    var model = QueryMediaWorkflowListResponseBody.MediaWorkflowList.MediaWorkflow()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaWorkflow = tmp
            }
        }
    }
    public class NonExistMediaWorkflowIds : Tea.TeaModel {
        public var mediaWorkflowId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaWorkflowId != nil {
                map["MediaWorkflowId"] = self.mediaWorkflowId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaWorkflowId") {
                self.mediaWorkflowId = dict["MediaWorkflowId"] as! [String]
            }
        }
    }
    public var mediaWorkflowList: QueryMediaWorkflowListResponseBody.MediaWorkflowList?

    public var nonExistMediaWorkflowIds: QueryMediaWorkflowListResponseBody.NonExistMediaWorkflowIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflowList?.validate()
        try self.nonExistMediaWorkflowIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowList != nil {
            map["MediaWorkflowList"] = self.mediaWorkflowList?.toMap()
        }
        if self.nonExistMediaWorkflowIds != nil {
            map["NonExistMediaWorkflowIds"] = self.nonExistMediaWorkflowIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowList") {
            var model = QueryMediaWorkflowListResponseBody.MediaWorkflowList()
            model.fromMap(dict["MediaWorkflowList"] as! [String: Any])
            self.mediaWorkflowList = model
        }
        if dict.keys.contains("NonExistMediaWorkflowIds") {
            var model = QueryMediaWorkflowListResponseBody.NonExistMediaWorkflowIds()
            model.fromMap(dict["NonExistMediaWorkflowIds"] as! [String: Any])
            self.nonExistMediaWorkflowIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMediaWorkflowListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaWorkflowListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMediaWorkflowListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryPipelineListRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineIds: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineIds != nil {
            map["PipelineIds"] = self.pipelineIds!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineIds") {
            self.pipelineIds = dict["PipelineIds"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryPipelineListResponseBody : Tea.TeaModel {
    public class NonExistPids : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public class PipelineList : Tea.TeaModel {
        public class Pipeline : Tea.TeaModel {
            public class NotifyConfig : Tea.TeaModel {
                public var queueName: String?

                public var topic: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.queueName != nil {
                        map["QueueName"] = self.queueName!
                    }
                    if self.topic != nil {
                        map["Topic"] = self.topic!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("QueueName") {
                        self.queueName = dict["QueueName"] as! String
                    }
                    if dict.keys.contains("Topic") {
                        self.topic = dict["Topic"] as! String
                    }
                }
            }
            public var id: String?

            public var name: String?

            public var notifyConfig: QueryPipelineListResponseBody.PipelineList.Pipeline.NotifyConfig?

            public var role: String?

            public var speed: String?

            public var speedLevel: Int64?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.notifyConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.notifyConfig != nil {
                    map["NotifyConfig"] = self.notifyConfig?.toMap()
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.speed != nil {
                    map["Speed"] = self.speed!
                }
                if self.speedLevel != nil {
                    map["SpeedLevel"] = self.speedLevel!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NotifyConfig") {
                    var model = QueryPipelineListResponseBody.PipelineList.Pipeline.NotifyConfig()
                    model.fromMap(dict["NotifyConfig"] as! [String: Any])
                    self.notifyConfig = model
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("Speed") {
                    self.speed = dict["Speed"] as! String
                }
                if dict.keys.contains("SpeedLevel") {
                    self.speedLevel = dict["SpeedLevel"] as! Int64
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
            }
        }
        public var pipeline: [QueryPipelineListResponseBody.PipelineList.Pipeline]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipeline != nil {
                var tmp : [Any] = []
                for k in self.pipeline! {
                    tmp.append(k.toMap())
                }
                map["Pipeline"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Pipeline") {
                var tmp : [QueryPipelineListResponseBody.PipelineList.Pipeline] = []
                for v in dict["Pipeline"] as! [Any] {
                    var model = QueryPipelineListResponseBody.PipelineList.Pipeline()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.pipeline = tmp
            }
        }
    }
    public var nonExistPids: QueryPipelineListResponseBody.NonExistPids?

    public var pipelineList: QueryPipelineListResponseBody.PipelineList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nonExistPids?.validate()
        try self.pipelineList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistPids != nil {
            map["NonExistPids"] = self.nonExistPids?.toMap()
        }
        if self.pipelineList != nil {
            map["PipelineList"] = self.pipelineList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistPids") {
            var model = QueryPipelineListResponseBody.NonExistPids()
            model.fromMap(dict["NonExistPids"] as! [String: Any])
            self.nonExistPids = model
        }
        if dict.keys.contains("PipelineList") {
            var model = QueryPipelineListResponseBody.PipelineList()
            model.fromMap(dict["PipelineList"] as! [String: Any])
            self.pipelineList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryPipelineListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryPipelineListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryPipelineListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySnapshotJobListRequest : Tea.TeaModel {
    public var endOfJobCreatedTimeRange: String?

    public var maximumPageSize: Int64?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotJobIds: String?

    public var startOfJobCreatedTimeRange: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfJobCreatedTimeRange != nil {
            map["EndOfJobCreatedTimeRange"] = self.endOfJobCreatedTimeRange!
        }
        if self.maximumPageSize != nil {
            map["MaximumPageSize"] = self.maximumPageSize!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotJobIds != nil {
            map["SnapshotJobIds"] = self.snapshotJobIds!
        }
        if self.startOfJobCreatedTimeRange != nil {
            map["StartOfJobCreatedTimeRange"] = self.startOfJobCreatedTimeRange!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfJobCreatedTimeRange") {
            self.endOfJobCreatedTimeRange = dict["EndOfJobCreatedTimeRange"] as! String
        }
        if dict.keys.contains("MaximumPageSize") {
            self.maximumPageSize = dict["MaximumPageSize"] as! Int64
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SnapshotJobIds") {
            self.snapshotJobIds = dict["SnapshotJobIds"] as! String
        }
        if dict.keys.contains("StartOfJobCreatedTimeRange") {
            self.startOfJobCreatedTimeRange = dict["StartOfJobCreatedTimeRange"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class QuerySnapshotJobListResponseBody : Tea.TeaModel {
    public class NonExistSnapshotJobIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public class SnapshotJobList : Tea.TeaModel {
        public class SnapshotJob : Tea.TeaModel {
            public class Input : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public var roleArn: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    if self.roleArn != nil {
                        map["RoleArn"] = self.roleArn!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                    if dict.keys.contains("RoleArn") {
                        self.roleArn = dict["RoleArn"] as! String
                    }
                }
            }
            public class MNSMessageResult : Tea.TeaModel {
                public var errorCode: String?

                public var errorMessage: String?

                public var messageId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.messageId != nil {
                        map["MessageId"] = self.messageId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("MessageId") {
                        self.messageId = dict["MessageId"] as! String
                    }
                }
            }
            public class SnapshotConfig : Tea.TeaModel {
                public class OutputFile : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public var roleArn: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        if self.roleArn != nil {
                            map["RoleArn"] = self.roleArn!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                        if dict.keys.contains("RoleArn") {
                            self.roleArn = dict["RoleArn"] as! String
                        }
                    }
                }
                public class TileOut : Tea.TeaModel {
                    public var cellHeight: String?

                    public var cellSelStep: String?

                    public var cellWidth: String?

                    public var color: String?

                    public var columns: String?

                    public var isKeepCellPic: String?

                    public var lines: String?

                    public var margin: String?

                    public var padding: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cellHeight != nil {
                            map["CellHeight"] = self.cellHeight!
                        }
                        if self.cellSelStep != nil {
                            map["CellSelStep"] = self.cellSelStep!
                        }
                        if self.cellWidth != nil {
                            map["CellWidth"] = self.cellWidth!
                        }
                        if self.color != nil {
                            map["Color"] = self.color!
                        }
                        if self.columns != nil {
                            map["Columns"] = self.columns!
                        }
                        if self.isKeepCellPic != nil {
                            map["IsKeepCellPic"] = self.isKeepCellPic!
                        }
                        if self.lines != nil {
                            map["Lines"] = self.lines!
                        }
                        if self.margin != nil {
                            map["Margin"] = self.margin!
                        }
                        if self.padding != nil {
                            map["Padding"] = self.padding!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CellHeight") {
                            self.cellHeight = dict["CellHeight"] as! String
                        }
                        if dict.keys.contains("CellSelStep") {
                            self.cellSelStep = dict["CellSelStep"] as! String
                        }
                        if dict.keys.contains("CellWidth") {
                            self.cellWidth = dict["CellWidth"] as! String
                        }
                        if dict.keys.contains("Color") {
                            self.color = dict["Color"] as! String
                        }
                        if dict.keys.contains("Columns") {
                            self.columns = dict["Columns"] as! String
                        }
                        if dict.keys.contains("IsKeepCellPic") {
                            self.isKeepCellPic = dict["IsKeepCellPic"] as! String
                        }
                        if dict.keys.contains("Lines") {
                            self.lines = dict["Lines"] as! String
                        }
                        if dict.keys.contains("Margin") {
                            self.margin = dict["Margin"] as! String
                        }
                        if dict.keys.contains("Padding") {
                            self.padding = dict["Padding"] as! String
                        }
                    }
                }
                public class TileOutputFile : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public var roleArn: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        if self.roleArn != nil {
                            map["RoleArn"] = self.roleArn!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                        if dict.keys.contains("RoleArn") {
                            self.roleArn = dict["RoleArn"] as! String
                        }
                    }
                }
                public var frameType: String?

                public var height: String?

                public var interval: String?

                public var num: String?

                public var outputFile: QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.SnapshotConfig.OutputFile?

                public var tileOut: QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.SnapshotConfig.TileOut?

                public var tileOutputFile: QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.SnapshotConfig.TileOutputFile?

                public var time: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.outputFile?.validate()
                    try self.tileOut?.validate()
                    try self.tileOutputFile?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.frameType != nil {
                        map["FrameType"] = self.frameType!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.num != nil {
                        map["Num"] = self.num!
                    }
                    if self.outputFile != nil {
                        map["OutputFile"] = self.outputFile?.toMap()
                    }
                    if self.tileOut != nil {
                        map["TileOut"] = self.tileOut?.toMap()
                    }
                    if self.tileOutputFile != nil {
                        map["TileOutputFile"] = self.tileOutputFile?.toMap()
                    }
                    if self.time != nil {
                        map["Time"] = self.time!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FrameType") {
                        self.frameType = dict["FrameType"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Interval") {
                        self.interval = dict["Interval"] as! String
                    }
                    if dict.keys.contains("Num") {
                        self.num = dict["Num"] as! String
                    }
                    if dict.keys.contains("OutputFile") {
                        var model = QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.SnapshotConfig.OutputFile()
                        model.fromMap(dict["OutputFile"] as! [String: Any])
                        self.outputFile = model
                    }
                    if dict.keys.contains("TileOut") {
                        var model = QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.SnapshotConfig.TileOut()
                        model.fromMap(dict["TileOut"] as! [String: Any])
                        self.tileOut = model
                    }
                    if dict.keys.contains("TileOutputFile") {
                        var model = QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.SnapshotConfig.TileOutputFile()
                        model.fromMap(dict["TileOutputFile"] as! [String: Any])
                        self.tileOutputFile = model
                    }
                    if dict.keys.contains("Time") {
                        self.time = dict["Time"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var code: String?

            public var count: String?

            public var creationTime: String?

            public var id: String?

            public var input: QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.Input?

            public var MNSMessageResult: QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.MNSMessageResult?

            public var message: String?

            public var pipelineId: String?

            public var snapshotConfig: QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.SnapshotConfig?

            public var state: String?

            public var tileCount: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.input?.validate()
                try self.MNSMessageResult?.validate()
                try self.snapshotConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                if self.MNSMessageResult != nil {
                    map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.snapshotConfig != nil {
                    map["SnapshotConfig"] = self.snapshotConfig?.toMap()
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.tileCount != nil {
                    map["TileCount"] = self.tileCount!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Input") {
                    var model = QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
                if dict.keys.contains("MNSMessageResult") {
                    var model = QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.MNSMessageResult()
                    model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                    self.MNSMessageResult = model
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("SnapshotConfig") {
                    var model = QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.SnapshotConfig()
                    model.fromMap(dict["SnapshotConfig"] as! [String: Any])
                    self.snapshotConfig = model
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("TileCount") {
                    self.tileCount = dict["TileCount"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var snapshotJob: [QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snapshotJob != nil {
                var tmp : [Any] = []
                for k in self.snapshotJob! {
                    tmp.append(k.toMap())
                }
                map["SnapshotJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SnapshotJob") {
                var tmp : [QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob] = []
                for v in dict["SnapshotJob"] as! [Any] {
                    var model = QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.snapshotJob = tmp
            }
        }
    }
    public var nextPageToken: String?

    public var nonExistSnapshotJobIds: QuerySnapshotJobListResponseBody.NonExistSnapshotJobIds?

    public var requestId: String?

    public var snapshotJobList: QuerySnapshotJobListResponseBody.SnapshotJobList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nonExistSnapshotJobIds?.validate()
        try self.snapshotJobList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.nonExistSnapshotJobIds != nil {
            map["NonExistSnapshotJobIds"] = self.nonExistSnapshotJobIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotJobList != nil {
            map["SnapshotJobList"] = self.snapshotJobList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("NonExistSnapshotJobIds") {
            var model = QuerySnapshotJobListResponseBody.NonExistSnapshotJobIds()
            model.fromMap(dict["NonExistSnapshotJobIds"] as! [String: Any])
            self.nonExistSnapshotJobIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotJobList") {
            var model = QuerySnapshotJobListResponseBody.SnapshotJobList()
            model.fromMap(dict["SnapshotJobList"] as! [String: Any])
            self.snapshotJobList = model
        }
    }
}

public class QuerySnapshotJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySnapshotJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QuerySnapshotJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTemplateListRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateIds != nil {
            map["TemplateIds"] = self.templateIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateIds") {
            self.templateIds = dict["TemplateIds"] as! String
        }
    }
}

public class QueryTemplateListResponseBody : Tea.TeaModel {
    public class NonExistTids : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public class TemplateList : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public class Audio : Tea.TeaModel {
                public var bitrate: String?

                public var channels: String?

                public var codec: String?

                public var profile: String?

                public var qscale: String?

                public var remove: String?

                public var samplerate: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.qscale != nil {
                        map["Qscale"] = self.qscale!
                    }
                    if self.remove != nil {
                        map["Remove"] = self.remove!
                    }
                    if self.samplerate != nil {
                        map["Samplerate"] = self.samplerate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Qscale") {
                        self.qscale = dict["Qscale"] as! String
                    }
                    if dict.keys.contains("Remove") {
                        self.remove = dict["Remove"] as! String
                    }
                    if dict.keys.contains("Samplerate") {
                        self.samplerate = dict["Samplerate"] as! String
                    }
                }
            }
            public class Container : Tea.TeaModel {
                public var format: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.format != nil {
                        map["Format"] = self.format!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Format") {
                        self.format = dict["Format"] as! String
                    }
                }
            }
            public class MuxConfig : Tea.TeaModel {
                public class Gif : Tea.TeaModel {
                    public var ditherMode: String?

                    public var finalDelay: String?

                    public var isCustomPalette: String?

                    public var loop: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ditherMode != nil {
                            map["DitherMode"] = self.ditherMode!
                        }
                        if self.finalDelay != nil {
                            map["FinalDelay"] = self.finalDelay!
                        }
                        if self.isCustomPalette != nil {
                            map["IsCustomPalette"] = self.isCustomPalette!
                        }
                        if self.loop != nil {
                            map["Loop"] = self.loop!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DitherMode") {
                            self.ditherMode = dict["DitherMode"] as! String
                        }
                        if dict.keys.contains("FinalDelay") {
                            self.finalDelay = dict["FinalDelay"] as! String
                        }
                        if dict.keys.contains("IsCustomPalette") {
                            self.isCustomPalette = dict["IsCustomPalette"] as! String
                        }
                        if dict.keys.contains("Loop") {
                            self.loop = dict["Loop"] as! String
                        }
                    }
                }
                public class Segment : Tea.TeaModel {
                    public var duration: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                    }
                }
                public class Webp : Tea.TeaModel {
                    public var loop: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.loop != nil {
                            map["Loop"] = self.loop!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Loop") {
                            self.loop = dict["Loop"] as! String
                        }
                    }
                }
                public var gif: QueryTemplateListResponseBody.TemplateList.Template.MuxConfig.Gif?

                public var segment: QueryTemplateListResponseBody.TemplateList.Template.MuxConfig.Segment?

                public var webp: QueryTemplateListResponseBody.TemplateList.Template.MuxConfig.Webp?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.gif?.validate()
                    try self.segment?.validate()
                    try self.webp?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gif != nil {
                        map["Gif"] = self.gif?.toMap()
                    }
                    if self.segment != nil {
                        map["Segment"] = self.segment?.toMap()
                    }
                    if self.webp != nil {
                        map["Webp"] = self.webp?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Gif") {
                        var model = QueryTemplateListResponseBody.TemplateList.Template.MuxConfig.Gif()
                        model.fromMap(dict["Gif"] as! [String: Any])
                        self.gif = model
                    }
                    if dict.keys.contains("Segment") {
                        var model = QueryTemplateListResponseBody.TemplateList.Template.MuxConfig.Segment()
                        model.fromMap(dict["Segment"] as! [String: Any])
                        self.segment = model
                    }
                    if dict.keys.contains("Webp") {
                        var model = QueryTemplateListResponseBody.TemplateList.Template.MuxConfig.Webp()
                        model.fromMap(dict["Webp"] as! [String: Any])
                        self.webp = model
                    }
                }
            }
            public class TransConfig : Tea.TeaModel {
                public var adjDarMethod: String?

                public var isCheckAudioBitrate: String?

                public var isCheckAudioBitrateFail: String?

                public var isCheckReso: String?

                public var isCheckResoFail: String?

                public var isCheckVideoBitrate: String?

                public var isCheckVideoBitrateFail: String?

                public var transMode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adjDarMethod != nil {
                        map["AdjDarMethod"] = self.adjDarMethod!
                    }
                    if self.isCheckAudioBitrate != nil {
                        map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                    }
                    if self.isCheckAudioBitrateFail != nil {
                        map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                    }
                    if self.isCheckReso != nil {
                        map["IsCheckReso"] = self.isCheckReso!
                    }
                    if self.isCheckResoFail != nil {
                        map["IsCheckResoFail"] = self.isCheckResoFail!
                    }
                    if self.isCheckVideoBitrate != nil {
                        map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                    }
                    if self.isCheckVideoBitrateFail != nil {
                        map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                    }
                    if self.transMode != nil {
                        map["TransMode"] = self.transMode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdjDarMethod") {
                        self.adjDarMethod = dict["AdjDarMethod"] as! String
                    }
                    if dict.keys.contains("IsCheckAudioBitrate") {
                        self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                    }
                    if dict.keys.contains("IsCheckAudioBitrateFail") {
                        self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                    }
                    if dict.keys.contains("IsCheckReso") {
                        self.isCheckReso = dict["IsCheckReso"] as! String
                    }
                    if dict.keys.contains("IsCheckResoFail") {
                        self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                    }
                    if dict.keys.contains("IsCheckVideoBitrate") {
                        self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                    }
                    if dict.keys.contains("IsCheckVideoBitrateFail") {
                        self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                    }
                    if dict.keys.contains("TransMode") {
                        self.transMode = dict["TransMode"] as! String
                    }
                }
            }
            public class Video : Tea.TeaModel {
                public class BitrateBnd : Tea.TeaModel {
                    public var max: String?

                    public var min: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.max != nil {
                            map["Max"] = self.max!
                        }
                        if self.min != nil {
                            map["Min"] = self.min!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Max") {
                            self.max = dict["Max"] as! String
                        }
                        if dict.keys.contains("Min") {
                            self.min = dict["Min"] as! String
                        }
                    }
                }
                public var bitrate: String?

                public var bitrateBnd: QueryTemplateListResponseBody.TemplateList.Template.Video.BitrateBnd?

                public var bufsize: String?

                public var codec: String?

                public var crf: String?

                public var crop: String?

                public var degrain: String?

                public var fps: String?

                public var gop: String?

                public var height: String?

                public var maxFps: String?

                public var maxrate: String?

                public var pad: String?

                public var pixFmt: String?

                public var preset: String?

                public var profile: String?

                public var qscale: String?

                public var remove: String?

                public var resoPriority: String?

                public var scanMode: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.bitrateBnd?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.bitrateBnd != nil {
                        map["BitrateBnd"] = self.bitrateBnd?.toMap()
                    }
                    if self.bufsize != nil {
                        map["Bufsize"] = self.bufsize!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.crf != nil {
                        map["Crf"] = self.crf!
                    }
                    if self.crop != nil {
                        map["Crop"] = self.crop!
                    }
                    if self.degrain != nil {
                        map["Degrain"] = self.degrain!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.gop != nil {
                        map["Gop"] = self.gop!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.maxFps != nil {
                        map["MaxFps"] = self.maxFps!
                    }
                    if self.maxrate != nil {
                        map["Maxrate"] = self.maxrate!
                    }
                    if self.pad != nil {
                        map["Pad"] = self.pad!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.preset != nil {
                        map["Preset"] = self.preset!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.qscale != nil {
                        map["Qscale"] = self.qscale!
                    }
                    if self.remove != nil {
                        map["Remove"] = self.remove!
                    }
                    if self.resoPriority != nil {
                        map["ResoPriority"] = self.resoPriority!
                    }
                    if self.scanMode != nil {
                        map["ScanMode"] = self.scanMode!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("BitrateBnd") {
                        var model = QueryTemplateListResponseBody.TemplateList.Template.Video.BitrateBnd()
                        model.fromMap(dict["BitrateBnd"] as! [String: Any])
                        self.bitrateBnd = model
                    }
                    if dict.keys.contains("Bufsize") {
                        self.bufsize = dict["Bufsize"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Crf") {
                        self.crf = dict["Crf"] as! String
                    }
                    if dict.keys.contains("Crop") {
                        self.crop = dict["Crop"] as! String
                    }
                    if dict.keys.contains("Degrain") {
                        self.degrain = dict["Degrain"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Gop") {
                        self.gop = dict["Gop"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("MaxFps") {
                        self.maxFps = dict["MaxFps"] as! String
                    }
                    if dict.keys.contains("Maxrate") {
                        self.maxrate = dict["Maxrate"] as! String
                    }
                    if dict.keys.contains("Pad") {
                        self.pad = dict["Pad"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Preset") {
                        self.preset = dict["Preset"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Qscale") {
                        self.qscale = dict["Qscale"] as! String
                    }
                    if dict.keys.contains("Remove") {
                        self.remove = dict["Remove"] as! String
                    }
                    if dict.keys.contains("ResoPriority") {
                        self.resoPriority = dict["ResoPriority"] as! String
                    }
                    if dict.keys.contains("ScanMode") {
                        self.scanMode = dict["ScanMode"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audio: QueryTemplateListResponseBody.TemplateList.Template.Audio?

            public var container: QueryTemplateListResponseBody.TemplateList.Template.Container?

            public var id: String?

            public var muxConfig: QueryTemplateListResponseBody.TemplateList.Template.MuxConfig?

            public var name: String?

            public var state: String?

            public var transConfig: QueryTemplateListResponseBody.TemplateList.Template.TransConfig?

            public var video: QueryTemplateListResponseBody.TemplateList.Template.Video?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audio?.validate()
                try self.container?.validate()
                try self.muxConfig?.validate()
                try self.transConfig?.validate()
                try self.video?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audio != nil {
                    map["Audio"] = self.audio?.toMap()
                }
                if self.container != nil {
                    map["Container"] = self.container?.toMap()
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.muxConfig != nil {
                    map["MuxConfig"] = self.muxConfig?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.transConfig != nil {
                    map["TransConfig"] = self.transConfig?.toMap()
                }
                if self.video != nil {
                    map["Video"] = self.video?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Audio") {
                    var model = QueryTemplateListResponseBody.TemplateList.Template.Audio()
                    model.fromMap(dict["Audio"] as! [String: Any])
                    self.audio = model
                }
                if dict.keys.contains("Container") {
                    var model = QueryTemplateListResponseBody.TemplateList.Template.Container()
                    model.fromMap(dict["Container"] as! [String: Any])
                    self.container = model
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("MuxConfig") {
                    var model = QueryTemplateListResponseBody.TemplateList.Template.MuxConfig()
                    model.fromMap(dict["MuxConfig"] as! [String: Any])
                    self.muxConfig = model
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("TransConfig") {
                    var model = QueryTemplateListResponseBody.TemplateList.Template.TransConfig()
                    model.fromMap(dict["TransConfig"] as! [String: Any])
                    self.transConfig = model
                }
                if dict.keys.contains("Video") {
                    var model = QueryTemplateListResponseBody.TemplateList.Template.Video()
                    model.fromMap(dict["Video"] as! [String: Any])
                    self.video = model
                }
            }
        }
        public var template: [QueryTemplateListResponseBody.TemplateList.Template]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.template != nil {
                var tmp : [Any] = []
                for k in self.template! {
                    tmp.append(k.toMap())
                }
                map["Template"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Template") {
                var tmp : [QueryTemplateListResponseBody.TemplateList.Template] = []
                for v in dict["Template"] as! [Any] {
                    var model = QueryTemplateListResponseBody.TemplateList.Template()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.template = tmp
            }
        }
    }
    public var nonExistTids: QueryTemplateListResponseBody.NonExistTids?

    public var requestId: String?

    public var templateList: QueryTemplateListResponseBody.TemplateList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nonExistTids?.validate()
        try self.templateList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistTids != nil {
            map["NonExistTids"] = self.nonExistTids?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateList != nil {
            map["TemplateList"] = self.templateList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistTids") {
            var model = QueryTemplateListResponseBody.NonExistTids()
            model.fromMap(dict["NonExistTids"] as! [String: Any])
            self.nonExistTids = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateList") {
            var model = QueryTemplateListResponseBody.TemplateList()
            model.fromMap(dict["TemplateList"] as! [String: Any])
            self.templateList = model
        }
    }
}

public class QueryTemplateListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTemplateListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryTemplateListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryWaterMarkTemplateListRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var waterMarkTemplateIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.waterMarkTemplateIds != nil {
            map["WaterMarkTemplateIds"] = self.waterMarkTemplateIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("WaterMarkTemplateIds") {
            self.waterMarkTemplateIds = dict["WaterMarkTemplateIds"] as! String
        }
    }
}

public class QueryWaterMarkTemplateListResponseBody : Tea.TeaModel {
    public class NonExistWids : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public class WaterMarkTemplateList : Tea.TeaModel {
        public class WaterMarkTemplate : Tea.TeaModel {
            public class RatioRefer : Tea.TeaModel {
                public var dx: String?

                public var dy: String?

                public var height: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dx != nil {
                        map["Dx"] = self.dx!
                    }
                    if self.dy != nil {
                        map["Dy"] = self.dy!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Dx") {
                        self.dx = dict["Dx"] as! String
                    }
                    if dict.keys.contains("Dy") {
                        self.dy = dict["Dy"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class Timeline : Tea.TeaModel {
                public var duration: String?

                public var start: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.start != nil {
                        map["Start"] = self.start!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Start") {
                        self.start = dict["Start"] as! String
                    }
                }
            }
            public var dx: String?

            public var dy: String?

            public var height: String?

            public var id: String?

            public var name: String?

            public var ratioRefer: QueryWaterMarkTemplateListResponseBody.WaterMarkTemplateList.WaterMarkTemplate.RatioRefer?

            public var referPos: String?

            public var state: String?

            public var timeline: QueryWaterMarkTemplateListResponseBody.WaterMarkTemplateList.WaterMarkTemplate.Timeline?

            public var type: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ratioRefer?.validate()
                try self.timeline?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dx != nil {
                    map["Dx"] = self.dx!
                }
                if self.dy != nil {
                    map["Dy"] = self.dy!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ratioRefer != nil {
                    map["RatioRefer"] = self.ratioRefer?.toMap()
                }
                if self.referPos != nil {
                    map["ReferPos"] = self.referPos!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.timeline != nil {
                    map["Timeline"] = self.timeline?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Dx") {
                    self.dx = dict["Dx"] as! String
                }
                if dict.keys.contains("Dy") {
                    self.dy = dict["Dy"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RatioRefer") {
                    var model = QueryWaterMarkTemplateListResponseBody.WaterMarkTemplateList.WaterMarkTemplate.RatioRefer()
                    model.fromMap(dict["RatioRefer"] as! [String: Any])
                    self.ratioRefer = model
                }
                if dict.keys.contains("ReferPos") {
                    self.referPos = dict["ReferPos"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Timeline") {
                    var model = QueryWaterMarkTemplateListResponseBody.WaterMarkTemplateList.WaterMarkTemplate.Timeline()
                    model.fromMap(dict["Timeline"] as! [String: Any])
                    self.timeline = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var waterMarkTemplate: [QueryWaterMarkTemplateListResponseBody.WaterMarkTemplateList.WaterMarkTemplate]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.waterMarkTemplate != nil {
                var tmp : [Any] = []
                for k in self.waterMarkTemplate! {
                    tmp.append(k.toMap())
                }
                map["WaterMarkTemplate"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WaterMarkTemplate") {
                var tmp : [QueryWaterMarkTemplateListResponseBody.WaterMarkTemplateList.WaterMarkTemplate] = []
                for v in dict["WaterMarkTemplate"] as! [Any] {
                    var model = QueryWaterMarkTemplateListResponseBody.WaterMarkTemplateList.WaterMarkTemplate()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.waterMarkTemplate = tmp
            }
        }
    }
    public var nonExistWids: QueryWaterMarkTemplateListResponseBody.NonExistWids?

    public var requestId: String?

    public var waterMarkTemplateList: QueryWaterMarkTemplateListResponseBody.WaterMarkTemplateList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nonExistWids?.validate()
        try self.waterMarkTemplateList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistWids != nil {
            map["NonExistWids"] = self.nonExistWids?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.waterMarkTemplateList != nil {
            map["WaterMarkTemplateList"] = self.waterMarkTemplateList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistWids") {
            var model = QueryWaterMarkTemplateListResponseBody.NonExistWids()
            model.fromMap(dict["NonExistWids"] as! [String: Any])
            self.nonExistWids = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WaterMarkTemplateList") {
            var model = QueryWaterMarkTemplateListResponseBody.WaterMarkTemplateList()
            model.fromMap(dict["WaterMarkTemplateList"] as! [String: Any])
            self.waterMarkTemplateList = model
        }
    }
}

public class QueryWaterMarkTemplateListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryWaterMarkTemplateListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryWaterMarkTemplateListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaWorkflowRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var stateList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.stateList != nil {
            map["StateList"] = self.stateList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StateList") {
            self.stateList = dict["StateList"] as! String
        }
    }
}

public class SearchMediaWorkflowResponseBody : Tea.TeaModel {
    public class MediaWorkflowList : Tea.TeaModel {
        public class MediaWorkflow : Tea.TeaModel {
            public var creationTime: String?

            public var mediaWorkflowId: String?

            public var name: String?

            public var state: String?

            public var topology: String?

            public var triggerMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.mediaWorkflowId != nil {
                    map["MediaWorkflowId"] = self.mediaWorkflowId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.topology != nil {
                    map["Topology"] = self.topology!
                }
                if self.triggerMode != nil {
                    map["TriggerMode"] = self.triggerMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("MediaWorkflowId") {
                    self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Topology") {
                    self.topology = dict["Topology"] as! String
                }
                if dict.keys.contains("TriggerMode") {
                    self.triggerMode = dict["TriggerMode"] as! String
                }
            }
        }
        public var mediaWorkflow: [SearchMediaWorkflowResponseBody.MediaWorkflowList.MediaWorkflow]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaWorkflow != nil {
                var tmp : [Any] = []
                for k in self.mediaWorkflow! {
                    tmp.append(k.toMap())
                }
                map["MediaWorkflow"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaWorkflow") {
                var tmp : [SearchMediaWorkflowResponseBody.MediaWorkflowList.MediaWorkflow] = []
                for v in dict["MediaWorkflow"] as! [Any] {
                    var model = SearchMediaWorkflowResponseBody.MediaWorkflowList.MediaWorkflow()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaWorkflow = tmp
            }
        }
    }
    public var mediaWorkflowList: SearchMediaWorkflowResponseBody.MediaWorkflowList?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflowList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowList != nil {
            map["MediaWorkflowList"] = self.mediaWorkflowList?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowList") {
            var model = SearchMediaWorkflowResponseBody.MediaWorkflowList()
            model.fromMap(dict["MediaWorkflowList"] as! [String: Any])
            self.mediaWorkflowList = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class SearchMediaWorkflowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaWorkflowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchMediaWorkflowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchPipelineRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class SearchPipelineResponseBody : Tea.TeaModel {
    public class PipelineList : Tea.TeaModel {
        public class Pipeline : Tea.TeaModel {
            public class NotifyConfig : Tea.TeaModel {
                public var queueName: String?

                public var topic: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.queueName != nil {
                        map["QueueName"] = self.queueName!
                    }
                    if self.topic != nil {
                        map["Topic"] = self.topic!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("QueueName") {
                        self.queueName = dict["QueueName"] as! String
                    }
                    if dict.keys.contains("Topic") {
                        self.topic = dict["Topic"] as! String
                    }
                }
            }
            public var id: String?

            public var name: String?

            public var notifyConfig: SearchPipelineResponseBody.PipelineList.Pipeline.NotifyConfig?

            public var role: String?

            public var speed: String?

            public var speedLevel: Int64?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.notifyConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.notifyConfig != nil {
                    map["NotifyConfig"] = self.notifyConfig?.toMap()
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.speed != nil {
                    map["Speed"] = self.speed!
                }
                if self.speedLevel != nil {
                    map["SpeedLevel"] = self.speedLevel!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NotifyConfig") {
                    var model = SearchPipelineResponseBody.PipelineList.Pipeline.NotifyConfig()
                    model.fromMap(dict["NotifyConfig"] as! [String: Any])
                    self.notifyConfig = model
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("Speed") {
                    self.speed = dict["Speed"] as! String
                }
                if dict.keys.contains("SpeedLevel") {
                    self.speedLevel = dict["SpeedLevel"] as! Int64
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
            }
        }
        public var pipeline: [SearchPipelineResponseBody.PipelineList.Pipeline]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipeline != nil {
                var tmp : [Any] = []
                for k in self.pipeline! {
                    tmp.append(k.toMap())
                }
                map["Pipeline"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Pipeline") {
                var tmp : [SearchPipelineResponseBody.PipelineList.Pipeline] = []
                for v in dict["Pipeline"] as! [Any] {
                    var model = SearchPipelineResponseBody.PipelineList.Pipeline()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.pipeline = tmp
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var pipelineList: SearchPipelineResponseBody.PipelineList?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipelineList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pipelineList != nil {
            map["PipelineList"] = self.pipelineList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PipelineList") {
            var model = SearchPipelineResponseBody.PipelineList()
            model.fromMap(dict["PipelineList"] as! [String: Any])
            self.pipelineList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class SearchPipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchPipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchPipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchTemplateRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class SearchTemplateResponseBody : Tea.TeaModel {
    public class TemplateList : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public class Audio : Tea.TeaModel {
                public var bitrate: String?

                public var channels: String?

                public var codec: String?

                public var profile: String?

                public var qscale: String?

                public var remove: String?

                public var samplerate: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.qscale != nil {
                        map["Qscale"] = self.qscale!
                    }
                    if self.remove != nil {
                        map["Remove"] = self.remove!
                    }
                    if self.samplerate != nil {
                        map["Samplerate"] = self.samplerate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Qscale") {
                        self.qscale = dict["Qscale"] as! String
                    }
                    if dict.keys.contains("Remove") {
                        self.remove = dict["Remove"] as! String
                    }
                    if dict.keys.contains("Samplerate") {
                        self.samplerate = dict["Samplerate"] as! String
                    }
                }
            }
            public class Container : Tea.TeaModel {
                public var format: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.format != nil {
                        map["Format"] = self.format!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Format") {
                        self.format = dict["Format"] as! String
                    }
                }
            }
            public class MuxConfig : Tea.TeaModel {
                public class Gif : Tea.TeaModel {
                    public var ditherMode: String?

                    public var finalDelay: String?

                    public var isCustomPalette: String?

                    public var loop: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ditherMode != nil {
                            map["DitherMode"] = self.ditherMode!
                        }
                        if self.finalDelay != nil {
                            map["FinalDelay"] = self.finalDelay!
                        }
                        if self.isCustomPalette != nil {
                            map["IsCustomPalette"] = self.isCustomPalette!
                        }
                        if self.loop != nil {
                            map["Loop"] = self.loop!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DitherMode") {
                            self.ditherMode = dict["DitherMode"] as! String
                        }
                        if dict.keys.contains("FinalDelay") {
                            self.finalDelay = dict["FinalDelay"] as! String
                        }
                        if dict.keys.contains("IsCustomPalette") {
                            self.isCustomPalette = dict["IsCustomPalette"] as! String
                        }
                        if dict.keys.contains("Loop") {
                            self.loop = dict["Loop"] as! String
                        }
                    }
                }
                public class Segment : Tea.TeaModel {
                    public var duration: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                    }
                }
                public var gif: SearchTemplateResponseBody.TemplateList.Template.MuxConfig.Gif?

                public var segment: SearchTemplateResponseBody.TemplateList.Template.MuxConfig.Segment?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.gif?.validate()
                    try self.segment?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gif != nil {
                        map["Gif"] = self.gif?.toMap()
                    }
                    if self.segment != nil {
                        map["Segment"] = self.segment?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Gif") {
                        var model = SearchTemplateResponseBody.TemplateList.Template.MuxConfig.Gif()
                        model.fromMap(dict["Gif"] as! [String: Any])
                        self.gif = model
                    }
                    if dict.keys.contains("Segment") {
                        var model = SearchTemplateResponseBody.TemplateList.Template.MuxConfig.Segment()
                        model.fromMap(dict["Segment"] as! [String: Any])
                        self.segment = model
                    }
                }
            }
            public class TransConfig : Tea.TeaModel {
                public var adjDarMethod: String?

                public var isCheckAudioBitrate: String?

                public var isCheckAudioBitrateFail: String?

                public var isCheckReso: String?

                public var isCheckResoFail: String?

                public var isCheckVideoBitrate: String?

                public var isCheckVideoBitrateFail: String?

                public var transMode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adjDarMethod != nil {
                        map["AdjDarMethod"] = self.adjDarMethod!
                    }
                    if self.isCheckAudioBitrate != nil {
                        map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                    }
                    if self.isCheckAudioBitrateFail != nil {
                        map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                    }
                    if self.isCheckReso != nil {
                        map["IsCheckReso"] = self.isCheckReso!
                    }
                    if self.isCheckResoFail != nil {
                        map["IsCheckResoFail"] = self.isCheckResoFail!
                    }
                    if self.isCheckVideoBitrate != nil {
                        map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                    }
                    if self.isCheckVideoBitrateFail != nil {
                        map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                    }
                    if self.transMode != nil {
                        map["TransMode"] = self.transMode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdjDarMethod") {
                        self.adjDarMethod = dict["AdjDarMethod"] as! String
                    }
                    if dict.keys.contains("IsCheckAudioBitrate") {
                        self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                    }
                    if dict.keys.contains("IsCheckAudioBitrateFail") {
                        self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                    }
                    if dict.keys.contains("IsCheckReso") {
                        self.isCheckReso = dict["IsCheckReso"] as! String
                    }
                    if dict.keys.contains("IsCheckResoFail") {
                        self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                    }
                    if dict.keys.contains("IsCheckVideoBitrate") {
                        self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                    }
                    if dict.keys.contains("IsCheckVideoBitrateFail") {
                        self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                    }
                    if dict.keys.contains("TransMode") {
                        self.transMode = dict["TransMode"] as! String
                    }
                }
            }
            public class Video : Tea.TeaModel {
                public class BitrateBnd : Tea.TeaModel {
                    public var max: String?

                    public var min: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.max != nil {
                            map["Max"] = self.max!
                        }
                        if self.min != nil {
                            map["Min"] = self.min!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Max") {
                            self.max = dict["Max"] as! String
                        }
                        if dict.keys.contains("Min") {
                            self.min = dict["Min"] as! String
                        }
                    }
                }
                public var bitrate: String?

                public var bitrateBnd: SearchTemplateResponseBody.TemplateList.Template.Video.BitrateBnd?

                public var bufsize: String?

                public var codec: String?

                public var crf: String?

                public var crop: String?

                public var degrain: String?

                public var fps: String?

                public var gop: String?

                public var height: String?

                public var maxFps: String?

                public var maxrate: String?

                public var pad: String?

                public var pixFmt: String?

                public var preset: String?

                public var profile: String?

                public var qscale: String?

                public var remove: String?

                public var scanMode: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.bitrateBnd?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.bitrateBnd != nil {
                        map["BitrateBnd"] = self.bitrateBnd?.toMap()
                    }
                    if self.bufsize != nil {
                        map["Bufsize"] = self.bufsize!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.crf != nil {
                        map["Crf"] = self.crf!
                    }
                    if self.crop != nil {
                        map["Crop"] = self.crop!
                    }
                    if self.degrain != nil {
                        map["Degrain"] = self.degrain!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.gop != nil {
                        map["Gop"] = self.gop!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.maxFps != nil {
                        map["MaxFps"] = self.maxFps!
                    }
                    if self.maxrate != nil {
                        map["Maxrate"] = self.maxrate!
                    }
                    if self.pad != nil {
                        map["Pad"] = self.pad!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.preset != nil {
                        map["Preset"] = self.preset!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.qscale != nil {
                        map["Qscale"] = self.qscale!
                    }
                    if self.remove != nil {
                        map["Remove"] = self.remove!
                    }
                    if self.scanMode != nil {
                        map["ScanMode"] = self.scanMode!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("BitrateBnd") {
                        var model = SearchTemplateResponseBody.TemplateList.Template.Video.BitrateBnd()
                        model.fromMap(dict["BitrateBnd"] as! [String: Any])
                        self.bitrateBnd = model
                    }
                    if dict.keys.contains("Bufsize") {
                        self.bufsize = dict["Bufsize"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Crf") {
                        self.crf = dict["Crf"] as! String
                    }
                    if dict.keys.contains("Crop") {
                        self.crop = dict["Crop"] as! String
                    }
                    if dict.keys.contains("Degrain") {
                        self.degrain = dict["Degrain"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Gop") {
                        self.gop = dict["Gop"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("MaxFps") {
                        self.maxFps = dict["MaxFps"] as! String
                    }
                    if dict.keys.contains("Maxrate") {
                        self.maxrate = dict["Maxrate"] as! String
                    }
                    if dict.keys.contains("Pad") {
                        self.pad = dict["Pad"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Preset") {
                        self.preset = dict["Preset"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Qscale") {
                        self.qscale = dict["Qscale"] as! String
                    }
                    if dict.keys.contains("Remove") {
                        self.remove = dict["Remove"] as! String
                    }
                    if dict.keys.contains("ScanMode") {
                        self.scanMode = dict["ScanMode"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audio: SearchTemplateResponseBody.TemplateList.Template.Audio?

            public var container: SearchTemplateResponseBody.TemplateList.Template.Container?

            public var id: String?

            public var muxConfig: SearchTemplateResponseBody.TemplateList.Template.MuxConfig?

            public var name: String?

            public var state: String?

            public var transConfig: SearchTemplateResponseBody.TemplateList.Template.TransConfig?

            public var video: SearchTemplateResponseBody.TemplateList.Template.Video?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audio?.validate()
                try self.container?.validate()
                try self.muxConfig?.validate()
                try self.transConfig?.validate()
                try self.video?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audio != nil {
                    map["Audio"] = self.audio?.toMap()
                }
                if self.container != nil {
                    map["Container"] = self.container?.toMap()
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.muxConfig != nil {
                    map["MuxConfig"] = self.muxConfig?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.transConfig != nil {
                    map["TransConfig"] = self.transConfig?.toMap()
                }
                if self.video != nil {
                    map["Video"] = self.video?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Audio") {
                    var model = SearchTemplateResponseBody.TemplateList.Template.Audio()
                    model.fromMap(dict["Audio"] as! [String: Any])
                    self.audio = model
                }
                if dict.keys.contains("Container") {
                    var model = SearchTemplateResponseBody.TemplateList.Template.Container()
                    model.fromMap(dict["Container"] as! [String: Any])
                    self.container = model
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("MuxConfig") {
                    var model = SearchTemplateResponseBody.TemplateList.Template.MuxConfig()
                    model.fromMap(dict["MuxConfig"] as! [String: Any])
                    self.muxConfig = model
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("TransConfig") {
                    var model = SearchTemplateResponseBody.TemplateList.Template.TransConfig()
                    model.fromMap(dict["TransConfig"] as! [String: Any])
                    self.transConfig = model
                }
                if dict.keys.contains("Video") {
                    var model = SearchTemplateResponseBody.TemplateList.Template.Video()
                    model.fromMap(dict["Video"] as! [String: Any])
                    self.video = model
                }
            }
        }
        public var template: [SearchTemplateResponseBody.TemplateList.Template]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.template != nil {
                var tmp : [Any] = []
                for k in self.template! {
                    tmp.append(k.toMap())
                }
                map["Template"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Template") {
                var tmp : [SearchTemplateResponseBody.TemplateList.Template] = []
                for v in dict["Template"] as! [Any] {
                    var model = SearchTemplateResponseBody.TemplateList.Template()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.template = tmp
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var templateList: SearchTemplateResponseBody.TemplateList?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateList != nil {
            map["TemplateList"] = self.templateList?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateList") {
            var model = SearchTemplateResponseBody.TemplateList()
            model.fromMap(dict["TemplateList"] as! [String: Any])
            self.templateList = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class SearchTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchWaterMarkTemplateRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class SearchWaterMarkTemplateResponseBody : Tea.TeaModel {
    public class WaterMarkTemplateList : Tea.TeaModel {
        public class WaterMarkTemplate : Tea.TeaModel {
            public class RatioRefer : Tea.TeaModel {
                public var dx: String?

                public var dy: String?

                public var height: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dx != nil {
                        map["Dx"] = self.dx!
                    }
                    if self.dy != nil {
                        map["Dy"] = self.dy!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Dx") {
                        self.dx = dict["Dx"] as! String
                    }
                    if dict.keys.contains("Dy") {
                        self.dy = dict["Dy"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class Timeline : Tea.TeaModel {
                public var duration: String?

                public var start: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.start != nil {
                        map["Start"] = self.start!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Start") {
                        self.start = dict["Start"] as! String
                    }
                }
            }
            public var dx: String?

            public var dy: String?

            public var height: String?

            public var id: String?

            public var name: String?

            public var ratioRefer: SearchWaterMarkTemplateResponseBody.WaterMarkTemplateList.WaterMarkTemplate.RatioRefer?

            public var referPos: String?

            public var state: String?

            public var timeline: SearchWaterMarkTemplateResponseBody.WaterMarkTemplateList.WaterMarkTemplate.Timeline?

            public var type: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ratioRefer?.validate()
                try self.timeline?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dx != nil {
                    map["Dx"] = self.dx!
                }
                if self.dy != nil {
                    map["Dy"] = self.dy!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ratioRefer != nil {
                    map["RatioRefer"] = self.ratioRefer?.toMap()
                }
                if self.referPos != nil {
                    map["ReferPos"] = self.referPos!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.timeline != nil {
                    map["Timeline"] = self.timeline?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Dx") {
                    self.dx = dict["Dx"] as! String
                }
                if dict.keys.contains("Dy") {
                    self.dy = dict["Dy"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RatioRefer") {
                    var model = SearchWaterMarkTemplateResponseBody.WaterMarkTemplateList.WaterMarkTemplate.RatioRefer()
                    model.fromMap(dict["RatioRefer"] as! [String: Any])
                    self.ratioRefer = model
                }
                if dict.keys.contains("ReferPos") {
                    self.referPos = dict["ReferPos"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Timeline") {
                    var model = SearchWaterMarkTemplateResponseBody.WaterMarkTemplateList.WaterMarkTemplate.Timeline()
                    model.fromMap(dict["Timeline"] as! [String: Any])
                    self.timeline = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var waterMarkTemplate: [SearchWaterMarkTemplateResponseBody.WaterMarkTemplateList.WaterMarkTemplate]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.waterMarkTemplate != nil {
                var tmp : [Any] = []
                for k in self.waterMarkTemplate! {
                    tmp.append(k.toMap())
                }
                map["WaterMarkTemplate"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WaterMarkTemplate") {
                var tmp : [SearchWaterMarkTemplateResponseBody.WaterMarkTemplateList.WaterMarkTemplate] = []
                for v in dict["WaterMarkTemplate"] as! [Any] {
                    var model = SearchWaterMarkTemplateResponseBody.WaterMarkTemplateList.WaterMarkTemplate()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.waterMarkTemplate = tmp
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var waterMarkTemplateList: SearchWaterMarkTemplateResponseBody.WaterMarkTemplateList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.waterMarkTemplateList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.waterMarkTemplateList != nil {
            map["WaterMarkTemplateList"] = self.waterMarkTemplateList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
        if dict.keys.contains("WaterMarkTemplateList") {
            var model = SearchWaterMarkTemplateResponseBody.WaterMarkTemplateList()
            model.fromMap(dict["WaterMarkTemplateList"] as! [String: Any])
            self.waterMarkTemplateList = model
        }
    }
}

public class SearchWaterMarkTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchWaterMarkTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchWaterMarkTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitAnalysisJobRequest : Tea.TeaModel {
    public var analysisConfig: String?

    public var input: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var priority: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.analysisConfig != nil {
            map["AnalysisConfig"] = self.analysisConfig!
        }
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AnalysisConfig") {
            self.analysisConfig = dict["AnalysisConfig"] as! String
        }
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitAnalysisJobResponseBody : Tea.TeaModel {
    public class AnalysisJob : Tea.TeaModel {
        public class AnalysisConfig : Tea.TeaModel {
            public class PropertiesControl : Tea.TeaModel {
                public class Crop : Tea.TeaModel {
                    public var height: String?

                    public var left_: String?

                    public var mode: String?

                    public var top: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.left_ != nil {
                            map["Left"] = self.left_!
                        }
                        if self.mode != nil {
                            map["Mode"] = self.mode!
                        }
                        if self.top != nil {
                            map["Top"] = self.top!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("Left") {
                            self.left_ = dict["Left"] as! String
                        }
                        if dict.keys.contains("Mode") {
                            self.mode = dict["Mode"] as! String
                        }
                        if dict.keys.contains("Top") {
                            self.top = dict["Top"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var crop: SubmitAnalysisJobResponseBody.AnalysisJob.AnalysisConfig.PropertiesControl.Crop?

                public var deinterlace: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.crop?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.crop != nil {
                        map["Crop"] = self.crop?.toMap()
                    }
                    if self.deinterlace != nil {
                        map["Deinterlace"] = self.deinterlace!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Crop") {
                        var model = SubmitAnalysisJobResponseBody.AnalysisJob.AnalysisConfig.PropertiesControl.Crop()
                        model.fromMap(dict["Crop"] as! [String: Any])
                        self.crop = model
                    }
                    if dict.keys.contains("Deinterlace") {
                        self.deinterlace = dict["Deinterlace"] as! String
                    }
                }
            }
            public class QualityControl : Tea.TeaModel {
                public var methodStreaming: String?

                public var rateQuality: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.methodStreaming != nil {
                        map["MethodStreaming"] = self.methodStreaming!
                    }
                    if self.rateQuality != nil {
                        map["RateQuality"] = self.rateQuality!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MethodStreaming") {
                        self.methodStreaming = dict["MethodStreaming"] as! String
                    }
                    if dict.keys.contains("RateQuality") {
                        self.rateQuality = dict["RateQuality"] as! String
                    }
                }
            }
            public var propertiesControl: SubmitAnalysisJobResponseBody.AnalysisJob.AnalysisConfig.PropertiesControl?

            public var qualityControl: SubmitAnalysisJobResponseBody.AnalysisJob.AnalysisConfig.QualityControl?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.propertiesControl?.validate()
                try self.qualityControl?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.propertiesControl != nil {
                    map["PropertiesControl"] = self.propertiesControl?.toMap()
                }
                if self.qualityControl != nil {
                    map["QualityControl"] = self.qualityControl?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PropertiesControl") {
                    var model = SubmitAnalysisJobResponseBody.AnalysisJob.AnalysisConfig.PropertiesControl()
                    model.fromMap(dict["PropertiesControl"] as! [String: Any])
                    self.propertiesControl = model
                }
                if dict.keys.contains("QualityControl") {
                    var model = SubmitAnalysisJobResponseBody.AnalysisJob.AnalysisConfig.QualityControl()
                    model.fromMap(dict["QualityControl"] as! [String: Any])
                    self.qualityControl = model
                }
            }
        }
        public class InputFile : Tea.TeaModel {
            public var bucket: String?

            public var location: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("Object") {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public class MNSMessageResult : Tea.TeaModel {
            public var errorCode: String?

            public var errorMessage: String?

            public var messageId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.messageId != nil {
                    map["MessageId"] = self.messageId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("MessageId") {
                    self.messageId = dict["MessageId"] as! String
                }
            }
        }
        public class TemplateList : Tea.TeaModel {
            public class Template : Tea.TeaModel {
                public class Audio : Tea.TeaModel {
                    public var bitrate: String?

                    public var channels: String?

                    public var codec: String?

                    public var profile: String?

                    public var qscale: String?

                    public var samplerate: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        if self.codec != nil {
                            map["Codec"] = self.codec!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.qscale != nil {
                            map["Qscale"] = self.qscale!
                        }
                        if self.samplerate != nil {
                            map["Samplerate"] = self.samplerate!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Channels") {
                            self.channels = dict["Channels"] as! String
                        }
                        if dict.keys.contains("Codec") {
                            self.codec = dict["Codec"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Qscale") {
                            self.qscale = dict["Qscale"] as! String
                        }
                        if dict.keys.contains("Samplerate") {
                            self.samplerate = dict["Samplerate"] as! String
                        }
                    }
                }
                public class Container : Tea.TeaModel {
                    public var format: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                    }
                }
                public class MuxConfig : Tea.TeaModel {
                    public class Gif : Tea.TeaModel {
                        public var finalDelay: String?

                        public var loop: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.finalDelay != nil {
                                map["FinalDelay"] = self.finalDelay!
                            }
                            if self.loop != nil {
                                map["Loop"] = self.loop!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("FinalDelay") {
                                self.finalDelay = dict["FinalDelay"] as! String
                            }
                            if dict.keys.contains("Loop") {
                                self.loop = dict["Loop"] as! String
                            }
                        }
                    }
                    public class Segment : Tea.TeaModel {
                        public var duration: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                        }
                    }
                    public var gif: SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.MuxConfig.Gif?

                    public var segment: SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.MuxConfig.Segment?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.gif?.validate()
                        try self.segment?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.gif != nil {
                            map["Gif"] = self.gif?.toMap()
                        }
                        if self.segment != nil {
                            map["Segment"] = self.segment?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Gif") {
                            var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.MuxConfig.Gif()
                            model.fromMap(dict["Gif"] as! [String: Any])
                            self.gif = model
                        }
                        if dict.keys.contains("Segment") {
                            var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.MuxConfig.Segment()
                            model.fromMap(dict["Segment"] as! [String: Any])
                            self.segment = model
                        }
                    }
                }
                public class TransConfig : Tea.TeaModel {
                    public var transMode: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.transMode != nil {
                            map["TransMode"] = self.transMode!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TransMode") {
                            self.transMode = dict["TransMode"] as! String
                        }
                    }
                }
                public class Video : Tea.TeaModel {
                    public class BitrateBnd : Tea.TeaModel {
                        public var max: String?

                        public var min: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.max != nil {
                                map["Max"] = self.max!
                            }
                            if self.min != nil {
                                map["Min"] = self.min!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Max") {
                                self.max = dict["Max"] as! String
                            }
                            if dict.keys.contains("Min") {
                                self.min = dict["Min"] as! String
                            }
                        }
                    }
                    public var bitrate: String?

                    public var bitrateBnd: SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.Video.BitrateBnd?

                    public var bufsize: String?

                    public var codec: String?

                    public var crf: String?

                    public var degrain: String?

                    public var fps: String?

                    public var gop: String?

                    public var height: String?

                    public var maxrate: String?

                    public var pixFmt: String?

                    public var preset: String?

                    public var profile: String?

                    public var qscale: String?

                    public var scanMode: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.bitrateBnd?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.bitrateBnd != nil {
                            map["BitrateBnd"] = self.bitrateBnd?.toMap()
                        }
                        if self.bufsize != nil {
                            map["Bufsize"] = self.bufsize!
                        }
                        if self.codec != nil {
                            map["Codec"] = self.codec!
                        }
                        if self.crf != nil {
                            map["Crf"] = self.crf!
                        }
                        if self.degrain != nil {
                            map["Degrain"] = self.degrain!
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.gop != nil {
                            map["Gop"] = self.gop!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.maxrate != nil {
                            map["Maxrate"] = self.maxrate!
                        }
                        if self.pixFmt != nil {
                            map["PixFmt"] = self.pixFmt!
                        }
                        if self.preset != nil {
                            map["Preset"] = self.preset!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.qscale != nil {
                            map["Qscale"] = self.qscale!
                        }
                        if self.scanMode != nil {
                            map["ScanMode"] = self.scanMode!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("BitrateBnd") {
                            var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.Video.BitrateBnd()
                            model.fromMap(dict["BitrateBnd"] as! [String: Any])
                            self.bitrateBnd = model
                        }
                        if dict.keys.contains("Bufsize") {
                            self.bufsize = dict["Bufsize"] as! String
                        }
                        if dict.keys.contains("Codec") {
                            self.codec = dict["Codec"] as! String
                        }
                        if dict.keys.contains("Crf") {
                            self.crf = dict["Crf"] as! String
                        }
                        if dict.keys.contains("Degrain") {
                            self.degrain = dict["Degrain"] as! String
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Gop") {
                            self.gop = dict["Gop"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("Maxrate") {
                            self.maxrate = dict["Maxrate"] as! String
                        }
                        if dict.keys.contains("PixFmt") {
                            self.pixFmt = dict["PixFmt"] as! String
                        }
                        if dict.keys.contains("Preset") {
                            self.preset = dict["Preset"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Qscale") {
                            self.qscale = dict["Qscale"] as! String
                        }
                        if dict.keys.contains("ScanMode") {
                            self.scanMode = dict["ScanMode"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var audio: SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.Audio?

                public var container: SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.Container?

                public var id: String?

                public var muxConfig: SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.MuxConfig?

                public var name: String?

                public var state: String?

                public var transConfig: SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.TransConfig?

                public var video: SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.Video?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.audio?.validate()
                    try self.container?.validate()
                    try self.muxConfig?.validate()
                    try self.transConfig?.validate()
                    try self.video?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audio != nil {
                        map["Audio"] = self.audio?.toMap()
                    }
                    if self.container != nil {
                        map["Container"] = self.container?.toMap()
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.muxConfig != nil {
                        map["MuxConfig"] = self.muxConfig?.toMap()
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    if self.transConfig != nil {
                        map["TransConfig"] = self.transConfig?.toMap()
                    }
                    if self.video != nil {
                        map["Video"] = self.video?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Audio") {
                        var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.Audio()
                        model.fromMap(dict["Audio"] as! [String: Any])
                        self.audio = model
                    }
                    if dict.keys.contains("Container") {
                        var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.Container()
                        model.fromMap(dict["Container"] as! [String: Any])
                        self.container = model
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("MuxConfig") {
                        var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.MuxConfig()
                        model.fromMap(dict["MuxConfig"] as! [String: Any])
                        self.muxConfig = model
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! String
                    }
                    if dict.keys.contains("TransConfig") {
                        var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.TransConfig()
                        model.fromMap(dict["TransConfig"] as! [String: Any])
                        self.transConfig = model
                    }
                    if dict.keys.contains("Video") {
                        var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.Video()
                        model.fromMap(dict["Video"] as! [String: Any])
                        self.video = model
                    }
                }
            }
            public var template: [SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.template != nil {
                    var tmp : [Any] = []
                    for k in self.template! {
                        tmp.append(k.toMap())
                    }
                    map["Template"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Template") {
                    var tmp : [SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template] = []
                    for v in dict["Template"] as! [Any] {
                        var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.template = tmp
                }
            }
        }
        public var analysisConfig: SubmitAnalysisJobResponseBody.AnalysisJob.AnalysisConfig?

        public var code: String?

        public var creationTime: String?

        public var id: String?

        public var inputFile: SubmitAnalysisJobResponseBody.AnalysisJob.InputFile?

        public var MNSMessageResult: SubmitAnalysisJobResponseBody.AnalysisJob.MNSMessageResult?

        public var message: String?

        public var percent: Int64?

        public var pipelineId: String?

        public var priority: String?

        public var state: String?

        public var templateList: SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.analysisConfig?.validate()
            try self.inputFile?.validate()
            try self.MNSMessageResult?.validate()
            try self.templateList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.analysisConfig != nil {
                map["AnalysisConfig"] = self.analysisConfig?.toMap()
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.inputFile != nil {
                map["InputFile"] = self.inputFile?.toMap()
            }
            if self.MNSMessageResult != nil {
                map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.templateList != nil {
                map["TemplateList"] = self.templateList?.toMap()
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AnalysisConfig") {
                var model = SubmitAnalysisJobResponseBody.AnalysisJob.AnalysisConfig()
                model.fromMap(dict["AnalysisConfig"] as! [String: Any])
                self.analysisConfig = model
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("InputFile") {
                var model = SubmitAnalysisJobResponseBody.AnalysisJob.InputFile()
                model.fromMap(dict["InputFile"] as! [String: Any])
                self.inputFile = model
            }
            if dict.keys.contains("MNSMessageResult") {
                var model = SubmitAnalysisJobResponseBody.AnalysisJob.MNSMessageResult()
                model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                self.MNSMessageResult = model
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! Int64
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("TemplateList") {
                var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList()
                model.fromMap(dict["TemplateList"] as! [String: Any])
                self.templateList = model
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var analysisJob: SubmitAnalysisJobResponseBody.AnalysisJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.analysisJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.analysisJob != nil {
            map["AnalysisJob"] = self.analysisJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AnalysisJob") {
            var model = SubmitAnalysisJobResponseBody.AnalysisJob()
            model.fromMap(dict["AnalysisJob"] as! [String: Any])
            self.analysisJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitAnalysisJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitAnalysisJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitAnalysisJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitEditingJobsRequest : Tea.TeaModel {
    public var editingInputs: String?

    public var editingJobOutputs: String?

    public var outputBucket: String?

    public var outputLocation: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.editingInputs != nil {
            map["EditingInputs"] = self.editingInputs!
        }
        if self.editingJobOutputs != nil {
            map["EditingJobOutputs"] = self.editingJobOutputs!
        }
        if self.outputBucket != nil {
            map["OutputBucket"] = self.outputBucket!
        }
        if self.outputLocation != nil {
            map["OutputLocation"] = self.outputLocation!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EditingInputs") {
            self.editingInputs = dict["EditingInputs"] as! String
        }
        if dict.keys.contains("EditingJobOutputs") {
            self.editingJobOutputs = dict["EditingJobOutputs"] as! String
        }
        if dict.keys.contains("OutputBucket") {
            self.outputBucket = dict["OutputBucket"] as! String
        }
        if dict.keys.contains("OutputLocation") {
            self.outputLocation = dict["OutputLocation"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class SubmitEditingJobsResponseBody : Tea.TeaModel {
    public class JobResultList : Tea.TeaModel {
        public class JobResult : Tea.TeaModel {
            public class Job : Tea.TeaModel {
                public class EditingConfig : Tea.TeaModel {
                    public class Audio : Tea.TeaModel {
                        public class Volume : Tea.TeaModel {
                            public var level: String?

                            public var method: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.level != nil {
                                    map["Level"] = self.level!
                                }
                                if self.method != nil {
                                    map["Method"] = self.method!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Level") {
                                    self.level = dict["Level"] as! String
                                }
                                if dict.keys.contains("Method") {
                                    self.method = dict["Method"] as! String
                                }
                            }
                        }
                        public var bitrate: String?

                        public var channels: String?

                        public var codec: String?

                        public var profile: String?

                        public var qscale: String?

                        public var samplerate: String?

                        public var volume: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Audio.Volume?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.volume?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.channels != nil {
                                map["Channels"] = self.channels!
                            }
                            if self.codec != nil {
                                map["Codec"] = self.codec!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.qscale != nil {
                                map["Qscale"] = self.qscale!
                            }
                            if self.samplerate != nil {
                                map["Samplerate"] = self.samplerate!
                            }
                            if self.volume != nil {
                                map["Volume"] = self.volume?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Channels") {
                                self.channels = dict["Channels"] as! String
                            }
                            if dict.keys.contains("Codec") {
                                self.codec = dict["Codec"] as! String
                            }
                            if dict.keys.contains("Profile") {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Qscale") {
                                self.qscale = dict["Qscale"] as! String
                            }
                            if dict.keys.contains("Samplerate") {
                                self.samplerate = dict["Samplerate"] as! String
                            }
                            if dict.keys.contains("Volume") {
                                var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Audio.Volume()
                                model.fromMap(dict["Volume"] as! [String: Any])
                                self.volume = model
                            }
                        }
                    }
                    public class Clip : Tea.TeaModel {
                        public class TimeSpan : Tea.TeaModel {
                            public var duration: String?

                            public var seek: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.seek != nil {
                                    map["Seek"] = self.seek!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Seek") {
                                    self.seek = dict["Seek"] as! String
                                }
                            }
                        }
                        public var timeSpan: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Clip.TimeSpan?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.timeSpan?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.timeSpan != nil {
                                map["TimeSpan"] = self.timeSpan?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("TimeSpan") {
                                var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Clip.TimeSpan()
                                model.fromMap(dict["TimeSpan"] as! [String: Any])
                                self.timeSpan = model
                            }
                        }
                    }
                    public class Container : Tea.TeaModel {
                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public class DigiWaterMark : Tea.TeaModel {
                        public class InputFile : Tea.TeaModel {
                            public var bucket: String?

                            public var location: String?

                            public var object: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bucket != nil {
                                    map["Bucket"] = self.bucket!
                                }
                                if self.location != nil {
                                    map["Location"] = self.location!
                                }
                                if self.object != nil {
                                    map["Object"] = self.object!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bucket") {
                                    self.bucket = dict["Bucket"] as! String
                                }
                                if dict.keys.contains("Location") {
                                    self.location = dict["Location"] as! String
                                }
                                if dict.keys.contains("Object") {
                                    self.object = dict["Object"] as! String
                                }
                            }
                        }
                        public var alpha: String?

                        public var inputFile: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.DigiWaterMark.InputFile?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.inputFile?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.alpha != nil {
                                map["Alpha"] = self.alpha!
                            }
                            if self.inputFile != nil {
                                map["InputFile"] = self.inputFile?.toMap()
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Alpha") {
                                self.alpha = dict["Alpha"] as! String
                            }
                            if dict.keys.contains("InputFile") {
                                var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.DigiWaterMark.InputFile()
                                model.fromMap(dict["InputFile"] as! [String: Any])
                                self.inputFile = model
                            }
                            if dict.keys.contains("Type") {
                                self.type = dict["Type"] as! String
                            }
                        }
                    }
                    public class Editing : Tea.TeaModel {
                        public class ClipList : Tea.TeaModel {
                            public class Clip : Tea.TeaModel {
                                public class Effects : Tea.TeaModel {
                                    public class Effect : Tea.TeaModel {
                                        public var effect: String?

                                        public var effectConfig: String?

                                        public override init() {
                                            super.init()
                                        }

                                        public init(_ dict: [String: Any]) {
                                            super.init()
                                            self.fromMap(dict)
                                        }

                                        public override func validate() throws -> Void {
                                        }

                                        public override func toMap() -> [String : Any] {
                                            var map = super.toMap()
                                            if self.effect != nil {
                                                map["Effect"] = self.effect!
                                            }
                                            if self.effectConfig != nil {
                                                map["EffectConfig"] = self.effectConfig!
                                            }
                                            return map
                                        }

                                        public override func fromMap(_ dict: [String: Any]) -> Void {
                                            if dict.keys.contains("Effect") {
                                                self.effect = dict["Effect"] as! String
                                            }
                                            if dict.keys.contains("EffectConfig") {
                                                self.effectConfig = dict["EffectConfig"] as! String
                                            }
                                        }
                                    }
                                    public var effect: [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.ClipList.Clip.Effects.Effect]?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.effect != nil {
                                            var tmp : [Any] = []
                                            for k in self.effect! {
                                                tmp.append(k.toMap())
                                            }
                                            map["Effect"] = tmp
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Effect") {
                                            var tmp : [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.ClipList.Clip.Effects.Effect] = []
                                            for v in dict["Effect"] as! [Any] {
                                                var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.ClipList.Clip.Effects.Effect()
                                                if v != nil {
                                                    model.fromMap(v as! [String: Any])
                                                }
                                                tmp.append(model)
                                            }
                                            self.effect = tmp
                                        }
                                    }
                                }
                                public var effects: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.ClipList.Clip.Effects?

                                public var id: String?

                                public var in_: String?

                                public var out: String?

                                public var sourceID: String?

                                public var sourceStrmMap: String?

                                public var sourceType: String?

                                public var type: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                    try self.effects?.validate()
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.effects != nil {
                                        map["Effects"] = self.effects?.toMap()
                                    }
                                    if self.id != nil {
                                        map["Id"] = self.id!
                                    }
                                    if self.in_ != nil {
                                        map["In"] = self.in_!
                                    }
                                    if self.out != nil {
                                        map["Out"] = self.out!
                                    }
                                    if self.sourceID != nil {
                                        map["SourceID"] = self.sourceID!
                                    }
                                    if self.sourceStrmMap != nil {
                                        map["SourceStrmMap"] = self.sourceStrmMap!
                                    }
                                    if self.sourceType != nil {
                                        map["SourceType"] = self.sourceType!
                                    }
                                    if self.type != nil {
                                        map["Type"] = self.type!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Effects") {
                                        var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.ClipList.Clip.Effects()
                                        model.fromMap(dict["Effects"] as! [String: Any])
                                        self.effects = model
                                    }
                                    if dict.keys.contains("Id") {
                                        self.id = dict["Id"] as! String
                                    }
                                    if dict.keys.contains("In") {
                                        self.in_ = dict["In"] as! String
                                    }
                                    if dict.keys.contains("Out") {
                                        self.out = dict["Out"] as! String
                                    }
                                    if dict.keys.contains("SourceID") {
                                        self.sourceID = dict["SourceID"] as! String
                                    }
                                    if dict.keys.contains("SourceStrmMap") {
                                        self.sourceStrmMap = dict["SourceStrmMap"] as! String
                                    }
                                    if dict.keys.contains("SourceType") {
                                        self.sourceType = dict["SourceType"] as! String
                                    }
                                    if dict.keys.contains("Type") {
                                        self.type = dict["Type"] as! String
                                    }
                                }
                            }
                            public var clip: [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.ClipList.Clip]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.clip != nil {
                                    var tmp : [Any] = []
                                    for k in self.clip! {
                                        tmp.append(k.toMap())
                                    }
                                    map["Clip"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Clip") {
                                    var tmp : [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.ClipList.Clip] = []
                                    for v in dict["Clip"] as! [Any] {
                                        var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.ClipList.Clip()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.clip = tmp
                                }
                            }
                        }
                        public class Timeline : Tea.TeaModel {
                            public class TimelineConfig : Tea.TeaModel {
                                public class TimelineConfigAudio : Tea.TeaModel {
                                    public var channelLayout: String?

                                    public var channels: String?

                                    public var samplerate: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.channelLayout != nil {
                                            map["ChannelLayout"] = self.channelLayout!
                                        }
                                        if self.channels != nil {
                                            map["Channels"] = self.channels!
                                        }
                                        if self.samplerate != nil {
                                            map["Samplerate"] = self.samplerate!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("ChannelLayout") {
                                            self.channelLayout = dict["ChannelLayout"] as! String
                                        }
                                        if dict.keys.contains("Channels") {
                                            self.channels = dict["Channels"] as! String
                                        }
                                        if dict.keys.contains("Samplerate") {
                                            self.samplerate = dict["Samplerate"] as! String
                                        }
                                    }
                                }
                                public class TimelineConfigVideo : Tea.TeaModel {
                                    public var bgColor: String?

                                    public var fps: String?

                                    public var height: String?

                                    public var isGpuData: String?

                                    public var isOneTrackData: String?

                                    public var reclosePrec: String?

                                    public var renderRatio: String?

                                    public var width: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.bgColor != nil {
                                            map["BgColor"] = self.bgColor!
                                        }
                                        if self.fps != nil {
                                            map["Fps"] = self.fps!
                                        }
                                        if self.height != nil {
                                            map["Height"] = self.height!
                                        }
                                        if self.isGpuData != nil {
                                            map["IsGpuData"] = self.isGpuData!
                                        }
                                        if self.isOneTrackData != nil {
                                            map["IsOneTrackData"] = self.isOneTrackData!
                                        }
                                        if self.reclosePrec != nil {
                                            map["ReclosePrec"] = self.reclosePrec!
                                        }
                                        if self.renderRatio != nil {
                                            map["RenderRatio"] = self.renderRatio!
                                        }
                                        if self.width != nil {
                                            map["Width"] = self.width!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("BgColor") {
                                            self.bgColor = dict["BgColor"] as! String
                                        }
                                        if dict.keys.contains("Fps") {
                                            self.fps = dict["Fps"] as! String
                                        }
                                        if dict.keys.contains("Height") {
                                            self.height = dict["Height"] as! String
                                        }
                                        if dict.keys.contains("IsGpuData") {
                                            self.isGpuData = dict["IsGpuData"] as! String
                                        }
                                        if dict.keys.contains("IsOneTrackData") {
                                            self.isOneTrackData = dict["IsOneTrackData"] as! String
                                        }
                                        if dict.keys.contains("ReclosePrec") {
                                            self.reclosePrec = dict["ReclosePrec"] as! String
                                        }
                                        if dict.keys.contains("RenderRatio") {
                                            self.renderRatio = dict["RenderRatio"] as! String
                                        }
                                        if dict.keys.contains("Width") {
                                            self.width = dict["Width"] as! String
                                        }
                                    }
                                }
                                public var timelineConfigAudio: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TimelineConfig.TimelineConfigAudio?

                                public var timelineConfigVideo: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TimelineConfig.TimelineConfigVideo?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                    try self.timelineConfigAudio?.validate()
                                    try self.timelineConfigVideo?.validate()
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.timelineConfigAudio != nil {
                                        map["TimelineConfigAudio"] = self.timelineConfigAudio?.toMap()
                                    }
                                    if self.timelineConfigVideo != nil {
                                        map["TimelineConfigVideo"] = self.timelineConfigVideo?.toMap()
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("TimelineConfigAudio") {
                                        var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TimelineConfig.TimelineConfigAudio()
                                        model.fromMap(dict["TimelineConfigAudio"] as! [String: Any])
                                        self.timelineConfigAudio = model
                                    }
                                    if dict.keys.contains("TimelineConfigVideo") {
                                        var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TimelineConfig.TimelineConfigVideo()
                                        model.fromMap(dict["TimelineConfigVideo"] as! [String: Any])
                                        self.timelineConfigVideo = model
                                    }
                                }
                            }
                            public class TrackList : Tea.TeaModel {
                                public class Track : Tea.TeaModel {
                                    public class Clips : Tea.TeaModel {
                                        public class Clip : Tea.TeaModel {
                                            public class ClipsConfig : Tea.TeaModel {
                                                public class ClipsConfigVideo : Tea.TeaModel {
                                                    public var l: String?

                                                    public var t: String?

                                                    public override init() {
                                                        super.init()
                                                    }

                                                    public init(_ dict: [String: Any]) {
                                                        super.init()
                                                        self.fromMap(dict)
                                                    }

                                                    public override func validate() throws -> Void {
                                                    }

                                                    public override func toMap() -> [String : Any] {
                                                        var map = super.toMap()
                                                        if self.l != nil {
                                                            map["L"] = self.l!
                                                        }
                                                        if self.t != nil {
                                                            map["T"] = self.t!
                                                        }
                                                        return map
                                                    }

                                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                                        if dict.keys.contains("L") {
                                                            self.l = dict["L"] as! String
                                                        }
                                                        if dict.keys.contains("T") {
                                                            self.t = dict["T"] as! String
                                                        }
                                                    }
                                                }
                                                public var clipsConfigVideo: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TrackList.Track.Clips.Clip.ClipsConfig.ClipsConfigVideo?

                                                public override init() {
                                                    super.init()
                                                }

                                                public init(_ dict: [String: Any]) {
                                                    super.init()
                                                    self.fromMap(dict)
                                                }

                                                public override func validate() throws -> Void {
                                                    try self.clipsConfigVideo?.validate()
                                                }

                                                public override func toMap() -> [String : Any] {
                                                    var map = super.toMap()
                                                    if self.clipsConfigVideo != nil {
                                                        map["ClipsConfigVideo"] = self.clipsConfigVideo?.toMap()
                                                    }
                                                    return map
                                                }

                                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                                    if dict.keys.contains("ClipsConfigVideo") {
                                                        var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TrackList.Track.Clips.Clip.ClipsConfig.ClipsConfigVideo()
                                                        model.fromMap(dict["ClipsConfigVideo"] as! [String: Any])
                                                        self.clipsConfigVideo = model
                                                    }
                                                }
                                            }
                                            public var clipsConfig: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TrackList.Track.Clips.Clip.ClipsConfig?

                                            public var in_: String?

                                            public var out: String?

                                            public var clipID: String?

                                            public override init() {
                                                super.init()
                                            }

                                            public init(_ dict: [String: Any]) {
                                                super.init()
                                                self.fromMap(dict)
                                            }

                                            public override func validate() throws -> Void {
                                                try self.clipsConfig?.validate()
                                            }

                                            public override func toMap() -> [String : Any] {
                                                var map = super.toMap()
                                                if self.clipsConfig != nil {
                                                    map["ClipsConfig"] = self.clipsConfig?.toMap()
                                                }
                                                if self.in_ != nil {
                                                    map["In"] = self.in_!
                                                }
                                                if self.out != nil {
                                                    map["Out"] = self.out!
                                                }
                                                if self.clipID != nil {
                                                    map["clipID"] = self.clipID!
                                                }
                                                return map
                                            }

                                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                                if dict.keys.contains("ClipsConfig") {
                                                    var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TrackList.Track.Clips.Clip.ClipsConfig()
                                                    model.fromMap(dict["ClipsConfig"] as! [String: Any])
                                                    self.clipsConfig = model
                                                }
                                                if dict.keys.contains("In") {
                                                    self.in_ = dict["In"] as! String
                                                }
                                                if dict.keys.contains("Out") {
                                                    self.out = dict["Out"] as! String
                                                }
                                                if dict.keys.contains("clipID") {
                                                    self.clipID = dict["clipID"] as! String
                                                }
                                            }
                                        }
                                        public var clip: [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TrackList.Track.Clips.Clip]?

                                        public override init() {
                                            super.init()
                                        }

                                        public init(_ dict: [String: Any]) {
                                            super.init()
                                            self.fromMap(dict)
                                        }

                                        public override func validate() throws -> Void {
                                        }

                                        public override func toMap() -> [String : Any] {
                                            var map = super.toMap()
                                            if self.clip != nil {
                                                var tmp : [Any] = []
                                                for k in self.clip! {
                                                    tmp.append(k.toMap())
                                                }
                                                map["Clip"] = tmp
                                            }
                                            return map
                                        }

                                        public override func fromMap(_ dict: [String: Any]) -> Void {
                                            if dict.keys.contains("Clip") {
                                                var tmp : [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TrackList.Track.Clips.Clip] = []
                                                for v in dict["Clip"] as! [Any] {
                                                    var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TrackList.Track.Clips.Clip()
                                                    if v != nil {
                                                        model.fromMap(v as! [String: Any])
                                                    }
                                                    tmp.append(model)
                                                }
                                                self.clip = tmp
                                            }
                                        }
                                    }
                                    public var clips: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TrackList.Track.Clips?

                                    public var id: String?

                                    public var order: String?

                                    public var type: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                        try self.clips?.validate()
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.clips != nil {
                                            map["Clips"] = self.clips?.toMap()
                                        }
                                        if self.id != nil {
                                            map["Id"] = self.id!
                                        }
                                        if self.order != nil {
                                            map["Order"] = self.order!
                                        }
                                        if self.type != nil {
                                            map["Type"] = self.type!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Clips") {
                                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TrackList.Track.Clips()
                                            model.fromMap(dict["Clips"] as! [String: Any])
                                            self.clips = model
                                        }
                                        if dict.keys.contains("Id") {
                                            self.id = dict["Id"] as! String
                                        }
                                        if dict.keys.contains("Order") {
                                            self.order = dict["Order"] as! String
                                        }
                                        if dict.keys.contains("Type") {
                                            self.type = dict["Type"] as! String
                                        }
                                    }
                                }
                                public var track: [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TrackList.Track]?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.track != nil {
                                        var tmp : [Any] = []
                                        for k in self.track! {
                                            tmp.append(k.toMap())
                                        }
                                        map["Track"] = tmp
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Track") {
                                        var tmp : [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TrackList.Track] = []
                                        for v in dict["Track"] as! [Any] {
                                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TrackList.Track()
                                            if v != nil {
                                                model.fromMap(v as! [String: Any])
                                            }
                                            tmp.append(model)
                                        }
                                        self.track = tmp
                                    }
                                }
                            }
                            public var timelineConfig: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TimelineConfig?

                            public var trackList: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TrackList?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.timelineConfig?.validate()
                                try self.trackList?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.timelineConfig != nil {
                                    map["TimelineConfig"] = self.timelineConfig?.toMap()
                                }
                                if self.trackList != nil {
                                    map["TrackList"] = self.trackList?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("TimelineConfig") {
                                    var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TimelineConfig()
                                    model.fromMap(dict["TimelineConfig"] as! [String: Any])
                                    self.timelineConfig = model
                                }
                                if dict.keys.contains("TrackList") {
                                    var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline.TrackList()
                                    model.fromMap(dict["TrackList"] as! [String: Any])
                                    self.trackList = model
                                }
                            }
                        }
                        public var clipList: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.ClipList?

                        public var timeline: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.clipList?.validate()
                            try self.timeline?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.clipList != nil {
                                map["ClipList"] = self.clipList?.toMap()
                            }
                            if self.timeline != nil {
                                map["Timeline"] = self.timeline?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ClipList") {
                                var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.ClipList()
                                model.fromMap(dict["ClipList"] as! [String: Any])
                                self.clipList = model
                            }
                            if dict.keys.contains("Timeline") {
                                var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing.Timeline()
                                model.fromMap(dict["Timeline"] as! [String: Any])
                                self.timeline = model
                            }
                        }
                    }
                    public class Encryption : Tea.TeaModel {
                        public var id: String?

                        public var key: String?

                        public var keyType: String?

                        public var keyUri: String?

                        public var skipCnt: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.id != nil {
                                map["Id"] = self.id!
                            }
                            if self.key != nil {
                                map["Key"] = self.key!
                            }
                            if self.keyType != nil {
                                map["KeyType"] = self.keyType!
                            }
                            if self.keyUri != nil {
                                map["KeyUri"] = self.keyUri!
                            }
                            if self.skipCnt != nil {
                                map["SkipCnt"] = self.skipCnt!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Id") {
                                self.id = dict["Id"] as! String
                            }
                            if dict.keys.contains("Key") {
                                self.key = dict["Key"] as! String
                            }
                            if dict.keys.contains("KeyType") {
                                self.keyType = dict["KeyType"] as! String
                            }
                            if dict.keys.contains("KeyUri") {
                                self.keyUri = dict["KeyUri"] as! String
                            }
                            if dict.keys.contains("SkipCnt") {
                                self.skipCnt = dict["SkipCnt"] as! String
                            }
                            if dict.keys.contains("Type") {
                                self.type = dict["Type"] as! String
                            }
                        }
                    }
                    public class M3U8NonStandardSupport : Tea.TeaModel {
                        public class TS : Tea.TeaModel {
                            public var md5Support: Bool?

                            public var sizeSupport: Bool?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.md5Support != nil {
                                    map["Md5Support"] = self.md5Support!
                                }
                                if self.sizeSupport != nil {
                                    map["SizeSupport"] = self.sizeSupport!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Md5Support") {
                                    self.md5Support = dict["Md5Support"] as! Bool
                                }
                                if dict.keys.contains("SizeSupport") {
                                    self.sizeSupport = dict["SizeSupport"] as! Bool
                                }
                            }
                        }
                        public var TS: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.M3U8NonStandardSupport.TS?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.TS?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.TS != nil {
                                map["TS"] = self.TS?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("TS") {
                                var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.M3U8NonStandardSupport.TS()
                                model.fromMap(dict["TS"] as! [String: Any])
                                self.TS = model
                            }
                        }
                    }
                    public class MergeList : Tea.TeaModel {
                        public class Merge : Tea.TeaModel {
                            public var duration: String?

                            public var mergeURL: String?

                            public var roleArn: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.mergeURL != nil {
                                    map["MergeURL"] = self.mergeURL!
                                }
                                if self.roleArn != nil {
                                    map["RoleArn"] = self.roleArn!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("MergeURL") {
                                    self.mergeURL = dict["MergeURL"] as! String
                                }
                                if dict.keys.contains("RoleArn") {
                                    self.roleArn = dict["RoleArn"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var merge: [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.MergeList.Merge]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.merge != nil {
                                var tmp : [Any] = []
                                for k in self.merge! {
                                    tmp.append(k.toMap())
                                }
                                map["Merge"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Merge") {
                                var tmp : [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.MergeList.Merge] = []
                                for v in dict["Merge"] as! [Any] {
                                    var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.MergeList.Merge()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.merge = tmp
                            }
                        }
                    }
                    public class MuxConfig : Tea.TeaModel {
                        public class Gif : Tea.TeaModel {
                            public var ditherMode: String?

                            public var finalDelay: String?

                            public var isCustomPalette: String?

                            public var loop: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.ditherMode != nil {
                                    map["DitherMode"] = self.ditherMode!
                                }
                                if self.finalDelay != nil {
                                    map["FinalDelay"] = self.finalDelay!
                                }
                                if self.isCustomPalette != nil {
                                    map["IsCustomPalette"] = self.isCustomPalette!
                                }
                                if self.loop != nil {
                                    map["Loop"] = self.loop!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("DitherMode") {
                                    self.ditherMode = dict["DitherMode"] as! String
                                }
                                if dict.keys.contains("FinalDelay") {
                                    self.finalDelay = dict["FinalDelay"] as! String
                                }
                                if dict.keys.contains("IsCustomPalette") {
                                    self.isCustomPalette = dict["IsCustomPalette"] as! String
                                }
                                if dict.keys.contains("Loop") {
                                    self.loop = dict["Loop"] as! String
                                }
                            }
                        }
                        public class Segment : Tea.TeaModel {
                            public var duration: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                            }
                        }
                        public var gif: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.MuxConfig.Gif?

                        public var segment: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.MuxConfig.Segment?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.gif?.validate()
                            try self.segment?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.gif != nil {
                                map["Gif"] = self.gif?.toMap()
                            }
                            if self.segment != nil {
                                map["Segment"] = self.segment?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Gif") {
                                var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.MuxConfig.Gif()
                                model.fromMap(dict["Gif"] as! [String: Any])
                                self.gif = model
                            }
                            if dict.keys.contains("Segment") {
                                var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.MuxConfig.Segment()
                                model.fromMap(dict["Segment"] as! [String: Any])
                                self.segment = model
                            }
                        }
                    }
                    public class OutputFile : Tea.TeaModel {
                        public var bucket: String?

                        public var location: String?

                        public var object: String?

                        public var roleArn: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bucket != nil {
                                map["Bucket"] = self.bucket!
                            }
                            if self.location != nil {
                                map["Location"] = self.location!
                            }
                            if self.object != nil {
                                map["Object"] = self.object!
                            }
                            if self.roleArn != nil {
                                map["RoleArn"] = self.roleArn!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bucket") {
                                self.bucket = dict["Bucket"] as! String
                            }
                            if dict.keys.contains("Location") {
                                self.location = dict["Location"] as! String
                            }
                            if dict.keys.contains("Object") {
                                self.object = dict["Object"] as! String
                            }
                            if dict.keys.contains("RoleArn") {
                                self.roleArn = dict["RoleArn"] as! String
                            }
                        }
                    }
                    public class Properties : Tea.TeaModel {
                        public class Format : Tea.TeaModel {
                            public var bitrate: String?

                            public var duration: String?

                            public var formatLongName: String?

                            public var formatName: String?

                            public var numPrograms: String?

                            public var numStreams: String?

                            public var size: String?

                            public var startTime: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.formatLongName != nil {
                                    map["FormatLongName"] = self.formatLongName!
                                }
                                if self.formatName != nil {
                                    map["FormatName"] = self.formatName!
                                }
                                if self.numPrograms != nil {
                                    map["NumPrograms"] = self.numPrograms!
                                }
                                if self.numStreams != nil {
                                    map["NumStreams"] = self.numStreams!
                                }
                                if self.size != nil {
                                    map["Size"] = self.size!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("FormatLongName") {
                                    self.formatLongName = dict["FormatLongName"] as! String
                                }
                                if dict.keys.contains("FormatName") {
                                    self.formatName = dict["FormatName"] as! String
                                }
                                if dict.keys.contains("NumPrograms") {
                                    self.numPrograms = dict["NumPrograms"] as! String
                                }
                                if dict.keys.contains("NumStreams") {
                                    self.numStreams = dict["NumStreams"] as! String
                                }
                                if dict.keys.contains("Size") {
                                    self.size = dict["Size"] as! String
                                }
                                if dict.keys.contains("StartTime") {
                                    self.startTime = dict["StartTime"] as! String
                                }
                            }
                        }
                        public class Streams : Tea.TeaModel {
                            public class AudioStreamList : Tea.TeaModel {
                                public class AudioStream : Tea.TeaModel {
                                    public var bitrate: String?

                                    public var channelLayout: String?

                                    public var channels: String?

                                    public var codecLongName: String?

                                    public var codecName: String?

                                    public var codecTag: String?

                                    public var codecTagString: String?

                                    public var codecTimeBase: String?

                                    public var duration: String?

                                    public var index: String?

                                    public var lang: String?

                                    public var numFrames: String?

                                    public var sampleFmt: String?

                                    public var samplerate: String?

                                    public var startTime: String?

                                    public var timebase: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.bitrate != nil {
                                            map["Bitrate"] = self.bitrate!
                                        }
                                        if self.channelLayout != nil {
                                            map["ChannelLayout"] = self.channelLayout!
                                        }
                                        if self.channels != nil {
                                            map["Channels"] = self.channels!
                                        }
                                        if self.codecLongName != nil {
                                            map["CodecLongName"] = self.codecLongName!
                                        }
                                        if self.codecName != nil {
                                            map["CodecName"] = self.codecName!
                                        }
                                        if self.codecTag != nil {
                                            map["CodecTag"] = self.codecTag!
                                        }
                                        if self.codecTagString != nil {
                                            map["CodecTagString"] = self.codecTagString!
                                        }
                                        if self.codecTimeBase != nil {
                                            map["CodecTimeBase"] = self.codecTimeBase!
                                        }
                                        if self.duration != nil {
                                            map["Duration"] = self.duration!
                                        }
                                        if self.index != nil {
                                            map["Index"] = self.index!
                                        }
                                        if self.lang != nil {
                                            map["Lang"] = self.lang!
                                        }
                                        if self.numFrames != nil {
                                            map["NumFrames"] = self.numFrames!
                                        }
                                        if self.sampleFmt != nil {
                                            map["SampleFmt"] = self.sampleFmt!
                                        }
                                        if self.samplerate != nil {
                                            map["Samplerate"] = self.samplerate!
                                        }
                                        if self.startTime != nil {
                                            map["StartTime"] = self.startTime!
                                        }
                                        if self.timebase != nil {
                                            map["Timebase"] = self.timebase!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Bitrate") {
                                            self.bitrate = dict["Bitrate"] as! String
                                        }
                                        if dict.keys.contains("ChannelLayout") {
                                            self.channelLayout = dict["ChannelLayout"] as! String
                                        }
                                        if dict.keys.contains("Channels") {
                                            self.channels = dict["Channels"] as! String
                                        }
                                        if dict.keys.contains("CodecLongName") {
                                            self.codecLongName = dict["CodecLongName"] as! String
                                        }
                                        if dict.keys.contains("CodecName") {
                                            self.codecName = dict["CodecName"] as! String
                                        }
                                        if dict.keys.contains("CodecTag") {
                                            self.codecTag = dict["CodecTag"] as! String
                                        }
                                        if dict.keys.contains("CodecTagString") {
                                            self.codecTagString = dict["CodecTagString"] as! String
                                        }
                                        if dict.keys.contains("CodecTimeBase") {
                                            self.codecTimeBase = dict["CodecTimeBase"] as! String
                                        }
                                        if dict.keys.contains("Duration") {
                                            self.duration = dict["Duration"] as! String
                                        }
                                        if dict.keys.contains("Index") {
                                            self.index = dict["Index"] as! String
                                        }
                                        if dict.keys.contains("Lang") {
                                            self.lang = dict["Lang"] as! String
                                        }
                                        if dict.keys.contains("NumFrames") {
                                            self.numFrames = dict["NumFrames"] as! String
                                        }
                                        if dict.keys.contains("SampleFmt") {
                                            self.sampleFmt = dict["SampleFmt"] as! String
                                        }
                                        if dict.keys.contains("Samplerate") {
                                            self.samplerate = dict["Samplerate"] as! String
                                        }
                                        if dict.keys.contains("StartTime") {
                                            self.startTime = dict["StartTime"] as! String
                                        }
                                        if dict.keys.contains("Timebase") {
                                            self.timebase = dict["Timebase"] as! String
                                        }
                                    }
                                }
                                public var audioStream: [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Streams.AudioStreamList.AudioStream]?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.audioStream != nil {
                                        var tmp : [Any] = []
                                        for k in self.audioStream! {
                                            tmp.append(k.toMap())
                                        }
                                        map["AudioStream"] = tmp
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("AudioStream") {
                                        var tmp : [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Streams.AudioStreamList.AudioStream] = []
                                        for v in dict["AudioStream"] as! [Any] {
                                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Streams.AudioStreamList.AudioStream()
                                            if v != nil {
                                                model.fromMap(v as! [String: Any])
                                            }
                                            tmp.append(model)
                                        }
                                        self.audioStream = tmp
                                    }
                                }
                            }
                            public class SubtitleStreamList : Tea.TeaModel {
                                public class SubtitleStream : Tea.TeaModel {
                                    public var index: String?

                                    public var lang: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.index != nil {
                                            map["Index"] = self.index!
                                        }
                                        if self.lang != nil {
                                            map["Lang"] = self.lang!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Index") {
                                            self.index = dict["Index"] as! String
                                        }
                                        if dict.keys.contains("Lang") {
                                            self.lang = dict["Lang"] as! String
                                        }
                                    }
                                }
                                public var subtitleStream: [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Streams.SubtitleStreamList.SubtitleStream]?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.subtitleStream != nil {
                                        var tmp : [Any] = []
                                        for k in self.subtitleStream! {
                                            tmp.append(k.toMap())
                                        }
                                        map["SubtitleStream"] = tmp
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("SubtitleStream") {
                                        var tmp : [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Streams.SubtitleStreamList.SubtitleStream] = []
                                        for v in dict["SubtitleStream"] as! [Any] {
                                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Streams.SubtitleStreamList.SubtitleStream()
                                            if v != nil {
                                                model.fromMap(v as! [String: Any])
                                            }
                                            tmp.append(model)
                                        }
                                        self.subtitleStream = tmp
                                    }
                                }
                            }
                            public class VideoStreamList : Tea.TeaModel {
                                public class VideoStream : Tea.TeaModel {
                                    public class NetworkCost : Tea.TeaModel {
                                        public var avgBitrate: String?

                                        public var costBandwidth: String?

                                        public var preloadTime: String?

                                        public override init() {
                                            super.init()
                                        }

                                        public init(_ dict: [String: Any]) {
                                            super.init()
                                            self.fromMap(dict)
                                        }

                                        public override func validate() throws -> Void {
                                        }

                                        public override func toMap() -> [String : Any] {
                                            var map = super.toMap()
                                            if self.avgBitrate != nil {
                                                map["AvgBitrate"] = self.avgBitrate!
                                            }
                                            if self.costBandwidth != nil {
                                                map["CostBandwidth"] = self.costBandwidth!
                                            }
                                            if self.preloadTime != nil {
                                                map["PreloadTime"] = self.preloadTime!
                                            }
                                            return map
                                        }

                                        public override func fromMap(_ dict: [String: Any]) -> Void {
                                            if dict.keys.contains("AvgBitrate") {
                                                self.avgBitrate = dict["AvgBitrate"] as! String
                                            }
                                            if dict.keys.contains("CostBandwidth") {
                                                self.costBandwidth = dict["CostBandwidth"] as! String
                                            }
                                            if dict.keys.contains("PreloadTime") {
                                                self.preloadTime = dict["PreloadTime"] as! String
                                            }
                                        }
                                    }
                                    public var avgFPS: String?

                                    public var bitrate: String?

                                    public var codecLongName: String?

                                    public var codecName: String?

                                    public var codecTag: String?

                                    public var codecTagString: String?

                                    public var codecTimeBase: String?

                                    public var dar: String?

                                    public var duration: String?

                                    public var fps: String?

                                    public var hasBFrames: String?

                                    public var height: String?

                                    public var index: String?

                                    public var lang: String?

                                    public var level: String?

                                    public var networkCost: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Streams.VideoStreamList.VideoStream.NetworkCost?

                                    public var numFrames: String?

                                    public var pixFmt: String?

                                    public var profile: String?

                                    public var sar: String?

                                    public var startTime: String?

                                    public var timebase: String?

                                    public var width: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                        try self.networkCost?.validate()
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.avgFPS != nil {
                                            map["AvgFPS"] = self.avgFPS!
                                        }
                                        if self.bitrate != nil {
                                            map["Bitrate"] = self.bitrate!
                                        }
                                        if self.codecLongName != nil {
                                            map["CodecLongName"] = self.codecLongName!
                                        }
                                        if self.codecName != nil {
                                            map["CodecName"] = self.codecName!
                                        }
                                        if self.codecTag != nil {
                                            map["CodecTag"] = self.codecTag!
                                        }
                                        if self.codecTagString != nil {
                                            map["CodecTagString"] = self.codecTagString!
                                        }
                                        if self.codecTimeBase != nil {
                                            map["CodecTimeBase"] = self.codecTimeBase!
                                        }
                                        if self.dar != nil {
                                            map["Dar"] = self.dar!
                                        }
                                        if self.duration != nil {
                                            map["Duration"] = self.duration!
                                        }
                                        if self.fps != nil {
                                            map["Fps"] = self.fps!
                                        }
                                        if self.hasBFrames != nil {
                                            map["HasBFrames"] = self.hasBFrames!
                                        }
                                        if self.height != nil {
                                            map["Height"] = self.height!
                                        }
                                        if self.index != nil {
                                            map["Index"] = self.index!
                                        }
                                        if self.lang != nil {
                                            map["Lang"] = self.lang!
                                        }
                                        if self.level != nil {
                                            map["Level"] = self.level!
                                        }
                                        if self.networkCost != nil {
                                            map["NetworkCost"] = self.networkCost?.toMap()
                                        }
                                        if self.numFrames != nil {
                                            map["NumFrames"] = self.numFrames!
                                        }
                                        if self.pixFmt != nil {
                                            map["PixFmt"] = self.pixFmt!
                                        }
                                        if self.profile != nil {
                                            map["Profile"] = self.profile!
                                        }
                                        if self.sar != nil {
                                            map["Sar"] = self.sar!
                                        }
                                        if self.startTime != nil {
                                            map["StartTime"] = self.startTime!
                                        }
                                        if self.timebase != nil {
                                            map["Timebase"] = self.timebase!
                                        }
                                        if self.width != nil {
                                            map["Width"] = self.width!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("AvgFPS") {
                                            self.avgFPS = dict["AvgFPS"] as! String
                                        }
                                        if dict.keys.contains("Bitrate") {
                                            self.bitrate = dict["Bitrate"] as! String
                                        }
                                        if dict.keys.contains("CodecLongName") {
                                            self.codecLongName = dict["CodecLongName"] as! String
                                        }
                                        if dict.keys.contains("CodecName") {
                                            self.codecName = dict["CodecName"] as! String
                                        }
                                        if dict.keys.contains("CodecTag") {
                                            self.codecTag = dict["CodecTag"] as! String
                                        }
                                        if dict.keys.contains("CodecTagString") {
                                            self.codecTagString = dict["CodecTagString"] as! String
                                        }
                                        if dict.keys.contains("CodecTimeBase") {
                                            self.codecTimeBase = dict["CodecTimeBase"] as! String
                                        }
                                        if dict.keys.contains("Dar") {
                                            self.dar = dict["Dar"] as! String
                                        }
                                        if dict.keys.contains("Duration") {
                                            self.duration = dict["Duration"] as! String
                                        }
                                        if dict.keys.contains("Fps") {
                                            self.fps = dict["Fps"] as! String
                                        }
                                        if dict.keys.contains("HasBFrames") {
                                            self.hasBFrames = dict["HasBFrames"] as! String
                                        }
                                        if dict.keys.contains("Height") {
                                            self.height = dict["Height"] as! String
                                        }
                                        if dict.keys.contains("Index") {
                                            self.index = dict["Index"] as! String
                                        }
                                        if dict.keys.contains("Lang") {
                                            self.lang = dict["Lang"] as! String
                                        }
                                        if dict.keys.contains("Level") {
                                            self.level = dict["Level"] as! String
                                        }
                                        if dict.keys.contains("NetworkCost") {
                                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Streams.VideoStreamList.VideoStream.NetworkCost()
                                            model.fromMap(dict["NetworkCost"] as! [String: Any])
                                            self.networkCost = model
                                        }
                                        if dict.keys.contains("NumFrames") {
                                            self.numFrames = dict["NumFrames"] as! String
                                        }
                                        if dict.keys.contains("PixFmt") {
                                            self.pixFmt = dict["PixFmt"] as! String
                                        }
                                        if dict.keys.contains("Profile") {
                                            self.profile = dict["Profile"] as! String
                                        }
                                        if dict.keys.contains("Sar") {
                                            self.sar = dict["Sar"] as! String
                                        }
                                        if dict.keys.contains("StartTime") {
                                            self.startTime = dict["StartTime"] as! String
                                        }
                                        if dict.keys.contains("Timebase") {
                                            self.timebase = dict["Timebase"] as! String
                                        }
                                        if dict.keys.contains("Width") {
                                            self.width = dict["Width"] as! String
                                        }
                                    }
                                }
                                public var videoStream: [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Streams.VideoStreamList.VideoStream]?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.videoStream != nil {
                                        var tmp : [Any] = []
                                        for k in self.videoStream! {
                                            tmp.append(k.toMap())
                                        }
                                        map["VideoStream"] = tmp
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("VideoStream") {
                                        var tmp : [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Streams.VideoStreamList.VideoStream] = []
                                        for v in dict["VideoStream"] as! [Any] {
                                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Streams.VideoStreamList.VideoStream()
                                            if v != nil {
                                                model.fromMap(v as! [String: Any])
                                            }
                                            tmp.append(model)
                                        }
                                        self.videoStream = tmp
                                    }
                                }
                            }
                            public var audioStreamList: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Streams.AudioStreamList?

                            public var subtitleStreamList: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Streams.SubtitleStreamList?

                            public var videoStreamList: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Streams.VideoStreamList?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.audioStreamList?.validate()
                                try self.subtitleStreamList?.validate()
                                try self.videoStreamList?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.audioStreamList != nil {
                                    map["AudioStreamList"] = self.audioStreamList?.toMap()
                                }
                                if self.subtitleStreamList != nil {
                                    map["SubtitleStreamList"] = self.subtitleStreamList?.toMap()
                                }
                                if self.videoStreamList != nil {
                                    map["VideoStreamList"] = self.videoStreamList?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AudioStreamList") {
                                    var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Streams.AudioStreamList()
                                    model.fromMap(dict["AudioStreamList"] as! [String: Any])
                                    self.audioStreamList = model
                                }
                                if dict.keys.contains("SubtitleStreamList") {
                                    var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Streams.SubtitleStreamList()
                                    model.fromMap(dict["SubtitleStreamList"] as! [String: Any])
                                    self.subtitleStreamList = model
                                }
                                if dict.keys.contains("VideoStreamList") {
                                    var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Streams.VideoStreamList()
                                    model.fromMap(dict["VideoStreamList"] as! [String: Any])
                                    self.videoStreamList = model
                                }
                            }
                        }
                        public var bitrate: String?

                        public var duration: String?

                        public var fileFormat: String?

                        public var fileSize: String?

                        public var format: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Format?

                        public var fps: String?

                        public var height: String?

                        public var streams: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Streams?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.format?.validate()
                            try self.streams?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.fileFormat != nil {
                                map["FileFormat"] = self.fileFormat!
                            }
                            if self.fileSize != nil {
                                map["FileSize"] = self.fileSize!
                            }
                            if self.format != nil {
                                map["Format"] = self.format?.toMap()
                            }
                            if self.fps != nil {
                                map["Fps"] = self.fps!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.streams != nil {
                                map["Streams"] = self.streams?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("FileFormat") {
                                self.fileFormat = dict["FileFormat"] as! String
                            }
                            if dict.keys.contains("FileSize") {
                                self.fileSize = dict["FileSize"] as! String
                            }
                            if dict.keys.contains("Format") {
                                var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Format()
                                model.fromMap(dict["Format"] as! [String: Any])
                                self.format = model
                            }
                            if dict.keys.contains("Fps") {
                                self.fps = dict["Fps"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("Streams") {
                                var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties.Streams()
                                model.fromMap(dict["Streams"] as! [String: Any])
                                self.streams = model
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public class SubtitleConfig : Tea.TeaModel {
                        public class ExtSubtitleList : Tea.TeaModel {
                            public class ExtSubtitle : Tea.TeaModel {
                                public class Input : Tea.TeaModel {
                                    public var bucket: String?

                                    public var location: String?

                                    public var object: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.bucket != nil {
                                            map["Bucket"] = self.bucket!
                                        }
                                        if self.location != nil {
                                            map["Location"] = self.location!
                                        }
                                        if self.object != nil {
                                            map["Object"] = self.object!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Bucket") {
                                            self.bucket = dict["Bucket"] as! String
                                        }
                                        if dict.keys.contains("Location") {
                                            self.location = dict["Location"] as! String
                                        }
                                        if dict.keys.contains("Object") {
                                            self.object = dict["Object"] as! String
                                        }
                                    }
                                }
                                public var charEnc: String?

                                public var fontName: String?

                                public var input: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.SubtitleConfig.ExtSubtitleList.ExtSubtitle.Input?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                    try self.input?.validate()
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.charEnc != nil {
                                        map["CharEnc"] = self.charEnc!
                                    }
                                    if self.fontName != nil {
                                        map["FontName"] = self.fontName!
                                    }
                                    if self.input != nil {
                                        map["Input"] = self.input?.toMap()
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("CharEnc") {
                                        self.charEnc = dict["CharEnc"] as! String
                                    }
                                    if dict.keys.contains("FontName") {
                                        self.fontName = dict["FontName"] as! String
                                    }
                                    if dict.keys.contains("Input") {
                                        var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.SubtitleConfig.ExtSubtitleList.ExtSubtitle.Input()
                                        model.fromMap(dict["Input"] as! [String: Any])
                                        self.input = model
                                    }
                                }
                            }
                            public var extSubtitle: [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.SubtitleConfig.ExtSubtitleList.ExtSubtitle]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.extSubtitle != nil {
                                    var tmp : [Any] = []
                                    for k in self.extSubtitle! {
                                        tmp.append(k.toMap())
                                    }
                                    map["ExtSubtitle"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("ExtSubtitle") {
                                    var tmp : [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.SubtitleConfig.ExtSubtitleList.ExtSubtitle] = []
                                    for v in dict["ExtSubtitle"] as! [Any] {
                                        var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.SubtitleConfig.ExtSubtitleList.ExtSubtitle()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.extSubtitle = tmp
                                }
                            }
                        }
                        public class SubtitleList : Tea.TeaModel {
                            public class Subtitle : Tea.TeaModel {
                                public var map: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.map != nil {
                                        map["Map"] = self.map!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Map") {
                                        self.map = dict["Map"] as! String
                                    }
                                }
                            }
                            public var subtitle: [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.SubtitleConfig.SubtitleList.Subtitle]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.subtitle != nil {
                                    var tmp : [Any] = []
                                    for k in self.subtitle! {
                                        tmp.append(k.toMap())
                                    }
                                    map["Subtitle"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Subtitle") {
                                    var tmp : [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.SubtitleConfig.SubtitleList.Subtitle] = []
                                    for v in dict["Subtitle"] as! [Any] {
                                        var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.SubtitleConfig.SubtitleList.Subtitle()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.subtitle = tmp
                                }
                            }
                        }
                        public var extSubtitleList: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.SubtitleConfig.ExtSubtitleList?

                        public var subtitleList: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.SubtitleConfig.SubtitleList?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.extSubtitleList?.validate()
                            try self.subtitleList?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.extSubtitleList != nil {
                                map["ExtSubtitleList"] = self.extSubtitleList?.toMap()
                            }
                            if self.subtitleList != nil {
                                map["SubtitleList"] = self.subtitleList?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ExtSubtitleList") {
                                var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.SubtitleConfig.ExtSubtitleList()
                                model.fromMap(dict["ExtSubtitleList"] as! [String: Any])
                                self.extSubtitleList = model
                            }
                            if dict.keys.contains("SubtitleList") {
                                var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.SubtitleConfig.SubtitleList()
                                model.fromMap(dict["SubtitleList"] as! [String: Any])
                                self.subtitleList = model
                            }
                        }
                    }
                    public class SuperReso : Tea.TeaModel {
                        public var isHalfSample: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.isHalfSample != nil {
                                map["IsHalfSample"] = self.isHalfSample!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("IsHalfSample") {
                                self.isHalfSample = dict["IsHalfSample"] as! String
                            }
                        }
                    }
                    public class TransConfig : Tea.TeaModel {
                        public var adjDarMethod: String?

                        public var duration: String?

                        public var isCheckAudioBitrate: String?

                        public var isCheckAudioBitrateFail: String?

                        public var isCheckReso: String?

                        public var isCheckResoFail: String?

                        public var isCheckVideoBitrate: String?

                        public var isCheckVideoBitrateFail: String?

                        public var transMode: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adjDarMethod != nil {
                                map["AdjDarMethod"] = self.adjDarMethod!
                            }
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.isCheckAudioBitrate != nil {
                                map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                            }
                            if self.isCheckAudioBitrateFail != nil {
                                map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                            }
                            if self.isCheckReso != nil {
                                map["IsCheckReso"] = self.isCheckReso!
                            }
                            if self.isCheckResoFail != nil {
                                map["IsCheckResoFail"] = self.isCheckResoFail!
                            }
                            if self.isCheckVideoBitrate != nil {
                                map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                            }
                            if self.isCheckVideoBitrateFail != nil {
                                map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                            }
                            if self.transMode != nil {
                                map["TransMode"] = self.transMode!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AdjDarMethod") {
                                self.adjDarMethod = dict["AdjDarMethod"] as! String
                            }
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("IsCheckAudioBitrate") {
                                self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                            }
                            if dict.keys.contains("IsCheckAudioBitrateFail") {
                                self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                            }
                            if dict.keys.contains("IsCheckReso") {
                                self.isCheckReso = dict["IsCheckReso"] as! String
                            }
                            if dict.keys.contains("IsCheckResoFail") {
                                self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                            }
                            if dict.keys.contains("IsCheckVideoBitrate") {
                                self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                            }
                            if dict.keys.contains("IsCheckVideoBitrateFail") {
                                self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                            }
                            if dict.keys.contains("TransMode") {
                                self.transMode = dict["TransMode"] as! String
                            }
                        }
                    }
                    public class Video : Tea.TeaModel {
                        public class BitrateBnd : Tea.TeaModel {
                            public var max: String?

                            public var min: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.max != nil {
                                    map["Max"] = self.max!
                                }
                                if self.min != nil {
                                    map["Min"] = self.min!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Max") {
                                    self.max = dict["Max"] as! String
                                }
                                if dict.keys.contains("Min") {
                                    self.min = dict["Min"] as! String
                                }
                            }
                        }
                        public var bitrate: String?

                        public var bitrateBnd: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Video.BitrateBnd?

                        public var bufsize: String?

                        public var codec: String?

                        public var crf: String?

                        public var crop: String?

                        public var degrain: String?

                        public var fps: String?

                        public var gop: String?

                        public var height: String?

                        public var maxFps: String?

                        public var maxrate: String?

                        public var pad: String?

                        public var pixFmt: String?

                        public var preset: String?

                        public var profile: String?

                        public var qscale: String?

                        public var scanMode: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.bitrateBnd?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.bitrateBnd != nil {
                                map["BitrateBnd"] = self.bitrateBnd?.toMap()
                            }
                            if self.bufsize != nil {
                                map["Bufsize"] = self.bufsize!
                            }
                            if self.codec != nil {
                                map["Codec"] = self.codec!
                            }
                            if self.crf != nil {
                                map["Crf"] = self.crf!
                            }
                            if self.crop != nil {
                                map["Crop"] = self.crop!
                            }
                            if self.degrain != nil {
                                map["Degrain"] = self.degrain!
                            }
                            if self.fps != nil {
                                map["Fps"] = self.fps!
                            }
                            if self.gop != nil {
                                map["Gop"] = self.gop!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.maxFps != nil {
                                map["MaxFps"] = self.maxFps!
                            }
                            if self.maxrate != nil {
                                map["Maxrate"] = self.maxrate!
                            }
                            if self.pad != nil {
                                map["Pad"] = self.pad!
                            }
                            if self.pixFmt != nil {
                                map["PixFmt"] = self.pixFmt!
                            }
                            if self.preset != nil {
                                map["Preset"] = self.preset!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.qscale != nil {
                                map["Qscale"] = self.qscale!
                            }
                            if self.scanMode != nil {
                                map["ScanMode"] = self.scanMode!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("BitrateBnd") {
                                var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Video.BitrateBnd()
                                model.fromMap(dict["BitrateBnd"] as! [String: Any])
                                self.bitrateBnd = model
                            }
                            if dict.keys.contains("Bufsize") {
                                self.bufsize = dict["Bufsize"] as! String
                            }
                            if dict.keys.contains("Codec") {
                                self.codec = dict["Codec"] as! String
                            }
                            if dict.keys.contains("Crf") {
                                self.crf = dict["Crf"] as! String
                            }
                            if dict.keys.contains("Crop") {
                                self.crop = dict["Crop"] as! String
                            }
                            if dict.keys.contains("Degrain") {
                                self.degrain = dict["Degrain"] as! String
                            }
                            if dict.keys.contains("Fps") {
                                self.fps = dict["Fps"] as! String
                            }
                            if dict.keys.contains("Gop") {
                                self.gop = dict["Gop"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("MaxFps") {
                                self.maxFps = dict["MaxFps"] as! String
                            }
                            if dict.keys.contains("Maxrate") {
                                self.maxrate = dict["Maxrate"] as! String
                            }
                            if dict.keys.contains("Pad") {
                                self.pad = dict["Pad"] as! String
                            }
                            if dict.keys.contains("PixFmt") {
                                self.pixFmt = dict["PixFmt"] as! String
                            }
                            if dict.keys.contains("Preset") {
                                self.preset = dict["Preset"] as! String
                            }
                            if dict.keys.contains("Profile") {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Qscale") {
                                self.qscale = dict["Qscale"] as! String
                            }
                            if dict.keys.contains("ScanMode") {
                                self.scanMode = dict["ScanMode"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public class WaterMarkList : Tea.TeaModel {
                        public class WaterMark : Tea.TeaModel {
                            public class InputFile : Tea.TeaModel {
                                public var bucket: String?

                                public var location: String?

                                public var object: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.bucket != nil {
                                        map["Bucket"] = self.bucket!
                                    }
                                    if self.location != nil {
                                        map["Location"] = self.location!
                                    }
                                    if self.object != nil {
                                        map["Object"] = self.object!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Bucket") {
                                        self.bucket = dict["Bucket"] as! String
                                    }
                                    if dict.keys.contains("Location") {
                                        self.location = dict["Location"] as! String
                                    }
                                    if dict.keys.contains("Object") {
                                        self.object = dict["Object"] as! String
                                    }
                                }
                            }
                            public var dx: String?

                            public var dy: String?

                            public var height: String?

                            public var inputFile: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.WaterMarkList.WaterMark.InputFile?

                            public var referPos: String?

                            public var type: String?

                            public var waterMarkTemplateId: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.inputFile?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.dx != nil {
                                    map["Dx"] = self.dx!
                                }
                                if self.dy != nil {
                                    map["Dy"] = self.dy!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.inputFile != nil {
                                    map["InputFile"] = self.inputFile?.toMap()
                                }
                                if self.referPos != nil {
                                    map["ReferPos"] = self.referPos!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                if self.waterMarkTemplateId != nil {
                                    map["WaterMarkTemplateId"] = self.waterMarkTemplateId!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Dx") {
                                    self.dx = dict["Dx"] as! String
                                }
                                if dict.keys.contains("Dy") {
                                    self.dy = dict["Dy"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("InputFile") {
                                    var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.WaterMarkList.WaterMark.InputFile()
                                    model.fromMap(dict["InputFile"] as! [String: Any])
                                    self.inputFile = model
                                }
                                if dict.keys.contains("ReferPos") {
                                    self.referPos = dict["ReferPos"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                                if dict.keys.contains("WaterMarkTemplateId") {
                                    self.waterMarkTemplateId = dict["WaterMarkTemplateId"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var waterMark: [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.WaterMarkList.WaterMark]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.waterMark != nil {
                                var tmp : [Any] = []
                                for k in self.waterMark! {
                                    tmp.append(k.toMap())
                                }
                                map["WaterMark"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("WaterMark") {
                                var tmp : [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.WaterMarkList.WaterMark] = []
                                for v in dict["WaterMark"] as! [Any] {
                                    var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.WaterMarkList.WaterMark()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.waterMark = tmp
                            }
                        }
                    }
                    public var audio: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Audio?

                    public var audioStreamMap: String?

                    public var clip: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Clip?

                    public var container: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Container?

                    public var deWatermark: String?

                    public var digiWaterMark: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.DigiWaterMark?

                    public var editing: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing?

                    public var encryption: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Encryption?

                    public var m3U8NonStandardSupport: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.M3U8NonStandardSupport?

                    public var mergeConfigUrl: String?

                    public var mergeList: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.MergeList?

                    public var muxConfig: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.MuxConfig?

                    public var outputFile: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.OutputFile?

                    public var priority: String?

                    public var properties: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties?

                    public var rotate: String?

                    public var subtitleConfig: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.SubtitleConfig?

                    public var superReso: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.SuperReso?

                    public var templateId: String?

                    public var transConfig: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.TransConfig?

                    public var userData: String?

                    public var video: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Video?

                    public var videoStreamMap: String?

                    public var waterMarkConfigUrl: String?

                    public var waterMarkList: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.WaterMarkList?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.audio?.validate()
                        try self.clip?.validate()
                        try self.container?.validate()
                        try self.digiWaterMark?.validate()
                        try self.editing?.validate()
                        try self.encryption?.validate()
                        try self.m3U8NonStandardSupport?.validate()
                        try self.mergeList?.validate()
                        try self.muxConfig?.validate()
                        try self.outputFile?.validate()
                        try self.properties?.validate()
                        try self.subtitleConfig?.validate()
                        try self.superReso?.validate()
                        try self.transConfig?.validate()
                        try self.video?.validate()
                        try self.waterMarkList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audio != nil {
                            map["Audio"] = self.audio?.toMap()
                        }
                        if self.audioStreamMap != nil {
                            map["AudioStreamMap"] = self.audioStreamMap!
                        }
                        if self.clip != nil {
                            map["Clip"] = self.clip?.toMap()
                        }
                        if self.container != nil {
                            map["Container"] = self.container?.toMap()
                        }
                        if self.deWatermark != nil {
                            map["DeWatermark"] = self.deWatermark!
                        }
                        if self.digiWaterMark != nil {
                            map["DigiWaterMark"] = self.digiWaterMark?.toMap()
                        }
                        if self.editing != nil {
                            map["Editing"] = self.editing?.toMap()
                        }
                        if self.encryption != nil {
                            map["Encryption"] = self.encryption?.toMap()
                        }
                        if self.m3U8NonStandardSupport != nil {
                            map["M3U8NonStandardSupport"] = self.m3U8NonStandardSupport?.toMap()
                        }
                        if self.mergeConfigUrl != nil {
                            map["MergeConfigUrl"] = self.mergeConfigUrl!
                        }
                        if self.mergeList != nil {
                            map["MergeList"] = self.mergeList?.toMap()
                        }
                        if self.muxConfig != nil {
                            map["MuxConfig"] = self.muxConfig?.toMap()
                        }
                        if self.outputFile != nil {
                            map["OutputFile"] = self.outputFile?.toMap()
                        }
                        if self.priority != nil {
                            map["Priority"] = self.priority!
                        }
                        if self.properties != nil {
                            map["Properties"] = self.properties?.toMap()
                        }
                        if self.rotate != nil {
                            map["Rotate"] = self.rotate!
                        }
                        if self.subtitleConfig != nil {
                            map["SubtitleConfig"] = self.subtitleConfig?.toMap()
                        }
                        if self.superReso != nil {
                            map["SuperReso"] = self.superReso?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        if self.transConfig != nil {
                            map["TransConfig"] = self.transConfig?.toMap()
                        }
                        if self.userData != nil {
                            map["UserData"] = self.userData!
                        }
                        if self.video != nil {
                            map["Video"] = self.video?.toMap()
                        }
                        if self.videoStreamMap != nil {
                            map["VideoStreamMap"] = self.videoStreamMap!
                        }
                        if self.waterMarkConfigUrl != nil {
                            map["WaterMarkConfigUrl"] = self.waterMarkConfigUrl!
                        }
                        if self.waterMarkList != nil {
                            map["WaterMarkList"] = self.waterMarkList?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Audio") {
                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Audio()
                            model.fromMap(dict["Audio"] as! [String: Any])
                            self.audio = model
                        }
                        if dict.keys.contains("AudioStreamMap") {
                            self.audioStreamMap = dict["AudioStreamMap"] as! String
                        }
                        if dict.keys.contains("Clip") {
                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Clip()
                            model.fromMap(dict["Clip"] as! [String: Any])
                            self.clip = model
                        }
                        if dict.keys.contains("Container") {
                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Container()
                            model.fromMap(dict["Container"] as! [String: Any])
                            self.container = model
                        }
                        if dict.keys.contains("DeWatermark") {
                            self.deWatermark = dict["DeWatermark"] as! String
                        }
                        if dict.keys.contains("DigiWaterMark") {
                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.DigiWaterMark()
                            model.fromMap(dict["DigiWaterMark"] as! [String: Any])
                            self.digiWaterMark = model
                        }
                        if dict.keys.contains("Editing") {
                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Editing()
                            model.fromMap(dict["Editing"] as! [String: Any])
                            self.editing = model
                        }
                        if dict.keys.contains("Encryption") {
                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Encryption()
                            model.fromMap(dict["Encryption"] as! [String: Any])
                            self.encryption = model
                        }
                        if dict.keys.contains("M3U8NonStandardSupport") {
                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.M3U8NonStandardSupport()
                            model.fromMap(dict["M3U8NonStandardSupport"] as! [String: Any])
                            self.m3U8NonStandardSupport = model
                        }
                        if dict.keys.contains("MergeConfigUrl") {
                            self.mergeConfigUrl = dict["MergeConfigUrl"] as! String
                        }
                        if dict.keys.contains("MergeList") {
                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.MergeList()
                            model.fromMap(dict["MergeList"] as! [String: Any])
                            self.mergeList = model
                        }
                        if dict.keys.contains("MuxConfig") {
                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.MuxConfig()
                            model.fromMap(dict["MuxConfig"] as! [String: Any])
                            self.muxConfig = model
                        }
                        if dict.keys.contains("OutputFile") {
                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.OutputFile()
                            model.fromMap(dict["OutputFile"] as! [String: Any])
                            self.outputFile = model
                        }
                        if dict.keys.contains("Priority") {
                            self.priority = dict["Priority"] as! String
                        }
                        if dict.keys.contains("Properties") {
                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Properties()
                            model.fromMap(dict["Properties"] as! [String: Any])
                            self.properties = model
                        }
                        if dict.keys.contains("Rotate") {
                            self.rotate = dict["Rotate"] as! String
                        }
                        if dict.keys.contains("SubtitleConfig") {
                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.SubtitleConfig()
                            model.fromMap(dict["SubtitleConfig"] as! [String: Any])
                            self.subtitleConfig = model
                        }
                        if dict.keys.contains("SuperReso") {
                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.SuperReso()
                            model.fromMap(dict["SuperReso"] as! [String: Any])
                            self.superReso = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                        if dict.keys.contains("TransConfig") {
                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.TransConfig()
                            model.fromMap(dict["TransConfig"] as! [String: Any])
                            self.transConfig = model
                        }
                        if dict.keys.contains("UserData") {
                            self.userData = dict["UserData"] as! String
                        }
                        if dict.keys.contains("Video") {
                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.Video()
                            model.fromMap(dict["Video"] as! [String: Any])
                            self.video = model
                        }
                        if dict.keys.contains("VideoStreamMap") {
                            self.videoStreamMap = dict["VideoStreamMap"] as! String
                        }
                        if dict.keys.contains("WaterMarkConfigUrl") {
                            self.waterMarkConfigUrl = dict["WaterMarkConfigUrl"] as! String
                        }
                        if dict.keys.contains("WaterMarkList") {
                            var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig.WaterMarkList()
                            model.fromMap(dict["WaterMarkList"] as! [String: Any])
                            self.waterMarkList = model
                        }
                    }
                }
                public class EditingInputs : Tea.TeaModel {
                    public class EditingInput : Tea.TeaModel {
                        public class InputConfig : Tea.TeaModel {
                            public var deinterlaceMethod: String?

                            public var isNormalSar: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.deinterlaceMethod != nil {
                                    map["DeinterlaceMethod"] = self.deinterlaceMethod!
                                }
                                if self.isNormalSar != nil {
                                    map["IsNormalSar"] = self.isNormalSar!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("DeinterlaceMethod") {
                                    self.deinterlaceMethod = dict["DeinterlaceMethod"] as! String
                                }
                                if dict.keys.contains("IsNormalSar") {
                                    self.isNormalSar = dict["IsNormalSar"] as! String
                                }
                            }
                        }
                        public class InputFile : Tea.TeaModel {
                            public var bucket: String?

                            public var location: String?

                            public var object: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bucket != nil {
                                    map["Bucket"] = self.bucket!
                                }
                                if self.location != nil {
                                    map["Location"] = self.location!
                                }
                                if self.object != nil {
                                    map["Object"] = self.object!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bucket") {
                                    self.bucket = dict["Bucket"] as! String
                                }
                                if dict.keys.contains("Location") {
                                    self.location = dict["Location"] as! String
                                }
                                if dict.keys.contains("Object") {
                                    self.object = dict["Object"] as! String
                                }
                            }
                        }
                        public var id: String?

                        public var inputConfig: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingInputs.EditingInput.InputConfig?

                        public var inputFile: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingInputs.EditingInput.InputFile?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.inputConfig?.validate()
                            try self.inputFile?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.id != nil {
                                map["Id"] = self.id!
                            }
                            if self.inputConfig != nil {
                                map["InputConfig"] = self.inputConfig?.toMap()
                            }
                            if self.inputFile != nil {
                                map["InputFile"] = self.inputFile?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Id") {
                                self.id = dict["Id"] as! String
                            }
                            if dict.keys.contains("InputConfig") {
                                var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingInputs.EditingInput.InputConfig()
                                model.fromMap(dict["InputConfig"] as! [String: Any])
                                self.inputConfig = model
                            }
                            if dict.keys.contains("InputFile") {
                                var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingInputs.EditingInput.InputFile()
                                model.fromMap(dict["InputFile"] as! [String: Any])
                                self.inputFile = model
                            }
                        }
                    }
                    public var editingInput: [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingInputs.EditingInput]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.editingInput != nil {
                            var tmp : [Any] = []
                            for k in self.editingInput! {
                                tmp.append(k.toMap())
                            }
                            map["EditingInput"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EditingInput") {
                            var tmp : [SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingInputs.EditingInput] = []
                            for v in dict["EditingInput"] as! [Any] {
                                var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingInputs.EditingInput()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.editingInput = tmp
                        }
                    }
                }
                public class MNSMessageResult : Tea.TeaModel {
                    public var errorCode: String?

                    public var errorMessage: String?

                    public var messageId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.errorCode != nil {
                            map["ErrorCode"] = self.errorCode!
                        }
                        if self.errorMessage != nil {
                            map["ErrorMessage"] = self.errorMessage!
                        }
                        if self.messageId != nil {
                            map["MessageId"] = self.messageId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ErrorCode") {
                            self.errorCode = dict["ErrorCode"] as! String
                        }
                        if dict.keys.contains("ErrorMessage") {
                            self.errorMessage = dict["ErrorMessage"] as! String
                        }
                        if dict.keys.contains("MessageId") {
                            self.messageId = dict["MessageId"] as! String
                        }
                    }
                }
                public var code: String?

                public var creationTime: String?

                public var editingConfig: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig?

                public var editingInputs: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingInputs?

                public var finishTime: String?

                public var jobId: String?

                public var MNSMessageResult: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.MNSMessageResult?

                public var message: String?

                public var percent: Int64?

                public var pipelineId: String?

                public var state: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.editingConfig?.validate()
                    try self.editingInputs?.validate()
                    try self.MNSMessageResult?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.creationTime != nil {
                        map["CreationTime"] = self.creationTime!
                    }
                    if self.editingConfig != nil {
                        map["EditingConfig"] = self.editingConfig?.toMap()
                    }
                    if self.editingInputs != nil {
                        map["EditingInputs"] = self.editingInputs?.toMap()
                    }
                    if self.finishTime != nil {
                        map["FinishTime"] = self.finishTime!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.MNSMessageResult != nil {
                        map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.pipelineId != nil {
                        map["PipelineId"] = self.pipelineId!
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! String
                    }
                    if dict.keys.contains("CreationTime") {
                        self.creationTime = dict["CreationTime"] as! String
                    }
                    if dict.keys.contains("EditingConfig") {
                        var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingConfig()
                        model.fromMap(dict["EditingConfig"] as! [String: Any])
                        self.editingConfig = model
                    }
                    if dict.keys.contains("EditingInputs") {
                        var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.EditingInputs()
                        model.fromMap(dict["EditingInputs"] as! [String: Any])
                        self.editingInputs = model
                    }
                    if dict.keys.contains("FinishTime") {
                        self.finishTime = dict["FinishTime"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("MNSMessageResult") {
                        var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job.MNSMessageResult()
                        model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                        self.MNSMessageResult = model
                    }
                    if dict.keys.contains("Message") {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! Int64
                    }
                    if dict.keys.contains("PipelineId") {
                        self.pipelineId = dict["PipelineId"] as! String
                    }
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! String
                    }
                }
            }
            public var code: String?

            public var job: SubmitEditingJobsResponseBody.JobResultList.JobResult.Job?

            public var message: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.job?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.job != nil {
                    map["Job"] = self.job?.toMap()
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Job") {
                    var model = SubmitEditingJobsResponseBody.JobResultList.JobResult.Job()
                    model.fromMap(dict["Job"] as! [String: Any])
                    self.job = model
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Success") {
                    self.success = dict["Success"] as! Bool
                }
            }
        }
        public var jobResult: [SubmitEditingJobsResponseBody.JobResultList.JobResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobResult != nil {
                var tmp : [Any] = []
                for k in self.jobResult! {
                    tmp.append(k.toMap())
                }
                map["JobResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobResult") {
                var tmp : [SubmitEditingJobsResponseBody.JobResultList.JobResult] = []
                for v in dict["JobResult"] as! [Any] {
                    var model = SubmitEditingJobsResponseBody.JobResultList.JobResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.jobResult = tmp
            }
        }
    }
    public var jobResultList: SubmitEditingJobsResponseBody.JobResultList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobResultList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobResultList != nil {
            map["JobResultList"] = self.jobResultList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobResultList") {
            var model = SubmitEditingJobsResponseBody.JobResultList()
            model.fromMap(dict["JobResultList"] as! [String: Any])
            self.jobResultList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitEditingJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitEditingJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitEditingJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitJobsRequest : Tea.TeaModel {
    public var input: String?

    public var outputBucket: String?

    public var outputLocation: String?

    public var outputs: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.outputBucket != nil {
            map["OutputBucket"] = self.outputBucket!
        }
        if self.outputLocation != nil {
            map["OutputLocation"] = self.outputLocation!
        }
        if self.outputs != nil {
            map["Outputs"] = self.outputs!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("OutputBucket") {
            self.outputBucket = dict["OutputBucket"] as! String
        }
        if dict.keys.contains("OutputLocation") {
            self.outputLocation = dict["OutputLocation"] as! String
        }
        if dict.keys.contains("Outputs") {
            self.outputs = dict["Outputs"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class SubmitJobsResponseBody : Tea.TeaModel {
    public class JobResultList : Tea.TeaModel {
        public class JobResult : Tea.TeaModel {
            public class Job : Tea.TeaModel {
                public class Input : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                    }
                }
                public class MNSMessageResult : Tea.TeaModel {
                    public var errorCode: String?

                    public var errorMessage: String?

                    public var messageId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.errorCode != nil {
                            map["ErrorCode"] = self.errorCode!
                        }
                        if self.errorMessage != nil {
                            map["ErrorMessage"] = self.errorMessage!
                        }
                        if self.messageId != nil {
                            map["MessageId"] = self.messageId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ErrorCode") {
                            self.errorCode = dict["ErrorCode"] as! String
                        }
                        if dict.keys.contains("ErrorMessage") {
                            self.errorMessage = dict["ErrorMessage"] as! String
                        }
                        if dict.keys.contains("MessageId") {
                            self.messageId = dict["MessageId"] as! String
                        }
                    }
                }
                public class Output : Tea.TeaModel {
                    public class AmixList : Tea.TeaModel {
                        public class Amix : Tea.TeaModel {
                            public var amixURL: String?

                            public var duration: String?

                            public var map: String?

                            public var mixDurMode: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.amixURL != nil {
                                    map["AmixURL"] = self.amixURL!
                                }
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.map != nil {
                                    map["Map"] = self.map!
                                }
                                if self.mixDurMode != nil {
                                    map["MixDurMode"] = self.mixDurMode!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AmixURL") {
                                    self.amixURL = dict["AmixURL"] as! String
                                }
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Map") {
                                    self.map = dict["Map"] as! String
                                }
                                if dict.keys.contains("MixDurMode") {
                                    self.mixDurMode = dict["MixDurMode"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var amix: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.AmixList.Amix]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.amix != nil {
                                var tmp : [Any] = []
                                for k in self.amix! {
                                    tmp.append(k.toMap())
                                }
                                map["Amix"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Amix") {
                                var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.AmixList.Amix] = []
                                for v in dict["Amix"] as! [Any] {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.AmixList.Amix()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.amix = tmp
                            }
                        }
                    }
                    public class Audio : Tea.TeaModel {
                        public class Volume : Tea.TeaModel {
                            public var level: String?

                            public var method: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.level != nil {
                                    map["Level"] = self.level!
                                }
                                if self.method != nil {
                                    map["Method"] = self.method!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Level") {
                                    self.level = dict["Level"] as! String
                                }
                                if dict.keys.contains("Method") {
                                    self.method = dict["Method"] as! String
                                }
                            }
                        }
                        public var bitrate: String?

                        public var channels: String?

                        public var codec: String?

                        public var profile: String?

                        public var qscale: String?

                        public var samplerate: String?

                        public var volume: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Audio.Volume?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.volume?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.channels != nil {
                                map["Channels"] = self.channels!
                            }
                            if self.codec != nil {
                                map["Codec"] = self.codec!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.qscale != nil {
                                map["Qscale"] = self.qscale!
                            }
                            if self.samplerate != nil {
                                map["Samplerate"] = self.samplerate!
                            }
                            if self.volume != nil {
                                map["Volume"] = self.volume?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Channels") {
                                self.channels = dict["Channels"] as! String
                            }
                            if dict.keys.contains("Codec") {
                                self.codec = dict["Codec"] as! String
                            }
                            if dict.keys.contains("Profile") {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Qscale") {
                                self.qscale = dict["Qscale"] as! String
                            }
                            if dict.keys.contains("Samplerate") {
                                self.samplerate = dict["Samplerate"] as! String
                            }
                            if dict.keys.contains("Volume") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Audio.Volume()
                                model.fromMap(dict["Volume"] as! [String: Any])
                                self.volume = model
                            }
                        }
                    }
                    public class Clip : Tea.TeaModel {
                        public class TimeSpan : Tea.TeaModel {
                            public var duration: String?

                            public var seek: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.seek != nil {
                                    map["Seek"] = self.seek!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Seek") {
                                    self.seek = dict["Seek"] as! String
                                }
                            }
                        }
                        public var timeSpan: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Clip.TimeSpan?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.timeSpan?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.timeSpan != nil {
                                map["TimeSpan"] = self.timeSpan?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("TimeSpan") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Clip.TimeSpan()
                                model.fromMap(dict["TimeSpan"] as! [String: Any])
                                self.timeSpan = model
                            }
                        }
                    }
                    public class Container : Tea.TeaModel {
                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public class DigiWaterMark : Tea.TeaModel {
                        public class InputFile : Tea.TeaModel {
                            public var bucket: String?

                            public var location: String?

                            public var object: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bucket != nil {
                                    map["Bucket"] = self.bucket!
                                }
                                if self.location != nil {
                                    map["Location"] = self.location!
                                }
                                if self.object != nil {
                                    map["Object"] = self.object!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bucket") {
                                    self.bucket = dict["Bucket"] as! String
                                }
                                if dict.keys.contains("Location") {
                                    self.location = dict["Location"] as! String
                                }
                                if dict.keys.contains("Object") {
                                    self.object = dict["Object"] as! String
                                }
                            }
                        }
                        public var alpha: String?

                        public var inputFile: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.DigiWaterMark.InputFile?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.inputFile?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.alpha != nil {
                                map["Alpha"] = self.alpha!
                            }
                            if self.inputFile != nil {
                                map["InputFile"] = self.inputFile?.toMap()
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Alpha") {
                                self.alpha = dict["Alpha"] as! String
                            }
                            if dict.keys.contains("InputFile") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.DigiWaterMark.InputFile()
                                model.fromMap(dict["InputFile"] as! [String: Any])
                                self.inputFile = model
                            }
                            if dict.keys.contains("Type") {
                                self.type = dict["Type"] as! String
                            }
                        }
                    }
                    public class Encryption : Tea.TeaModel {
                        public var id: String?

                        public var key: String?

                        public var keyType: String?

                        public var keyUri: String?

                        public var skipCnt: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.id != nil {
                                map["Id"] = self.id!
                            }
                            if self.key != nil {
                                map["Key"] = self.key!
                            }
                            if self.keyType != nil {
                                map["KeyType"] = self.keyType!
                            }
                            if self.keyUri != nil {
                                map["KeyUri"] = self.keyUri!
                            }
                            if self.skipCnt != nil {
                                map["SkipCnt"] = self.skipCnt!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Id") {
                                self.id = dict["Id"] as! String
                            }
                            if dict.keys.contains("Key") {
                                self.key = dict["Key"] as! String
                            }
                            if dict.keys.contains("KeyType") {
                                self.keyType = dict["KeyType"] as! String
                            }
                            if dict.keys.contains("KeyUri") {
                                self.keyUri = dict["KeyUri"] as! String
                            }
                            if dict.keys.contains("SkipCnt") {
                                self.skipCnt = dict["SkipCnt"] as! String
                            }
                            if dict.keys.contains("Type") {
                                self.type = dict["Type"] as! String
                            }
                        }
                    }
                    public class M3U8NonStandardSupport : Tea.TeaModel {
                        public class TS : Tea.TeaModel {
                            public var md5Support: Bool?

                            public var sizeSupport: Bool?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.md5Support != nil {
                                    map["Md5Support"] = self.md5Support!
                                }
                                if self.sizeSupport != nil {
                                    map["SizeSupport"] = self.sizeSupport!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Md5Support") {
                                    self.md5Support = dict["Md5Support"] as! Bool
                                }
                                if dict.keys.contains("SizeSupport") {
                                    self.sizeSupport = dict["SizeSupport"] as! Bool
                                }
                            }
                        }
                        public var TS: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.M3U8NonStandardSupport.TS?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.TS?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.TS != nil {
                                map["TS"] = self.TS?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("TS") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.M3U8NonStandardSupport.TS()
                                model.fromMap(dict["TS"] as! [String: Any])
                                self.TS = model
                            }
                        }
                    }
                    public class MergeList : Tea.TeaModel {
                        public class Merge : Tea.TeaModel {
                            public var duration: String?

                            public var mergeURL: String?

                            public var roleArn: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.mergeURL != nil {
                                    map["MergeURL"] = self.mergeURL!
                                }
                                if self.roleArn != nil {
                                    map["RoleArn"] = self.roleArn!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("MergeURL") {
                                    self.mergeURL = dict["MergeURL"] as! String
                                }
                                if dict.keys.contains("RoleArn") {
                                    self.roleArn = dict["RoleArn"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var merge: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MergeList.Merge]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.merge != nil {
                                var tmp : [Any] = []
                                for k in self.merge! {
                                    tmp.append(k.toMap())
                                }
                                map["Merge"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Merge") {
                                var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MergeList.Merge] = []
                                for v in dict["Merge"] as! [Any] {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MergeList.Merge()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.merge = tmp
                            }
                        }
                    }
                    public class MuxConfig : Tea.TeaModel {
                        public class Gif : Tea.TeaModel {
                            public var ditherMode: String?

                            public var finalDelay: String?

                            public var isCustomPalette: String?

                            public var loop: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.ditherMode != nil {
                                    map["DitherMode"] = self.ditherMode!
                                }
                                if self.finalDelay != nil {
                                    map["FinalDelay"] = self.finalDelay!
                                }
                                if self.isCustomPalette != nil {
                                    map["IsCustomPalette"] = self.isCustomPalette!
                                }
                                if self.loop != nil {
                                    map["Loop"] = self.loop!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("DitherMode") {
                                    self.ditherMode = dict["DitherMode"] as! String
                                }
                                if dict.keys.contains("FinalDelay") {
                                    self.finalDelay = dict["FinalDelay"] as! String
                                }
                                if dict.keys.contains("IsCustomPalette") {
                                    self.isCustomPalette = dict["IsCustomPalette"] as! String
                                }
                                if dict.keys.contains("Loop") {
                                    self.loop = dict["Loop"] as! String
                                }
                            }
                        }
                        public class Segment : Tea.TeaModel {
                            public var duration: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                            }
                        }
                        public class Webp : Tea.TeaModel {
                            public var loop: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.loop != nil {
                                    map["Loop"] = self.loop!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Loop") {
                                    self.loop = dict["Loop"] as! String
                                }
                            }
                        }
                        public var gif: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MuxConfig.Gif?

                        public var segment: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MuxConfig.Segment?

                        public var webp: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MuxConfig.Webp?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.gif?.validate()
                            try self.segment?.validate()
                            try self.webp?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.gif != nil {
                                map["Gif"] = self.gif?.toMap()
                            }
                            if self.segment != nil {
                                map["Segment"] = self.segment?.toMap()
                            }
                            if self.webp != nil {
                                map["Webp"] = self.webp?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Gif") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MuxConfig.Gif()
                                model.fromMap(dict["Gif"] as! [String: Any])
                                self.gif = model
                            }
                            if dict.keys.contains("Segment") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MuxConfig.Segment()
                                model.fromMap(dict["Segment"] as! [String: Any])
                                self.segment = model
                            }
                            if dict.keys.contains("Webp") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MuxConfig.Webp()
                                model.fromMap(dict["Webp"] as! [String: Any])
                                self.webp = model
                            }
                        }
                    }
                    public class OpeningList : Tea.TeaModel {
                        public class Opening : Tea.TeaModel {
                            public var height: String?

                            public var start: String?

                            public var width: String?

                            public var openUrl: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                if self.openUrl != nil {
                                    map["openUrl"] = self.openUrl!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                                if dict.keys.contains("openUrl") {
                                    self.openUrl = dict["openUrl"] as! String
                                }
                            }
                        }
                        public var opening: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OpeningList.Opening]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.opening != nil {
                                var tmp : [Any] = []
                                for k in self.opening! {
                                    tmp.append(k.toMap())
                                }
                                map["Opening"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Opening") {
                                var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OpeningList.Opening] = []
                                for v in dict["Opening"] as! [Any] {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OpeningList.Opening()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.opening = tmp
                            }
                        }
                    }
                    public class OutSubtitleList : Tea.TeaModel {
                        public class OutSubtitle : Tea.TeaModel {
                            public class OutSubtitleFile : Tea.TeaModel {
                                public var bucket: String?

                                public var location: String?

                                public var object: String?

                                public var roleArn: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.bucket != nil {
                                        map["Bucket"] = self.bucket!
                                    }
                                    if self.location != nil {
                                        map["Location"] = self.location!
                                    }
                                    if self.object != nil {
                                        map["Object"] = self.object!
                                    }
                                    if self.roleArn != nil {
                                        map["RoleArn"] = self.roleArn!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Bucket") {
                                        self.bucket = dict["Bucket"] as! String
                                    }
                                    if dict.keys.contains("Location") {
                                        self.location = dict["Location"] as! String
                                    }
                                    if dict.keys.contains("Object") {
                                        self.object = dict["Object"] as! String
                                    }
                                    if dict.keys.contains("RoleArn") {
                                        self.roleArn = dict["RoleArn"] as! String
                                    }
                                }
                            }
                            public var map: String?

                            public var message: String?

                            public var outSubtitleFile: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OutSubtitleList.OutSubtitle.OutSubtitleFile?

                            public var success: Bool?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.outSubtitleFile?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.map != nil {
                                    map["Map"] = self.map!
                                }
                                if self.message != nil {
                                    map["Message"] = self.message!
                                }
                                if self.outSubtitleFile != nil {
                                    map["OutSubtitleFile"] = self.outSubtitleFile?.toMap()
                                }
                                if self.success != nil {
                                    map["Success"] = self.success!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Map") {
                                    self.map = dict["Map"] as! String
                                }
                                if dict.keys.contains("Message") {
                                    self.message = dict["Message"] as! String
                                }
                                if dict.keys.contains("OutSubtitleFile") {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OutSubtitleList.OutSubtitle.OutSubtitleFile()
                                    model.fromMap(dict["OutSubtitleFile"] as! [String: Any])
                                    self.outSubtitleFile = model
                                }
                                if dict.keys.contains("Success") {
                                    self.success = dict["Success"] as! Bool
                                }
                            }
                        }
                        public var outSubtitle: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OutSubtitleList.OutSubtitle]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.outSubtitle != nil {
                                var tmp : [Any] = []
                                for k in self.outSubtitle! {
                                    tmp.append(k.toMap())
                                }
                                map["OutSubtitle"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("OutSubtitle") {
                                var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OutSubtitleList.OutSubtitle] = []
                                for v in dict["OutSubtitle"] as! [Any] {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OutSubtitleList.OutSubtitle()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.outSubtitle = tmp
                            }
                        }
                    }
                    public class OutputFile : Tea.TeaModel {
                        public var bucket: String?

                        public var location: String?

                        public var object: String?

                        public var roleArn: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bucket != nil {
                                map["Bucket"] = self.bucket!
                            }
                            if self.location != nil {
                                map["Location"] = self.location!
                            }
                            if self.object != nil {
                                map["Object"] = self.object!
                            }
                            if self.roleArn != nil {
                                map["RoleArn"] = self.roleArn!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bucket") {
                                self.bucket = dict["Bucket"] as! String
                            }
                            if dict.keys.contains("Location") {
                                self.location = dict["Location"] as! String
                            }
                            if dict.keys.contains("Object") {
                                self.object = dict["Object"] as! String
                            }
                            if dict.keys.contains("RoleArn") {
                                self.roleArn = dict["RoleArn"] as! String
                            }
                        }
                    }
                    public class Properties : Tea.TeaModel {
                        public class Format : Tea.TeaModel {
                            public var bitrate: String?

                            public var duration: String?

                            public var formatLongName: String?

                            public var formatName: String?

                            public var numPrograms: String?

                            public var numStreams: String?

                            public var size: String?

                            public var startTime: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.formatLongName != nil {
                                    map["FormatLongName"] = self.formatLongName!
                                }
                                if self.formatName != nil {
                                    map["FormatName"] = self.formatName!
                                }
                                if self.numPrograms != nil {
                                    map["NumPrograms"] = self.numPrograms!
                                }
                                if self.numStreams != nil {
                                    map["NumStreams"] = self.numStreams!
                                }
                                if self.size != nil {
                                    map["Size"] = self.size!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("FormatLongName") {
                                    self.formatLongName = dict["FormatLongName"] as! String
                                }
                                if dict.keys.contains("FormatName") {
                                    self.formatName = dict["FormatName"] as! String
                                }
                                if dict.keys.contains("NumPrograms") {
                                    self.numPrograms = dict["NumPrograms"] as! String
                                }
                                if dict.keys.contains("NumStreams") {
                                    self.numStreams = dict["NumStreams"] as! String
                                }
                                if dict.keys.contains("Size") {
                                    self.size = dict["Size"] as! String
                                }
                                if dict.keys.contains("StartTime") {
                                    self.startTime = dict["StartTime"] as! String
                                }
                            }
                        }
                        public class Streams : Tea.TeaModel {
                            public class AudioStreamList : Tea.TeaModel {
                                public class AudioStream : Tea.TeaModel {
                                    public var bitrate: String?

                                    public var channelLayout: String?

                                    public var channels: String?

                                    public var codecLongName: String?

                                    public var codecName: String?

                                    public var codecTag: String?

                                    public var codecTagString: String?

                                    public var codecTimeBase: String?

                                    public var duration: String?

                                    public var index: String?

                                    public var lang: String?

                                    public var numFrames: String?

                                    public var sampleFmt: String?

                                    public var samplerate: String?

                                    public var startTime: String?

                                    public var timebase: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.bitrate != nil {
                                            map["Bitrate"] = self.bitrate!
                                        }
                                        if self.channelLayout != nil {
                                            map["ChannelLayout"] = self.channelLayout!
                                        }
                                        if self.channels != nil {
                                            map["Channels"] = self.channels!
                                        }
                                        if self.codecLongName != nil {
                                            map["CodecLongName"] = self.codecLongName!
                                        }
                                        if self.codecName != nil {
                                            map["CodecName"] = self.codecName!
                                        }
                                        if self.codecTag != nil {
                                            map["CodecTag"] = self.codecTag!
                                        }
                                        if self.codecTagString != nil {
                                            map["CodecTagString"] = self.codecTagString!
                                        }
                                        if self.codecTimeBase != nil {
                                            map["CodecTimeBase"] = self.codecTimeBase!
                                        }
                                        if self.duration != nil {
                                            map["Duration"] = self.duration!
                                        }
                                        if self.index != nil {
                                            map["Index"] = self.index!
                                        }
                                        if self.lang != nil {
                                            map["Lang"] = self.lang!
                                        }
                                        if self.numFrames != nil {
                                            map["NumFrames"] = self.numFrames!
                                        }
                                        if self.sampleFmt != nil {
                                            map["SampleFmt"] = self.sampleFmt!
                                        }
                                        if self.samplerate != nil {
                                            map["Samplerate"] = self.samplerate!
                                        }
                                        if self.startTime != nil {
                                            map["StartTime"] = self.startTime!
                                        }
                                        if self.timebase != nil {
                                            map["Timebase"] = self.timebase!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Bitrate") {
                                            self.bitrate = dict["Bitrate"] as! String
                                        }
                                        if dict.keys.contains("ChannelLayout") {
                                            self.channelLayout = dict["ChannelLayout"] as! String
                                        }
                                        if dict.keys.contains("Channels") {
                                            self.channels = dict["Channels"] as! String
                                        }
                                        if dict.keys.contains("CodecLongName") {
                                            self.codecLongName = dict["CodecLongName"] as! String
                                        }
                                        if dict.keys.contains("CodecName") {
                                            self.codecName = dict["CodecName"] as! String
                                        }
                                        if dict.keys.contains("CodecTag") {
                                            self.codecTag = dict["CodecTag"] as! String
                                        }
                                        if dict.keys.contains("CodecTagString") {
                                            self.codecTagString = dict["CodecTagString"] as! String
                                        }
                                        if dict.keys.contains("CodecTimeBase") {
                                            self.codecTimeBase = dict["CodecTimeBase"] as! String
                                        }
                                        if dict.keys.contains("Duration") {
                                            self.duration = dict["Duration"] as! String
                                        }
                                        if dict.keys.contains("Index") {
                                            self.index = dict["Index"] as! String
                                        }
                                        if dict.keys.contains("Lang") {
                                            self.lang = dict["Lang"] as! String
                                        }
                                        if dict.keys.contains("NumFrames") {
                                            self.numFrames = dict["NumFrames"] as! String
                                        }
                                        if dict.keys.contains("SampleFmt") {
                                            self.sampleFmt = dict["SampleFmt"] as! String
                                        }
                                        if dict.keys.contains("Samplerate") {
                                            self.samplerate = dict["Samplerate"] as! String
                                        }
                                        if dict.keys.contains("StartTime") {
                                            self.startTime = dict["StartTime"] as! String
                                        }
                                        if dict.keys.contains("Timebase") {
                                            self.timebase = dict["Timebase"] as! String
                                        }
                                    }
                                }
                                public var audioStream: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.AudioStreamList.AudioStream]?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.audioStream != nil {
                                        var tmp : [Any] = []
                                        for k in self.audioStream! {
                                            tmp.append(k.toMap())
                                        }
                                        map["AudioStream"] = tmp
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("AudioStream") {
                                        var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.AudioStreamList.AudioStream] = []
                                        for v in dict["AudioStream"] as! [Any] {
                                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.AudioStreamList.AudioStream()
                                            if v != nil {
                                                model.fromMap(v as! [String: Any])
                                            }
                                            tmp.append(model)
                                        }
                                        self.audioStream = tmp
                                    }
                                }
                            }
                            public class SubtitleStreamList : Tea.TeaModel {
                                public class SubtitleStream : Tea.TeaModel {
                                    public var index: String?

                                    public var lang: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.index != nil {
                                            map["Index"] = self.index!
                                        }
                                        if self.lang != nil {
                                            map["Lang"] = self.lang!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Index") {
                                            self.index = dict["Index"] as! String
                                        }
                                        if dict.keys.contains("Lang") {
                                            self.lang = dict["Lang"] as! String
                                        }
                                    }
                                }
                                public var subtitleStream: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.SubtitleStreamList.SubtitleStream]?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.subtitleStream != nil {
                                        var tmp : [Any] = []
                                        for k in self.subtitleStream! {
                                            tmp.append(k.toMap())
                                        }
                                        map["SubtitleStream"] = tmp
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("SubtitleStream") {
                                        var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.SubtitleStreamList.SubtitleStream] = []
                                        for v in dict["SubtitleStream"] as! [Any] {
                                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.SubtitleStreamList.SubtitleStream()
                                            if v != nil {
                                                model.fromMap(v as! [String: Any])
                                            }
                                            tmp.append(model)
                                        }
                                        self.subtitleStream = tmp
                                    }
                                }
                            }
                            public class VideoStreamList : Tea.TeaModel {
                                public class VideoStream : Tea.TeaModel {
                                    public class NetworkCost : Tea.TeaModel {
                                        public var avgBitrate: String?

                                        public var costBandwidth: String?

                                        public var preloadTime: String?

                                        public override init() {
                                            super.init()
                                        }

                                        public init(_ dict: [String: Any]) {
                                            super.init()
                                            self.fromMap(dict)
                                        }

                                        public override func validate() throws -> Void {
                                        }

                                        public override func toMap() -> [String : Any] {
                                            var map = super.toMap()
                                            if self.avgBitrate != nil {
                                                map["AvgBitrate"] = self.avgBitrate!
                                            }
                                            if self.costBandwidth != nil {
                                                map["CostBandwidth"] = self.costBandwidth!
                                            }
                                            if self.preloadTime != nil {
                                                map["PreloadTime"] = self.preloadTime!
                                            }
                                            return map
                                        }

                                        public override func fromMap(_ dict: [String: Any]) -> Void {
                                            if dict.keys.contains("AvgBitrate") {
                                                self.avgBitrate = dict["AvgBitrate"] as! String
                                            }
                                            if dict.keys.contains("CostBandwidth") {
                                                self.costBandwidth = dict["CostBandwidth"] as! String
                                            }
                                            if dict.keys.contains("PreloadTime") {
                                                self.preloadTime = dict["PreloadTime"] as! String
                                            }
                                        }
                                    }
                                    public var avgFPS: String?

                                    public var bitrate: String?

                                    public var codecLongName: String?

                                    public var codecName: String?

                                    public var codecTag: String?

                                    public var codecTagString: String?

                                    public var codecTimeBase: String?

                                    public var dar: String?

                                    public var duration: String?

                                    public var fps: String?

                                    public var hasBFrames: String?

                                    public var height: String?

                                    public var index: String?

                                    public var lang: String?

                                    public var level: String?

                                    public var networkCost: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.VideoStreamList.VideoStream.NetworkCost?

                                    public var numFrames: String?

                                    public var pixFmt: String?

                                    public var profile: String?

                                    public var sar: String?

                                    public var startTime: String?

                                    public var timebase: String?

                                    public var width: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                        try self.networkCost?.validate()
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.avgFPS != nil {
                                            map["AvgFPS"] = self.avgFPS!
                                        }
                                        if self.bitrate != nil {
                                            map["Bitrate"] = self.bitrate!
                                        }
                                        if self.codecLongName != nil {
                                            map["CodecLongName"] = self.codecLongName!
                                        }
                                        if self.codecName != nil {
                                            map["CodecName"] = self.codecName!
                                        }
                                        if self.codecTag != nil {
                                            map["CodecTag"] = self.codecTag!
                                        }
                                        if self.codecTagString != nil {
                                            map["CodecTagString"] = self.codecTagString!
                                        }
                                        if self.codecTimeBase != nil {
                                            map["CodecTimeBase"] = self.codecTimeBase!
                                        }
                                        if self.dar != nil {
                                            map["Dar"] = self.dar!
                                        }
                                        if self.duration != nil {
                                            map["Duration"] = self.duration!
                                        }
                                        if self.fps != nil {
                                            map["Fps"] = self.fps!
                                        }
                                        if self.hasBFrames != nil {
                                            map["HasBFrames"] = self.hasBFrames!
                                        }
                                        if self.height != nil {
                                            map["Height"] = self.height!
                                        }
                                        if self.index != nil {
                                            map["Index"] = self.index!
                                        }
                                        if self.lang != nil {
                                            map["Lang"] = self.lang!
                                        }
                                        if self.level != nil {
                                            map["Level"] = self.level!
                                        }
                                        if self.networkCost != nil {
                                            map["NetworkCost"] = self.networkCost?.toMap()
                                        }
                                        if self.numFrames != nil {
                                            map["NumFrames"] = self.numFrames!
                                        }
                                        if self.pixFmt != nil {
                                            map["PixFmt"] = self.pixFmt!
                                        }
                                        if self.profile != nil {
                                            map["Profile"] = self.profile!
                                        }
                                        if self.sar != nil {
                                            map["Sar"] = self.sar!
                                        }
                                        if self.startTime != nil {
                                            map["StartTime"] = self.startTime!
                                        }
                                        if self.timebase != nil {
                                            map["Timebase"] = self.timebase!
                                        }
                                        if self.width != nil {
                                            map["Width"] = self.width!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("AvgFPS") {
                                            self.avgFPS = dict["AvgFPS"] as! String
                                        }
                                        if dict.keys.contains("Bitrate") {
                                            self.bitrate = dict["Bitrate"] as! String
                                        }
                                        if dict.keys.contains("CodecLongName") {
                                            self.codecLongName = dict["CodecLongName"] as! String
                                        }
                                        if dict.keys.contains("CodecName") {
                                            self.codecName = dict["CodecName"] as! String
                                        }
                                        if dict.keys.contains("CodecTag") {
                                            self.codecTag = dict["CodecTag"] as! String
                                        }
                                        if dict.keys.contains("CodecTagString") {
                                            self.codecTagString = dict["CodecTagString"] as! String
                                        }
                                        if dict.keys.contains("CodecTimeBase") {
                                            self.codecTimeBase = dict["CodecTimeBase"] as! String
                                        }
                                        if dict.keys.contains("Dar") {
                                            self.dar = dict["Dar"] as! String
                                        }
                                        if dict.keys.contains("Duration") {
                                            self.duration = dict["Duration"] as! String
                                        }
                                        if dict.keys.contains("Fps") {
                                            self.fps = dict["Fps"] as! String
                                        }
                                        if dict.keys.contains("HasBFrames") {
                                            self.hasBFrames = dict["HasBFrames"] as! String
                                        }
                                        if dict.keys.contains("Height") {
                                            self.height = dict["Height"] as! String
                                        }
                                        if dict.keys.contains("Index") {
                                            self.index = dict["Index"] as! String
                                        }
                                        if dict.keys.contains("Lang") {
                                            self.lang = dict["Lang"] as! String
                                        }
                                        if dict.keys.contains("Level") {
                                            self.level = dict["Level"] as! String
                                        }
                                        if dict.keys.contains("NetworkCost") {
                                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.VideoStreamList.VideoStream.NetworkCost()
                                            model.fromMap(dict["NetworkCost"] as! [String: Any])
                                            self.networkCost = model
                                        }
                                        if dict.keys.contains("NumFrames") {
                                            self.numFrames = dict["NumFrames"] as! String
                                        }
                                        if dict.keys.contains("PixFmt") {
                                            self.pixFmt = dict["PixFmt"] as! String
                                        }
                                        if dict.keys.contains("Profile") {
                                            self.profile = dict["Profile"] as! String
                                        }
                                        if dict.keys.contains("Sar") {
                                            self.sar = dict["Sar"] as! String
                                        }
                                        if dict.keys.contains("StartTime") {
                                            self.startTime = dict["StartTime"] as! String
                                        }
                                        if dict.keys.contains("Timebase") {
                                            self.timebase = dict["Timebase"] as! String
                                        }
                                        if dict.keys.contains("Width") {
                                            self.width = dict["Width"] as! String
                                        }
                                    }
                                }
                                public var videoStream: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.VideoStreamList.VideoStream]?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.videoStream != nil {
                                        var tmp : [Any] = []
                                        for k in self.videoStream! {
                                            tmp.append(k.toMap())
                                        }
                                        map["VideoStream"] = tmp
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("VideoStream") {
                                        var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.VideoStreamList.VideoStream] = []
                                        for v in dict["VideoStream"] as! [Any] {
                                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.VideoStreamList.VideoStream()
                                            if v != nil {
                                                model.fromMap(v as! [String: Any])
                                            }
                                            tmp.append(model)
                                        }
                                        self.videoStream = tmp
                                    }
                                }
                            }
                            public var audioStreamList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.AudioStreamList?

                            public var subtitleStreamList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.SubtitleStreamList?

                            public var videoStreamList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.VideoStreamList?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.audioStreamList?.validate()
                                try self.subtitleStreamList?.validate()
                                try self.videoStreamList?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.audioStreamList != nil {
                                    map["AudioStreamList"] = self.audioStreamList?.toMap()
                                }
                                if self.subtitleStreamList != nil {
                                    map["SubtitleStreamList"] = self.subtitleStreamList?.toMap()
                                }
                                if self.videoStreamList != nil {
                                    map["VideoStreamList"] = self.videoStreamList?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AudioStreamList") {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.AudioStreamList()
                                    model.fromMap(dict["AudioStreamList"] as! [String: Any])
                                    self.audioStreamList = model
                                }
                                if dict.keys.contains("SubtitleStreamList") {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.SubtitleStreamList()
                                    model.fromMap(dict["SubtitleStreamList"] as! [String: Any])
                                    self.subtitleStreamList = model
                                }
                                if dict.keys.contains("VideoStreamList") {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.VideoStreamList()
                                    model.fromMap(dict["VideoStreamList"] as! [String: Any])
                                    self.videoStreamList = model
                                }
                            }
                        }
                        public var bitrate: String?

                        public var duration: String?

                        public var fileFormat: String?

                        public var fileSize: String?

                        public var format: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Format?

                        public var fps: String?

                        public var height: String?

                        public var streams: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.format?.validate()
                            try self.streams?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.fileFormat != nil {
                                map["FileFormat"] = self.fileFormat!
                            }
                            if self.fileSize != nil {
                                map["FileSize"] = self.fileSize!
                            }
                            if self.format != nil {
                                map["Format"] = self.format?.toMap()
                            }
                            if self.fps != nil {
                                map["Fps"] = self.fps!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.streams != nil {
                                map["Streams"] = self.streams?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("FileFormat") {
                                self.fileFormat = dict["FileFormat"] as! String
                            }
                            if dict.keys.contains("FileSize") {
                                self.fileSize = dict["FileSize"] as! String
                            }
                            if dict.keys.contains("Format") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Format()
                                model.fromMap(dict["Format"] as! [String: Any])
                                self.format = model
                            }
                            if dict.keys.contains("Fps") {
                                self.fps = dict["Fps"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("Streams") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams()
                                model.fromMap(dict["Streams"] as! [String: Any])
                                self.streams = model
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public class SubtitleConfig : Tea.TeaModel {
                        public class ExtSubtitleList : Tea.TeaModel {
                            public class ExtSubtitle : Tea.TeaModel {
                                public class Input : Tea.TeaModel {
                                    public var bucket: String?

                                    public var location: String?

                                    public var object: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.bucket != nil {
                                            map["Bucket"] = self.bucket!
                                        }
                                        if self.location != nil {
                                            map["Location"] = self.location!
                                        }
                                        if self.object != nil {
                                            map["Object"] = self.object!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Bucket") {
                                            self.bucket = dict["Bucket"] as! String
                                        }
                                        if dict.keys.contains("Location") {
                                            self.location = dict["Location"] as! String
                                        }
                                        if dict.keys.contains("Object") {
                                            self.object = dict["Object"] as! String
                                        }
                                    }
                                }
                                public var charEnc: String?

                                public var fontName: String?

                                public var input: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle.Input?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                    try self.input?.validate()
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.charEnc != nil {
                                        map["CharEnc"] = self.charEnc!
                                    }
                                    if self.fontName != nil {
                                        map["FontName"] = self.fontName!
                                    }
                                    if self.input != nil {
                                        map["Input"] = self.input?.toMap()
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("CharEnc") {
                                        self.charEnc = dict["CharEnc"] as! String
                                    }
                                    if dict.keys.contains("FontName") {
                                        self.fontName = dict["FontName"] as! String
                                    }
                                    if dict.keys.contains("Input") {
                                        var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle.Input()
                                        model.fromMap(dict["Input"] as! [String: Any])
                                        self.input = model
                                    }
                                }
                            }
                            public var extSubtitle: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.extSubtitle != nil {
                                    var tmp : [Any] = []
                                    for k in self.extSubtitle! {
                                        tmp.append(k.toMap())
                                    }
                                    map["ExtSubtitle"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("ExtSubtitle") {
                                    var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle] = []
                                    for v in dict["ExtSubtitle"] as! [Any] {
                                        var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.extSubtitle = tmp
                                }
                            }
                        }
                        public class SubtitleList : Tea.TeaModel {
                            public class Subtitle : Tea.TeaModel {
                                public var map: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.map != nil {
                                        map["Map"] = self.map!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Map") {
                                        self.map = dict["Map"] as! String
                                    }
                                }
                            }
                            public var subtitle: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.SubtitleList.Subtitle]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.subtitle != nil {
                                    var tmp : [Any] = []
                                    for k in self.subtitle! {
                                        tmp.append(k.toMap())
                                    }
                                    map["Subtitle"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Subtitle") {
                                    var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.SubtitleList.Subtitle] = []
                                    for v in dict["Subtitle"] as! [Any] {
                                        var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.SubtitleList.Subtitle()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.subtitle = tmp
                                }
                            }
                        }
                        public var extSubtitleList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.ExtSubtitleList?

                        public var subtitleList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.SubtitleList?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.extSubtitleList?.validate()
                            try self.subtitleList?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.extSubtitleList != nil {
                                map["ExtSubtitleList"] = self.extSubtitleList?.toMap()
                            }
                            if self.subtitleList != nil {
                                map["SubtitleList"] = self.subtitleList?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ExtSubtitleList") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.ExtSubtitleList()
                                model.fromMap(dict["ExtSubtitleList"] as! [String: Any])
                                self.extSubtitleList = model
                            }
                            if dict.keys.contains("SubtitleList") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.SubtitleList()
                                model.fromMap(dict["SubtitleList"] as! [String: Any])
                                self.subtitleList = model
                            }
                        }
                    }
                    public class SuperReso : Tea.TeaModel {
                        public var isHalfSample: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.isHalfSample != nil {
                                map["IsHalfSample"] = self.isHalfSample!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("IsHalfSample") {
                                self.isHalfSample = dict["IsHalfSample"] as! String
                            }
                        }
                    }
                    public class TailSlateList : Tea.TeaModel {
                        public class TailSlate : Tea.TeaModel {
                            public var bgColor: String?

                            public var blendDuration: String?

                            public var height: String?

                            public var isMergeAudio: Bool?

                            public var start: String?

                            public var tailUrl: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bgColor != nil {
                                    map["BgColor"] = self.bgColor!
                                }
                                if self.blendDuration != nil {
                                    map["BlendDuration"] = self.blendDuration!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.isMergeAudio != nil {
                                    map["IsMergeAudio"] = self.isMergeAudio!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                if self.tailUrl != nil {
                                    map["TailUrl"] = self.tailUrl!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("BgColor") {
                                    self.bgColor = dict["BgColor"] as! String
                                }
                                if dict.keys.contains("BlendDuration") {
                                    self.blendDuration = dict["BlendDuration"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("IsMergeAudio") {
                                    self.isMergeAudio = dict["IsMergeAudio"] as! Bool
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                                if dict.keys.contains("TailUrl") {
                                    self.tailUrl = dict["TailUrl"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var tailSlate: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.TailSlateList.TailSlate]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.tailSlate != nil {
                                var tmp : [Any] = []
                                for k in self.tailSlate! {
                                    tmp.append(k.toMap())
                                }
                                map["TailSlate"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("TailSlate") {
                                var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.TailSlateList.TailSlate] = []
                                for v in dict["TailSlate"] as! [Any] {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.TailSlateList.TailSlate()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.tailSlate = tmp
                            }
                        }
                    }
                    public class TransConfig : Tea.TeaModel {
                        public var adjDarMethod: String?

                        public var isCheckAudioBitrate: String?

                        public var isCheckAudioBitrateFail: String?

                        public var isCheckReso: String?

                        public var isCheckResoFail: String?

                        public var isCheckVideoBitrate: String?

                        public var isCheckVideoBitrateFail: String?

                        public var transMode: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adjDarMethod != nil {
                                map["AdjDarMethod"] = self.adjDarMethod!
                            }
                            if self.isCheckAudioBitrate != nil {
                                map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                            }
                            if self.isCheckAudioBitrateFail != nil {
                                map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                            }
                            if self.isCheckReso != nil {
                                map["IsCheckReso"] = self.isCheckReso!
                            }
                            if self.isCheckResoFail != nil {
                                map["IsCheckResoFail"] = self.isCheckResoFail!
                            }
                            if self.isCheckVideoBitrate != nil {
                                map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                            }
                            if self.isCheckVideoBitrateFail != nil {
                                map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                            }
                            if self.transMode != nil {
                                map["TransMode"] = self.transMode!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AdjDarMethod") {
                                self.adjDarMethod = dict["AdjDarMethod"] as! String
                            }
                            if dict.keys.contains("IsCheckAudioBitrate") {
                                self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                            }
                            if dict.keys.contains("IsCheckAudioBitrateFail") {
                                self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                            }
                            if dict.keys.contains("IsCheckReso") {
                                self.isCheckReso = dict["IsCheckReso"] as! String
                            }
                            if dict.keys.contains("IsCheckResoFail") {
                                self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                            }
                            if dict.keys.contains("IsCheckVideoBitrate") {
                                self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                            }
                            if dict.keys.contains("IsCheckVideoBitrateFail") {
                                self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                            }
                            if dict.keys.contains("TransMode") {
                                self.transMode = dict["TransMode"] as! String
                            }
                        }
                    }
                    public class Video : Tea.TeaModel {
                        public class BitrateBnd : Tea.TeaModel {
                            public var max: String?

                            public var min: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.max != nil {
                                    map["Max"] = self.max!
                                }
                                if self.min != nil {
                                    map["Min"] = self.min!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Max") {
                                    self.max = dict["Max"] as! String
                                }
                                if dict.keys.contains("Min") {
                                    self.min = dict["Min"] as! String
                                }
                            }
                        }
                        public var bitrate: String?

                        public var bitrateBnd: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Video.BitrateBnd?

                        public var bufsize: String?

                        public var codec: String?

                        public var crf: String?

                        public var crop: String?

                        public var degrain: String?

                        public var fps: String?

                        public var gop: String?

                        public var height: String?

                        public var maxFps: String?

                        public var maxrate: String?

                        public var pad: String?

                        public var pixFmt: String?

                        public var preset: String?

                        public var profile: String?

                        public var qscale: String?

                        public var resoPriority: String?

                        public var scanMode: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.bitrateBnd?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.bitrateBnd != nil {
                                map["BitrateBnd"] = self.bitrateBnd?.toMap()
                            }
                            if self.bufsize != nil {
                                map["Bufsize"] = self.bufsize!
                            }
                            if self.codec != nil {
                                map["Codec"] = self.codec!
                            }
                            if self.crf != nil {
                                map["Crf"] = self.crf!
                            }
                            if self.crop != nil {
                                map["Crop"] = self.crop!
                            }
                            if self.degrain != nil {
                                map["Degrain"] = self.degrain!
                            }
                            if self.fps != nil {
                                map["Fps"] = self.fps!
                            }
                            if self.gop != nil {
                                map["Gop"] = self.gop!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.maxFps != nil {
                                map["MaxFps"] = self.maxFps!
                            }
                            if self.maxrate != nil {
                                map["Maxrate"] = self.maxrate!
                            }
                            if self.pad != nil {
                                map["Pad"] = self.pad!
                            }
                            if self.pixFmt != nil {
                                map["PixFmt"] = self.pixFmt!
                            }
                            if self.preset != nil {
                                map["Preset"] = self.preset!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.qscale != nil {
                                map["Qscale"] = self.qscale!
                            }
                            if self.resoPriority != nil {
                                map["ResoPriority"] = self.resoPriority!
                            }
                            if self.scanMode != nil {
                                map["ScanMode"] = self.scanMode!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("BitrateBnd") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Video.BitrateBnd()
                                model.fromMap(dict["BitrateBnd"] as! [String: Any])
                                self.bitrateBnd = model
                            }
                            if dict.keys.contains("Bufsize") {
                                self.bufsize = dict["Bufsize"] as! String
                            }
                            if dict.keys.contains("Codec") {
                                self.codec = dict["Codec"] as! String
                            }
                            if dict.keys.contains("Crf") {
                                self.crf = dict["Crf"] as! String
                            }
                            if dict.keys.contains("Crop") {
                                self.crop = dict["Crop"] as! String
                            }
                            if dict.keys.contains("Degrain") {
                                self.degrain = dict["Degrain"] as! String
                            }
                            if dict.keys.contains("Fps") {
                                self.fps = dict["Fps"] as! String
                            }
                            if dict.keys.contains("Gop") {
                                self.gop = dict["Gop"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("MaxFps") {
                                self.maxFps = dict["MaxFps"] as! String
                            }
                            if dict.keys.contains("Maxrate") {
                                self.maxrate = dict["Maxrate"] as! String
                            }
                            if dict.keys.contains("Pad") {
                                self.pad = dict["Pad"] as! String
                            }
                            if dict.keys.contains("PixFmt") {
                                self.pixFmt = dict["PixFmt"] as! String
                            }
                            if dict.keys.contains("Preset") {
                                self.preset = dict["Preset"] as! String
                            }
                            if dict.keys.contains("Profile") {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Qscale") {
                                self.qscale = dict["Qscale"] as! String
                            }
                            if dict.keys.contains("ResoPriority") {
                                self.resoPriority = dict["ResoPriority"] as! String
                            }
                            if dict.keys.contains("ScanMode") {
                                self.scanMode = dict["ScanMode"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public class WaterMarkList : Tea.TeaModel {
                        public class WaterMark : Tea.TeaModel {
                            public class InputFile : Tea.TeaModel {
                                public var bucket: String?

                                public var location: String?

                                public var object: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.bucket != nil {
                                        map["Bucket"] = self.bucket!
                                    }
                                    if self.location != nil {
                                        map["Location"] = self.location!
                                    }
                                    if self.object != nil {
                                        map["Object"] = self.object!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Bucket") {
                                        self.bucket = dict["Bucket"] as! String
                                    }
                                    if dict.keys.contains("Location") {
                                        self.location = dict["Location"] as! String
                                    }
                                    if dict.keys.contains("Object") {
                                        self.object = dict["Object"] as! String
                                    }
                                }
                            }
                            public var dx: String?

                            public var dy: String?

                            public var height: String?

                            public var inputFile: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.WaterMarkList.WaterMark.InputFile?

                            public var referPos: String?

                            public var type: String?

                            public var waterMarkTemplateId: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.inputFile?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.dx != nil {
                                    map["Dx"] = self.dx!
                                }
                                if self.dy != nil {
                                    map["Dy"] = self.dy!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.inputFile != nil {
                                    map["InputFile"] = self.inputFile?.toMap()
                                }
                                if self.referPos != nil {
                                    map["ReferPos"] = self.referPos!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                if self.waterMarkTemplateId != nil {
                                    map["WaterMarkTemplateId"] = self.waterMarkTemplateId!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Dx") {
                                    self.dx = dict["Dx"] as! String
                                }
                                if dict.keys.contains("Dy") {
                                    self.dy = dict["Dy"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("InputFile") {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.WaterMarkList.WaterMark.InputFile()
                                    model.fromMap(dict["InputFile"] as! [String: Any])
                                    self.inputFile = model
                                }
                                if dict.keys.contains("ReferPos") {
                                    self.referPos = dict["ReferPos"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                                if dict.keys.contains("WaterMarkTemplateId") {
                                    self.waterMarkTemplateId = dict["WaterMarkTemplateId"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var waterMark: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.WaterMarkList.WaterMark]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.waterMark != nil {
                                var tmp : [Any] = []
                                for k in self.waterMark! {
                                    tmp.append(k.toMap())
                                }
                                map["WaterMark"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("WaterMark") {
                                var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.WaterMarkList.WaterMark] = []
                                for v in dict["WaterMark"] as! [Any] {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.WaterMarkList.WaterMark()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.waterMark = tmp
                            }
                        }
                    }
                    public var amixList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.AmixList?

                    public var audio: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Audio?

                    public var audioStreamMap: String?

                    public var clip: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Clip?

                    public var container: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Container?

                    public var deWatermark: String?

                    public var digiWaterMark: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.DigiWaterMark?

                    public var encryption: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Encryption?

                    public var m3U8NonStandardSupport: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.M3U8NonStandardSupport?

                    public var mergeConfigUrl: String?

                    public var mergeList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MergeList?

                    public var muxConfig: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MuxConfig?

                    public var openingList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OpeningList?

                    public var outSubtitleList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OutSubtitleList?

                    public var outputFile: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OutputFile?

                    public var priority: String?

                    public var properties: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties?

                    public var rotate: String?

                    public var subtitleConfig: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig?

                    public var superReso: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SuperReso?

                    public var tailSlateList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.TailSlateList?

                    public var templateId: String?

                    public var transConfig: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.TransConfig?

                    public var userData: String?

                    public var video: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Video?

                    public var videoStreamMap: String?

                    public var waterMarkConfigUrl: String?

                    public var waterMarkList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.WaterMarkList?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.amixList?.validate()
                        try self.audio?.validate()
                        try self.clip?.validate()
                        try self.container?.validate()
                        try self.digiWaterMark?.validate()
                        try self.encryption?.validate()
                        try self.m3U8NonStandardSupport?.validate()
                        try self.mergeList?.validate()
                        try self.muxConfig?.validate()
                        try self.openingList?.validate()
                        try self.outSubtitleList?.validate()
                        try self.outputFile?.validate()
                        try self.properties?.validate()
                        try self.subtitleConfig?.validate()
                        try self.superReso?.validate()
                        try self.tailSlateList?.validate()
                        try self.transConfig?.validate()
                        try self.video?.validate()
                        try self.waterMarkList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.amixList != nil {
                            map["AmixList"] = self.amixList?.toMap()
                        }
                        if self.audio != nil {
                            map["Audio"] = self.audio?.toMap()
                        }
                        if self.audioStreamMap != nil {
                            map["AudioStreamMap"] = self.audioStreamMap!
                        }
                        if self.clip != nil {
                            map["Clip"] = self.clip?.toMap()
                        }
                        if self.container != nil {
                            map["Container"] = self.container?.toMap()
                        }
                        if self.deWatermark != nil {
                            map["DeWatermark"] = self.deWatermark!
                        }
                        if self.digiWaterMark != nil {
                            map["DigiWaterMark"] = self.digiWaterMark?.toMap()
                        }
                        if self.encryption != nil {
                            map["Encryption"] = self.encryption?.toMap()
                        }
                        if self.m3U8NonStandardSupport != nil {
                            map["M3U8NonStandardSupport"] = self.m3U8NonStandardSupport?.toMap()
                        }
                        if self.mergeConfigUrl != nil {
                            map["MergeConfigUrl"] = self.mergeConfigUrl!
                        }
                        if self.mergeList != nil {
                            map["MergeList"] = self.mergeList?.toMap()
                        }
                        if self.muxConfig != nil {
                            map["MuxConfig"] = self.muxConfig?.toMap()
                        }
                        if self.openingList != nil {
                            map["OpeningList"] = self.openingList?.toMap()
                        }
                        if self.outSubtitleList != nil {
                            map["OutSubtitleList"] = self.outSubtitleList?.toMap()
                        }
                        if self.outputFile != nil {
                            map["OutputFile"] = self.outputFile?.toMap()
                        }
                        if self.priority != nil {
                            map["Priority"] = self.priority!
                        }
                        if self.properties != nil {
                            map["Properties"] = self.properties?.toMap()
                        }
                        if self.rotate != nil {
                            map["Rotate"] = self.rotate!
                        }
                        if self.subtitleConfig != nil {
                            map["SubtitleConfig"] = self.subtitleConfig?.toMap()
                        }
                        if self.superReso != nil {
                            map["SuperReso"] = self.superReso?.toMap()
                        }
                        if self.tailSlateList != nil {
                            map["TailSlateList"] = self.tailSlateList?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        if self.transConfig != nil {
                            map["TransConfig"] = self.transConfig?.toMap()
                        }
                        if self.userData != nil {
                            map["UserData"] = self.userData!
                        }
                        if self.video != nil {
                            map["Video"] = self.video?.toMap()
                        }
                        if self.videoStreamMap != nil {
                            map["VideoStreamMap"] = self.videoStreamMap!
                        }
                        if self.waterMarkConfigUrl != nil {
                            map["WaterMarkConfigUrl"] = self.waterMarkConfigUrl!
                        }
                        if self.waterMarkList != nil {
                            map["WaterMarkList"] = self.waterMarkList?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AmixList") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.AmixList()
                            model.fromMap(dict["AmixList"] as! [String: Any])
                            self.amixList = model
                        }
                        if dict.keys.contains("Audio") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Audio()
                            model.fromMap(dict["Audio"] as! [String: Any])
                            self.audio = model
                        }
                        if dict.keys.contains("AudioStreamMap") {
                            self.audioStreamMap = dict["AudioStreamMap"] as! String
                        }
                        if dict.keys.contains("Clip") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Clip()
                            model.fromMap(dict["Clip"] as! [String: Any])
                            self.clip = model
                        }
                        if dict.keys.contains("Container") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Container()
                            model.fromMap(dict["Container"] as! [String: Any])
                            self.container = model
                        }
                        if dict.keys.contains("DeWatermark") {
                            self.deWatermark = dict["DeWatermark"] as! String
                        }
                        if dict.keys.contains("DigiWaterMark") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.DigiWaterMark()
                            model.fromMap(dict["DigiWaterMark"] as! [String: Any])
                            self.digiWaterMark = model
                        }
                        if dict.keys.contains("Encryption") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Encryption()
                            model.fromMap(dict["Encryption"] as! [String: Any])
                            self.encryption = model
                        }
                        if dict.keys.contains("M3U8NonStandardSupport") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.M3U8NonStandardSupport()
                            model.fromMap(dict["M3U8NonStandardSupport"] as! [String: Any])
                            self.m3U8NonStandardSupport = model
                        }
                        if dict.keys.contains("MergeConfigUrl") {
                            self.mergeConfigUrl = dict["MergeConfigUrl"] as! String
                        }
                        if dict.keys.contains("MergeList") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MergeList()
                            model.fromMap(dict["MergeList"] as! [String: Any])
                            self.mergeList = model
                        }
                        if dict.keys.contains("MuxConfig") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MuxConfig()
                            model.fromMap(dict["MuxConfig"] as! [String: Any])
                            self.muxConfig = model
                        }
                        if dict.keys.contains("OpeningList") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OpeningList()
                            model.fromMap(dict["OpeningList"] as! [String: Any])
                            self.openingList = model
                        }
                        if dict.keys.contains("OutSubtitleList") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OutSubtitleList()
                            model.fromMap(dict["OutSubtitleList"] as! [String: Any])
                            self.outSubtitleList = model
                        }
                        if dict.keys.contains("OutputFile") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OutputFile()
                            model.fromMap(dict["OutputFile"] as! [String: Any])
                            self.outputFile = model
                        }
                        if dict.keys.contains("Priority") {
                            self.priority = dict["Priority"] as! String
                        }
                        if dict.keys.contains("Properties") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties()
                            model.fromMap(dict["Properties"] as! [String: Any])
                            self.properties = model
                        }
                        if dict.keys.contains("Rotate") {
                            self.rotate = dict["Rotate"] as! String
                        }
                        if dict.keys.contains("SubtitleConfig") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig()
                            model.fromMap(dict["SubtitleConfig"] as! [String: Any])
                            self.subtitleConfig = model
                        }
                        if dict.keys.contains("SuperReso") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SuperReso()
                            model.fromMap(dict["SuperReso"] as! [String: Any])
                            self.superReso = model
                        }
                        if dict.keys.contains("TailSlateList") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.TailSlateList()
                            model.fromMap(dict["TailSlateList"] as! [String: Any])
                            self.tailSlateList = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                        if dict.keys.contains("TransConfig") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.TransConfig()
                            model.fromMap(dict["TransConfig"] as! [String: Any])
                            self.transConfig = model
                        }
                        if dict.keys.contains("UserData") {
                            self.userData = dict["UserData"] as! String
                        }
                        if dict.keys.contains("Video") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Video()
                            model.fromMap(dict["Video"] as! [String: Any])
                            self.video = model
                        }
                        if dict.keys.contains("VideoStreamMap") {
                            self.videoStreamMap = dict["VideoStreamMap"] as! String
                        }
                        if dict.keys.contains("WaterMarkConfigUrl") {
                            self.waterMarkConfigUrl = dict["WaterMarkConfigUrl"] as! String
                        }
                        if dict.keys.contains("WaterMarkList") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.WaterMarkList()
                            model.fromMap(dict["WaterMarkList"] as! [String: Any])
                            self.waterMarkList = model
                        }
                    }
                }
                public var code: String?

                public var creationTime: String?

                public var finishTime: String?

                public var input: SubmitJobsResponseBody.JobResultList.JobResult.Job.Input?

                public var jobId: String?

                public var MNSMessageResult: SubmitJobsResponseBody.JobResultList.JobResult.Job.MNSMessageResult?

                public var message: String?

                public var output: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output?

                public var percent: Int64?

                public var pipelineId: String?

                public var state: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.input?.validate()
                    try self.MNSMessageResult?.validate()
                    try self.output?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.creationTime != nil {
                        map["CreationTime"] = self.creationTime!
                    }
                    if self.finishTime != nil {
                        map["FinishTime"] = self.finishTime!
                    }
                    if self.input != nil {
                        map["Input"] = self.input?.toMap()
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.MNSMessageResult != nil {
                        map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.output != nil {
                        map["Output"] = self.output?.toMap()
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.pipelineId != nil {
                        map["PipelineId"] = self.pipelineId!
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! String
                    }
                    if dict.keys.contains("CreationTime") {
                        self.creationTime = dict["CreationTime"] as! String
                    }
                    if dict.keys.contains("FinishTime") {
                        self.finishTime = dict["FinishTime"] as! String
                    }
                    if dict.keys.contains("Input") {
                        var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Input()
                        model.fromMap(dict["Input"] as! [String: Any])
                        self.input = model
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("MNSMessageResult") {
                        var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.MNSMessageResult()
                        model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                        self.MNSMessageResult = model
                    }
                    if dict.keys.contains("Message") {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("Output") {
                        var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output()
                        model.fromMap(dict["Output"] as! [String: Any])
                        self.output = model
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! Int64
                    }
                    if dict.keys.contains("PipelineId") {
                        self.pipelineId = dict["PipelineId"] as! String
                    }
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! String
                    }
                }
            }
            public var code: String?

            public var job: SubmitJobsResponseBody.JobResultList.JobResult.Job?

            public var message: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.job?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.job != nil {
                    map["Job"] = self.job?.toMap()
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Job") {
                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job()
                    model.fromMap(dict["Job"] as! [String: Any])
                    self.job = model
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Success") {
                    self.success = dict["Success"] as! Bool
                }
            }
        }
        public var jobResult: [SubmitJobsResponseBody.JobResultList.JobResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobResult != nil {
                var tmp : [Any] = []
                for k in self.jobResult! {
                    tmp.append(k.toMap())
                }
                map["JobResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobResult") {
                var tmp : [SubmitJobsResponseBody.JobResultList.JobResult] = []
                for v in dict["JobResult"] as! [Any] {
                    var model = SubmitJobsResponseBody.JobResultList.JobResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.jobResult = tmp
            }
        }
    }
    public var jobResultList: SubmitJobsResponseBody.JobResultList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobResultList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobResultList != nil {
            map["JobResultList"] = self.jobResultList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobResultList") {
            var model = SubmitJobsResponseBody.JobResultList()
            model.fromMap(dict["JobResultList"] as! [String: Any])
            self.jobResultList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitMediaInfoJobRequest : Tea.TeaModel {
    public var async: Bool?

    public var input: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.async != nil {
            map["Async"] = self.async!
        }
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Async") {
            self.async = dict["Async"] as! Bool
        }
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaInfoJobResponseBody : Tea.TeaModel {
    public class MediaInfoJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var bucket: String?

            public var location: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("Object") {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public class MNSMessageResult : Tea.TeaModel {
            public var errorCode: String?

            public var errorMessage: String?

            public var messageId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.messageId != nil {
                    map["MessageId"] = self.messageId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("MessageId") {
                    self.messageId = dict["MessageId"] as! String
                }
            }
        }
        public class Properties : Tea.TeaModel {
            public class Format : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var formatLongName: String?

                public var formatName: String?

                public var numPrograms: String?

                public var numStreams: String?

                public var size: String?

                public var startTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.formatLongName != nil {
                        map["FormatLongName"] = self.formatLongName!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.numPrograms != nil {
                        map["NumPrograms"] = self.numPrograms!
                    }
                    if self.numStreams != nil {
                        map["NumStreams"] = self.numStreams!
                    }
                    if self.size != nil {
                        map["Size"] = self.size!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FormatLongName") {
                        self.formatLongName = dict["FormatLongName"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("NumPrograms") {
                        self.numPrograms = dict["NumPrograms"] as! String
                    }
                    if dict.keys.contains("NumStreams") {
                        self.numStreams = dict["NumStreams"] as! String
                    }
                    if dict.keys.contains("Size") {
                        self.size = dict["Size"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                }
            }
            public class Streams : Tea.TeaModel {
                public class AudioStreamList : Tea.TeaModel {
                    public class AudioStream : Tea.TeaModel {
                        public var bitrate: String?

                        public var channelLayout: String?

                        public var channels: String?

                        public var codecLongName: String?

                        public var codecName: String?

                        public var codecTag: String?

                        public var codecTagString: String?

                        public var codecTimeBase: String?

                        public var duration: String?

                        public var index: String?

                        public var lang: String?

                        public var numFrames: String?

                        public var sampleFmt: String?

                        public var samplerate: String?

                        public var startTime: String?

                        public var timebase: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.channelLayout != nil {
                                map["ChannelLayout"] = self.channelLayout!
                            }
                            if self.channels != nil {
                                map["Channels"] = self.channels!
                            }
                            if self.codecLongName != nil {
                                map["CodecLongName"] = self.codecLongName!
                            }
                            if self.codecName != nil {
                                map["CodecName"] = self.codecName!
                            }
                            if self.codecTag != nil {
                                map["CodecTag"] = self.codecTag!
                            }
                            if self.codecTagString != nil {
                                map["CodecTagString"] = self.codecTagString!
                            }
                            if self.codecTimeBase != nil {
                                map["CodecTimeBase"] = self.codecTimeBase!
                            }
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.index != nil {
                                map["Index"] = self.index!
                            }
                            if self.lang != nil {
                                map["Lang"] = self.lang!
                            }
                            if self.numFrames != nil {
                                map["NumFrames"] = self.numFrames!
                            }
                            if self.sampleFmt != nil {
                                map["SampleFmt"] = self.sampleFmt!
                            }
                            if self.samplerate != nil {
                                map["Samplerate"] = self.samplerate!
                            }
                            if self.startTime != nil {
                                map["StartTime"] = self.startTime!
                            }
                            if self.timebase != nil {
                                map["Timebase"] = self.timebase!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("ChannelLayout") {
                                self.channelLayout = dict["ChannelLayout"] as! String
                            }
                            if dict.keys.contains("Channels") {
                                self.channels = dict["Channels"] as! String
                            }
                            if dict.keys.contains("CodecLongName") {
                                self.codecLongName = dict["CodecLongName"] as! String
                            }
                            if dict.keys.contains("CodecName") {
                                self.codecName = dict["CodecName"] as! String
                            }
                            if dict.keys.contains("CodecTag") {
                                self.codecTag = dict["CodecTag"] as! String
                            }
                            if dict.keys.contains("CodecTagString") {
                                self.codecTagString = dict["CodecTagString"] as! String
                            }
                            if dict.keys.contains("CodecTimeBase") {
                                self.codecTimeBase = dict["CodecTimeBase"] as! String
                            }
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("Index") {
                                self.index = dict["Index"] as! String
                            }
                            if dict.keys.contains("Lang") {
                                self.lang = dict["Lang"] as! String
                            }
                            if dict.keys.contains("NumFrames") {
                                self.numFrames = dict["NumFrames"] as! String
                            }
                            if dict.keys.contains("SampleFmt") {
                                self.sampleFmt = dict["SampleFmt"] as! String
                            }
                            if dict.keys.contains("Samplerate") {
                                self.samplerate = dict["Samplerate"] as! String
                            }
                            if dict.keys.contains("StartTime") {
                                self.startTime = dict["StartTime"] as! String
                            }
                            if dict.keys.contains("Timebase") {
                                self.timebase = dict["Timebase"] as! String
                            }
                        }
                    }
                    public var audioStream: [SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.AudioStreamList.AudioStream]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioStream != nil {
                            var tmp : [Any] = []
                            for k in self.audioStream! {
                                tmp.append(k.toMap())
                            }
                            map["AudioStream"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioStream") {
                            var tmp : [SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.AudioStreamList.AudioStream] = []
                            for v in dict["AudioStream"] as! [Any] {
                                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.AudioStreamList.AudioStream()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.audioStream = tmp
                        }
                    }
                }
                public class SubtitleStreamList : Tea.TeaModel {
                    public class SubtitleStream : Tea.TeaModel {
                        public var index: String?

                        public var lang: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.index != nil {
                                map["Index"] = self.index!
                            }
                            if self.lang != nil {
                                map["Lang"] = self.lang!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Index") {
                                self.index = dict["Index"] as! String
                            }
                            if dict.keys.contains("Lang") {
                                self.lang = dict["Lang"] as! String
                            }
                        }
                    }
                    public var subtitleStream: [SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.SubtitleStreamList.SubtitleStream]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.subtitleStream != nil {
                            var tmp : [Any] = []
                            for k in self.subtitleStream! {
                                tmp.append(k.toMap())
                            }
                            map["SubtitleStream"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("SubtitleStream") {
                            var tmp : [SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.SubtitleStreamList.SubtitleStream] = []
                            for v in dict["SubtitleStream"] as! [Any] {
                                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.SubtitleStreamList.SubtitleStream()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.subtitleStream = tmp
                        }
                    }
                }
                public class VideoStreamList : Tea.TeaModel {
                    public class VideoStream : Tea.TeaModel {
                        public class NetworkCost : Tea.TeaModel {
                            public var avgBitrate: String?

                            public var costBandwidth: String?

                            public var preloadTime: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.avgBitrate != nil {
                                    map["AvgBitrate"] = self.avgBitrate!
                                }
                                if self.costBandwidth != nil {
                                    map["CostBandwidth"] = self.costBandwidth!
                                }
                                if self.preloadTime != nil {
                                    map["PreloadTime"] = self.preloadTime!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AvgBitrate") {
                                    self.avgBitrate = dict["AvgBitrate"] as! String
                                }
                                if dict.keys.contains("CostBandwidth") {
                                    self.costBandwidth = dict["CostBandwidth"] as! String
                                }
                                if dict.keys.contains("PreloadTime") {
                                    self.preloadTime = dict["PreloadTime"] as! String
                                }
                            }
                        }
                        public var avgFPS: String?

                        public var bitrate: String?

                        public var codecLongName: String?

                        public var codecName: String?

                        public var codecTag: String?

                        public var codecTagString: String?

                        public var codecTimeBase: String?

                        public var dar: String?

                        public var duration: String?

                        public var fps: String?

                        public var hasBFrames: String?

                        public var height: String?

                        public var index: String?

                        public var lang: String?

                        public var level: String?

                        public var networkCost: SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream.NetworkCost?

                        public var numFrames: String?

                        public var pixFmt: String?

                        public var profile: String?

                        public var rotate: String?

                        public var sar: String?

                        public var startTime: String?

                        public var timebase: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.networkCost?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.avgFPS != nil {
                                map["AvgFPS"] = self.avgFPS!
                            }
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.codecLongName != nil {
                                map["CodecLongName"] = self.codecLongName!
                            }
                            if self.codecName != nil {
                                map["CodecName"] = self.codecName!
                            }
                            if self.codecTag != nil {
                                map["CodecTag"] = self.codecTag!
                            }
                            if self.codecTagString != nil {
                                map["CodecTagString"] = self.codecTagString!
                            }
                            if self.codecTimeBase != nil {
                                map["CodecTimeBase"] = self.codecTimeBase!
                            }
                            if self.dar != nil {
                                map["Dar"] = self.dar!
                            }
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.fps != nil {
                                map["Fps"] = self.fps!
                            }
                            if self.hasBFrames != nil {
                                map["HasBFrames"] = self.hasBFrames!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.index != nil {
                                map["Index"] = self.index!
                            }
                            if self.lang != nil {
                                map["Lang"] = self.lang!
                            }
                            if self.level != nil {
                                map["Level"] = self.level!
                            }
                            if self.networkCost != nil {
                                map["NetworkCost"] = self.networkCost?.toMap()
                            }
                            if self.numFrames != nil {
                                map["NumFrames"] = self.numFrames!
                            }
                            if self.pixFmt != nil {
                                map["PixFmt"] = self.pixFmt!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.rotate != nil {
                                map["Rotate"] = self.rotate!
                            }
                            if self.sar != nil {
                                map["Sar"] = self.sar!
                            }
                            if self.startTime != nil {
                                map["StartTime"] = self.startTime!
                            }
                            if self.timebase != nil {
                                map["Timebase"] = self.timebase!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AvgFPS") {
                                self.avgFPS = dict["AvgFPS"] as! String
                            }
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("CodecLongName") {
                                self.codecLongName = dict["CodecLongName"] as! String
                            }
                            if dict.keys.contains("CodecName") {
                                self.codecName = dict["CodecName"] as! String
                            }
                            if dict.keys.contains("CodecTag") {
                                self.codecTag = dict["CodecTag"] as! String
                            }
                            if dict.keys.contains("CodecTagString") {
                                self.codecTagString = dict["CodecTagString"] as! String
                            }
                            if dict.keys.contains("CodecTimeBase") {
                                self.codecTimeBase = dict["CodecTimeBase"] as! String
                            }
                            if dict.keys.contains("Dar") {
                                self.dar = dict["Dar"] as! String
                            }
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("Fps") {
                                self.fps = dict["Fps"] as! String
                            }
                            if dict.keys.contains("HasBFrames") {
                                self.hasBFrames = dict["HasBFrames"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("Index") {
                                self.index = dict["Index"] as! String
                            }
                            if dict.keys.contains("Lang") {
                                self.lang = dict["Lang"] as! String
                            }
                            if dict.keys.contains("Level") {
                                self.level = dict["Level"] as! String
                            }
                            if dict.keys.contains("NetworkCost") {
                                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream.NetworkCost()
                                model.fromMap(dict["NetworkCost"] as! [String: Any])
                                self.networkCost = model
                            }
                            if dict.keys.contains("NumFrames") {
                                self.numFrames = dict["NumFrames"] as! String
                            }
                            if dict.keys.contains("PixFmt") {
                                self.pixFmt = dict["PixFmt"] as! String
                            }
                            if dict.keys.contains("Profile") {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Rotate") {
                                self.rotate = dict["Rotate"] as! String
                            }
                            if dict.keys.contains("Sar") {
                                self.sar = dict["Sar"] as! String
                            }
                            if dict.keys.contains("StartTime") {
                                self.startTime = dict["StartTime"] as! String
                            }
                            if dict.keys.contains("Timebase") {
                                self.timebase = dict["Timebase"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var videoStream: [SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.videoStream != nil {
                            var tmp : [Any] = []
                            for k in self.videoStream! {
                                tmp.append(k.toMap())
                            }
                            map["VideoStream"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("VideoStream") {
                            var tmp : [SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream] = []
                            for v in dict["VideoStream"] as! [Any] {
                                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.videoStream = tmp
                        }
                    }
                }
                public var audioStreamList: SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.AudioStreamList?

                public var subtitleStreamList: SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.SubtitleStreamList?

                public var videoStreamList: SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.VideoStreamList?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.audioStreamList?.validate()
                    try self.subtitleStreamList?.validate()
                    try self.videoStreamList?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioStreamList != nil {
                        map["AudioStreamList"] = self.audioStreamList?.toMap()
                    }
                    if self.subtitleStreamList != nil {
                        map["SubtitleStreamList"] = self.subtitleStreamList?.toMap()
                    }
                    if self.videoStreamList != nil {
                        map["VideoStreamList"] = self.videoStreamList?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioStreamList") {
                        var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.AudioStreamList()
                        model.fromMap(dict["AudioStreamList"] as! [String: Any])
                        self.audioStreamList = model
                    }
                    if dict.keys.contains("SubtitleStreamList") {
                        var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.SubtitleStreamList()
                        model.fromMap(dict["SubtitleStreamList"] as! [String: Any])
                        self.subtitleStreamList = model
                    }
                    if dict.keys.contains("VideoStreamList") {
                        var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.VideoStreamList()
                        model.fromMap(dict["VideoStreamList"] as! [String: Any])
                        self.videoStreamList = model
                    }
                }
            }
            public var bitrate: String?

            public var duration: String?

            public var fileFormat: String?

            public var fileSize: String?

            public var format: SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Format?

            public var fps: String?

            public var height: String?

            public var streams: SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.format?.validate()
                try self.streams?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.fileFormat != nil {
                    map["FileFormat"] = self.fileFormat!
                }
                if self.fileSize != nil {
                    map["FileSize"] = self.fileSize!
                }
                if self.format != nil {
                    map["Format"] = self.format?.toMap()
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.streams != nil {
                    map["Streams"] = self.streams?.toMap()
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("FileFormat") {
                    self.fileFormat = dict["FileFormat"] as! String
                }
                if dict.keys.contains("FileSize") {
                    self.fileSize = dict["FileSize"] as! String
                }
                if dict.keys.contains("Format") {
                    var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Format()
                    model.fromMap(dict["Format"] as! [String: Any])
                    self.format = model
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Streams") {
                    var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams()
                    model.fromMap(dict["Streams"] as! [String: Any])
                    self.streams = model
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var async: Bool?

        public var code: String?

        public var creationTime: String?

        public var input: SubmitMediaInfoJobResponseBody.MediaInfoJob.Input?

        public var jobId: String?

        public var MNSMessageResult: SubmitMediaInfoJobResponseBody.MediaInfoJob.MNSMessageResult?

        public var message: String?

        public var pipelineId: String?

        public var properties: SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties?

        public var state: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.MNSMessageResult?.validate()
            try self.properties?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.MNSMessageResult != nil {
                map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.properties != nil {
                map["Properties"] = self.properties?.toMap()
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MNSMessageResult") {
                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.MNSMessageResult()
                model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                self.MNSMessageResult = model
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Properties") {
                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties()
                model.fromMap(dict["Properties"] as! [String: Any])
                self.properties = model
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var mediaInfoJob: SubmitMediaInfoJobResponseBody.MediaInfoJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfoJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfoJob != nil {
            map["MediaInfoJob"] = self.mediaInfoJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfoJob") {
            var model = SubmitMediaInfoJobResponseBody.MediaInfoJob()
            model.fromMap(dict["MediaInfoJob"] as! [String: Any])
            self.mediaInfoJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitMediaInfoJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitMediaInfoJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitMediaInfoJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSnapshotJobRequest : Tea.TeaModel {
    public var input: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotConfig: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotConfig != nil {
            map["SnapshotConfig"] = self.snapshotConfig!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SnapshotConfig") {
            self.snapshotConfig = dict["SnapshotConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSnapshotJobResponseBody : Tea.TeaModel {
    public class SnapshotJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var bucket: String?

            public var location: String?

            public var object: String?

            public var roleArn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                if self.roleArn != nil {
                    map["RoleArn"] = self.roleArn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("Object") {
                    self.object = dict["Object"] as! String
                }
                if dict.keys.contains("RoleArn") {
                    self.roleArn = dict["RoleArn"] as! String
                }
            }
        }
        public class MNSMessageResult : Tea.TeaModel {
            public var errorCode: String?

            public var errorMessage: String?

            public var messageId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.messageId != nil {
                    map["MessageId"] = self.messageId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("MessageId") {
                    self.messageId = dict["MessageId"] as! String
                }
            }
        }
        public class SnapshotConfig : Tea.TeaModel {
            public class OutputFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public var roleArn: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    if self.roleArn != nil {
                        map["RoleArn"] = self.roleArn!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                    if dict.keys.contains("RoleArn") {
                        self.roleArn = dict["RoleArn"] as! String
                    }
                }
            }
            public class TileOut : Tea.TeaModel {
                public var cellHeight: String?

                public var cellSelStep: String?

                public var cellWidth: String?

                public var color: String?

                public var columns: String?

                public var isKeepCellPic: String?

                public var lines: String?

                public var margin: String?

                public var padding: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cellHeight != nil {
                        map["CellHeight"] = self.cellHeight!
                    }
                    if self.cellSelStep != nil {
                        map["CellSelStep"] = self.cellSelStep!
                    }
                    if self.cellWidth != nil {
                        map["CellWidth"] = self.cellWidth!
                    }
                    if self.color != nil {
                        map["Color"] = self.color!
                    }
                    if self.columns != nil {
                        map["Columns"] = self.columns!
                    }
                    if self.isKeepCellPic != nil {
                        map["IsKeepCellPic"] = self.isKeepCellPic!
                    }
                    if self.lines != nil {
                        map["Lines"] = self.lines!
                    }
                    if self.margin != nil {
                        map["Margin"] = self.margin!
                    }
                    if self.padding != nil {
                        map["Padding"] = self.padding!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CellHeight") {
                        self.cellHeight = dict["CellHeight"] as! String
                    }
                    if dict.keys.contains("CellSelStep") {
                        self.cellSelStep = dict["CellSelStep"] as! String
                    }
                    if dict.keys.contains("CellWidth") {
                        self.cellWidth = dict["CellWidth"] as! String
                    }
                    if dict.keys.contains("Color") {
                        self.color = dict["Color"] as! String
                    }
                    if dict.keys.contains("Columns") {
                        self.columns = dict["Columns"] as! String
                    }
                    if dict.keys.contains("IsKeepCellPic") {
                        self.isKeepCellPic = dict["IsKeepCellPic"] as! String
                    }
                    if dict.keys.contains("Lines") {
                        self.lines = dict["Lines"] as! String
                    }
                    if dict.keys.contains("Margin") {
                        self.margin = dict["Margin"] as! String
                    }
                    if dict.keys.contains("Padding") {
                        self.padding = dict["Padding"] as! String
                    }
                }
            }
            public class TileOutputFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public var roleArn: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    if self.roleArn != nil {
                        map["RoleArn"] = self.roleArn!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                    if dict.keys.contains("RoleArn") {
                        self.roleArn = dict["RoleArn"] as! String
                    }
                }
            }
            public var frameType: String?

            public var height: String?

            public var interval: String?

            public var num: String?

            public var outputFile: SubmitSnapshotJobResponseBody.SnapshotJob.SnapshotConfig.OutputFile?

            public var tileOut: SubmitSnapshotJobResponseBody.SnapshotJob.SnapshotConfig.TileOut?

            public var tileOutputFile: SubmitSnapshotJobResponseBody.SnapshotJob.SnapshotConfig.TileOutputFile?

            public var time: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputFile?.validate()
                try self.tileOut?.validate()
                try self.tileOutputFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.frameType != nil {
                    map["FrameType"] = self.frameType!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.num != nil {
                    map["Num"] = self.num!
                }
                if self.outputFile != nil {
                    map["OutputFile"] = self.outputFile?.toMap()
                }
                if self.tileOut != nil {
                    map["TileOut"] = self.tileOut?.toMap()
                }
                if self.tileOutputFile != nil {
                    map["TileOutputFile"] = self.tileOutputFile?.toMap()
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FrameType") {
                    self.frameType = dict["FrameType"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! String
                }
                if dict.keys.contains("Num") {
                    self.num = dict["Num"] as! String
                }
                if dict.keys.contains("OutputFile") {
                    var model = SubmitSnapshotJobResponseBody.SnapshotJob.SnapshotConfig.OutputFile()
                    model.fromMap(dict["OutputFile"] as! [String: Any])
                    self.outputFile = model
                }
                if dict.keys.contains("TileOut") {
                    var model = SubmitSnapshotJobResponseBody.SnapshotJob.SnapshotConfig.TileOut()
                    model.fromMap(dict["TileOut"] as! [String: Any])
                    self.tileOut = model
                }
                if dict.keys.contains("TileOutputFile") {
                    var model = SubmitSnapshotJobResponseBody.SnapshotJob.SnapshotConfig.TileOutputFile()
                    model.fromMap(dict["TileOutputFile"] as! [String: Any])
                    self.tileOutputFile = model
                }
                if dict.keys.contains("Time") {
                    self.time = dict["Time"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var code: String?

        public var count: String?

        public var creationTime: String?

        public var id: String?

        public var input: SubmitSnapshotJobResponseBody.SnapshotJob.Input?

        public var MNSMessageResult: SubmitSnapshotJobResponseBody.SnapshotJob.MNSMessageResult?

        public var message: String?

        public var pipelineId: String?

        public var snapshotConfig: SubmitSnapshotJobResponseBody.SnapshotJob.SnapshotConfig?

        public var state: String?

        public var tileCount: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.MNSMessageResult?.validate()
            try self.snapshotConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.MNSMessageResult != nil {
                map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.snapshotConfig != nil {
                map["SnapshotConfig"] = self.snapshotConfig?.toMap()
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.tileCount != nil {
                map["TileCount"] = self.tileCount!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Input") {
                var model = SubmitSnapshotJobResponseBody.SnapshotJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("MNSMessageResult") {
                var model = SubmitSnapshotJobResponseBody.SnapshotJob.MNSMessageResult()
                model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                self.MNSMessageResult = model
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("SnapshotConfig") {
                var model = SubmitSnapshotJobResponseBody.SnapshotJob.SnapshotConfig()
                model.fromMap(dict["SnapshotConfig"] as! [String: Any])
                self.snapshotConfig = model
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("TileCount") {
                self.tileCount = dict["TileCount"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var requestId: String?

    public var snapshotJob: SubmitSnapshotJobResponseBody.SnapshotJob?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotJob != nil {
            map["SnapshotJob"] = self.snapshotJob?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotJob") {
            var model = SubmitSnapshotJobResponseBody.SnapshotJob()
            model.fromMap(dict["SnapshotJob"] as! [String: Any])
            self.snapshotJob = model
        }
    }
}

public class SubmitSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnbindInputBucketRequest : Tea.TeaModel {
    public var bucket: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var roleArn: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucket != nil {
            map["Bucket"] = self.bucket!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.roleArn != nil {
            map["RoleArn"] = self.roleArn!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bucket") {
            self.bucket = dict["Bucket"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RoleArn") {
            self.roleArn = dict["RoleArn"] as! String
        }
    }
}

public class UnbindInputBucketResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnbindInputBucketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindInputBucketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnbindInputBucketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnbindOutputBucketRequest : Tea.TeaModel {
    public var bucket: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucket != nil {
            map["Bucket"] = self.bucket!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bucket") {
            self.bucket = dict["Bucket"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UnbindOutputBucketResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnbindOutputBucketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindOutputBucketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnbindOutputBucketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCategoryNameRequest : Tea.TeaModel {
    public var cateId: String?

    public var cateName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.cateName != nil {
            map["CateName"] = self.cateName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! String
        }
        if dict.keys.contains("CateName") {
            self.cateName = dict["CateName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UpdateCategoryNameResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateCategoryNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCategoryNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCategoryNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var coverURL: String?

    public var description_: String?

    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateMediaResponseBody : Tea.TeaModel {
    public class Media : Tea.TeaModel {
        public class File : Tea.TeaModel {
            public var state: String?

            public var URL: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.URL != nil {
                    map["URL"] = self.URL!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("URL") {
                    self.URL = dict["URL"] as! String
                }
            }
        }
        public class RunIdList : Tea.TeaModel {
            public var runId: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.runId != nil {
                    map["RunId"] = self.runId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RunId") {
                    self.runId = dict["RunId"] as! [String]
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var tag: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Tag") {
                    self.tag = dict["Tag"] as! [String]
                }
            }
        }
        public var bitrate: String?

        public var cateId: Int64?

        public var censorState: String?

        public var coverURL: String?

        public var creationTime: String?

        public var description_: String?

        public var duration: String?

        public var file: UpdateMediaResponseBody.Media.File?

        public var format: String?

        public var fps: String?

        public var height: String?

        public var mediaId: String?

        public var publishState: String?

        public var runIdList: UpdateMediaResponseBody.Media.RunIdList?

        public var size: String?

        public var tags: UpdateMediaResponseBody.Media.Tags?

        public var title: String?

        public var width: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.file?.validate()
            try self.runIdList?.validate()
            try self.tags?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bitrate != nil {
                map["Bitrate"] = self.bitrate!
            }
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.censorState != nil {
                map["CensorState"] = self.censorState!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.file != nil {
                map["File"] = self.file?.toMap()
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.fps != nil {
                map["Fps"] = self.fps!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.publishState != nil {
                map["PublishState"] = self.publishState!
            }
            if self.runIdList != nil {
                map["RunIdList"] = self.runIdList?.toMap()
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.tags != nil {
                map["Tags"] = self.tags?.toMap()
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bitrate") {
                self.bitrate = dict["Bitrate"] as! String
            }
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CensorState") {
                self.censorState = dict["CensorState"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("File") {
                var model = UpdateMediaResponseBody.Media.File()
                model.fromMap(dict["File"] as! [String: Any])
                self.file = model
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("Fps") {
                self.fps = dict["Fps"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("PublishState") {
                self.publishState = dict["PublishState"] as! String
            }
            if dict.keys.contains("RunIdList") {
                var model = UpdateMediaResponseBody.Media.RunIdList()
                model.fromMap(dict["RunIdList"] as! [String: Any])
                self.runIdList = model
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! String
            }
            if dict.keys.contains("Tags") {
                var model = UpdateMediaResponseBody.Media.Tags()
                model.fromMap(dict["Tags"] as! [String: Any])
                self.tags = model
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! String
            }
        }
    }
    public var media: UpdateMediaResponseBody.Media?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.media?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.media != nil {
            map["Media"] = self.media?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Media") {
            var model = UpdateMediaResponseBody.Media()
            model.fromMap(dict["Media"] as! [String: Any])
            self.media = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaCategoryRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UpdateMediaCategoryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaCoverRequest : Tea.TeaModel {
    public var coverURL: String?

    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UpdateMediaCoverResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaCoverResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaCoverResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaCoverResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaPublishStateRequest : Tea.TeaModel {
    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var publish: Bool?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publish != nil {
            map["Publish"] = self.publish!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Publish") {
            self.publish = dict["Publish"] as! Bool
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UpdateMediaPublishStateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaPublishStateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaPublishStateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaPublishStateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaWorkflowRequest : Tea.TeaModel {
    public var mediaWorkflowId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var topology: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowId != nil {
            map["MediaWorkflowId"] = self.mediaWorkflowId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.topology != nil {
            map["Topology"] = self.topology!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowId") {
            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Topology") {
            self.topology = dict["Topology"] as! String
        }
    }
}

public class UpdateMediaWorkflowResponseBody : Tea.TeaModel {
    public class MediaWorkflow : Tea.TeaModel {
        public var creationTime: String?

        public var mediaWorkflowId: String?

        public var name: String?

        public var state: String?

        public var topology: String?

        public var triggerMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.mediaWorkflowId != nil {
                map["MediaWorkflowId"] = self.mediaWorkflowId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.topology != nil {
                map["Topology"] = self.topology!
            }
            if self.triggerMode != nil {
                map["TriggerMode"] = self.triggerMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("MediaWorkflowId") {
                self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Topology") {
                self.topology = dict["Topology"] as! String
            }
            if dict.keys.contains("TriggerMode") {
                self.triggerMode = dict["TriggerMode"] as! String
            }
        }
    }
    public var mediaWorkflow: UpdateMediaWorkflowResponseBody.MediaWorkflow?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflow?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflow != nil {
            map["MediaWorkflow"] = self.mediaWorkflow?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflow") {
            var model = UpdateMediaWorkflowResponseBody.MediaWorkflow()
            model.fromMap(dict["MediaWorkflow"] as! [String: Any])
            self.mediaWorkflow = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaWorkflowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaWorkflowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaWorkflowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaWorkflowTriggerModeRequest : Tea.TeaModel {
    public var mediaWorkflowId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var triggerMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowId != nil {
            map["MediaWorkflowId"] = self.mediaWorkflowId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.triggerMode != nil {
            map["TriggerMode"] = self.triggerMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowId") {
            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TriggerMode") {
            self.triggerMode = dict["TriggerMode"] as! String
        }
    }
}

public class UpdateMediaWorkflowTriggerModeResponseBody : Tea.TeaModel {
    public class MediaWorkflow : Tea.TeaModel {
        public var creationTime: String?

        public var mediaWorkflowId: String?

        public var name: String?

        public var state: String?

        public var topology: String?

        public var triggerMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.mediaWorkflowId != nil {
                map["MediaWorkflowId"] = self.mediaWorkflowId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.topology != nil {
                map["Topology"] = self.topology!
            }
            if self.triggerMode != nil {
                map["TriggerMode"] = self.triggerMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("MediaWorkflowId") {
                self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Topology") {
                self.topology = dict["Topology"] as! String
            }
            if dict.keys.contains("TriggerMode") {
                self.triggerMode = dict["TriggerMode"] as! String
            }
        }
    }
    public var mediaWorkflow: UpdateMediaWorkflowTriggerModeResponseBody.MediaWorkflow?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflow?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflow != nil {
            map["MediaWorkflow"] = self.mediaWorkflow?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflow") {
            var model = UpdateMediaWorkflowTriggerModeResponseBody.MediaWorkflow()
            model.fromMap(dict["MediaWorkflow"] as! [String: Any])
            self.mediaWorkflow = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaWorkflowTriggerModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaWorkflowTriggerModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaWorkflowTriggerModeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePipelineRequest : Tea.TeaModel {
    public var name: String?

    public var notifyConfig: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var role: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifyConfig != nil {
            map["NotifyConfig"] = self.notifyConfig!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NotifyConfig") {
            self.notifyConfig = dict["NotifyConfig"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class UpdatePipelineResponseBody : Tea.TeaModel {
    public class Pipeline : Tea.TeaModel {
        public class NotifyConfig : Tea.TeaModel {
            public var queueName: String?

            public var topic: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.queueName != nil {
                    map["QueueName"] = self.queueName!
                }
                if self.topic != nil {
                    map["Topic"] = self.topic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("QueueName") {
                    self.queueName = dict["QueueName"] as! String
                }
                if dict.keys.contains("Topic") {
                    self.topic = dict["Topic"] as! String
                }
            }
        }
        public var id: String?

        public var name: String?

        public var notifyConfig: UpdatePipelineResponseBody.Pipeline.NotifyConfig?

        public var role: String?

        public var speed: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.notifyConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifyConfig != nil {
                map["NotifyConfig"] = self.notifyConfig?.toMap()
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.speed != nil {
                map["Speed"] = self.speed!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NotifyConfig") {
                var model = UpdatePipelineResponseBody.Pipeline.NotifyConfig()
                model.fromMap(dict["NotifyConfig"] as! [String: Any])
                self.notifyConfig = model
            }
            if dict.keys.contains("Role") {
                self.role = dict["Role"] as! String
            }
            if dict.keys.contains("Speed") {
                self.speed = dict["Speed"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var pipeline: UpdatePipelineResponseBody.Pipeline?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipeline != nil {
            map["Pipeline"] = self.pipeline?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pipeline") {
            var model = UpdatePipelineResponseBody.Pipeline()
            model.fromMap(dict["Pipeline"] as! [String: Any])
            self.pipeline = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdatePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTemplateRequest : Tea.TeaModel {
    public var audio: String?

    public var container: String?

    public var muxConfig: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateId: String?

    public var transConfig: String?

    public var video: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audio != nil {
            map["Audio"] = self.audio!
        }
        if self.container != nil {
            map["Container"] = self.container!
        }
        if self.muxConfig != nil {
            map["MuxConfig"] = self.muxConfig!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.transConfig != nil {
            map["TransConfig"] = self.transConfig!
        }
        if self.video != nil {
            map["Video"] = self.video!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Audio") {
            self.audio = dict["Audio"] as! String
        }
        if dict.keys.contains("Container") {
            self.container = dict["Container"] as! String
        }
        if dict.keys.contains("MuxConfig") {
            self.muxConfig = dict["MuxConfig"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TransConfig") {
            self.transConfig = dict["TransConfig"] as! String
        }
        if dict.keys.contains("Video") {
            self.video = dict["Video"] as! String
        }
    }
}

public class UpdateTemplateResponseBody : Tea.TeaModel {
    public class Template : Tea.TeaModel {
        public class Audio : Tea.TeaModel {
            public var bitrate: String?

            public var channels: String?

            public var codec: String?

            public var profile: String?

            public var qscale: String?

            public var remove: String?

            public var samplerate: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.qscale != nil {
                    map["Qscale"] = self.qscale!
                }
                if self.remove != nil {
                    map["Remove"] = self.remove!
                }
                if self.samplerate != nil {
                    map["Samplerate"] = self.samplerate!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Channels") {
                    self.channels = dict["Channels"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Qscale") {
                    self.qscale = dict["Qscale"] as! String
                }
                if dict.keys.contains("Remove") {
                    self.remove = dict["Remove"] as! String
                }
                if dict.keys.contains("Samplerate") {
                    self.samplerate = dict["Samplerate"] as! String
                }
            }
        }
        public class Container : Tea.TeaModel {
            public var format: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.format != nil {
                    map["Format"] = self.format!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
            }
        }
        public class MuxConfig : Tea.TeaModel {
            public class Gif : Tea.TeaModel {
                public var ditherMode: String?

                public var finalDelay: String?

                public var isCustomPalette: String?

                public var loop: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ditherMode != nil {
                        map["DitherMode"] = self.ditherMode!
                    }
                    if self.finalDelay != nil {
                        map["FinalDelay"] = self.finalDelay!
                    }
                    if self.isCustomPalette != nil {
                        map["IsCustomPalette"] = self.isCustomPalette!
                    }
                    if self.loop != nil {
                        map["Loop"] = self.loop!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DitherMode") {
                        self.ditherMode = dict["DitherMode"] as! String
                    }
                    if dict.keys.contains("FinalDelay") {
                        self.finalDelay = dict["FinalDelay"] as! String
                    }
                    if dict.keys.contains("IsCustomPalette") {
                        self.isCustomPalette = dict["IsCustomPalette"] as! String
                    }
                    if dict.keys.contains("Loop") {
                        self.loop = dict["Loop"] as! String
                    }
                }
            }
            public class Segment : Tea.TeaModel {
                public var duration: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                }
            }
            public class Webp : Tea.TeaModel {
                public var loop: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.loop != nil {
                        map["Loop"] = self.loop!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Loop") {
                        self.loop = dict["Loop"] as! String
                    }
                }
            }
            public var gif: UpdateTemplateResponseBody.Template.MuxConfig.Gif?

            public var segment: UpdateTemplateResponseBody.Template.MuxConfig.Segment?

            public var webp: UpdateTemplateResponseBody.Template.MuxConfig.Webp?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.gif?.validate()
                try self.segment?.validate()
                try self.webp?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gif != nil {
                    map["Gif"] = self.gif?.toMap()
                }
                if self.segment != nil {
                    map["Segment"] = self.segment?.toMap()
                }
                if self.webp != nil {
                    map["Webp"] = self.webp?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Gif") {
                    var model = UpdateTemplateResponseBody.Template.MuxConfig.Gif()
                    model.fromMap(dict["Gif"] as! [String: Any])
                    self.gif = model
                }
                if dict.keys.contains("Segment") {
                    var model = UpdateTemplateResponseBody.Template.MuxConfig.Segment()
                    model.fromMap(dict["Segment"] as! [String: Any])
                    self.segment = model
                }
                if dict.keys.contains("Webp") {
                    var model = UpdateTemplateResponseBody.Template.MuxConfig.Webp()
                    model.fromMap(dict["Webp"] as! [String: Any])
                    self.webp = model
                }
            }
        }
        public class TransConfig : Tea.TeaModel {
            public var adjDarMethod: String?

            public var isCheckAudioBitrate: String?

            public var isCheckAudioBitrateFail: String?

            public var isCheckReso: String?

            public var isCheckResoFail: String?

            public var isCheckVideoBitrate: String?

            public var isCheckVideoBitrateFail: String?

            public var transMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adjDarMethod != nil {
                    map["AdjDarMethod"] = self.adjDarMethod!
                }
                if self.isCheckAudioBitrate != nil {
                    map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                }
                if self.isCheckAudioBitrateFail != nil {
                    map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                }
                if self.isCheckReso != nil {
                    map["IsCheckReso"] = self.isCheckReso!
                }
                if self.isCheckResoFail != nil {
                    map["IsCheckResoFail"] = self.isCheckResoFail!
                }
                if self.isCheckVideoBitrate != nil {
                    map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                }
                if self.isCheckVideoBitrateFail != nil {
                    map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                }
                if self.transMode != nil {
                    map["TransMode"] = self.transMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdjDarMethod") {
                    self.adjDarMethod = dict["AdjDarMethod"] as! String
                }
                if dict.keys.contains("IsCheckAudioBitrate") {
                    self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                }
                if dict.keys.contains("IsCheckAudioBitrateFail") {
                    self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                }
                if dict.keys.contains("IsCheckReso") {
                    self.isCheckReso = dict["IsCheckReso"] as! String
                }
                if dict.keys.contains("IsCheckResoFail") {
                    self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                }
                if dict.keys.contains("IsCheckVideoBitrate") {
                    self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                }
                if dict.keys.contains("IsCheckVideoBitrateFail") {
                    self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                }
                if dict.keys.contains("TransMode") {
                    self.transMode = dict["TransMode"] as! String
                }
            }
        }
        public class Video : Tea.TeaModel {
            public class BitrateBnd : Tea.TeaModel {
                public var max: String?

                public var min: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.max != nil {
                        map["Max"] = self.max!
                    }
                    if self.min != nil {
                        map["Min"] = self.min!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Max") {
                        self.max = dict["Max"] as! String
                    }
                    if dict.keys.contains("Min") {
                        self.min = dict["Min"] as! String
                    }
                }
            }
            public var bitrate: String?

            public var bitrateBnd: UpdateTemplateResponseBody.Template.Video.BitrateBnd?

            public var bufsize: String?

            public var codec: String?

            public var crf: String?

            public var crop: String?

            public var degrain: String?

            public var fps: String?

            public var gop: String?

            public var height: String?

            public var maxFps: String?

            public var maxrate: String?

            public var pad: String?

            public var pixFmt: String?

            public var preset: String?

            public var profile: String?

            public var qscale: String?

            public var remove: String?

            public var resoPriority: String?

            public var scanMode: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.bitrateBnd?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.bitrateBnd != nil {
                    map["BitrateBnd"] = self.bitrateBnd?.toMap()
                }
                if self.bufsize != nil {
                    map["Bufsize"] = self.bufsize!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.crf != nil {
                    map["Crf"] = self.crf!
                }
                if self.crop != nil {
                    map["Crop"] = self.crop!
                }
                if self.degrain != nil {
                    map["Degrain"] = self.degrain!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.gop != nil {
                    map["Gop"] = self.gop!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.maxFps != nil {
                    map["MaxFps"] = self.maxFps!
                }
                if self.maxrate != nil {
                    map["Maxrate"] = self.maxrate!
                }
                if self.pad != nil {
                    map["Pad"] = self.pad!
                }
                if self.pixFmt != nil {
                    map["PixFmt"] = self.pixFmt!
                }
                if self.preset != nil {
                    map["Preset"] = self.preset!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.qscale != nil {
                    map["Qscale"] = self.qscale!
                }
                if self.remove != nil {
                    map["Remove"] = self.remove!
                }
                if self.resoPriority != nil {
                    map["ResoPriority"] = self.resoPriority!
                }
                if self.scanMode != nil {
                    map["ScanMode"] = self.scanMode!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("BitrateBnd") {
                    var model = UpdateTemplateResponseBody.Template.Video.BitrateBnd()
                    model.fromMap(dict["BitrateBnd"] as! [String: Any])
                    self.bitrateBnd = model
                }
                if dict.keys.contains("Bufsize") {
                    self.bufsize = dict["Bufsize"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Crf") {
                    self.crf = dict["Crf"] as! String
                }
                if dict.keys.contains("Crop") {
                    self.crop = dict["Crop"] as! String
                }
                if dict.keys.contains("Degrain") {
                    self.degrain = dict["Degrain"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Gop") {
                    self.gop = dict["Gop"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("MaxFps") {
                    self.maxFps = dict["MaxFps"] as! String
                }
                if dict.keys.contains("Maxrate") {
                    self.maxrate = dict["Maxrate"] as! String
                }
                if dict.keys.contains("Pad") {
                    self.pad = dict["Pad"] as! String
                }
                if dict.keys.contains("PixFmt") {
                    self.pixFmt = dict["PixFmt"] as! String
                }
                if dict.keys.contains("Preset") {
                    self.preset = dict["Preset"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Qscale") {
                    self.qscale = dict["Qscale"] as! String
                }
                if dict.keys.contains("Remove") {
                    self.remove = dict["Remove"] as! String
                }
                if dict.keys.contains("ResoPriority") {
                    self.resoPriority = dict["ResoPriority"] as! String
                }
                if dict.keys.contains("ScanMode") {
                    self.scanMode = dict["ScanMode"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var audio: UpdateTemplateResponseBody.Template.Audio?

        public var container: UpdateTemplateResponseBody.Template.Container?

        public var id: String?

        public var muxConfig: UpdateTemplateResponseBody.Template.MuxConfig?

        public var name: String?

        public var state: String?

        public var transConfig: UpdateTemplateResponseBody.Template.TransConfig?

        public var video: UpdateTemplateResponseBody.Template.Video?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.audio?.validate()
            try self.container?.validate()
            try self.muxConfig?.validate()
            try self.transConfig?.validate()
            try self.video?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audio != nil {
                map["Audio"] = self.audio?.toMap()
            }
            if self.container != nil {
                map["Container"] = self.container?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.muxConfig != nil {
                map["MuxConfig"] = self.muxConfig?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.transConfig != nil {
                map["TransConfig"] = self.transConfig?.toMap()
            }
            if self.video != nil {
                map["Video"] = self.video?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Audio") {
                var model = UpdateTemplateResponseBody.Template.Audio()
                model.fromMap(dict["Audio"] as! [String: Any])
                self.audio = model
            }
            if dict.keys.contains("Container") {
                var model = UpdateTemplateResponseBody.Template.Container()
                model.fromMap(dict["Container"] as! [String: Any])
                self.container = model
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MuxConfig") {
                var model = UpdateTemplateResponseBody.Template.MuxConfig()
                model.fromMap(dict["MuxConfig"] as! [String: Any])
                self.muxConfig = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("TransConfig") {
                var model = UpdateTemplateResponseBody.Template.TransConfig()
                model.fromMap(dict["TransConfig"] as! [String: Any])
                self.transConfig = model
            }
            if dict.keys.contains("Video") {
                var model = UpdateTemplateResponseBody.Template.Video()
                model.fromMap(dict["Video"] as! [String: Any])
                self.video = model
            }
        }
    }
    public var requestId: String?

    public var template: UpdateTemplateResponseBody.Template?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.template != nil {
            map["Template"] = self.template?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Template") {
            var model = UpdateTemplateResponseBody.Template()
            model.fromMap(dict["Template"] as! [String: Any])
            self.template = model
        }
    }
}

public class UpdateTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWaterMarkTemplateRequest : Tea.TeaModel {
    public var config: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var waterMarkTemplateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.waterMarkTemplateId != nil {
            map["WaterMarkTemplateId"] = self.waterMarkTemplateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("WaterMarkTemplateId") {
            self.waterMarkTemplateId = dict["WaterMarkTemplateId"] as! String
        }
    }
}

public class UpdateWaterMarkTemplateResponseBody : Tea.TeaModel {
    public class WaterMarkTemplate : Tea.TeaModel {
        public class RatioRefer : Tea.TeaModel {
            public var dx: String?

            public var dy: String?

            public var height: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dx != nil {
                    map["Dx"] = self.dx!
                }
                if self.dy != nil {
                    map["Dy"] = self.dy!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Dx") {
                    self.dx = dict["Dx"] as! String
                }
                if dict.keys.contains("Dy") {
                    self.dy = dict["Dy"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public class Timeline : Tea.TeaModel {
            public var duration: String?

            public var start: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.start != nil {
                    map["Start"] = self.start!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("Start") {
                    self.start = dict["Start"] as! String
                }
            }
        }
        public var dx: String?

        public var dy: String?

        public var height: String?

        public var id: String?

        public var name: String?

        public var ratioRefer: UpdateWaterMarkTemplateResponseBody.WaterMarkTemplate.RatioRefer?

        public var referPos: String?

        public var state: String?

        public var timeline: UpdateWaterMarkTemplateResponseBody.WaterMarkTemplate.Timeline?

        public var type: String?

        public var width: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ratioRefer?.validate()
            try self.timeline?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dx != nil {
                map["Dx"] = self.dx!
            }
            if self.dy != nil {
                map["Dy"] = self.dy!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ratioRefer != nil {
                map["RatioRefer"] = self.ratioRefer?.toMap()
            }
            if self.referPos != nil {
                map["ReferPos"] = self.referPos!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Dx") {
                self.dx = dict["Dx"] as! String
            }
            if dict.keys.contains("Dy") {
                self.dy = dict["Dy"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RatioRefer") {
                var model = UpdateWaterMarkTemplateResponseBody.WaterMarkTemplate.RatioRefer()
                model.fromMap(dict["RatioRefer"] as! [String: Any])
                self.ratioRefer = model
            }
            if dict.keys.contains("ReferPos") {
                self.referPos = dict["ReferPos"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Timeline") {
                var model = UpdateWaterMarkTemplateResponseBody.WaterMarkTemplate.Timeline()
                model.fromMap(dict["Timeline"] as! [String: Any])
                self.timeline = model
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! String
            }
        }
    }
    public var requestId: String?

    public var waterMarkTemplate: UpdateWaterMarkTemplateResponseBody.WaterMarkTemplate?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.waterMarkTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.waterMarkTemplate != nil {
            map["WaterMarkTemplate"] = self.waterMarkTemplate?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WaterMarkTemplate") {
            var model = UpdateWaterMarkTemplateResponseBody.WaterMarkTemplate()
            model.fromMap(dict["WaterMarkTemplate"] as! [String: Any])
            self.waterMarkTemplate = model
        }
    }
}

public class UpdateWaterMarkTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWaterMarkTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateWaterMarkTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
