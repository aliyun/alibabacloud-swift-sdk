import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AntChainPurposeResponse : Tea.TeaModel {
    public var chainPurposeExtend: String?

    public var chainPurposeItem: String?

    public var createTime: String?

    public var purpose: String?

    public var recordList: [ChainPurpose]?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chainPurposeExtend != nil {
            map["ChainPurposeExtend"] = self.chainPurposeExtend!
        }
        if self.chainPurposeItem != nil {
            map["ChainPurposeItem"] = self.chainPurposeItem!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.purpose != nil {
            map["Purpose"] = self.purpose!
        }
        if self.recordList != nil {
            var tmp : [Any] = []
            for k in self.recordList! {
                tmp.append(k.toMap())
            }
            map["RecordList"] = tmp
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChainPurposeExtend") {
            self.chainPurposeExtend = dict["ChainPurposeExtend"] as! String
        }
        if dict.keys.contains("ChainPurposeItem") {
            self.chainPurposeItem = dict["ChainPurposeItem"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("Purpose") {
            self.purpose = dict["Purpose"] as! String
        }
        if dict.keys.contains("RecordList") {
            var tmp : [ChainPurpose] = []
            for v in dict["RecordList"] as! [Any] {
                var model = ChainPurpose()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.recordList = tmp
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class AntChainPurposeResponseAli : Tea.TeaModel {
    public var recordList: [ChainPurposeInfoAli]?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.recordList != nil {
            var tmp : [Any] = []
            for k in self.recordList! {
                tmp.append(k.toMap())
            }
            map["RecordList"] = tmp
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RecordList") {
            var tmp : [ChainPurposeInfoAli] = []
            for v in dict["RecordList"] as! [Any] {
                var model = ChainPurposeInfoAli()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.recordList = tmp
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ChainPurpose : Tea.TeaModel {
    public var extend: Bool?

    public var id: String?

    public var item: Bool?

    public var key: String?

    public var name: String?

    public var purposeItem: String?

    public var status: String?

    public var time: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extend != nil {
            map["Extend"] = self.extend!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.item != nil {
            map["Item"] = self.item!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.purposeItem != nil {
            map["PurposeItem"] = self.purposeItem!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.time != nil {
            map["Time"] = self.time!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Extend") {
            self.extend = dict["Extend"] as! Bool
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Item") {
            self.item = dict["Item"] as! Bool
        }
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PurposeItem") {
            self.purposeItem = dict["PurposeItem"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Time") {
            self.time = dict["Time"] as! String
        }
    }
}

public class ChainPurposeInfoAli : Tea.TeaModel {
    public var chainPurposeExtend: String?

    public var chainPurposeItem: String?

    public var id: String?

    public var key: String?

    public var purpose: String?

    public var status: String?

    public var time: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chainPurposeExtend != nil {
            map["ChainPurposeExtend"] = self.chainPurposeExtend!
        }
        if self.chainPurposeItem != nil {
            map["ChainPurposeItem"] = self.chainPurposeItem!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.purpose != nil {
            map["Purpose"] = self.purpose!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.time != nil {
            map["Time"] = self.time!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChainPurposeExtend") {
            self.chainPurposeExtend = dict["ChainPurposeExtend"] as! String
        }
        if dict.keys.contains("ChainPurposeItem") {
            self.chainPurposeItem = dict["ChainPurposeItem"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("Purpose") {
            self.purpose = dict["Purpose"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Time") {
            self.time = dict["Time"] as! String
        }
    }
}

public class ChainPurposeListAli : Tea.TeaModel {
    public var extend: Bool?

    public var id: String?

    public var item: Bool?

    public var key: String?

    public var purpose: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extend != nil {
            map["Extend"] = self.extend!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.item != nil {
            map["Item"] = self.item!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.purpose != nil {
            map["Purpose"] = self.purpose!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Extend") {
            self.extend = dict["Extend"] as! Bool
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Item") {
            self.item = dict["Item"] as! Bool
        }
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("Purpose") {
            self.purpose = dict["Purpose"] as! String
        }
    }
}

public class CheckPointStructBody : Tea.TeaModel {
    public var errorCount: String?

    public var height: String?

    public var index: String?

    public var lastError: String?

    public var totalCount: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCount != nil {
            map["ErrorCount"] = self.errorCount!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.index != nil {
            map["Index"] = self.index!
        }
        if self.lastError != nil {
            map["LastError"] = self.lastError!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCount") {
            self.errorCount = dict["ErrorCount"] as! String
        }
        if dict.keys.contains("Height") {
            self.height = dict["Height"] as! String
        }
        if dict.keys.contains("Index") {
            self.index = dict["Index"] as! String
        }
        if dict.keys.contains("LastError") {
            self.lastError = dict["LastError"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CommonResponsePageableStructBody : Tea.TeaModel {
    public var current: String?

    public var list: [TriggerLogDTOStructBody]?

    public var pageSize: String?

    public var total: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.current != nil {
            map["Current"] = self.current!
        }
        if self.list != nil {
            var tmp : [Any] = []
            for k in self.list! {
                tmp.append(k.toMap())
            }
            map["List"] = tmp
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Current") {
            self.current = dict["Current"] as! String
        }
        if dict.keys.contains("List") {
            var tmp : [TriggerLogDTOStructBody] = []
            for v in dict["List"] as! [Any] {
                var model = TriggerLogDTOStructBody()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.list = tmp
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("Total") {
            self.total = dict["Total"] as! String
        }
    }
}

public class PositionStructBody : Tea.TeaModel {
    public var errorCount: String?

    public var height: String?

    public var index: String?

    public var lastError: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCount != nil {
            map["ErrorCount"] = self.errorCount!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        if self.index != nil {
            map["Index"] = self.index!
        }
        if self.lastError != nil {
            map["LastError"] = self.lastError!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCount") {
            self.errorCount = dict["ErrorCount"] as! String
        }
        if dict.keys.contains("Height") {
            self.height = dict["Height"] as! String
        }
        if dict.keys.contains("Index") {
            self.index = dict["Index"] as! String
        }
        if dict.keys.contains("LastError") {
            self.lastError = dict["LastError"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class TriggerDTOStructBody : Tea.TeaModel {
    public var checkpoint: CheckPointStructBody?

    public var createTime: String?

    public var errorMessage: String?

    public var name: String?

    public var option: String?

    public var pendingErrorLogs: String?

    public var source: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.checkpoint?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.checkpoint != nil {
            map["Checkpoint"] = self.checkpoint?.toMap()
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.option != nil {
            map["Option"] = self.option!
        }
        if self.pendingErrorLogs != nil {
            map["PendingErrorLogs"] = self.pendingErrorLogs!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Checkpoint") {
            var model = CheckPointStructBody()
            model.fromMap(dict["Checkpoint"] as! [String: Any])
            self.checkpoint = model
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Option") {
            self.option = dict["Option"] as! String
        }
        if dict.keys.contains("PendingErrorLogs") {
            self.pendingErrorLogs = dict["PendingErrorLogs"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class TriggerLogDTOStructBody : Tea.TeaModel {
    public var createTime: String?

    public var modifyTime: String?

    public var position: PositionStructBody?

    public var status: String?

    public var uuid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.position?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.modifyTime != nil {
            map["ModifyTime"] = self.modifyTime!
        }
        if self.position != nil {
            map["Position"] = self.position?.toMap()
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.uuid != nil {
            map["Uuid"] = self.uuid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("ModifyTime") {
            self.modifyTime = dict["ModifyTime"] as! String
        }
        if dict.keys.contains("Position") {
            var model = PositionStructBody()
            model.fromMap(dict["Position"] as! [String: Any])
            self.position = model
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Uuid") {
            self.uuid = dict["Uuid"] as! String
        }
    }
}

public class AcceptEthereumInvitationRequest : Tea.TeaModel {
    public var code: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
    }
}

public class AcceptEthereumInvitationResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AcceptEthereumInvitationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AcceptEthereumInvitationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AcceptEthereumInvitationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AcceptInvitationRequest : Tea.TeaModel {
    public var code: String?

    public var isAccepted: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.isAccepted != nil {
            map["IsAccepted"] = self.isAccepted!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("IsAccepted") {
            self.isAccepted = dict["IsAccepted"] as! Bool
        }
    }
}

public class AcceptInvitationResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AcceptInvitationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AcceptInvitationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AcceptInvitationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddAntChainSubnetMemberCheckRequest : Tea.TeaModel {
    public var antChainId: String?

    public var consortiumId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
    }
}

public class AddAntChainSubnetMemberCheckResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ConsortiumMemberInfoList : Tea.TeaModel {
            public var memberId: String?

            public var memberName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.memberId != nil {
                    map["MemberId"] = self.memberId!
                }
                if self.memberName != nil {
                    map["MemberName"] = self.memberName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MemberId") {
                    self.memberId = dict["MemberId"] as! String
                }
                if dict.keys.contains("MemberName") {
                    self.memberName = dict["MemberName"] as! String
                }
            }
        }
        public var consortiumMemberInfoList: [AddAntChainSubnetMemberCheckResponseBody.Result.ConsortiumMemberInfoList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consortiumMemberInfoList != nil {
                var tmp : [Any] = []
                for k in self.consortiumMemberInfoList! {
                    tmp.append(k.toMap())
                }
                map["ConsortiumMemberInfoList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsortiumMemberInfoList") {
                var tmp : [AddAntChainSubnetMemberCheckResponseBody.Result.ConsortiumMemberInfoList] = []
                for v in dict["ConsortiumMemberInfoList"] as! [Any] {
                    var model = AddAntChainSubnetMemberCheckResponseBody.Result.ConsortiumMemberInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.consortiumMemberInfoList = tmp
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: AddAntChainSubnetMemberCheckResponseBody.Result?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = AddAntChainSubnetMemberCheckResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddAntChainSubnetMemberCheckResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAntChainSubnetMemberCheckResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddAntChainSubnetMemberCheckResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddAntChainSubnetNodeCheckRequest : Tea.TeaModel {
    public var antChainId: String?

    public var consortiumId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
    }
}

public class AddAntChainSubnetNodeCheckResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var nodeId: String?

        public var nodeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: [AddAntChainSubnetNodeCheckResponseBody.Result]?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [AddAntChainSubnetNodeCheckResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = AddAntChainSubnetNodeCheckResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddAntChainSubnetNodeCheckResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddAntChainSubnetNodeCheckResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddAntChainSubnetNodeCheckResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddEthereumNodeRequest : Tea.TeaModel {
    public var description_: String?

    public var ethereumId: String?

    public var externalNode: Bool?

    public var nodeName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ethereumId != nil {
            map["EthereumId"] = self.ethereumId!
        }
        if self.externalNode != nil {
            map["ExternalNode"] = self.externalNode!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EthereumId") {
            self.ethereumId = dict["EthereumId"] as! String
        }
        if dict.keys.contains("ExternalNode") {
            self.externalNode = dict["ExternalNode"] as! Bool
        }
        if dict.keys.contains("NodeName") {
            self.nodeName = dict["NodeName"] as! String
        }
    }
}

public class AddEthereumNodeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createTime: Int64?

        public var creator: String?

        public var description_: String?

        public var ethereumId: String?

        public var ethereumName: String?

        public var id: String?

        public var networkId: String?

        public var nodeName: String?

        public var publicIp: String?

        public var regionId: String?

        public var rpcPort: Int32?

        public var state: String?

        public var wsPort: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ethereumId != nil {
                map["EthereumId"] = self.ethereumId!
            }
            if self.ethereumName != nil {
                map["EthereumName"] = self.ethereumName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.publicIp != nil {
                map["PublicIp"] = self.publicIp!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.rpcPort != nil {
                map["RpcPort"] = self.rpcPort!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.wsPort != nil {
                map["WsPort"] = self.wsPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EthereumId") {
                self.ethereumId = dict["EthereumId"] as! String
            }
            if dict.keys.contains("EthereumName") {
                self.ethereumName = dict["EthereumName"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("NetworkId") {
                self.networkId = dict["NetworkId"] as! String
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("PublicIp") {
                self.publicIp = dict["PublicIp"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RpcPort") {
                self.rpcPort = dict["RpcPort"] as! Int32
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("WsPort") {
                self.wsPort = dict["WsPort"] as! Int32
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: AddEthereumNodeResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = AddEthereumNodeResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddEthereumNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddEthereumNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddEthereumNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddFabricExternalOrganizationToChannelRequest : Tea.TeaModel {
    public var channelId: String?

    public var description_: String?

    public var joinRequest: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.joinRequest != nil {
            map["JoinRequest"] = self.joinRequest!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("JoinRequest") {
            self.joinRequest = dict["JoinRequest"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class AddFabricExternalOrganizationToChannelResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public class AddedOrganizations : Tea.TeaModel {
                public class AnchorPeers : Tea.TeaModel {
                    public var host: String?

                    public var port: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.host != nil {
                            map["Host"] = self.host!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Host") {
                            self.host = dict["Host"] as! String
                        }
                        if dict.keys.contains("Port") {
                            self.port = dict["Port"] as! Int32
                        }
                    }
                }
                public class OrdererNodes : Tea.TeaModel {
                    public var address: String?

                    public var certificate: String?

                    public var key: String?

                    public var tlsroot: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.certificate != nil {
                            map["Certificate"] = self.certificate!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.tlsroot != nil {
                            map["Tlsroot"] = self.tlsroot!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Address") {
                            self.address = dict["Address"] as! String
                        }
                        if dict.keys.contains("Certificate") {
                            self.certificate = dict["Certificate"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Tlsroot") {
                            self.tlsroot = dict["Tlsroot"] as! String
                        }
                    }
                }
                public var anchorPeers: [AddFabricExternalOrganizationToChannelResponseBody.Result.Content.AddedOrganizations.AnchorPeers]?

                public var crls: String?

                public var mspId: String?

                public var mspType: String?

                public var orderer: Bool?

                public var ordererNodes: [AddFabricExternalOrganizationToChannelResponseBody.Result.Content.AddedOrganizations.OrdererNodes]?

                public var rootCertificates: String?

                public var tlsRootCertificates: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.anchorPeers != nil {
                        var tmp : [Any] = []
                        for k in self.anchorPeers! {
                            tmp.append(k.toMap())
                        }
                        map["AnchorPeers"] = tmp
                    }
                    if self.crls != nil {
                        map["Crls"] = self.crls!
                    }
                    if self.mspId != nil {
                        map["MspId"] = self.mspId!
                    }
                    if self.mspType != nil {
                        map["MspType"] = self.mspType!
                    }
                    if self.orderer != nil {
                        map["Orderer"] = self.orderer!
                    }
                    if self.ordererNodes != nil {
                        var tmp : [Any] = []
                        for k in self.ordererNodes! {
                            tmp.append(k.toMap())
                        }
                        map["OrdererNodes"] = tmp
                    }
                    if self.rootCertificates != nil {
                        map["RootCertificates"] = self.rootCertificates!
                    }
                    if self.tlsRootCertificates != nil {
                        map["TlsRootCertificates"] = self.tlsRootCertificates!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnchorPeers") {
                        var tmp : [AddFabricExternalOrganizationToChannelResponseBody.Result.Content.AddedOrganizations.AnchorPeers] = []
                        for v in dict["AnchorPeers"] as! [Any] {
                            var model = AddFabricExternalOrganizationToChannelResponseBody.Result.Content.AddedOrganizations.AnchorPeers()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.anchorPeers = tmp
                    }
                    if dict.keys.contains("Crls") {
                        self.crls = dict["Crls"] as! String
                    }
                    if dict.keys.contains("MspId") {
                        self.mspId = dict["MspId"] as! String
                    }
                    if dict.keys.contains("MspType") {
                        self.mspType = dict["MspType"] as! String
                    }
                    if dict.keys.contains("Orderer") {
                        self.orderer = dict["Orderer"] as! Bool
                    }
                    if dict.keys.contains("OrdererNodes") {
                        var tmp : [AddFabricExternalOrganizationToChannelResponseBody.Result.Content.AddedOrganizations.OrdererNodes] = []
                        for v in dict["OrdererNodes"] as! [Any] {
                            var model = AddFabricExternalOrganizationToChannelResponseBody.Result.Content.AddedOrganizations.OrdererNodes()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ordererNodes = tmp
                    }
                    if dict.keys.contains("RootCertificates") {
                        self.rootCertificates = dict["RootCertificates"] as! String
                    }
                    if dict.keys.contains("TlsRootCertificates") {
                        self.tlsRootCertificates = dict["TlsRootCertificates"] as! String
                    }
                }
            }
            public class ChaincodeSpecPkg : Tea.TeaModel {
                public class Cs : Tea.TeaModel {
                    public var input: String?

                    public var name: String?

                    public var path: String?

                    public var type: Int32?

                    public var version: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.input != nil {
                            map["Input"] = self.input!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.path != nil {
                            map["Path"] = self.path!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.version != nil {
                            map["Version"] = self.version!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Input") {
                            self.input = dict["Input"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Path") {
                            self.path = dict["Path"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! Int32
                        }
                        if dict.keys.contains("Version") {
                            self.version = dict["Version"] as! String
                        }
                    }
                }
                public var cs: AddFabricExternalOrganizationToChannelResponseBody.Result.Content.ChaincodeSpecPkg.Cs?

                public var policy: String?

                public var sha256: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.cs?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cs != nil {
                        map["Cs"] = self.cs?.toMap()
                    }
                    if self.policy != nil {
                        map["Policy"] = self.policy!
                    }
                    if self.sha256 != nil {
                        map["Sha256"] = self.sha256!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cs") {
                        var model = AddFabricExternalOrganizationToChannelResponseBody.Result.Content.ChaincodeSpecPkg.Cs()
                        model.fromMap(dict["Cs"] as! [String: Any])
                        self.cs = model
                    }
                    if dict.keys.contains("Policy") {
                        self.policy = dict["Policy"] as! String
                    }
                    if dict.keys.contains("Sha256") {
                        self.sha256 = dict["Sha256"] as! String
                    }
                }
            }
            public class OrdererConfig : Tea.TeaModel {
                public var batchTimeout: String?

                public var maxMessageCount: Int32?

                public var preferredMaxBytes: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.batchTimeout != nil {
                        map["BatchTimeout"] = self.batchTimeout!
                    }
                    if self.maxMessageCount != nil {
                        map["MaxMessageCount"] = self.maxMessageCount!
                    }
                    if self.preferredMaxBytes != nil {
                        map["PreferredMaxBytes"] = self.preferredMaxBytes!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BatchTimeout") {
                        self.batchTimeout = dict["BatchTimeout"] as! String
                    }
                    if dict.keys.contains("MaxMessageCount") {
                        self.maxMessageCount = dict["MaxMessageCount"] as! Int32
                    }
                    if dict.keys.contains("PreferredMaxBytes") {
                        self.preferredMaxBytes = dict["PreferredMaxBytes"] as! Int32
                    }
                }
            }
            public class RemovedOrganizations : Tea.TeaModel {
                public class AnchorPeers : Tea.TeaModel {
                    public var host: String?

                    public var port: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.host != nil {
                            map["Host"] = self.host!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Host") {
                            self.host = dict["Host"] as! String
                        }
                        if dict.keys.contains("Port") {
                            self.port = dict["Port"] as! Int32
                        }
                    }
                }
                public class OrdererNodes : Tea.TeaModel {
                    public var address: String?

                    public var certificate: String?

                    public var key: String?

                    public var tlsroot: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.certificate != nil {
                            map["Certificate"] = self.certificate!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.tlsroot != nil {
                            map["Tlsroot"] = self.tlsroot!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Address") {
                            self.address = dict["Address"] as! String
                        }
                        if dict.keys.contains("Certificate") {
                            self.certificate = dict["Certificate"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Tlsroot") {
                            self.tlsroot = dict["Tlsroot"] as! String
                        }
                    }
                }
                public var anchorPeers: [AddFabricExternalOrganizationToChannelResponseBody.Result.Content.RemovedOrganizations.AnchorPeers]?

                public var crls: String?

                public var mspId: String?

                public var mspType: String?

                public var orderer: Bool?

                public var ordererNodes: [AddFabricExternalOrganizationToChannelResponseBody.Result.Content.RemovedOrganizations.OrdererNodes]?

                public var rootCertificates: String?

                public var tlsRootCertificates: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.anchorPeers != nil {
                        var tmp : [Any] = []
                        for k in self.anchorPeers! {
                            tmp.append(k.toMap())
                        }
                        map["AnchorPeers"] = tmp
                    }
                    if self.crls != nil {
                        map["Crls"] = self.crls!
                    }
                    if self.mspId != nil {
                        map["MspId"] = self.mspId!
                    }
                    if self.mspType != nil {
                        map["MspType"] = self.mspType!
                    }
                    if self.orderer != nil {
                        map["Orderer"] = self.orderer!
                    }
                    if self.ordererNodes != nil {
                        var tmp : [Any] = []
                        for k in self.ordererNodes! {
                            tmp.append(k.toMap())
                        }
                        map["OrdererNodes"] = tmp
                    }
                    if self.rootCertificates != nil {
                        map["RootCertificates"] = self.rootCertificates!
                    }
                    if self.tlsRootCertificates != nil {
                        map["TlsRootCertificates"] = self.tlsRootCertificates!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnchorPeers") {
                        var tmp : [AddFabricExternalOrganizationToChannelResponseBody.Result.Content.RemovedOrganizations.AnchorPeers] = []
                        for v in dict["AnchorPeers"] as! [Any] {
                            var model = AddFabricExternalOrganizationToChannelResponseBody.Result.Content.RemovedOrganizations.AnchorPeers()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.anchorPeers = tmp
                    }
                    if dict.keys.contains("Crls") {
                        self.crls = dict["Crls"] as! String
                    }
                    if dict.keys.contains("MspId") {
                        self.mspId = dict["MspId"] as! String
                    }
                    if dict.keys.contains("MspType") {
                        self.mspType = dict["MspType"] as! String
                    }
                    if dict.keys.contains("Orderer") {
                        self.orderer = dict["Orderer"] as! Bool
                    }
                    if dict.keys.contains("OrdererNodes") {
                        var tmp : [AddFabricExternalOrganizationToChannelResponseBody.Result.Content.RemovedOrganizations.OrdererNodes] = []
                        for v in dict["OrdererNodes"] as! [Any] {
                            var model = AddFabricExternalOrganizationToChannelResponseBody.Result.Content.RemovedOrganizations.OrdererNodes()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ordererNodes = tmp
                    }
                    if dict.keys.contains("RootCertificates") {
                        self.rootCertificates = dict["RootCertificates"] as! String
                    }
                    if dict.keys.contains("TlsRootCertificates") {
                        self.tlsRootCertificates = dict["TlsRootCertificates"] as! String
                    }
                }
            }
            public var addedOrganizations: [AddFabricExternalOrganizationToChannelResponseBody.Result.Content.AddedOrganizations]?

            public var chaincodeSpecPkg: AddFabricExternalOrganizationToChannelResponseBody.Result.Content.ChaincodeSpecPkg?

            public var ordererConfig: AddFabricExternalOrganizationToChannelResponseBody.Result.Content.OrdererConfig?

            public var raw: String?

            public var removedOrganizations: [AddFabricExternalOrganizationToChannelResponseBody.Result.Content.RemovedOrganizations]?

            public var rwSets: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.chaincodeSpecPkg?.validate()
                try self.ordererConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addedOrganizations != nil {
                    var tmp : [Any] = []
                    for k in self.addedOrganizations! {
                        tmp.append(k.toMap())
                    }
                    map["AddedOrganizations"] = tmp
                }
                if self.chaincodeSpecPkg != nil {
                    map["ChaincodeSpecPkg"] = self.chaincodeSpecPkg?.toMap()
                }
                if self.ordererConfig != nil {
                    map["OrdererConfig"] = self.ordererConfig?.toMap()
                }
                if self.raw != nil {
                    map["Raw"] = self.raw!
                }
                if self.removedOrganizations != nil {
                    var tmp : [Any] = []
                    for k in self.removedOrganizations! {
                        tmp.append(k.toMap())
                    }
                    map["RemovedOrganizations"] = tmp
                }
                if self.rwSets != nil {
                    map["RwSets"] = self.rwSets!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddedOrganizations") {
                    var tmp : [AddFabricExternalOrganizationToChannelResponseBody.Result.Content.AddedOrganizations] = []
                    for v in dict["AddedOrganizations"] as! [Any] {
                        var model = AddFabricExternalOrganizationToChannelResponseBody.Result.Content.AddedOrganizations()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.addedOrganizations = tmp
                }
                if dict.keys.contains("ChaincodeSpecPkg") {
                    var model = AddFabricExternalOrganizationToChannelResponseBody.Result.Content.ChaincodeSpecPkg()
                    model.fromMap(dict["ChaincodeSpecPkg"] as! [String: Any])
                    self.chaincodeSpecPkg = model
                }
                if dict.keys.contains("OrdererConfig") {
                    var model = AddFabricExternalOrganizationToChannelResponseBody.Result.Content.OrdererConfig()
                    model.fromMap(dict["OrdererConfig"] as! [String: Any])
                    self.ordererConfig = model
                }
                if dict.keys.contains("Raw") {
                    self.raw = dict["Raw"] as! String
                }
                if dict.keys.contains("RemovedOrganizations") {
                    var tmp : [AddFabricExternalOrganizationToChannelResponseBody.Result.Content.RemovedOrganizations] = []
                    for v in dict["RemovedOrganizations"] as! [Any] {
                        var model = AddFabricExternalOrganizationToChannelResponseBody.Result.Content.RemovedOrganizations()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.removedOrganizations = tmp
                }
                if dict.keys.contains("RwSets") {
                    self.rwSets = dict["RwSets"] as! String
                }
            }
        }
        public var content: AddFabricExternalOrganizationToChannelResponseBody.Result.Content?

        public var createTime: Int64?

        public var creator: String?

        public var description_: String?

        public var status: String?

        public var taskId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.content?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                var model = AddFabricExternalOrganizationToChannelResponseBody.Result.Content()
                model.fromMap(dict["Content"] as! [String: Any])
                self.content = model
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: AddFabricExternalOrganizationToChannelResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = AddFabricExternalOrganizationToChannelResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddFabricExternalOrganizationToChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddFabricExternalOrganizationToChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddFabricExternalOrganizationToChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddFabricOrganizationToExternalChannelRequest : Tea.TeaModel {
    public var joinResponse: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.joinResponse != nil {
            map["JoinResponse"] = self.joinResponse!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JoinResponse") {
            self.joinResponse = dict["JoinResponse"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class AddFabricOrganizationToExternalChannelResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var m: Int32?

        public var n: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.m != nil {
                map["M"] = self.m!
            }
            if self.n != nil {
                map["N"] = self.n!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("M") {
                self.m = dict["M"] as! Int32
            }
            if dict.keys.contains("N") {
                self.n = dict["N"] as! Int32
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [AddFabricOrganizationToExternalChannelResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [AddFabricOrganizationToExternalChannelResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = AddFabricOrganizationToExternalChannelResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class AddFabricOrganizationToExternalChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddFabricOrganizationToExternalChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddFabricOrganizationToExternalChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyAntChainRequest : Tea.TeaModel {
    public var bizid: String?

    public var consortiumId: String?

    public var uploadReq: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.uploadReq != nil {
            map["UploadReq"] = self.uploadReq!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("UploadReq") {
            self.uploadReq = dict["UploadReq"] as! String
        }
    }
}

public class ApplyAntChainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class ApplyAntChainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyAntChainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyAntChainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyAntChainCertificateRequest : Tea.TeaModel {
    public var antChainId: String?

    public var uploadReq: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.uploadReq != nil {
            map["UploadReq"] = self.uploadReq!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("UploadReq") {
            self.uploadReq = dict["UploadReq"] as! String
        }
    }
}

public class ApplyAntChainCertificateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class ApplyAntChainCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyAntChainCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyAntChainCertificateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyAntChainCertificateWithKeyAutoCreationRequest : Tea.TeaModel {
    public var antChainId: String?

    public var commonName: String?

    public var consortiumId: String?

    public var countryName: String?

    public var localityName: String?

    public var organizationName: String?

    public var organizationUnitName: String?

    public var password: String?

    public var stateOrProvinceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.commonName != nil {
            map["CommonName"] = self.commonName!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.countryName != nil {
            map["CountryName"] = self.countryName!
        }
        if self.localityName != nil {
            map["LocalityName"] = self.localityName!
        }
        if self.organizationName != nil {
            map["OrganizationName"] = self.organizationName!
        }
        if self.organizationUnitName != nil {
            map["OrganizationUnitName"] = self.organizationUnitName!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.stateOrProvinceName != nil {
            map["StateOrProvinceName"] = self.stateOrProvinceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("CommonName") {
            self.commonName = dict["CommonName"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("CountryName") {
            self.countryName = dict["CountryName"] as! String
        }
        if dict.keys.contains("LocalityName") {
            self.localityName = dict["LocalityName"] as! String
        }
        if dict.keys.contains("OrganizationName") {
            self.organizationName = dict["OrganizationName"] as! String
        }
        if dict.keys.contains("OrganizationUnitName") {
            self.organizationUnitName = dict["OrganizationUnitName"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("StateOrProvinceName") {
            self.stateOrProvinceName = dict["StateOrProvinceName"] as! String
        }
    }
}

public class ApplyAntChainCertificateWithKeyAutoCreationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class DownloadPath : Tea.TeaModel {
            public var caCrtUrl: String?

            public var clientCrtUrl: String?

            public var sdkUrl: String?

            public var trustCaUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.caCrtUrl != nil {
                    map["CaCrtUrl"] = self.caCrtUrl!
                }
                if self.clientCrtUrl != nil {
                    map["ClientCrtUrl"] = self.clientCrtUrl!
                }
                if self.sdkUrl != nil {
                    map["SdkUrl"] = self.sdkUrl!
                }
                if self.trustCaUrl != nil {
                    map["TrustCaUrl"] = self.trustCaUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CaCrtUrl") {
                    self.caCrtUrl = dict["CaCrtUrl"] as! String
                }
                if dict.keys.contains("ClientCrtUrl") {
                    self.clientCrtUrl = dict["ClientCrtUrl"] as! String
                }
                if dict.keys.contains("SdkUrl") {
                    self.sdkUrl = dict["SdkUrl"] as! String
                }
                if dict.keys.contains("TrustCaUrl") {
                    self.trustCaUrl = dict["TrustCaUrl"] as! String
                }
            }
        }
        public var downloadPath: ApplyAntChainCertificateWithKeyAutoCreationResponseBody.Result.DownloadPath?

        public var privateKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.downloadPath?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downloadPath != nil {
                map["DownloadPath"] = self.downloadPath?.toMap()
            }
            if self.privateKey != nil {
                map["PrivateKey"] = self.privateKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DownloadPath") {
                var model = ApplyAntChainCertificateWithKeyAutoCreationResponseBody.Result.DownloadPath()
                model.fromMap(dict["DownloadPath"] as! [String: Any])
                self.downloadPath = model
            }
            if dict.keys.contains("PrivateKey") {
                self.privateKey = dict["PrivateKey"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: ApplyAntChainCertificateWithKeyAutoCreationResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = ApplyAntChainCertificateWithKeyAutoCreationResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class ApplyAntChainCertificateWithKeyAutoCreationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyAntChainCertificateWithKeyAutoCreationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyAntChainCertificateWithKeyAutoCreationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyAntChainWithKeyAutoCreationRequest : Tea.TeaModel {
    public var antChainId: String?

    public var commonName: String?

    public var consortiumId: String?

    public var countryName: String?

    public var localityName: String?

    public var organizationName: String?

    public var organizationUnitName: String?

    public var password: String?

    public var stateOrProvinceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.commonName != nil {
            map["CommonName"] = self.commonName!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.countryName != nil {
            map["CountryName"] = self.countryName!
        }
        if self.localityName != nil {
            map["LocalityName"] = self.localityName!
        }
        if self.organizationName != nil {
            map["OrganizationName"] = self.organizationName!
        }
        if self.organizationUnitName != nil {
            map["OrganizationUnitName"] = self.organizationUnitName!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.stateOrProvinceName != nil {
            map["StateOrProvinceName"] = self.stateOrProvinceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("CommonName") {
            self.commonName = dict["CommonName"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("CountryName") {
            self.countryName = dict["CountryName"] as! String
        }
        if dict.keys.contains("LocalityName") {
            self.localityName = dict["LocalityName"] as! String
        }
        if dict.keys.contains("OrganizationName") {
            self.organizationName = dict["OrganizationName"] as! String
        }
        if dict.keys.contains("OrganizationUnitName") {
            self.organizationUnitName = dict["OrganizationUnitName"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("StateOrProvinceName") {
            self.stateOrProvinceName = dict["StateOrProvinceName"] as! String
        }
    }
}

public class ApplyAntChainWithKeyAutoCreationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class DownloadPath : Tea.TeaModel {
            public var caCrtUrl: String?

            public var clientCrtUrl: String?

            public var sdkUrl: String?

            public var trustCaUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.caCrtUrl != nil {
                    map["CaCrtUrl"] = self.caCrtUrl!
                }
                if self.clientCrtUrl != nil {
                    map["ClientCrtUrl"] = self.clientCrtUrl!
                }
                if self.sdkUrl != nil {
                    map["SdkUrl"] = self.sdkUrl!
                }
                if self.trustCaUrl != nil {
                    map["TrustCaUrl"] = self.trustCaUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CaCrtUrl") {
                    self.caCrtUrl = dict["CaCrtUrl"] as! String
                }
                if dict.keys.contains("ClientCrtUrl") {
                    self.clientCrtUrl = dict["ClientCrtUrl"] as! String
                }
                if dict.keys.contains("SdkUrl") {
                    self.sdkUrl = dict["SdkUrl"] as! String
                }
                if dict.keys.contains("TrustCaUrl") {
                    self.trustCaUrl = dict["TrustCaUrl"] as! String
                }
            }
        }
        public var downloadPath: ApplyAntChainWithKeyAutoCreationResponseBody.Result.DownloadPath?

        public var privateKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.downloadPath?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downloadPath != nil {
                map["DownloadPath"] = self.downloadPath?.toMap()
            }
            if self.privateKey != nil {
                map["PrivateKey"] = self.privateKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DownloadPath") {
                var model = ApplyAntChainWithKeyAutoCreationResponseBody.Result.DownloadPath()
                model.fromMap(dict["DownloadPath"] as! [String: Any])
                self.downloadPath = model
            }
            if dict.keys.contains("PrivateKey") {
                self.privateKey = dict["PrivateKey"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: ApplyAntChainWithKeyAutoCreationResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = ApplyAntChainWithKeyAutoCreationResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class ApplyAntChainWithKeyAutoCreationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyAntChainWithKeyAutoCreationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyAntChainWithKeyAutoCreationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyBlockchainRequest : Tea.TeaModel {
    public var account: String?

    public var accountPubKey: String?

    public var accountRecoverPubKey: String?

    public var blockchain: String?

    public var uploadReq: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.account != nil {
            map["Account"] = self.account!
        }
        if self.accountPubKey != nil {
            map["AccountPubKey"] = self.accountPubKey!
        }
        if self.accountRecoverPubKey != nil {
            map["AccountRecoverPubKey"] = self.accountRecoverPubKey!
        }
        if self.blockchain != nil {
            map["Blockchain"] = self.blockchain!
        }
        if self.uploadReq != nil {
            map["UploadReq"] = self.uploadReq!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Account") {
            self.account = dict["Account"] as! String
        }
        if dict.keys.contains("AccountPubKey") {
            self.accountPubKey = dict["AccountPubKey"] as! String
        }
        if dict.keys.contains("AccountRecoverPubKey") {
            self.accountRecoverPubKey = dict["AccountRecoverPubKey"] as! String
        }
        if dict.keys.contains("Blockchain") {
            self.blockchain = dict["Blockchain"] as! String
        }
        if dict.keys.contains("UploadReq") {
            self.uploadReq = dict["UploadReq"] as! String
        }
    }
}

public class ApplyBlockchainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class ApplyBlockchainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyBlockchainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyBlockchainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyBlockchainWithKeyAutoCreationRequest : Tea.TeaModel {
    public var bizid: String?

    public var commonName: String?

    public var countryName: String?

    public var localityName: String?

    public var organizationName: String?

    public var organizationUnitName: String?

    public var password: String?

    public var stateOrProvinceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.commonName != nil {
            map["CommonName"] = self.commonName!
        }
        if self.countryName != nil {
            map["CountryName"] = self.countryName!
        }
        if self.localityName != nil {
            map["LocalityName"] = self.localityName!
        }
        if self.organizationName != nil {
            map["OrganizationName"] = self.organizationName!
        }
        if self.organizationUnitName != nil {
            map["OrganizationUnitName"] = self.organizationUnitName!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.stateOrProvinceName != nil {
            map["StateOrProvinceName"] = self.stateOrProvinceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("CommonName") {
            self.commonName = dict["CommonName"] as! String
        }
        if dict.keys.contains("CountryName") {
            self.countryName = dict["CountryName"] as! String
        }
        if dict.keys.contains("LocalityName") {
            self.localityName = dict["LocalityName"] as! String
        }
        if dict.keys.contains("OrganizationName") {
            self.organizationName = dict["OrganizationName"] as! String
        }
        if dict.keys.contains("OrganizationUnitName") {
            self.organizationUnitName = dict["OrganizationUnitName"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("StateOrProvinceName") {
            self.stateOrProvinceName = dict["StateOrProvinceName"] as! String
        }
    }
}

public class ApplyBlockchainWithKeyAutoCreationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class DownloadPath : Tea.TeaModel {
            public var bizviewUrl: String?

            public var certUrl: String?

            public var sdkUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizviewUrl != nil {
                    map["BizviewUrl"] = self.bizviewUrl!
                }
                if self.certUrl != nil {
                    map["CertUrl"] = self.certUrl!
                }
                if self.sdkUrl != nil {
                    map["SdkUrl"] = self.sdkUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizviewUrl") {
                    self.bizviewUrl = dict["BizviewUrl"] as! String
                }
                if dict.keys.contains("CertUrl") {
                    self.certUrl = dict["CertUrl"] as! String
                }
                if dict.keys.contains("SdkUrl") {
                    self.sdkUrl = dict["SdkUrl"] as! String
                }
            }
        }
        public var downloadPath: ApplyBlockchainWithKeyAutoCreationResponseBody.Result.DownloadPath?

        public var privateKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.downloadPath?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downloadPath != nil {
                map["DownloadPath"] = self.downloadPath?.toMap()
            }
            if self.privateKey != nil {
                map["PrivateKey"] = self.privateKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DownloadPath") {
                var model = ApplyBlockchainWithKeyAutoCreationResponseBody.Result.DownloadPath()
                model.fromMap(dict["DownloadPath"] as! [String: Any])
                self.downloadPath = model
            }
            if dict.keys.contains("PrivateKey") {
                self.privateKey = dict["PrivateKey"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: ApplyBlockchainWithKeyAutoCreationResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = ApplyBlockchainWithKeyAutoCreationResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class ApplyBlockchainWithKeyAutoCreationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyBlockchainWithKeyAutoCreationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyBlockchainWithKeyAutoCreationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyPublicAntChainRequest : Tea.TeaModel {
    public var bizid: String?

    public var consortiumId: String?

    public var uploadReq: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.uploadReq != nil {
            map["UploadReq"] = self.uploadReq!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("UploadReq") {
            self.uploadReq = dict["UploadReq"] as! String
        }
    }
}

public class ApplyPublicAntChainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class ApplyPublicAntChainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyPublicAntChainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyPublicAntChainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyPublicAntChainWithKeyAutoCreationRequest : Tea.TeaModel {
    public var bizid: String?

    public var commonName: String?

    public var countryName: String?

    public var localityName: String?

    public var organizationName: String?

    public var organizationUnitName: String?

    public var password: String?

    public var stateOrProvinceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.commonName != nil {
            map["CommonName"] = self.commonName!
        }
        if self.countryName != nil {
            map["CountryName"] = self.countryName!
        }
        if self.localityName != nil {
            map["LocalityName"] = self.localityName!
        }
        if self.organizationName != nil {
            map["OrganizationName"] = self.organizationName!
        }
        if self.organizationUnitName != nil {
            map["OrganizationUnitName"] = self.organizationUnitName!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.stateOrProvinceName != nil {
            map["StateOrProvinceName"] = self.stateOrProvinceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("CommonName") {
            self.commonName = dict["CommonName"] as! String
        }
        if dict.keys.contains("CountryName") {
            self.countryName = dict["CountryName"] as! String
        }
        if dict.keys.contains("LocalityName") {
            self.localityName = dict["LocalityName"] as! String
        }
        if dict.keys.contains("OrganizationName") {
            self.organizationName = dict["OrganizationName"] as! String
        }
        if dict.keys.contains("OrganizationUnitName") {
            self.organizationUnitName = dict["OrganizationUnitName"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("StateOrProvinceName") {
            self.stateOrProvinceName = dict["StateOrProvinceName"] as! String
        }
    }
}

public class ApplyPublicAntChainWithKeyAutoCreationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class DownloadPath : Tea.TeaModel {
            public var caCrtUrl: String?

            public var clientCrtUrl: String?

            public var sdkUrl: String?

            public var trustCaUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.caCrtUrl != nil {
                    map["CaCrtUrl"] = self.caCrtUrl!
                }
                if self.clientCrtUrl != nil {
                    map["ClientCrtUrl"] = self.clientCrtUrl!
                }
                if self.sdkUrl != nil {
                    map["SdkUrl"] = self.sdkUrl!
                }
                if self.trustCaUrl != nil {
                    map["TrustCaUrl"] = self.trustCaUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CaCrtUrl") {
                    self.caCrtUrl = dict["CaCrtUrl"] as! String
                }
                if dict.keys.contains("ClientCrtUrl") {
                    self.clientCrtUrl = dict["ClientCrtUrl"] as! String
                }
                if dict.keys.contains("SdkUrl") {
                    self.sdkUrl = dict["SdkUrl"] as! String
                }
                if dict.keys.contains("TrustCaUrl") {
                    self.trustCaUrl = dict["TrustCaUrl"] as! String
                }
            }
        }
        public var downloadPath: ApplyPublicAntChainWithKeyAutoCreationResponseBody.Result.DownloadPath?

        public var privateKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.downloadPath?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downloadPath != nil {
                map["DownloadPath"] = self.downloadPath?.toMap()
            }
            if self.privateKey != nil {
                map["PrivateKey"] = self.privateKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DownloadPath") {
                var model = ApplyPublicAntChainWithKeyAutoCreationResponseBody.Result.DownloadPath()
                model.fromMap(dict["DownloadPath"] as! [String: Any])
                self.downloadPath = model
            }
            if dict.keys.contains("PrivateKey") {
                self.privateKey = dict["PrivateKey"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: ApplyPublicAntChainWithKeyAutoCreationResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = ApplyPublicAntChainWithKeyAutoCreationResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class ApplyPublicAntChainWithKeyAutoCreationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyPublicAntChainWithKeyAutoCreationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyPublicAntChainWithKeyAutoCreationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApproveEthereumInviteeRequest : Tea.TeaModel {
    public class Invitee : Tea.TeaModel {
        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
        }
    }
    public var id: String?

    public var invitee: [ApproveEthereumInviteeRequest.Invitee]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.invitee != nil {
            var tmp : [Any] = []
            for k in self.invitee! {
                tmp.append(k.toMap())
            }
            map["Invitee"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Invitee") {
            var tmp : [ApproveEthereumInviteeRequest.Invitee] = []
            for v in dict["Invitee"] as! [Any] {
                var model = ApproveEthereumInviteeRequest.Invitee()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.invitee = tmp
        }
    }
}

public class ApproveEthereumInviteeResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ApproveEthereumInviteeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApproveEthereumInviteeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApproveEthereumInviteeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApproveFabricChaincodeDefinitionRequest : Tea.TeaModel {
    public var chaincodeId: String?

    public var chaincodePackageId: String?

    public var location: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chaincodeId != nil {
            map["ChaincodeId"] = self.chaincodeId!
        }
        if self.chaincodePackageId != nil {
            map["ChaincodePackageId"] = self.chaincodePackageId!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChaincodeId") {
            self.chaincodeId = dict["ChaincodeId"] as! String
        }
        if dict.keys.contains("ChaincodePackageId") {
            self.chaincodePackageId = dict["ChaincodePackageId"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class ApproveFabricChaincodeDefinitionResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var chaincodeId: String?

        public var channelName: String?

        public var consortiumId: String?

        public var createTime: String?

        public var deployTime: String?

        public var endorsePolicy: String?

        public var input: String?

        public var install: Bool?

        public var message: String?

        public var name: String?

        public var path: String?

        public var providerId: String?

        public var providerName: String?

        public var state: String?

        public var type: Int32?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chaincodeId != nil {
                map["ChaincodeId"] = self.chaincodeId!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.deployTime != nil {
                map["DeployTime"] = self.deployTime!
            }
            if self.endorsePolicy != nil {
                map["EndorsePolicy"] = self.endorsePolicy!
            }
            if self.input != nil {
                map["Input"] = self.input!
            }
            if self.install != nil {
                map["Install"] = self.install!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.providerId != nil {
                map["ProviderId"] = self.providerId!
            }
            if self.providerName != nil {
                map["ProviderName"] = self.providerName!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChaincodeId") {
                self.chaincodeId = dict["ChaincodeId"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DeployTime") {
                self.deployTime = dict["DeployTime"] as! String
            }
            if dict.keys.contains("EndorsePolicy") {
                self.endorsePolicy = dict["EndorsePolicy"] as! String
            }
            if dict.keys.contains("Input") {
                self.input = dict["Input"] as! String
            }
            if dict.keys.contains("Install") {
                self.install = dict["Install"] as! Bool
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("ProviderId") {
                self.providerId = dict["ProviderId"] as! String
            }
            if dict.keys.contains("ProviderName") {
                self.providerName = dict["ProviderName"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var chaincodeDefinitionId: String?

    public var chaincodePackageId: String?

    public var errorCode: Int32?

    public var initRequired: Bool?

    public var requestId: String?

    public var result: ApproveFabricChaincodeDefinitionResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chaincodeDefinitionId != nil {
            map["ChaincodeDefinitionId"] = self.chaincodeDefinitionId!
        }
        if self.chaincodePackageId != nil {
            map["ChaincodePackageId"] = self.chaincodePackageId!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.initRequired != nil {
            map["InitRequired"] = self.initRequired!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChaincodeDefinitionId") {
            self.chaincodeDefinitionId = dict["ChaincodeDefinitionId"] as! String
        }
        if dict.keys.contains("ChaincodePackageId") {
            self.chaincodePackageId = dict["ChaincodePackageId"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("InitRequired") {
            self.initRequired = dict["InitRequired"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = ApproveFabricChaincodeDefinitionResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ApproveFabricChaincodeDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApproveFabricChaincodeDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApproveFabricChaincodeDefinitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest : Tea.TeaModel {
    public var antChainId: String?

    public var phoneList: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.phoneList != nil {
            map["PhoneList"] = self.phoneList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("PhoneList") {
            self.phoneList = dict["PhoneList"] as! [String: Any]
        }
    }
}

public class BatchAddAntChainMiniAppQRCodeAuthorizedUsersShrinkRequest : Tea.TeaModel {
    public var antChainId: String?

    public var phoneListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.phoneListShrink != nil {
            map["PhoneList"] = self.phoneListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("PhoneList") {
            self.phoneListShrink = dict["PhoneList"] as! String
        }
    }
}

public class BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindFabricManagementChaincodeRequest : Tea.TeaModel {
    public var chaincodeId: String?

    public var channelId: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chaincodeId != nil {
            map["ChaincodeId"] = self.chaincodeId!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChaincodeId") {
            self.chaincodeId = dict["ChaincodeId"] as! String
        }
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class BindFabricManagementChaincodeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var input: String?

        public var name: String?

        public var path: Int64?

        public var type: Int32?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.input != nil {
                map["Input"] = self.input!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Input") {
                self.input = dict["Input"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: BindFabricManagementChaincodeResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = BindFabricManagementChaincodeResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class BindFabricManagementChaincodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindFabricManagementChaincodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BindFabricManagementChaincodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckConsortiumDomainRequest : Tea.TeaModel {
    public var domainCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainCode != nil {
            map["DomainCode"] = self.domainCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DomainCode") {
            self.domainCode = dict["DomainCode"] as! String
        }
    }
}

public class CheckConsortiumDomainResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var domain: String?

        public var prompt: String?

        public var valid: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.prompt != nil {
                map["Prompt"] = self.prompt!
            }
            if self.valid != nil {
                map["Valid"] = self.valid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Prompt") {
                self.prompt = dict["Prompt"] as! String
            }
            if dict.keys.contains("Valid") {
                self.valid = dict["Valid"] as! Bool
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: CheckConsortiumDomainResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CheckConsortiumDomainResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CheckConsortiumDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckConsortiumDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CheckConsortiumDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CheckOrganizationDomainRequest : Tea.TeaModel {
    public var domain: String?

    public var domainCode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.domainCode != nil {
            map["DomainCode"] = self.domainCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Domain") {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("DomainCode") {
            self.domainCode = dict["DomainCode"] as! String
        }
    }
}

public class CheckOrganizationDomainResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var domain: String?

        public var prompt: String?

        public var valid: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.prompt != nil {
                map["Prompt"] = self.prompt!
            }
            if self.valid != nil {
                map["Valid"] = self.valid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Prompt") {
                self.prompt = dict["Prompt"] as! String
            }
            if dict.keys.contains("Valid") {
                self.valid = dict["Valid"] as! Bool
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: CheckOrganizationDomainResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CheckOrganizationDomainResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CheckOrganizationDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckOrganizationDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CheckOrganizationDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfirmConsortiumMemberRequest : Tea.TeaModel {
    public class Organization : Tea.TeaModel {
        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
        }
    }
    public var consortiumId: String?

    public var organization: [ConfirmConsortiumMemberRequest.Organization]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.organization != nil {
            var tmp : [Any] = []
            for k in self.organization! {
                tmp.append(k.toMap())
            }
            map["Organization"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("Organization") {
            var tmp : [ConfirmConsortiumMemberRequest.Organization] = []
            for v in dict["Organization"] as! [Any] {
                var model = ConfirmConsortiumMemberRequest.Organization()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.organization = tmp
        }
    }
}

public class ConfirmConsortiumMemberResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ConfirmConsortiumMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfirmConsortiumMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConfirmConsortiumMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CopyAntChainContractProjectRequest : Tea.TeaModel {
    public var projectDescription: String?

    public var projectId: String?

    public var projectName: String?

    public var projectVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectDescription != nil {
            map["ProjectDescription"] = self.projectDescription!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.projectVersion != nil {
            map["ProjectVersion"] = self.projectVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectDescription") {
            self.projectDescription = dict["ProjectDescription"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
        if dict.keys.contains("ProjectVersion") {
            self.projectVersion = dict["ProjectVersion"] as! String
        }
    }
}

public class CopyAntChainContractProjectResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consortiumId: String?

        public var createTime: Int64?

        public var projectDescription: String?

        public var projectId: String?

        public var projectName: String?

        public var projectVersion: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.projectDescription != nil {
                map["ProjectDescription"] = self.projectDescription!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.projectVersion != nil {
                map["ProjectVersion"] = self.projectVersion!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ProjectDescription") {
                self.projectDescription = dict["ProjectDescription"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("ProjectName") {
                self.projectName = dict["ProjectName"] as! String
            }
            if dict.keys.contains("ProjectVersion") {
                self.projectVersion = dict["ProjectVersion"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var result: CopyAntChainContractProjectResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CopyAntChainContractProjectResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class CopyAntChainContractProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyAntChainContractProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CopyAntChainContractProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAccessTokenRequest : Tea.TeaModel {
    public var accessTokenLifetime: String?

    public var organizationId: String?

    public var refreshTokenLifetime: String?

    public var scope: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessTokenLifetime != nil {
            map["AccessTokenLifetime"] = self.accessTokenLifetime!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.refreshTokenLifetime != nil {
            map["RefreshTokenLifetime"] = self.refreshTokenLifetime!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessTokenLifetime") {
            self.accessTokenLifetime = dict["AccessTokenLifetime"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("RefreshTokenLifetime") {
            self.refreshTokenLifetime = dict["RefreshTokenLifetime"] as! String
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
    }
}

public class CreateAccessTokenResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessToken: String?

        public var expiresIn: Int64?

        public var refreshToken: String?

        public var tokenType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessToken != nil {
                map["AccessToken"] = self.accessToken!
            }
            if self.expiresIn != nil {
                map["ExpiresIn"] = self.expiresIn!
            }
            if self.refreshToken != nil {
                map["RefreshToken"] = self.refreshToken!
            }
            if self.tokenType != nil {
                map["TokenType"] = self.tokenType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessToken") {
                self.accessToken = dict["AccessToken"] as! String
            }
            if dict.keys.contains("ExpiresIn") {
                self.expiresIn = dict["ExpiresIn"] as! Int64
            }
            if dict.keys.contains("RefreshToken") {
                self.refreshToken = dict["RefreshToken"] as! String
            }
            if dict.keys.contains("TokenType") {
                self.tokenType = dict["TokenType"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: CreateAccessTokenResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateAccessTokenResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateAccessTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAccessTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAccessTokenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAccountRequest : Tea.TeaModel {
    public var account: String?

    public var accountPubKey: String?

    public var accountRecoverPubKey: String?

    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.account != nil {
            map["Account"] = self.account!
        }
        if self.accountPubKey != nil {
            map["AccountPubKey"] = self.accountPubKey!
        }
        if self.accountRecoverPubKey != nil {
            map["AccountRecoverPubKey"] = self.accountRecoverPubKey!
        }
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Account") {
            self.account = dict["Account"] as! String
        }
        if dict.keys.contains("AccountPubKey") {
            self.accountPubKey = dict["AccountPubKey"] as! String
        }
        if dict.keys.contains("AccountRecoverPubKey") {
            self.accountRecoverPubKey = dict["AccountRecoverPubKey"] as! String
        }
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class CreateAccountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class CreateAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAccountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAccountWithKeyPairAutoCreationRequest : Tea.TeaModel {
    public var account: String?

    public var bizid: String?

    public var password: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.account != nil {
            map["Account"] = self.account!
        }
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Account") {
            self.account = dict["Account"] as! String
        }
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
    }
}

public class CreateAccountWithKeyPairAutoCreationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accountPrivateKey: String?

        public var accountPublicKey: String?

        public var accountRecoverPrivateKey: String?

        public var accountRecoverPublicKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountPrivateKey != nil {
                map["AccountPrivateKey"] = self.accountPrivateKey!
            }
            if self.accountPublicKey != nil {
                map["AccountPublicKey"] = self.accountPublicKey!
            }
            if self.accountRecoverPrivateKey != nil {
                map["AccountRecoverPrivateKey"] = self.accountRecoverPrivateKey!
            }
            if self.accountRecoverPublicKey != nil {
                map["AccountRecoverPublicKey"] = self.accountRecoverPublicKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountPrivateKey") {
                self.accountPrivateKey = dict["AccountPrivateKey"] as! String
            }
            if dict.keys.contains("AccountPublicKey") {
                self.accountPublicKey = dict["AccountPublicKey"] as! String
            }
            if dict.keys.contains("AccountRecoverPrivateKey") {
                self.accountRecoverPrivateKey = dict["AccountRecoverPrivateKey"] as! String
            }
            if dict.keys.contains("AccountRecoverPublicKey") {
                self.accountRecoverPublicKey = dict["AccountRecoverPublicKey"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: CreateAccountWithKeyPairAutoCreationResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateAccountWithKeyPairAutoCreationResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class CreateAccountWithKeyPairAutoCreationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAccountWithKeyPairAutoCreationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAccountWithKeyPairAutoCreationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAntChainRequest : Tea.TeaModel {
    public var antChainName: String?

    public var blockchainRegionId: String?

    public var cipherSuit: String?

    public var consortiumId: String?

    public var liveTime: Int32?

    public var merkleTreeSuit: String?

    public var nodeNum: Int32?

    public var resourceSize: Int32?

    public var tlsAlgo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainName != nil {
            map["AntChainName"] = self.antChainName!
        }
        if self.blockchainRegionId != nil {
            map["BlockchainRegionId"] = self.blockchainRegionId!
        }
        if self.cipherSuit != nil {
            map["CipherSuit"] = self.cipherSuit!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.liveTime != nil {
            map["LiveTime"] = self.liveTime!
        }
        if self.merkleTreeSuit != nil {
            map["MerkleTreeSuit"] = self.merkleTreeSuit!
        }
        if self.nodeNum != nil {
            map["NodeNum"] = self.nodeNum!
        }
        if self.resourceSize != nil {
            map["ResourceSize"] = self.resourceSize!
        }
        if self.tlsAlgo != nil {
            map["TlsAlgo"] = self.tlsAlgo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainName") {
            self.antChainName = dict["AntChainName"] as! String
        }
        if dict.keys.contains("BlockchainRegionId") {
            self.blockchainRegionId = dict["BlockchainRegionId"] as! String
        }
        if dict.keys.contains("CipherSuit") {
            self.cipherSuit = dict["CipherSuit"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("LiveTime") {
            self.liveTime = dict["LiveTime"] as! Int32
        }
        if dict.keys.contains("MerkleTreeSuit") {
            self.merkleTreeSuit = dict["MerkleTreeSuit"] as! String
        }
        if dict.keys.contains("NodeNum") {
            self.nodeNum = dict["NodeNum"] as! Int32
        }
        if dict.keys.contains("ResourceSize") {
            self.resourceSize = dict["ResourceSize"] as! Int32
        }
        if dict.keys.contains("TlsAlgo") {
            self.tlsAlgo = dict["TlsAlgo"] as! String
        }
    }
}

public class CreateAntChainResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var antChainId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.antChainId != nil {
                map["AntChainId"] = self.antChainId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AntChainId") {
                self.antChainId = dict["AntChainId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: CreateAntChainResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateAntChainResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class CreateAntChainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAntChainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAntChainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAntChainAccountRequest : Tea.TeaModel {
    public var account: String?

    public var accountPubKey: String?

    public var accountRecoverPubKey: String?

    public var antChainId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.account != nil {
            map["Account"] = self.account!
        }
        if self.accountPubKey != nil {
            map["AccountPubKey"] = self.accountPubKey!
        }
        if self.accountRecoverPubKey != nil {
            map["AccountRecoverPubKey"] = self.accountRecoverPubKey!
        }
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Account") {
            self.account = dict["Account"] as! String
        }
        if dict.keys.contains("AccountPubKey") {
            self.accountPubKey = dict["AccountPubKey"] as! String
        }
        if dict.keys.contains("AccountRecoverPubKey") {
            self.accountRecoverPubKey = dict["AccountRecoverPubKey"] as! String
        }
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
    }
}

public class CreateAntChainAccountResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var account: String?

        public var antChainId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.account != nil {
                map["Account"] = self.account!
            }
            if self.antChainId != nil {
                map["AntChainId"] = self.antChainId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Account") {
                self.account = dict["Account"] as! String
            }
            if dict.keys.contains("AntChainId") {
                self.antChainId = dict["AntChainId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: CreateAntChainAccountResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateAntChainAccountResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class CreateAntChainAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAntChainAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAntChainAccountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAntChainAccountWithKeyPairAutoCreationRequest : Tea.TeaModel {
    public var account: String?

    public var antChainId: String?

    public var password: String?

    public var recoverPassword: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.account != nil {
            map["Account"] = self.account!
        }
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.recoverPassword != nil {
            map["RecoverPassword"] = self.recoverPassword!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Account") {
            self.account = dict["Account"] as! String
        }
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("RecoverPassword") {
            self.recoverPassword = dict["RecoverPassword"] as! String
        }
    }
}

public class CreateAntChainAccountWithKeyPairAutoCreationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var account: String?

        public var accountPrivateKey: String?

        public var accountPublicKey: String?

        public var accountRecoverPrivateKey: String?

        public var accountRecoverPublicKey: String?

        public var antChainId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.account != nil {
                map["Account"] = self.account!
            }
            if self.accountPrivateKey != nil {
                map["AccountPrivateKey"] = self.accountPrivateKey!
            }
            if self.accountPublicKey != nil {
                map["AccountPublicKey"] = self.accountPublicKey!
            }
            if self.accountRecoverPrivateKey != nil {
                map["AccountRecoverPrivateKey"] = self.accountRecoverPrivateKey!
            }
            if self.accountRecoverPublicKey != nil {
                map["AccountRecoverPublicKey"] = self.accountRecoverPublicKey!
            }
            if self.antChainId != nil {
                map["AntChainId"] = self.antChainId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Account") {
                self.account = dict["Account"] as! String
            }
            if dict.keys.contains("AccountPrivateKey") {
                self.accountPrivateKey = dict["AccountPrivateKey"] as! String
            }
            if dict.keys.contains("AccountPublicKey") {
                self.accountPublicKey = dict["AccountPublicKey"] as! String
            }
            if dict.keys.contains("AccountRecoverPrivateKey") {
                self.accountRecoverPrivateKey = dict["AccountRecoverPrivateKey"] as! String
            }
            if dict.keys.contains("AccountRecoverPublicKey") {
                self.accountRecoverPublicKey = dict["AccountRecoverPublicKey"] as! String
            }
            if dict.keys.contains("AntChainId") {
                self.antChainId = dict["AntChainId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: CreateAntChainAccountWithKeyPairAutoCreationResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateAntChainAccountWithKeyPairAutoCreationResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class CreateAntChainAccountWithKeyPairAutoCreationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAntChainAccountWithKeyPairAutoCreationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAntChainAccountWithKeyPairAutoCreationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAntChainConsortiumRequest : Tea.TeaModel {
    public var consortiumDescription: String?

    public var consortiumName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumDescription != nil {
            map["ConsortiumDescription"] = self.consortiumDescription!
        }
        if self.consortiumName != nil {
            map["ConsortiumName"] = self.consortiumName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumDescription") {
            self.consortiumDescription = dict["ConsortiumDescription"] as! String
        }
        if dict.keys.contains("ConsortiumName") {
            self.consortiumName = dict["ConsortiumName"] as! String
        }
    }
}

public class CreateAntChainConsortiumResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consortiumId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: CreateAntChainConsortiumResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateAntChainConsortiumResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class CreateAntChainConsortiumResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAntChainConsortiumResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAntChainConsortiumResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAntChainContractContentRequest : Tea.TeaModel {
    public var content: String?

    public var contentName: String?

    public var isDirectory: Bool?

    public var parentContentId: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.contentName != nil {
            map["ContentName"] = self.contentName!
        }
        if self.isDirectory != nil {
            map["IsDirectory"] = self.isDirectory!
        }
        if self.parentContentId != nil {
            map["ParentContentId"] = self.parentContentId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("ContentName") {
            self.contentName = dict["ContentName"] as! String
        }
        if dict.keys.contains("IsDirectory") {
            self.isDirectory = dict["IsDirectory"] as! Bool
        }
        if dict.keys.contains("ParentContentId") {
            self.parentContentId = dict["ParentContentId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class CreateAntChainContractContentResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var content: String?

        public var contentId: String?

        public var contentName: String?

        public var createTime: String?

        public var isDirectory: Bool?

        public var parentContentId: String?

        public var projectId: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.contentId != nil {
                map["ContentId"] = self.contentId!
            }
            if self.contentName != nil {
                map["ContentName"] = self.contentName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.isDirectory != nil {
                map["IsDirectory"] = self.isDirectory!
            }
            if self.parentContentId != nil {
                map["ParentContentId"] = self.parentContentId!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("ContentId") {
                self.contentId = dict["ContentId"] as! String
            }
            if dict.keys.contains("ContentName") {
                self.contentName = dict["ContentName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("IsDirectory") {
                self.isDirectory = dict["IsDirectory"] as! Bool
            }
            if dict.keys.contains("ParentContentId") {
                self.parentContentId = dict["ParentContentId"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: CreateAntChainContractContentResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateAntChainContractContentResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class CreateAntChainContractContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAntChainContractContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAntChainContractContentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAntChainContractProjectRequest : Tea.TeaModel {
    public var consortiumId: String?

    public var projectDescription: String?

    public var projectName: String?

    public var projectVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.projectDescription != nil {
            map["ProjectDescription"] = self.projectDescription!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.projectVersion != nil {
            map["ProjectVersion"] = self.projectVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("ProjectDescription") {
            self.projectDescription = dict["ProjectDescription"] as! String
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
        if dict.keys.contains("ProjectVersion") {
            self.projectVersion = dict["ProjectVersion"] as! String
        }
    }
}

public class CreateAntChainContractProjectResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consortiumId: String?

        public var createTime: Int64?

        public var projectDescription: String?

        public var projectId: String?

        public var projectName: String?

        public var projectVersion: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.projectDescription != nil {
                map["ProjectDescription"] = self.projectDescription!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.projectVersion != nil {
                map["ProjectVersion"] = self.projectVersion!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ProjectDescription") {
                self.projectDescription = dict["ProjectDescription"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("ProjectName") {
                self.projectName = dict["ProjectName"] as! String
            }
            if dict.keys.contains("ProjectVersion") {
                self.projectVersion = dict["ProjectVersion"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var result: CreateAntChainContractProjectResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateAntChainContractProjectResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class CreateAntChainContractProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAntChainContractProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAntChainContractProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBlockchainRequest : Tea.TeaModel {
    public var bizid: String?

    public var blockchainRegionId: String?

    public var blockchainType: String?

    public var cipherSuit: String?

    public var liveTime: Int32?

    public var machineNum: Int32?

    public var merkleTreeSuit: String?

    public var size: Int32?

    public var tlsAlgo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.blockchainRegionId != nil {
            map["BlockchainRegionId"] = self.blockchainRegionId!
        }
        if self.blockchainType != nil {
            map["BlockchainType"] = self.blockchainType!
        }
        if self.cipherSuit != nil {
            map["CipherSuit"] = self.cipherSuit!
        }
        if self.liveTime != nil {
            map["LiveTime"] = self.liveTime!
        }
        if self.machineNum != nil {
            map["MachineNum"] = self.machineNum!
        }
        if self.merkleTreeSuit != nil {
            map["MerkleTreeSuit"] = self.merkleTreeSuit!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tlsAlgo != nil {
            map["TlsAlgo"] = self.tlsAlgo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("BlockchainRegionId") {
            self.blockchainRegionId = dict["BlockchainRegionId"] as! String
        }
        if dict.keys.contains("BlockchainType") {
            self.blockchainType = dict["BlockchainType"] as! String
        }
        if dict.keys.contains("CipherSuit") {
            self.cipherSuit = dict["CipherSuit"] as! String
        }
        if dict.keys.contains("LiveTime") {
            self.liveTime = dict["LiveTime"] as! Int32
        }
        if dict.keys.contains("MachineNum") {
            self.machineNum = dict["MachineNum"] as! Int32
        }
        if dict.keys.contains("MerkleTreeSuit") {
            self.merkleTreeSuit = dict["MerkleTreeSuit"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int32
        }
        if dict.keys.contains("TlsAlgo") {
            self.tlsAlgo = dict["TlsAlgo"] as! String
        }
    }
}

public class CreateBlockchainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class CreateBlockchainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBlockchainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateBlockchainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBlockchainApplicationRequest : Tea.TeaModel {
    public var bizid: String?

    public var blockchainRegionId: String?

    public var blockchainType: String?

    public var cipherSuit: String?

    public var liveTime: Int32?

    public var machineNum: Int32?

    public var merkleTreeSuit: String?

    public var size: Int32?

    public var tlsAlgo: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.blockchainRegionId != nil {
            map["BlockchainRegionId"] = self.blockchainRegionId!
        }
        if self.blockchainType != nil {
            map["BlockchainType"] = self.blockchainType!
        }
        if self.cipherSuit != nil {
            map["CipherSuit"] = self.cipherSuit!
        }
        if self.liveTime != nil {
            map["LiveTime"] = self.liveTime!
        }
        if self.machineNum != nil {
            map["MachineNum"] = self.machineNum!
        }
        if self.merkleTreeSuit != nil {
            map["MerkleTreeSuit"] = self.merkleTreeSuit!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tlsAlgo != nil {
            map["TlsAlgo"] = self.tlsAlgo!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("BlockchainRegionId") {
            self.blockchainRegionId = dict["BlockchainRegionId"] as! String
        }
        if dict.keys.contains("BlockchainType") {
            self.blockchainType = dict["BlockchainType"] as! String
        }
        if dict.keys.contains("CipherSuit") {
            self.cipherSuit = dict["CipherSuit"] as! String
        }
        if dict.keys.contains("LiveTime") {
            self.liveTime = dict["LiveTime"] as! Int32
        }
        if dict.keys.contains("MachineNum") {
            self.machineNum = dict["MachineNum"] as! Int32
        }
        if dict.keys.contains("MerkleTreeSuit") {
            self.merkleTreeSuit = dict["MerkleTreeSuit"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int32
        }
        if dict.keys.contains("TlsAlgo") {
            self.tlsAlgo = dict["TlsAlgo"] as! String
        }
    }
}

public class CreateBlockchainApplicationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class CreateBlockchainApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBlockchainApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateBlockchainApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBlockchainApplyRequest : Tea.TeaModel {
    public var bizid: String?

    public var liveTime: Int32?

    public var machineNum: Int32?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.liveTime != nil {
            map["LiveTime"] = self.liveTime!
        }
        if self.machineNum != nil {
            map["MachineNum"] = self.machineNum!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("LiveTime") {
            self.liveTime = dict["LiveTime"] as! Int32
        }
        if dict.keys.contains("MachineNum") {
            self.machineNum = dict["MachineNum"] as! Int32
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int32
        }
    }
}

public class CreateBlockchainApplyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class CreateBlockchainApplyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBlockchainApplyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateBlockchainApplyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateChaincodeRequest : Tea.TeaModel {
    public var channelId: String?

    public var consortiumId: String?

    public var endorsePolicy: String?

    public var location: String?

    public var organizationId: String?

    public var ossBucket: String?

    public var ossUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.endorsePolicy != nil {
            map["EndorsePolicy"] = self.endorsePolicy!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ossUrl != nil {
            map["OssUrl"] = self.ossUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("EndorsePolicy") {
            self.endorsePolicy = dict["EndorsePolicy"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("OssBucket") {
            self.ossBucket = dict["OssBucket"] as! String
        }
        if dict.keys.contains("OssUrl") {
            self.ossUrl = dict["OssUrl"] as! String
        }
    }
}

public class CreateChaincodeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var chaincodeId: String?

        public var channelName: String?

        public var consortiumId: String?

        public var createTime: String?

        public var deployTime: String?

        public var endorsePolicy: String?

        public var input: String?

        public var install: Bool?

        public var message: String?

        public var name: String?

        public var path: String?

        public var providerId: String?

        public var providerName: String?

        public var state: String?

        public var type: Int32?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chaincodeId != nil {
                map["ChaincodeId"] = self.chaincodeId!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.deployTime != nil {
                map["DeployTime"] = self.deployTime!
            }
            if self.endorsePolicy != nil {
                map["EndorsePolicy"] = self.endorsePolicy!
            }
            if self.input != nil {
                map["Input"] = self.input!
            }
            if self.install != nil {
                map["Install"] = self.install!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.providerId != nil {
                map["ProviderId"] = self.providerId!
            }
            if self.providerName != nil {
                map["ProviderName"] = self.providerName!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChaincodeId") {
                self.chaincodeId = dict["ChaincodeId"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DeployTime") {
                self.deployTime = dict["DeployTime"] as! String
            }
            if dict.keys.contains("EndorsePolicy") {
                self.endorsePolicy = dict["EndorsePolicy"] as! String
            }
            if dict.keys.contains("Input") {
                self.input = dict["Input"] as! String
            }
            if dict.keys.contains("Install") {
                self.install = dict["Install"] as! Bool
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("ProviderId") {
                self.providerId = dict["ProviderId"] as! String
            }
            if dict.keys.contains("ProviderName") {
                self.providerName = dict["ProviderName"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: CreateChaincodeResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateChaincodeResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateChaincodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateChaincodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateChaincodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateChannelRequest : Tea.TeaModel {
    public class Organization : Tea.TeaModel {
        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
        }
    }
    public var batchTimeout: Int32?

    public var channelName: String?

    public var consortiumId: String?

    public var maxMessageCount: Int32?

    public var organization: [CreateChannelRequest.Organization]?

    public var preferredMaxBytes: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchTimeout != nil {
            map["BatchTimeout"] = self.batchTimeout!
        }
        if self.channelName != nil {
            map["ChannelName"] = self.channelName!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.maxMessageCount != nil {
            map["MaxMessageCount"] = self.maxMessageCount!
        }
        if self.organization != nil {
            var tmp : [Any] = []
            for k in self.organization! {
                tmp.append(k.toMap())
            }
            map["Organization"] = tmp
        }
        if self.preferredMaxBytes != nil {
            map["PreferredMaxBytes"] = self.preferredMaxBytes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchTimeout") {
            self.batchTimeout = dict["BatchTimeout"] as! Int32
        }
        if dict.keys.contains("ChannelName") {
            self.channelName = dict["ChannelName"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("MaxMessageCount") {
            self.maxMessageCount = dict["MaxMessageCount"] as! Int32
        }
        if dict.keys.contains("Organization") {
            var tmp : [CreateChannelRequest.Organization] = []
            for v in dict["Organization"] as! [Any] {
                var model = CreateChannelRequest.Organization()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.organization = tmp
        }
        if dict.keys.contains("PreferredMaxBytes") {
            self.preferredMaxBytes = dict["PreferredMaxBytes"] as! Int32
        }
    }
}

public class CreateChannelResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var batchTimeout: Int32?

        public var blockCount: Int32?

        public var chaincodeCount: Int32?

        public var channelId: String?

        public var consortiumId: String?

        public var consortiumName: String?

        public var createTime: String?

        public var maxMessageCount: Int32?

        public var memberCount: Int32?

        public var name: String?

        public var ownerBid: String?

        public var ownerName: String?

        public var ownerUid: Int32?

        public var preferredMaxBytes: Int32?

        public var requestId: String?

        public var state: String?

        public var supportConfig: Bool?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.batchTimeout != nil {
                map["BatchTimeout"] = self.batchTimeout!
            }
            if self.blockCount != nil {
                map["BlockCount"] = self.blockCount!
            }
            if self.chaincodeCount != nil {
                map["ChaincodeCount"] = self.chaincodeCount!
            }
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.consortiumName != nil {
                map["ConsortiumName"] = self.consortiumName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.maxMessageCount != nil {
                map["MaxMessageCount"] = self.maxMessageCount!
            }
            if self.memberCount != nil {
                map["MemberCount"] = self.memberCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ownerBid != nil {
                map["OwnerBid"] = self.ownerBid!
            }
            if self.ownerName != nil {
                map["OwnerName"] = self.ownerName!
            }
            if self.ownerUid != nil {
                map["OwnerUid"] = self.ownerUid!
            }
            if self.preferredMaxBytes != nil {
                map["PreferredMaxBytes"] = self.preferredMaxBytes!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.supportConfig != nil {
                map["SupportConfig"] = self.supportConfig!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BatchTimeout") {
                self.batchTimeout = dict["BatchTimeout"] as! Int32
            }
            if dict.keys.contains("BlockCount") {
                self.blockCount = dict["BlockCount"] as! Int32
            }
            if dict.keys.contains("ChaincodeCount") {
                self.chaincodeCount = dict["ChaincodeCount"] as! Int32
            }
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("ConsortiumName") {
                self.consortiumName = dict["ConsortiumName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("MaxMessageCount") {
                self.maxMessageCount = dict["MaxMessageCount"] as! Int32
            }
            if dict.keys.contains("MemberCount") {
                self.memberCount = dict["MemberCount"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OwnerBid") {
                self.ownerBid = dict["OwnerBid"] as! String
            }
            if dict.keys.contains("OwnerName") {
                self.ownerName = dict["OwnerName"] as! String
            }
            if dict.keys.contains("OwnerUid") {
                self.ownerUid = dict["OwnerUid"] as! Int32
            }
            if dict.keys.contains("PreferredMaxBytes") {
                self.preferredMaxBytes = dict["PreferredMaxBytes"] as! Int32
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("SupportConfig") {
                self.supportConfig = dict["SupportConfig"] as! Bool
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: CreateChannelResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateChannelResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateChannelMemberRequest : Tea.TeaModel {
    public class Organization : Tea.TeaModel {
        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
        }
    }
    public var channelId: String?

    public var organization: [CreateChannelMemberRequest.Organization]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.organization != nil {
            var tmp : [Any] = []
            for k in self.organization! {
                tmp.append(k.toMap())
            }
            map["Organization"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("Organization") {
            var tmp : [CreateChannelMemberRequest.Organization] = []
            for v in dict["Organization"] as! [Any] {
                var model = CreateChannelMemberRequest.Organization()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.organization = tmp
        }
    }
}

public class CreateChannelMemberResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateChannelMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateChannelMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateChannelMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCloudIntegrationServiceTokenRequest : Tea.TeaModel {
    public var organizationId: String?

    public var service: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.service != nil {
            map["Service"] = self.service!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("Service") {
            self.service = dict["Service"] as! String
        }
    }
}

public class CreateCloudIntegrationServiceTokenResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateCloudIntegrationServiceTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCloudIntegrationServiceTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCloudIntegrationServiceTokenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCloudServiceIntegrationRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class CreateCloudServiceIntegrationResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateCloudServiceIntegrationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCloudServiceIntegrationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCloudServiceIntegrationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCloudServiceSessionRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class CreateCloudServiceSessionResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateCloudServiceSessionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCloudServiceSessionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCloudServiceSessionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateConsortiumRequest : Tea.TeaModel {
    public class Organization : Tea.TeaModel {
        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
        }
    }
    public var channelPolicy: String?

    public var description_: String?

    public var domain: String?

    public var duration: Int32?

    public var location: String?

    public var majorVersion: String?

    public var name: String?

    public var ordererType: String?

    public var orderersCount: Int32?

    public var organization: [CreateConsortiumRequest.Organization]?

    public var peersCount: Int32?

    public var pricingCycle: String?

    public var specName: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelPolicy != nil {
            map["ChannelPolicy"] = self.channelPolicy!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.majorVersion != nil {
            map["MajorVersion"] = self.majorVersion!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ordererType != nil {
            map["OrdererType"] = self.ordererType!
        }
        if self.orderersCount != nil {
            map["OrderersCount"] = self.orderersCount!
        }
        if self.organization != nil {
            var tmp : [Any] = []
            for k in self.organization! {
                tmp.append(k.toMap())
            }
            map["Organization"] = tmp
        }
        if self.peersCount != nil {
            map["PeersCount"] = self.peersCount!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.specName != nil {
            map["SpecName"] = self.specName!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelPolicy") {
            self.channelPolicy = dict["ChannelPolicy"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Domain") {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! Int32
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("MajorVersion") {
            self.majorVersion = dict["MajorVersion"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OrdererType") {
            self.ordererType = dict["OrdererType"] as! String
        }
        if dict.keys.contains("OrderersCount") {
            self.orderersCount = dict["OrderersCount"] as! Int32
        }
        if dict.keys.contains("Organization") {
            var tmp : [CreateConsortiumRequest.Organization] = []
            for v in dict["Organization"] as! [Any] {
                var model = CreateConsortiumRequest.Organization()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.organization = tmp
        }
        if dict.keys.contains("PeersCount") {
            self.peersCount = dict["PeersCount"] as! Int32
        }
        if dict.keys.contains("PricingCycle") {
            self.pricingCycle = dict["PricingCycle"] as! String
        }
        if dict.keys.contains("SpecName") {
            self.specName = dict["SpecName"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateConsortiumResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var channelCount: Int32?

        public var channelPolicy: String?

        public var clusterState: String?

        public var codeName: String?

        public var consortiumId: String?

        public var createTime: String?

        public var description_: String?

        public var domain: String?

        public var memberCount: Int32?

        public var name: String?

        public var ordererCount: Int32?

        public var ordererType: String?

        public var ownerBid: String?

        public var ownerUid: Int64?

        public var regionId: String?

        public var serviceState: String?

        public var specName: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelCount != nil {
                map["ChannelCount"] = self.channelCount!
            }
            if self.channelPolicy != nil {
                map["ChannelPolicy"] = self.channelPolicy!
            }
            if self.clusterState != nil {
                map["ClusterState"] = self.clusterState!
            }
            if self.codeName != nil {
                map["CodeName"] = self.codeName!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.memberCount != nil {
                map["MemberCount"] = self.memberCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ordererCount != nil {
                map["OrdererCount"] = self.ordererCount!
            }
            if self.ordererType != nil {
                map["OrdererType"] = self.ordererType!
            }
            if self.ownerBid != nil {
                map["OwnerBid"] = self.ownerBid!
            }
            if self.ownerUid != nil {
                map["OwnerUid"] = self.ownerUid!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.serviceState != nil {
                map["ServiceState"] = self.serviceState!
            }
            if self.specName != nil {
                map["SpecName"] = self.specName!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelCount") {
                self.channelCount = dict["ChannelCount"] as! Int32
            }
            if dict.keys.contains("ChannelPolicy") {
                self.channelPolicy = dict["ChannelPolicy"] as! String
            }
            if dict.keys.contains("ClusterState") {
                self.clusterState = dict["ClusterState"] as! String
            }
            if dict.keys.contains("CodeName") {
                self.codeName = dict["CodeName"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("MemberCount") {
                self.memberCount = dict["MemberCount"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OrdererCount") {
                self.ordererCount = dict["OrdererCount"] as! Int32
            }
            if dict.keys.contains("OrdererType") {
                self.ordererType = dict["OrdererType"] as! String
            }
            if dict.keys.contains("OwnerBid") {
                self.ownerBid = dict["OwnerBid"] as! String
            }
            if dict.keys.contains("OwnerUid") {
                self.ownerUid = dict["OwnerUid"] as! Int64
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ServiceState") {
                self.serviceState = dict["ServiceState"] as! String
            }
            if dict.keys.contains("SpecName") {
                self.specName = dict["SpecName"] as! String
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: CreateConsortiumResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateConsortiumResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateConsortiumResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateConsortiumResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateConsortiumResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateConsortiumMemberRequest : Tea.TeaModel {
    public class Organization : Tea.TeaModel {
        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
        }
    }
    public var code: String?

    public var consortiumId: String?

    public var organization: [CreateConsortiumMemberRequest.Organization]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.organization != nil {
            var tmp : [Any] = []
            for k in self.organization! {
                tmp.append(k.toMap())
            }
            map["Organization"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("Organization") {
            var tmp : [CreateConsortiumMemberRequest.Organization] = []
            for v in dict["Organization"] as! [Any] {
                var model = CreateConsortiumMemberRequest.Organization()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.organization = tmp
        }
    }
}

public class CreateConsortiumMemberResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateConsortiumMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateConsortiumMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateConsortiumMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEcosphereRequest : Tea.TeaModel {
    public class Organization : Tea.TeaModel {
        public var description_: String?

        public var domain: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var channelPolicy: String?

    public var consortiumName: String?

    public var description_: String?

    public var duration: Int32?

    public var location: String?

    public var majorVersion: String?

    public var ordererDomain: String?

    public var ordererType: String?

    public var orderersCount: Int32?

    public var organization: [CreateEcosphereRequest.Organization]?

    public var peersCount: Int32?

    public var pricingCycle: String?

    public var specName: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelPolicy != nil {
            map["ChannelPolicy"] = self.channelPolicy!
        }
        if self.consortiumName != nil {
            map["ConsortiumName"] = self.consortiumName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.majorVersion != nil {
            map["MajorVersion"] = self.majorVersion!
        }
        if self.ordererDomain != nil {
            map["OrdererDomain"] = self.ordererDomain!
        }
        if self.ordererType != nil {
            map["OrdererType"] = self.ordererType!
        }
        if self.orderersCount != nil {
            map["OrderersCount"] = self.orderersCount!
        }
        if self.organization != nil {
            var tmp : [Any] = []
            for k in self.organization! {
                tmp.append(k.toMap())
            }
            map["Organization"] = tmp
        }
        if self.peersCount != nil {
            map["PeersCount"] = self.peersCount!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.specName != nil {
            map["SpecName"] = self.specName!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelPolicy") {
            self.channelPolicy = dict["ChannelPolicy"] as! String
        }
        if dict.keys.contains("ConsortiumName") {
            self.consortiumName = dict["ConsortiumName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! Int32
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("MajorVersion") {
            self.majorVersion = dict["MajorVersion"] as! String
        }
        if dict.keys.contains("OrdererDomain") {
            self.ordererDomain = dict["OrdererDomain"] as! String
        }
        if dict.keys.contains("OrdererType") {
            self.ordererType = dict["OrdererType"] as! String
        }
        if dict.keys.contains("OrderersCount") {
            self.orderersCount = dict["OrderersCount"] as! Int32
        }
        if dict.keys.contains("Organization") {
            var tmp : [CreateEcosphereRequest.Organization] = []
            for v in dict["Organization"] as! [Any] {
                var model = CreateEcosphereRequest.Organization()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.organization = tmp
        }
        if dict.keys.contains("PeersCount") {
            self.peersCount = dict["PeersCount"] as! Int32
        }
        if dict.keys.contains("PricingCycle") {
            self.pricingCycle = dict["PricingCycle"] as! String
        }
        if dict.keys.contains("SpecName") {
            self.specName = dict["SpecName"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateEcosphereResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Organizations : Tea.TeaModel {
            public var clusterState: String?

            public var code: String?

            public var createTime: String?

            public var description_: String?

            public var domain: String?

            public var name: String?

            public var serviceState: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterState != nil {
                    map["ClusterState"] = self.clusterState!
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.serviceState != nil {
                    map["ServiceState"] = self.serviceState!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterState") {
                    self.clusterState = dict["ClusterState"] as! String
                }
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Domain") {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ServiceState") {
                    self.serviceState = dict["ServiceState"] as! String
                }
            }
        }
        public class Specification : Tea.TeaModel {
            public var name: String?

            public var numOfNodes: Int32?

            public var title: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.numOfNodes != nil {
                    map["NumOfNodes"] = self.numOfNodes!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NumOfNodes") {
                    self.numOfNodes = dict["NumOfNodes"] as! Int32
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
            }
        }
        public var channelCount: Int32?

        public var channelPolicy: String?

        public var clusterState: String?

        public var code: String?

        public var consortiumId: String?

        public var createTime: String?

        public var description_: String?

        public var domain: String?

        public var memberCount: Int32?

        public var name: String?

        public var ordererCount: Int32?

        public var ordererType: String?

        public var organizations: [CreateEcosphereResponseBody.Result.Organizations]?

        public var ownerBid: String?

        public var ownerUid: Int64?

        public var regionId: String?

        public var serviceState: String?

        public var specName: String?

        public var specification: CreateEcosphereResponseBody.Result.Specification?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.specification?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelCount != nil {
                map["ChannelCount"] = self.channelCount!
            }
            if self.channelPolicy != nil {
                map["ChannelPolicy"] = self.channelPolicy!
            }
            if self.clusterState != nil {
                map["ClusterState"] = self.clusterState!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.memberCount != nil {
                map["MemberCount"] = self.memberCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ordererCount != nil {
                map["OrdererCount"] = self.ordererCount!
            }
            if self.ordererType != nil {
                map["OrdererType"] = self.ordererType!
            }
            if self.organizations != nil {
                var tmp : [Any] = []
                for k in self.organizations! {
                    tmp.append(k.toMap())
                }
                map["Organizations"] = tmp
            }
            if self.ownerBid != nil {
                map["OwnerBid"] = self.ownerBid!
            }
            if self.ownerUid != nil {
                map["OwnerUid"] = self.ownerUid!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.serviceState != nil {
                map["ServiceState"] = self.serviceState!
            }
            if self.specName != nil {
                map["SpecName"] = self.specName!
            }
            if self.specification != nil {
                map["Specification"] = self.specification?.toMap()
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelCount") {
                self.channelCount = dict["ChannelCount"] as! Int32
            }
            if dict.keys.contains("ChannelPolicy") {
                self.channelPolicy = dict["ChannelPolicy"] as! String
            }
            if dict.keys.contains("ClusterState") {
                self.clusterState = dict["ClusterState"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("MemberCount") {
                self.memberCount = dict["MemberCount"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OrdererCount") {
                self.ordererCount = dict["OrdererCount"] as! Int32
            }
            if dict.keys.contains("OrdererType") {
                self.ordererType = dict["OrdererType"] as! String
            }
            if dict.keys.contains("Organizations") {
                var tmp : [CreateEcosphereResponseBody.Result.Organizations] = []
                for v in dict["Organizations"] as! [Any] {
                    var model = CreateEcosphereResponseBody.Result.Organizations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.organizations = tmp
            }
            if dict.keys.contains("OwnerBid") {
                self.ownerBid = dict["OwnerBid"] as! String
            }
            if dict.keys.contains("OwnerUid") {
                self.ownerUid = dict["OwnerUid"] as! Int64
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ServiceState") {
                self.serviceState = dict["ServiceState"] as! String
            }
            if dict.keys.contains("SpecName") {
                self.specName = dict["SpecName"] as! String
            }
            if dict.keys.contains("Specification") {
                var model = CreateEcosphereResponseBody.Result.Specification()
                model.fromMap(dict["Specification"] as! [String: Any])
                self.specification = model
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var errorMessage: String?

    public var requestId: String?

    public var result: CreateEcosphereResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("ErrorMessage") {
            self.errorMessage = dict["ErrorMessage"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateEcosphereResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateEcosphereResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEcosphereResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEcosphereResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEthereumRequest : Tea.TeaModel {
    public class Node : Tea.TeaModel {
        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var consensus: String?

    public var description_: String?

    public var difficulty: String?

    public var gas: String?

    public var name: String?

    public var networkId: String?

    public var node: [CreateEthereumRequest.Node]?

    public var region: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consensus != nil {
            map["Consensus"] = self.consensus!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.difficulty != nil {
            map["Difficulty"] = self.difficulty!
        }
        if self.gas != nil {
            map["Gas"] = self.gas!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.networkId != nil {
            map["NetworkId"] = self.networkId!
        }
        if self.node != nil {
            var tmp : [Any] = []
            for k in self.node! {
                tmp.append(k.toMap())
            }
            map["Node"] = tmp
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Consensus") {
            self.consensus = dict["Consensus"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Difficulty") {
            self.difficulty = dict["Difficulty"] as! String
        }
        if dict.keys.contains("Gas") {
            self.gas = dict["Gas"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NetworkId") {
            self.networkId = dict["NetworkId"] as! String
        }
        if dict.keys.contains("Node") {
            var tmp : [CreateEthereumRequest.Node] = []
            for v in dict["Node"] as! [Any] {
                var model = CreateEthereumRequest.Node()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.node = tmp
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
    }
}

public class CreateEthereumResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consensus: String?

        public var creator: String?

        public var description_: String?

        public var id: String?

        public var name: String?

        public var networkId: String?

        public var regionId: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consensus != nil {
                map["Consensus"] = self.consensus!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Consensus") {
                self.consensus = dict["Consensus"] as! String
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NetworkId") {
                self.networkId = dict["NetworkId"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: CreateEthereumResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateEthereumResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateEthereumResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEthereumResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEthereumResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEthereumInvitationRequest : Tea.TeaModel {
    public var ethereumId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ethereumId != nil {
            map["EthereumId"] = self.ethereumId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EthereumId") {
            self.ethereumId = dict["EthereumId"] as! String
        }
    }
}

public class CreateEthereumInvitationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var code: String?

        public var createTime: String?

        public var expireTime: String?

        public var token: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.token != nil {
                map["Token"] = self.token!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("Token") {
                self.token = dict["Token"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: CreateEthereumInvitationResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateEthereumInvitationResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateEthereumInvitationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEthereumInvitationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateEthereumInvitationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFabricChaincodePackageRequest : Tea.TeaModel {
    public var location: String?

    public var organizationId: String?

    public var ossBucket: String?

    public var ossUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ossUrl != nil {
            map["OssUrl"] = self.ossUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("OssBucket") {
            self.ossBucket = dict["OssBucket"] as! String
        }
        if dict.keys.contains("OssUrl") {
            self.ossUrl = dict["OssUrl"] as! String
        }
    }
}

public class CreateFabricChaincodePackageResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var chaincodePackageId: Int32?

        public var checksum: String?

        public var deleteTime: Int64?

        public var deleted: Bool?

        public var installTime: Int64?

        public var label: String?

        public var md5sum: String?

        public var organizationId: String?

        public var ossBucket: String?

        public var ossURL: String?

        public var providerBid: String?

        public var providerUid: Int64?

        public var state: String?

        public var type: String?

        public var typeString: Bool?

        public var uploadTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chaincodePackageId != nil {
                map["ChaincodePackageId"] = self.chaincodePackageId!
            }
            if self.checksum != nil {
                map["Checksum"] = self.checksum!
            }
            if self.deleteTime != nil {
                map["DeleteTime"] = self.deleteTime!
            }
            if self.deleted != nil {
                map["Deleted"] = self.deleted!
            }
            if self.installTime != nil {
                map["InstallTime"] = self.installTime!
            }
            if self.label != nil {
                map["Label"] = self.label!
            }
            if self.md5sum != nil {
                map["Md5sum"] = self.md5sum!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.ossBucket != nil {
                map["OssBucket"] = self.ossBucket!
            }
            if self.ossURL != nil {
                map["OssURL"] = self.ossURL!
            }
            if self.providerBid != nil {
                map["ProviderBid"] = self.providerBid!
            }
            if self.providerUid != nil {
                map["ProviderUid"] = self.providerUid!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeString != nil {
                map["TypeString"] = self.typeString!
            }
            if self.uploadTime != nil {
                map["UploadTime"] = self.uploadTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChaincodePackageId") {
                self.chaincodePackageId = dict["ChaincodePackageId"] as! Int32
            }
            if dict.keys.contains("Checksum") {
                self.checksum = dict["Checksum"] as! String
            }
            if dict.keys.contains("DeleteTime") {
                self.deleteTime = dict["DeleteTime"] as! Int64
            }
            if dict.keys.contains("Deleted") {
                self.deleted = dict["Deleted"] as! Bool
            }
            if dict.keys.contains("InstallTime") {
                self.installTime = dict["InstallTime"] as! Int64
            }
            if dict.keys.contains("Label") {
                self.label = dict["Label"] as! String
            }
            if dict.keys.contains("Md5sum") {
                self.md5sum = dict["Md5sum"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
            if dict.keys.contains("OssBucket") {
                self.ossBucket = dict["OssBucket"] as! String
            }
            if dict.keys.contains("OssURL") {
                self.ossURL = dict["OssURL"] as! String
            }
            if dict.keys.contains("ProviderBid") {
                self.providerBid = dict["ProviderBid"] as! String
            }
            if dict.keys.contains("ProviderUid") {
                self.providerUid = dict["ProviderUid"] as! Int64
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("TypeString") {
                self.typeString = dict["TypeString"] as! Bool
            }
            if dict.keys.contains("UploadTime") {
                self.uploadTime = dict["UploadTime"] as! Int64
            }
        }
    }
    public var errorCode: Int32?

    public var message: String?

    public var requestId: String?

    public var result: CreateFabricChaincodePackageResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateFabricChaincodePackageResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateFabricChaincodePackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFabricChaincodePackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateFabricChaincodePackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrganizationRequest : Tea.TeaModel {
    public var description_: String?

    public var domain: String?

    public var duration: Int32?

    public var location: String?

    public var majorVersion: String?

    public var name: String?

    public var peersCount: Int32?

    public var pricingCycle: String?

    public var specName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.majorVersion != nil {
            map["MajorVersion"] = self.majorVersion!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.peersCount != nil {
            map["PeersCount"] = self.peersCount!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.specName != nil {
            map["SpecName"] = self.specName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Domain") {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! Int32
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("MajorVersion") {
            self.majorVersion = dict["MajorVersion"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PeersCount") {
            self.peersCount = dict["PeersCount"] as! Int32
        }
        if dict.keys.contains("PricingCycle") {
            self.pricingCycle = dict["PricingCycle"] as! String
        }
        if dict.keys.contains("SpecName") {
            self.specName = dict["SpecName"] as! String
        }
    }
}

public class CreateOrganizationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var clusterState: String?

        public var codeName: String?

        public var consortiumCount: Int32?

        public var createTime: String?

        public var description_: String?

        public var domain: String?

        public var name: String?

        public var organizationId: String?

        public var ownerBid: String?

        public var ownerName: String?

        public var ownerUid: Int32?

        public var peerCount: Int32?

        public var regionId: String?

        public var requestId: String?

        public var serviceState: String?

        public var specName: String?

        public var userCount: Int32?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterState != nil {
                map["ClusterState"] = self.clusterState!
            }
            if self.codeName != nil {
                map["CodeName"] = self.codeName!
            }
            if self.consortiumCount != nil {
                map["ConsortiumCount"] = self.consortiumCount!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.ownerBid != nil {
                map["OwnerBid"] = self.ownerBid!
            }
            if self.ownerName != nil {
                map["OwnerName"] = self.ownerName!
            }
            if self.ownerUid != nil {
                map["OwnerUid"] = self.ownerUid!
            }
            if self.peerCount != nil {
                map["PeerCount"] = self.peerCount!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.serviceState != nil {
                map["ServiceState"] = self.serviceState!
            }
            if self.specName != nil {
                map["SpecName"] = self.specName!
            }
            if self.userCount != nil {
                map["UserCount"] = self.userCount!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterState") {
                self.clusterState = dict["ClusterState"] as! String
            }
            if dict.keys.contains("CodeName") {
                self.codeName = dict["CodeName"] as! String
            }
            if dict.keys.contains("ConsortiumCount") {
                self.consortiumCount = dict["ConsortiumCount"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
            if dict.keys.contains("OwnerBid") {
                self.ownerBid = dict["OwnerBid"] as! String
            }
            if dict.keys.contains("OwnerName") {
                self.ownerName = dict["OwnerName"] as! String
            }
            if dict.keys.contains("OwnerUid") {
                self.ownerUid = dict["OwnerUid"] as! Int32
            }
            if dict.keys.contains("PeerCount") {
                self.peerCount = dict["PeerCount"] as! Int32
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("ServiceState") {
                self.serviceState = dict["ServiceState"] as! String
            }
            if dict.keys.contains("SpecName") {
                self.specName = dict["SpecName"] as! String
            }
            if dict.keys.contains("UserCount") {
                self.userCount = dict["UserCount"] as! Int32
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: CreateOrganizationResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateOrganizationResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateOrganizationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrganizationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOrganizationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOrganizationUserRequest : Tea.TeaModel {
    public var attrs: String?

    public var organizationId: String?

    public var password: String?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attrs != nil {
            map["Attrs"] = self.attrs!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Attrs") {
            self.attrs = dict["Attrs"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("Username") {
            self.username = dict["Username"] as! String
        }
    }
}

public class CreateOrganizationUserResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createTime: String?

        public var expireTime: String?

        public var fullname: String?

        public var organizationId: String?

        public var password: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.fullname != nil {
                map["Fullname"] = self.fullname!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.username != nil {
                map["Username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("Fullname") {
                self.fullname = dict["Fullname"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("Username") {
                self.username = dict["Username"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: CreateOrganizationUserResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateOrganizationUserResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateOrganizationUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrganizationUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOrganizationUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateOwnAccountRequest : Tea.TeaModel {
    public var bizid: String?

    public var identity: String?

    public var publicKey: String?

    public var recoveryKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.identity != nil {
            map["Identity"] = self.identity!
        }
        if self.publicKey != nil {
            map["PublicKey"] = self.publicKey!
        }
        if self.recoveryKey != nil {
            map["RecoveryKey"] = self.recoveryKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Identity") {
            self.identity = dict["Identity"] as! String
        }
        if dict.keys.contains("PublicKey") {
            self.publicKey = dict["PublicKey"] as! String
        }
        if dict.keys.contains("RecoveryKey") {
            self.recoveryKey = dict["RecoveryKey"] as! String
        }
    }
}

public class CreateOwnAccountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class CreateOwnAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOwnAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateOwnAccountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePublicAccountWithKeyPairAutoCreationRequest : Tea.TeaModel {
    public var account: String?

    public var bizid: String?

    public var password: String?

    public var recoverPassword: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.account != nil {
            map["Account"] = self.account!
        }
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.recoverPassword != nil {
            map["RecoverPassword"] = self.recoverPassword!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Account") {
            self.account = dict["Account"] as! String
        }
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("RecoverPassword") {
            self.recoverPassword = dict["RecoverPassword"] as! String
        }
    }
}

public class CreatePublicAccountWithKeyPairAutoCreationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accountPrivateKey: String?

        public var accountPublicKey: String?

        public var accountRecoverPrivateKey: String?

        public var accountRecoverPublicKey: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountPrivateKey != nil {
                map["AccountPrivateKey"] = self.accountPrivateKey!
            }
            if self.accountPublicKey != nil {
                map["AccountPublicKey"] = self.accountPublicKey!
            }
            if self.accountRecoverPrivateKey != nil {
                map["AccountRecoverPrivateKey"] = self.accountRecoverPrivateKey!
            }
            if self.accountRecoverPublicKey != nil {
                map["AccountRecoverPublicKey"] = self.accountRecoverPublicKey!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountPrivateKey") {
                self.accountPrivateKey = dict["AccountPrivateKey"] as! String
            }
            if dict.keys.contains("AccountPublicKey") {
                self.accountPublicKey = dict["AccountPublicKey"] as! String
            }
            if dict.keys.contains("AccountRecoverPrivateKey") {
                self.accountRecoverPrivateKey = dict["AccountRecoverPrivateKey"] as! String
            }
            if dict.keys.contains("AccountRecoverPublicKey") {
                self.accountRecoverPublicKey = dict["AccountRecoverPublicKey"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: CreatePublicAccountWithKeyPairAutoCreationResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreatePublicAccountWithKeyPairAutoCreationResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class CreatePublicAccountWithKeyPairAutoCreationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePublicAccountWithKeyPairAutoCreationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePublicAccountWithKeyPairAutoCreationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePublicAntChainAccountRequest : Tea.TeaModel {
    public var account: String?

    public var accountPubKey: String?

    public var accountRecoverPubKey: String?

    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.account != nil {
            map["Account"] = self.account!
        }
        if self.accountPubKey != nil {
            map["AccountPubKey"] = self.accountPubKey!
        }
        if self.accountRecoverPubKey != nil {
            map["AccountRecoverPubKey"] = self.accountRecoverPubKey!
        }
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Account") {
            self.account = dict["Account"] as! String
        }
        if dict.keys.contains("AccountPubKey") {
            self.accountPubKey = dict["AccountPubKey"] as! String
        }
        if dict.keys.contains("AccountRecoverPubKey") {
            self.accountRecoverPubKey = dict["AccountRecoverPubKey"] as! String
        }
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class CreatePublicAntChainAccountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class CreatePublicAntChainAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePublicAntChainAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePublicAntChainAccountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSmartContractJobResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessId: String?

        public var dir: Int32?

        public var expire: Int64?

        public var host: String?

        public var jobID: String?

        public var policy: String?

        public var signature: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessId != nil {
                map["AccessId"] = self.accessId!
            }
            if self.dir != nil {
                map["Dir"] = self.dir!
            }
            if self.expire != nil {
                map["Expire"] = self.expire!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.jobID != nil {
                map["JobID"] = self.jobID!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.signature != nil {
                map["Signature"] = self.signature!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessId") {
                self.accessId = dict["AccessId"] as! String
            }
            if dict.keys.contains("Dir") {
                self.dir = dict["Dir"] as! Int32
            }
            if dict.keys.contains("Expire") {
                self.expire = dict["Expire"] as! Int64
            }
            if dict.keys.contains("Host") {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("JobID") {
                self.jobID = dict["JobID"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("Signature") {
                self.signature = dict["Signature"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: CreateSmartContractJobResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateSmartContractJobResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateSmartContractJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSmartContractJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSmartContractJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTriggerRequest : Tea.TeaModel {
    public var channelId: String?

    public var name: String?

    public var options: String?

    public var organizationId: String?

    public var source: String?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.options != nil {
            map["Options"] = self.options!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Options") {
            self.options = dict["Options"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateTriggerResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var channelId: String?

        public var channelName: String?

        public var createTime: Int64?

        public var errorMessage: String?

        public var name: String?

        public var options: String?

        public var source: String?

        public var status: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.options != nil {
                map["Options"] = self.options!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Options") {
                self.options = dict["Options"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: CreateTriggerResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateTriggerResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateTriggerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTriggerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTriggerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAntChainConsortiumRequest : Tea.TeaModel {
    public var consortiumId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
    }
}

public class DeleteAntChainConsortiumResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class DeleteAntChainConsortiumResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAntChainConsortiumResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAntChainConsortiumResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAntChainContractContentRequest : Tea.TeaModel {
    public var contentId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contentId != nil {
            map["ContentId"] = self.contentId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContentId") {
            self.contentId = dict["ContentId"] as! String
        }
    }
}

public class DeleteAntChainContractContentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class DeleteAntChainContractContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAntChainContractContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAntChainContractContentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAntChainContractProjectRequest : Tea.TeaModel {
    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class DeleteAntChainContractProjectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class DeleteAntChainContractProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAntChainContractProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAntChainContractProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAntChainMiniAppQRCodeAuthorizedUserRequest : Tea.TeaModel {
    public var antChainId: String?

    public var phone: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.phone != nil {
            map["Phone"] = self.phone!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("Phone") {
            self.phone = dict["Phone"] as! String
        }
    }
}

public class DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class DeleteAntChainMiniAppQRCodeAuthorizedUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteChaincodeRequest : Tea.TeaModel {
    public var chaincodeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chaincodeId != nil {
            map["ChaincodeId"] = self.chaincodeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChaincodeId") {
            self.chaincodeId = dict["ChaincodeId"] as! String
        }
    }
}

public class DeleteChaincodeResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteChaincodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteChaincodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteChaincodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGovernanceTaskRequest : Tea.TeaModel {
    public var channelId: String?

    public var organizationId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DeleteGovernanceTaskResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public class AddedOrganizations : Tea.TeaModel {
                public class AnchorPeers : Tea.TeaModel {
                    public var host: String?

                    public var port: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.host != nil {
                            map["Host"] = self.host!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Host") {
                            self.host = dict["Host"] as! String
                        }
                        if dict.keys.contains("Port") {
                            self.port = dict["Port"] as! Int32
                        }
                    }
                }
                public class OrdererNodes : Tea.TeaModel {
                    public var address: String?

                    public var certificate: String?

                    public var key: String?

                    public var tlsroot: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.certificate != nil {
                            map["Certificate"] = self.certificate!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.tlsroot != nil {
                            map["Tlsroot"] = self.tlsroot!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Address") {
                            self.address = dict["Address"] as! String
                        }
                        if dict.keys.contains("Certificate") {
                            self.certificate = dict["Certificate"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Tlsroot") {
                            self.tlsroot = dict["Tlsroot"] as! String
                        }
                    }
                }
                public var anchorPeers: [DeleteGovernanceTaskResponseBody.Result.Content.AddedOrganizations.AnchorPeers]?

                public var crls: String?

                public var mspId: String?

                public var mspType: String?

                public var orderer: Bool?

                public var ordererNodes: [DeleteGovernanceTaskResponseBody.Result.Content.AddedOrganizations.OrdererNodes]?

                public var rootCertificates: String?

                public var tlsRootCertificates: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.anchorPeers != nil {
                        var tmp : [Any] = []
                        for k in self.anchorPeers! {
                            tmp.append(k.toMap())
                        }
                        map["AnchorPeers"] = tmp
                    }
                    if self.crls != nil {
                        map["Crls"] = self.crls!
                    }
                    if self.mspId != nil {
                        map["MspId"] = self.mspId!
                    }
                    if self.mspType != nil {
                        map["MspType"] = self.mspType!
                    }
                    if self.orderer != nil {
                        map["Orderer"] = self.orderer!
                    }
                    if self.ordererNodes != nil {
                        var tmp : [Any] = []
                        for k in self.ordererNodes! {
                            tmp.append(k.toMap())
                        }
                        map["OrdererNodes"] = tmp
                    }
                    if self.rootCertificates != nil {
                        map["RootCertificates"] = self.rootCertificates!
                    }
                    if self.tlsRootCertificates != nil {
                        map["TlsRootCertificates"] = self.tlsRootCertificates!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnchorPeers") {
                        var tmp : [DeleteGovernanceTaskResponseBody.Result.Content.AddedOrganizations.AnchorPeers] = []
                        for v in dict["AnchorPeers"] as! [Any] {
                            var model = DeleteGovernanceTaskResponseBody.Result.Content.AddedOrganizations.AnchorPeers()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.anchorPeers = tmp
                    }
                    if dict.keys.contains("Crls") {
                        self.crls = dict["Crls"] as! String
                    }
                    if dict.keys.contains("MspId") {
                        self.mspId = dict["MspId"] as! String
                    }
                    if dict.keys.contains("MspType") {
                        self.mspType = dict["MspType"] as! String
                    }
                    if dict.keys.contains("Orderer") {
                        self.orderer = dict["Orderer"] as! Bool
                    }
                    if dict.keys.contains("OrdererNodes") {
                        var tmp : [DeleteGovernanceTaskResponseBody.Result.Content.AddedOrganizations.OrdererNodes] = []
                        for v in dict["OrdererNodes"] as! [Any] {
                            var model = DeleteGovernanceTaskResponseBody.Result.Content.AddedOrganizations.OrdererNodes()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ordererNodes = tmp
                    }
                    if dict.keys.contains("RootCertificates") {
                        self.rootCertificates = dict["RootCertificates"] as! String
                    }
                    if dict.keys.contains("TlsRootCertificates") {
                        self.tlsRootCertificates = dict["TlsRootCertificates"] as! String
                    }
                }
            }
            public class ChaincodeSpecPkg : Tea.TeaModel {
                public class Cs : Tea.TeaModel {
                    public var input: String?

                    public var name: String?

                    public var path: String?

                    public var type: Int32?

                    public var version: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.input != nil {
                            map["Input"] = self.input!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.path != nil {
                            map["Path"] = self.path!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.version != nil {
                            map["Version"] = self.version!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Input") {
                            self.input = dict["Input"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Path") {
                            self.path = dict["Path"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! Int32
                        }
                        if dict.keys.contains("Version") {
                            self.version = dict["Version"] as! String
                        }
                    }
                }
                public var cs: DeleteGovernanceTaskResponseBody.Result.Content.ChaincodeSpecPkg.Cs?

                public var policy: String?

                public var sha256: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.cs?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cs != nil {
                        map["Cs"] = self.cs?.toMap()
                    }
                    if self.policy != nil {
                        map["Policy"] = self.policy!
                    }
                    if self.sha256 != nil {
                        map["Sha256"] = self.sha256!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cs") {
                        var model = DeleteGovernanceTaskResponseBody.Result.Content.ChaincodeSpecPkg.Cs()
                        model.fromMap(dict["Cs"] as! [String: Any])
                        self.cs = model
                    }
                    if dict.keys.contains("Policy") {
                        self.policy = dict["Policy"] as! String
                    }
                    if dict.keys.contains("Sha256") {
                        self.sha256 = dict["Sha256"] as! String
                    }
                }
            }
            public class OrdererConfig : Tea.TeaModel {
                public var batchTimeout: String?

                public var maxMessageCount: Int32?

                public var preferredMaxBytes: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.batchTimeout != nil {
                        map["BatchTimeout"] = self.batchTimeout!
                    }
                    if self.maxMessageCount != nil {
                        map["MaxMessageCount"] = self.maxMessageCount!
                    }
                    if self.preferredMaxBytes != nil {
                        map["PreferredMaxBytes"] = self.preferredMaxBytes!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BatchTimeout") {
                        self.batchTimeout = dict["BatchTimeout"] as! String
                    }
                    if dict.keys.contains("MaxMessageCount") {
                        self.maxMessageCount = dict["MaxMessageCount"] as! Int32
                    }
                    if dict.keys.contains("PreferredMaxBytes") {
                        self.preferredMaxBytes = dict["PreferredMaxBytes"] as! Int32
                    }
                }
            }
            public class RemovedOrganizations : Tea.TeaModel {
                public class AnchorPeers : Tea.TeaModel {
                    public var host: String?

                    public var port: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.host != nil {
                            map["Host"] = self.host!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Host") {
                            self.host = dict["Host"] as! String
                        }
                        if dict.keys.contains("Port") {
                            self.port = dict["Port"] as! Int32
                        }
                    }
                }
                public class OrdererNodes : Tea.TeaModel {
                    public var address: String?

                    public var certificate: String?

                    public var key: String?

                    public var tlsroot: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.certificate != nil {
                            map["Certificate"] = self.certificate!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.tlsroot != nil {
                            map["Tlsroot"] = self.tlsroot!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Address") {
                            self.address = dict["Address"] as! String
                        }
                        if dict.keys.contains("Certificate") {
                            self.certificate = dict["Certificate"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Tlsroot") {
                            self.tlsroot = dict["Tlsroot"] as! String
                        }
                    }
                }
                public var anchorPeers: [DeleteGovernanceTaskResponseBody.Result.Content.RemovedOrganizations.AnchorPeers]?

                public var crls: String?

                public var mspId: String?

                public var mspType: String?

                public var orderer: Bool?

                public var ordererNodes: [DeleteGovernanceTaskResponseBody.Result.Content.RemovedOrganizations.OrdererNodes]?

                public var rootCertificates: String?

                public var tlsRootCertificates: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.anchorPeers != nil {
                        var tmp : [Any] = []
                        for k in self.anchorPeers! {
                            tmp.append(k.toMap())
                        }
                        map["AnchorPeers"] = tmp
                    }
                    if self.crls != nil {
                        map["Crls"] = self.crls!
                    }
                    if self.mspId != nil {
                        map["MspId"] = self.mspId!
                    }
                    if self.mspType != nil {
                        map["MspType"] = self.mspType!
                    }
                    if self.orderer != nil {
                        map["Orderer"] = self.orderer!
                    }
                    if self.ordererNodes != nil {
                        var tmp : [Any] = []
                        for k in self.ordererNodes! {
                            tmp.append(k.toMap())
                        }
                        map["OrdererNodes"] = tmp
                    }
                    if self.rootCertificates != nil {
                        map["RootCertificates"] = self.rootCertificates!
                    }
                    if self.tlsRootCertificates != nil {
                        map["TlsRootCertificates"] = self.tlsRootCertificates!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnchorPeers") {
                        var tmp : [DeleteGovernanceTaskResponseBody.Result.Content.RemovedOrganizations.AnchorPeers] = []
                        for v in dict["AnchorPeers"] as! [Any] {
                            var model = DeleteGovernanceTaskResponseBody.Result.Content.RemovedOrganizations.AnchorPeers()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.anchorPeers = tmp
                    }
                    if dict.keys.contains("Crls") {
                        self.crls = dict["Crls"] as! String
                    }
                    if dict.keys.contains("MspId") {
                        self.mspId = dict["MspId"] as! String
                    }
                    if dict.keys.contains("MspType") {
                        self.mspType = dict["MspType"] as! String
                    }
                    if dict.keys.contains("Orderer") {
                        self.orderer = dict["Orderer"] as! Bool
                    }
                    if dict.keys.contains("OrdererNodes") {
                        var tmp : [DeleteGovernanceTaskResponseBody.Result.Content.RemovedOrganizations.OrdererNodes] = []
                        for v in dict["OrdererNodes"] as! [Any] {
                            var model = DeleteGovernanceTaskResponseBody.Result.Content.RemovedOrganizations.OrdererNodes()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ordererNodes = tmp
                    }
                    if dict.keys.contains("RootCertificates") {
                        self.rootCertificates = dict["RootCertificates"] as! String
                    }
                    if dict.keys.contains("TlsRootCertificates") {
                        self.tlsRootCertificates = dict["TlsRootCertificates"] as! String
                    }
                }
            }
            public var addedOrganizations: [DeleteGovernanceTaskResponseBody.Result.Content.AddedOrganizations]?

            public var chaincodeSpecPkg: DeleteGovernanceTaskResponseBody.Result.Content.ChaincodeSpecPkg?

            public var ordererConfig: DeleteGovernanceTaskResponseBody.Result.Content.OrdererConfig?

            public var raw: String?

            public var removedOrganizations: [DeleteGovernanceTaskResponseBody.Result.Content.RemovedOrganizations]?

            public var rwSets: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.chaincodeSpecPkg?.validate()
                try self.ordererConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addedOrganizations != nil {
                    var tmp : [Any] = []
                    for k in self.addedOrganizations! {
                        tmp.append(k.toMap())
                    }
                    map["AddedOrganizations"] = tmp
                }
                if self.chaincodeSpecPkg != nil {
                    map["ChaincodeSpecPkg"] = self.chaincodeSpecPkg?.toMap()
                }
                if self.ordererConfig != nil {
                    map["OrdererConfig"] = self.ordererConfig?.toMap()
                }
                if self.raw != nil {
                    map["Raw"] = self.raw!
                }
                if self.removedOrganizations != nil {
                    var tmp : [Any] = []
                    for k in self.removedOrganizations! {
                        tmp.append(k.toMap())
                    }
                    map["RemovedOrganizations"] = tmp
                }
                if self.rwSets != nil {
                    map["RwSets"] = self.rwSets!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddedOrganizations") {
                    var tmp : [DeleteGovernanceTaskResponseBody.Result.Content.AddedOrganizations] = []
                    for v in dict["AddedOrganizations"] as! [Any] {
                        var model = DeleteGovernanceTaskResponseBody.Result.Content.AddedOrganizations()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.addedOrganizations = tmp
                }
                if dict.keys.contains("ChaincodeSpecPkg") {
                    var model = DeleteGovernanceTaskResponseBody.Result.Content.ChaincodeSpecPkg()
                    model.fromMap(dict["ChaincodeSpecPkg"] as! [String: Any])
                    self.chaincodeSpecPkg = model
                }
                if dict.keys.contains("OrdererConfig") {
                    var model = DeleteGovernanceTaskResponseBody.Result.Content.OrdererConfig()
                    model.fromMap(dict["OrdererConfig"] as! [String: Any])
                    self.ordererConfig = model
                }
                if dict.keys.contains("Raw") {
                    self.raw = dict["Raw"] as! String
                }
                if dict.keys.contains("RemovedOrganizations") {
                    var tmp : [DeleteGovernanceTaskResponseBody.Result.Content.RemovedOrganizations] = []
                    for v in dict["RemovedOrganizations"] as! [Any] {
                        var model = DeleteGovernanceTaskResponseBody.Result.Content.RemovedOrganizations()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.removedOrganizations = tmp
                }
                if dict.keys.contains("RwSets") {
                    self.rwSets = dict["RwSets"] as! String
                }
            }
        }
        public var channelName: String?

        public var content: DeleteGovernanceTaskResponseBody.Result.Content?

        public var createTime: Int64?

        public var creator: String?

        public var description_: String?

        public var status: String?

        public var taskId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.content?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.content != nil {
                map["Content"] = self.content?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("Content") {
                var model = DeleteGovernanceTaskResponseBody.Result.Content()
                model.fromMap(dict["Content"] as! [String: Any])
                self.content = model
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DeleteGovernanceTaskResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DeleteGovernanceTaskResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteGovernanceTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGovernanceTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGovernanceTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTriggerRequest : Tea.TeaModel {
    public var channelId: String?

    public var name: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DeleteTriggerResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Checkpoint : Tea.TeaModel {
            public var errorCount: Int64?

            public var height: Int64?

            public var index: Int64?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCount != nil {
                    map["ErrorCount"] = self.errorCount!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCount") {
                    self.errorCount = dict["ErrorCount"] as! Int64
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int64
                }
                if dict.keys.contains("Index") {
                    self.index = dict["Index"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var channelId: String?

        public var channelName: String?

        public var checkpoint: DeleteTriggerResponseBody.Result.Checkpoint?

        public var createTime: Int64?

        public var errorMessage: String?

        public var name: String?

        public var options: String?

        public var source: String?

        public var status: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkpoint?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.checkpoint != nil {
                map["Checkpoint"] = self.checkpoint?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.options != nil {
                map["Options"] = self.options!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("Checkpoint") {
                var model = DeleteTriggerResponseBody.Result.Checkpoint()
                model.fromMap(dict["Checkpoint"] as! [String: Any])
                self.checkpoint = model
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Options") {
                self.options = dict["Options"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DeleteTriggerResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DeleteTriggerResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DeleteTriggerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTriggerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTriggerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainAccountsRequest : Tea.TeaModel {
    public var antChainId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeAntChainAccountsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Accounts : Tea.TeaModel {
            public var account: String?

            public var accountPublicKey: String?

            public var accountRecoveryKey: String?

            public var accountStatus: String?

            public var antChainId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.account != nil {
                    map["Account"] = self.account!
                }
                if self.accountPublicKey != nil {
                    map["AccountPublicKey"] = self.accountPublicKey!
                }
                if self.accountRecoveryKey != nil {
                    map["AccountRecoveryKey"] = self.accountRecoveryKey!
                }
                if self.accountStatus != nil {
                    map["AccountStatus"] = self.accountStatus!
                }
                if self.antChainId != nil {
                    map["AntChainId"] = self.antChainId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Account") {
                    self.account = dict["Account"] as! String
                }
                if dict.keys.contains("AccountPublicKey") {
                    self.accountPublicKey = dict["AccountPublicKey"] as! String
                }
                if dict.keys.contains("AccountRecoveryKey") {
                    self.accountRecoveryKey = dict["AccountRecoveryKey"] as! String
                }
                if dict.keys.contains("AccountStatus") {
                    self.accountStatus = dict["AccountStatus"] as! String
                }
                if dict.keys.contains("AntChainId") {
                    self.antChainId = dict["AntChainId"] as! String
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var pageNumber: Int32?

            public var pageSize: Int32?

            public var totalCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PageNumber") {
                    self.pageNumber = dict["PageNumber"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("TotalCount") {
                    self.totalCount = dict["TotalCount"] as! Int32
                }
            }
        }
        public var accounts: [DescribeAntChainAccountsResponseBody.Result.Accounts]?

        public var pagination: DescribeAntChainAccountsResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accounts != nil {
                var tmp : [Any] = []
                for k in self.accounts! {
                    tmp.append(k.toMap())
                }
                map["Accounts"] = tmp
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Accounts") {
                var tmp : [DescribeAntChainAccountsResponseBody.Result.Accounts] = []
                for v in dict["Accounts"] as! [Any] {
                    var model = DescribeAntChainAccountsResponseBody.Result.Accounts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.accounts = tmp
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeAntChainAccountsResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeAntChainAccountsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainAccountsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeAntChainAccountsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainAccountsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainAccountsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainAccountsNewRequest : Tea.TeaModel {
    public var antChainId: String?

    public var consortiumId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeAntChainAccountsNewResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Accounts : Tea.TeaModel {
            public var account: String?

            public var accountPublicKey: String?

            public var accountRecoveryKey: String?

            public var accountStatus: String?

            public var antChainId: String?

            public var createTime: Int64?

            public var memberName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.account != nil {
                    map["Account"] = self.account!
                }
                if self.accountPublicKey != nil {
                    map["AccountPublicKey"] = self.accountPublicKey!
                }
                if self.accountRecoveryKey != nil {
                    map["AccountRecoveryKey"] = self.accountRecoveryKey!
                }
                if self.accountStatus != nil {
                    map["AccountStatus"] = self.accountStatus!
                }
                if self.antChainId != nil {
                    map["AntChainId"] = self.antChainId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.memberName != nil {
                    map["MemberName"] = self.memberName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Account") {
                    self.account = dict["Account"] as! String
                }
                if dict.keys.contains("AccountPublicKey") {
                    self.accountPublicKey = dict["AccountPublicKey"] as! String
                }
                if dict.keys.contains("AccountRecoveryKey") {
                    self.accountRecoveryKey = dict["AccountRecoveryKey"] as! String
                }
                if dict.keys.contains("AccountStatus") {
                    self.accountStatus = dict["AccountStatus"] as! String
                }
                if dict.keys.contains("AntChainId") {
                    self.antChainId = dict["AntChainId"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("MemberName") {
                    self.memberName = dict["MemberName"] as! String
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var pageNumber: Int32?

            public var pageSize: Int32?

            public var totalCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PageNumber") {
                    self.pageNumber = dict["PageNumber"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("TotalCount") {
                    self.totalCount = dict["TotalCount"] as! Int32
                }
            }
        }
        public var accounts: [DescribeAntChainAccountsNewResponseBody.Result.Accounts]?

        public var consortiumAdmin: Bool?

        public var pagination: DescribeAntChainAccountsNewResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accounts != nil {
                var tmp : [Any] = []
                for k in self.accounts! {
                    tmp.append(k.toMap())
                }
                map["Accounts"] = tmp
            }
            if self.consortiumAdmin != nil {
                map["ConsortiumAdmin"] = self.consortiumAdmin!
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Accounts") {
                var tmp : [DescribeAntChainAccountsNewResponseBody.Result.Accounts] = []
                for v in dict["Accounts"] as! [Any] {
                    var model = DescribeAntChainAccountsNewResponseBody.Result.Accounts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.accounts = tmp
            }
            if dict.keys.contains("ConsortiumAdmin") {
                self.consortiumAdmin = dict["ConsortiumAdmin"] as! Bool
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeAntChainAccountsNewResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: DescribeAntChainAccountsNewResponseBody.Result?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainAccountsNewResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainAccountsNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainAccountsNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainAccountsNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainApplicationsRequest : Tea.TeaModel {
    public var bizid: String?

    public var current: Int32?

    public var pageSize: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.current != nil {
            map["Current"] = self.current!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Current") {
            self.current = dict["Current"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeAntChainApplicationsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ApplyHistoryList : Tea.TeaModel {
            public var bizid: String?

            public var createtime: Int64?

            public var id: Int32?

            public var rejectReason: String?

            public var reqAddr: String?

            public var signedAddr: String?

            public var status: Int32?

            public var updatetime: Int64?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizid != nil {
                    map["Bizid"] = self.bizid!
                }
                if self.createtime != nil {
                    map["Createtime"] = self.createtime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.rejectReason != nil {
                    map["RejectReason"] = self.rejectReason!
                }
                if self.reqAddr != nil {
                    map["ReqAddr"] = self.reqAddr!
                }
                if self.signedAddr != nil {
                    map["SignedAddr"] = self.signedAddr!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.updatetime != nil {
                    map["Updatetime"] = self.updatetime!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bizid") {
                    self.bizid = dict["Bizid"] as! String
                }
                if dict.keys.contains("Createtime") {
                    self.createtime = dict["Createtime"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int32
                }
                if dict.keys.contains("RejectReason") {
                    self.rejectReason = dict["RejectReason"] as! String
                }
                if dict.keys.contains("ReqAddr") {
                    self.reqAddr = dict["ReqAddr"] as! String
                }
                if dict.keys.contains("SignedAddr") {
                    self.signedAddr = dict["SignedAddr"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("Updatetime") {
                    self.updatetime = dict["Updatetime"] as! Int64
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var current: Int32?

            public var pageSize: Int32?

            public var total: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.current != nil {
                    map["Current"] = self.current!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Current") {
                    self.current = dict["Current"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int32
                }
            }
        }
        public var applyHistoryList: [DescribeAntChainApplicationsResponseBody.Result.ApplyHistoryList]?

        public var pagination: DescribeAntChainApplicationsResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applyHistoryList != nil {
                var tmp : [Any] = []
                for k in self.applyHistoryList! {
                    tmp.append(k.toMap())
                }
                map["ApplyHistoryList"] = tmp
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplyHistoryList") {
                var tmp : [DescribeAntChainApplicationsResponseBody.Result.ApplyHistoryList] = []
                for v in dict["ApplyHistoryList"] as! [Any] {
                    var model = DescribeAntChainApplicationsResponseBody.Result.ApplyHistoryList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.applyHistoryList = tmp
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeAntChainApplicationsResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeAntChainApplicationsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainApplicationsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeAntChainApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainApplicationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainBlockRequest : Tea.TeaModel {
    public var antChainId: String?

    public var height: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("Height") {
            self.height = dict["Height"] as! Int64
        }
    }
}

public class DescribeAntChainBlockResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var antChainId: String?

        public var blockHash: String?

        public var createTime: Int64?

        public var height: Int32?

        public var previousHash: String?

        public var rootTxHash: String?

        public var transSummaryList: String?

        public var transactionSize: Int32?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.antChainId != nil {
                map["AntChainId"] = self.antChainId!
            }
            if self.blockHash != nil {
                map["BlockHash"] = self.blockHash!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.previousHash != nil {
                map["PreviousHash"] = self.previousHash!
            }
            if self.rootTxHash != nil {
                map["RootTxHash"] = self.rootTxHash!
            }
            if self.transSummaryList != nil {
                map["TransSummaryList"] = self.transSummaryList!
            }
            if self.transactionSize != nil {
                map["TransactionSize"] = self.transactionSize!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AntChainId") {
                self.antChainId = dict["AntChainId"] as! String
            }
            if dict.keys.contains("BlockHash") {
                self.blockHash = dict["BlockHash"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! Int32
            }
            if dict.keys.contains("PreviousHash") {
                self.previousHash = dict["PreviousHash"] as! String
            }
            if dict.keys.contains("RootTxHash") {
                self.rootTxHash = dict["RootTxHash"] as! String
            }
            if dict.keys.contains("TransSummaryList") {
                self.transSummaryList = dict["TransSummaryList"] as! String
            }
            if dict.keys.contains("TransactionSize") {
                self.transactionSize = dict["TransactionSize"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var result: DescribeAntChainBlockResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainBlockResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeAntChainBlockResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainBlockResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainBlockResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainBlockNewRequest : Tea.TeaModel {
    public var antChainId: String?

    public var consortiumId: String?

    public var height: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("Height") {
            self.height = dict["Height"] as! Int64
        }
    }
}

public class DescribeAntChainBlockNewResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class TransSummaryList : Tea.TeaModel {
            public var alias: String?

            public var blockHash: String?

            public var category: Int32?

            public var createTime: Int64?

            public var from: String?

            public var gasUsed: Int64?

            public var hash: String?

            public var height: Int64?

            public var referenceCount: Int32?

            public var to: String?

            public var transTypeV10: String?

            public var transTypeV6: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.blockHash != nil {
                    map["BlockHash"] = self.blockHash!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.from != nil {
                    map["From"] = self.from!
                }
                if self.gasUsed != nil {
                    map["GasUsed"] = self.gasUsed!
                }
                if self.hash != nil {
                    map["Hash"] = self.hash!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.referenceCount != nil {
                    map["ReferenceCount"] = self.referenceCount!
                }
                if self.to != nil {
                    map["To"] = self.to!
                }
                if self.transTypeV10 != nil {
                    map["TransTypeV10"] = self.transTypeV10!
                }
                if self.transTypeV6 != nil {
                    map["TransTypeV6"] = self.transTypeV6!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("BlockHash") {
                    self.blockHash = dict["BlockHash"] as! String
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! Int32
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("From") {
                    self.from = dict["From"] as! String
                }
                if dict.keys.contains("GasUsed") {
                    self.gasUsed = dict["GasUsed"] as! Int64
                }
                if dict.keys.contains("Hash") {
                    self.hash = dict["Hash"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int64
                }
                if dict.keys.contains("ReferenceCount") {
                    self.referenceCount = dict["ReferenceCount"] as! Int32
                }
                if dict.keys.contains("To") {
                    self.to = dict["To"] as! String
                }
                if dict.keys.contains("TransTypeV10") {
                    self.transTypeV10 = dict["TransTypeV10"] as! String
                }
                if dict.keys.contains("TransTypeV6") {
                    self.transTypeV6 = dict["TransTypeV6"] as! String
                }
            }
        }
        public var antChainId: String?

        public var blockHash: String?

        public var createTime: Int64?

        public var height: Int32?

        public var previousHash: String?

        public var rootTxHash: String?

        public var transSummaryList: [DescribeAntChainBlockNewResponseBody.Result.TransSummaryList]?

        public var transactionSize: Int32?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.antChainId != nil {
                map["AntChainId"] = self.antChainId!
            }
            if self.blockHash != nil {
                map["BlockHash"] = self.blockHash!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.previousHash != nil {
                map["PreviousHash"] = self.previousHash!
            }
            if self.rootTxHash != nil {
                map["RootTxHash"] = self.rootTxHash!
            }
            if self.transSummaryList != nil {
                var tmp : [Any] = []
                for k in self.transSummaryList! {
                    tmp.append(k.toMap())
                }
                map["TransSummaryList"] = tmp
            }
            if self.transactionSize != nil {
                map["TransactionSize"] = self.transactionSize!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AntChainId") {
                self.antChainId = dict["AntChainId"] as! String
            }
            if dict.keys.contains("BlockHash") {
                self.blockHash = dict["BlockHash"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! Int32
            }
            if dict.keys.contains("PreviousHash") {
                self.previousHash = dict["PreviousHash"] as! String
            }
            if dict.keys.contains("RootTxHash") {
                self.rootTxHash = dict["RootTxHash"] as! String
            }
            if dict.keys.contains("TransSummaryList") {
                var tmp : [DescribeAntChainBlockNewResponseBody.Result.TransSummaryList] = []
                for v in dict["TransSummaryList"] as! [Any] {
                    var model = DescribeAntChainBlockNewResponseBody.Result.TransSummaryList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.transSummaryList = tmp
            }
            if dict.keys.contains("TransactionSize") {
                self.transactionSize = dict["TransactionSize"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: DescribeAntChainBlockNewResponseBody.Result?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainBlockNewResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainBlockNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainBlockNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainBlockNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainCertificateApplicationsRequest : Tea.TeaModel {
    public var antChainId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeAntChainCertificateApplicationsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class CertificateApplications : Tea.TeaModel {
            public var antChainId: String?

            public var bid: String?

            public var createtime: Int64?

            public var status: String?

            public var updatetime: Int64?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.antChainId != nil {
                    map["AntChainId"] = self.antChainId!
                }
                if self.bid != nil {
                    map["Bid"] = self.bid!
                }
                if self.createtime != nil {
                    map["Createtime"] = self.createtime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.updatetime != nil {
                    map["Updatetime"] = self.updatetime!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AntChainId") {
                    self.antChainId = dict["AntChainId"] as! String
                }
                if dict.keys.contains("Bid") {
                    self.bid = dict["Bid"] as! String
                }
                if dict.keys.contains("Createtime") {
                    self.createtime = dict["Createtime"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Updatetime") {
                    self.updatetime = dict["Updatetime"] as! Int64
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var pageNumber: Int32?

            public var pageSize: Int32?

            public var totalCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PageNumber") {
                    self.pageNumber = dict["PageNumber"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("TotalCount") {
                    self.totalCount = dict["TotalCount"] as! Int32
                }
            }
        }
        public var certificateApplications: [DescribeAntChainCertificateApplicationsResponseBody.Result.CertificateApplications]?

        public var pagination: DescribeAntChainCertificateApplicationsResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certificateApplications != nil {
                var tmp : [Any] = []
                for k in self.certificateApplications! {
                    tmp.append(k.toMap())
                }
                map["CertificateApplications"] = tmp
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CertificateApplications") {
                var tmp : [DescribeAntChainCertificateApplicationsResponseBody.Result.CertificateApplications] = []
                for v in dict["CertificateApplications"] as! [Any] {
                    var model = DescribeAntChainCertificateApplicationsResponseBody.Result.CertificateApplications()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.certificateApplications = tmp
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeAntChainCertificateApplicationsResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeAntChainCertificateApplicationsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainCertificateApplicationsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeAntChainCertificateApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainCertificateApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainCertificateApplicationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainCertificateApplicationsNewRequest : Tea.TeaModel {
    public var antChainId: String?

    public var consortiumId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeAntChainCertificateApplicationsNewResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class CertificateApplications : Tea.TeaModel {
            public var antChainId: String?

            public var bid: String?

            public var createtime: Int64?

            public var status: String?

            public var updatetime: Int64?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.antChainId != nil {
                    map["AntChainId"] = self.antChainId!
                }
                if self.bid != nil {
                    map["Bid"] = self.bid!
                }
                if self.createtime != nil {
                    map["Createtime"] = self.createtime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.updatetime != nil {
                    map["Updatetime"] = self.updatetime!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AntChainId") {
                    self.antChainId = dict["AntChainId"] as! String
                }
                if dict.keys.contains("Bid") {
                    self.bid = dict["Bid"] as! String
                }
                if dict.keys.contains("Createtime") {
                    self.createtime = dict["Createtime"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Updatetime") {
                    self.updatetime = dict["Updatetime"] as! Int64
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var pageNumber: Int32?

            public var pageSize: Int32?

            public var totalCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PageNumber") {
                    self.pageNumber = dict["PageNumber"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("TotalCount") {
                    self.totalCount = dict["TotalCount"] as! Int32
                }
            }
        }
        public var certificateApplications: [DescribeAntChainCertificateApplicationsNewResponseBody.Result.CertificateApplications]?

        public var pagination: DescribeAntChainCertificateApplicationsNewResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certificateApplications != nil {
                var tmp : [Any] = []
                for k in self.certificateApplications! {
                    tmp.append(k.toMap())
                }
                map["CertificateApplications"] = tmp
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CertificateApplications") {
                var tmp : [DescribeAntChainCertificateApplicationsNewResponseBody.Result.CertificateApplications] = []
                for v in dict["CertificateApplications"] as! [Any] {
                    var model = DescribeAntChainCertificateApplicationsNewResponseBody.Result.CertificateApplications()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.certificateApplications = tmp
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeAntChainCertificateApplicationsNewResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: DescribeAntChainCertificateApplicationsNewResponseBody.Result?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainCertificateApplicationsNewResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainCertificateApplicationsNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainCertificateApplicationsNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainCertificateApplicationsNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainConfigOptionsRequest : Tea.TeaModel {
    public var purpose: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.purpose != nil {
            map["Purpose"] = self.purpose!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Purpose") {
            self.purpose = dict["Purpose"] as! String
        }
    }
}

public class DescribeAntChainConfigOptionsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String: Any]
        }
    }
}

public class DescribeAntChainConfigOptionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainConfigOptionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainConfigOptionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainConsortiumsRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeAntChainConsortiumsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class AntConsortiums : Tea.TeaModel {
            public var chainNum: Int64?

            public var consortiumDescription: String?

            public var consortiumId: String?

            public var consortiumName: String?

            public var createTime: Int64?

            public var isEmptyConsortium: Bool?

            public var memberNum: Int64?

            public var role: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.chainNum != nil {
                    map["ChainNum"] = self.chainNum!
                }
                if self.consortiumDescription != nil {
                    map["ConsortiumDescription"] = self.consortiumDescription!
                }
                if self.consortiumId != nil {
                    map["ConsortiumId"] = self.consortiumId!
                }
                if self.consortiumName != nil {
                    map["ConsortiumName"] = self.consortiumName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.isEmptyConsortium != nil {
                    map["IsEmptyConsortium"] = self.isEmptyConsortium!
                }
                if self.memberNum != nil {
                    map["MemberNum"] = self.memberNum!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChainNum") {
                    self.chainNum = dict["ChainNum"] as! Int64
                }
                if dict.keys.contains("ConsortiumDescription") {
                    self.consortiumDescription = dict["ConsortiumDescription"] as! String
                }
                if dict.keys.contains("ConsortiumId") {
                    self.consortiumId = dict["ConsortiumId"] as! String
                }
                if dict.keys.contains("ConsortiumName") {
                    self.consortiumName = dict["ConsortiumName"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("IsEmptyConsortium") {
                    self.isEmptyConsortium = dict["IsEmptyConsortium"] as! Bool
                }
                if dict.keys.contains("MemberNum") {
                    self.memberNum = dict["MemberNum"] as! Int64
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var pageNumber: Int32?

            public var pageSize: Int32?

            public var totalCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PageNumber") {
                    self.pageNumber = dict["PageNumber"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("TotalCount") {
                    self.totalCount = dict["TotalCount"] as! Int32
                }
            }
        }
        public var antConsortiums: [DescribeAntChainConsortiumsResponseBody.Result.AntConsortiums]?

        public var pagination: DescribeAntChainConsortiumsResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.antConsortiums != nil {
                var tmp : [Any] = []
                for k in self.antConsortiums! {
                    tmp.append(k.toMap())
                }
                map["AntConsortiums"] = tmp
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AntConsortiums") {
                var tmp : [DescribeAntChainConsortiumsResponseBody.Result.AntConsortiums] = []
                for v in dict["AntConsortiums"] as! [Any] {
                    var model = DescribeAntChainConsortiumsResponseBody.Result.AntConsortiums()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.antConsortiums = tmp
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeAntChainConsortiumsResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeAntChainConsortiumsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainConsortiumsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeAntChainConsortiumsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainConsortiumsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainConsortiumsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainConsortiumsNewRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeAntChainConsortiumsNewResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class AntConsortiums : Tea.TeaModel {
            public var chainNum: Int64?

            public var consortiumDescription: String?

            public var consortiumId: String?

            public var consortiumName: String?

            public var createTime: Int64?

            public var isEmptyConsortium: Bool?

            public var memberNum: Int64?

            public var role: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.chainNum != nil {
                    map["ChainNum"] = self.chainNum!
                }
                if self.consortiumDescription != nil {
                    map["ConsortiumDescription"] = self.consortiumDescription!
                }
                if self.consortiumId != nil {
                    map["ConsortiumId"] = self.consortiumId!
                }
                if self.consortiumName != nil {
                    map["ConsortiumName"] = self.consortiumName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.isEmptyConsortium != nil {
                    map["IsEmptyConsortium"] = self.isEmptyConsortium!
                }
                if self.memberNum != nil {
                    map["MemberNum"] = self.memberNum!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChainNum") {
                    self.chainNum = dict["ChainNum"] as! Int64
                }
                if dict.keys.contains("ConsortiumDescription") {
                    self.consortiumDescription = dict["ConsortiumDescription"] as! String
                }
                if dict.keys.contains("ConsortiumId") {
                    self.consortiumId = dict["ConsortiumId"] as! String
                }
                if dict.keys.contains("ConsortiumName") {
                    self.consortiumName = dict["ConsortiumName"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("IsEmptyConsortium") {
                    self.isEmptyConsortium = dict["IsEmptyConsortium"] as! Bool
                }
                if dict.keys.contains("MemberNum") {
                    self.memberNum = dict["MemberNum"] as! Int64
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var pageNumber: Int32?

            public var pageSize: Int32?

            public var totalCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PageNumber") {
                    self.pageNumber = dict["PageNumber"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("TotalCount") {
                    self.totalCount = dict["TotalCount"] as! Int32
                }
            }
        }
        public var antConsortiums: [DescribeAntChainConsortiumsNewResponseBody.Result.AntConsortiums]?

        public var pagination: DescribeAntChainConsortiumsNewResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.antConsortiums != nil {
                var tmp : [Any] = []
                for k in self.antConsortiums! {
                    tmp.append(k.toMap())
                }
                map["AntConsortiums"] = tmp
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AntConsortiums") {
                var tmp : [DescribeAntChainConsortiumsNewResponseBody.Result.AntConsortiums] = []
                for v in dict["AntConsortiums"] as! [Any] {
                    var model = DescribeAntChainConsortiumsNewResponseBody.Result.AntConsortiums()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.antConsortiums = tmp
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeAntChainConsortiumsNewResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: DescribeAntChainConsortiumsNewResponseBody.Result?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainConsortiumsNewResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainConsortiumsNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainConsortiumsNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainConsortiumsNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainContractProjectContentTreeRequest : Tea.TeaModel {
    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class DescribeAntChainContractProjectContentTreeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var children: [[String: Any]]?

        public var projectDescription: String?

        public var projectId: String?

        public var projectName: String?

        public var projectVersion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.children != nil {
                map["Children"] = self.children!
            }
            if self.projectDescription != nil {
                map["ProjectDescription"] = self.projectDescription!
            }
            if self.projectId != nil {
                map["ProjectId"] = self.projectId!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            if self.projectVersion != nil {
                map["ProjectVersion"] = self.projectVersion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Children") {
                self.children = dict["Children"] as! [[String: Any]]
            }
            if dict.keys.contains("ProjectDescription") {
                self.projectDescription = dict["ProjectDescription"] as! String
            }
            if dict.keys.contains("ProjectId") {
                self.projectId = dict["ProjectId"] as! String
            }
            if dict.keys.contains("ProjectName") {
                self.projectName = dict["ProjectName"] as! String
            }
            if dict.keys.contains("ProjectVersion") {
                self.projectVersion = dict["ProjectVersion"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeAntChainContractProjectContentTreeResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainContractProjectContentTreeResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeAntChainContractProjectContentTreeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainContractProjectContentTreeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainContractProjectContentTreeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainContractProjectContentTreeNewRequest : Tea.TeaModel {
    public var consortiumId: String?

    public var projectId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
    }
}

public class DescribeAntChainContractProjectContentTreeNewResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: String?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainContractProjectContentTreeNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainContractProjectContentTreeNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainContractProjectContentTreeNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainContractProjectsRequest : Tea.TeaModel {
    public var consortiumId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeAntChainContractProjectsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ContractProjects : Tea.TeaModel {
            public var consortiumId: String?

            public var createTime: Int64?

            public var projectDescription: String?

            public var projectId: String?

            public var projectName: String?

            public var projectVersion: String?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.consortiumId != nil {
                    map["ConsortiumId"] = self.consortiumId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.projectDescription != nil {
                    map["ProjectDescription"] = self.projectDescription!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                if self.projectVersion != nil {
                    map["ProjectVersion"] = self.projectVersion!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConsortiumId") {
                    self.consortiumId = dict["ConsortiumId"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("ProjectDescription") {
                    self.projectDescription = dict["ProjectDescription"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("ProjectName") {
                    self.projectName = dict["ProjectName"] as! String
                }
                if dict.keys.contains("ProjectVersion") {
                    self.projectVersion = dict["ProjectVersion"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var pageNumber: Int32?

            public var pageSize: Int32?

            public var totalCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PageNumber") {
                    self.pageNumber = dict["PageNumber"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("TotalCount") {
                    self.totalCount = dict["TotalCount"] as! Int32
                }
            }
        }
        public var contractProjects: [DescribeAntChainContractProjectsResponseBody.Result.ContractProjects]?

        public var pagination: DescribeAntChainContractProjectsResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contractProjects != nil {
                var tmp : [Any] = []
                for k in self.contractProjects! {
                    tmp.append(k.toMap())
                }
                map["ContractProjects"] = tmp
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContractProjects") {
                var tmp : [DescribeAntChainContractProjectsResponseBody.Result.ContractProjects] = []
                for v in dict["ContractProjects"] as! [Any] {
                    var model = DescribeAntChainContractProjectsResponseBody.Result.ContractProjects()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.contractProjects = tmp
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeAntChainContractProjectsResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeAntChainContractProjectsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainContractProjectsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeAntChainContractProjectsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainContractProjectsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainContractProjectsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainContractProjectsNewRequest : Tea.TeaModel {
    public var consortiumId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeAntChainContractProjectsNewResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ContractProjects : Tea.TeaModel {
            public var consortiumId: String?

            public var createTime: Int64?

            public var projectDescription: String?

            public var projectId: String?

            public var projectName: String?

            public var projectVersion: String?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.consortiumId != nil {
                    map["ConsortiumId"] = self.consortiumId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.projectDescription != nil {
                    map["ProjectDescription"] = self.projectDescription!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                if self.projectVersion != nil {
                    map["ProjectVersion"] = self.projectVersion!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConsortiumId") {
                    self.consortiumId = dict["ConsortiumId"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("ProjectDescription") {
                    self.projectDescription = dict["ProjectDescription"] as! String
                }
                if dict.keys.contains("ProjectId") {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("ProjectName") {
                    self.projectName = dict["ProjectName"] as! String
                }
                if dict.keys.contains("ProjectVersion") {
                    self.projectVersion = dict["ProjectVersion"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var pageNumber: Int32?

            public var pageSize: Int32?

            public var totalCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PageNumber") {
                    self.pageNumber = dict["PageNumber"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("TotalCount") {
                    self.totalCount = dict["TotalCount"] as! Int32
                }
            }
        }
        public var contractProjects: [DescribeAntChainContractProjectsNewResponseBody.Result.ContractProjects]?

        public var pagination: DescribeAntChainContractProjectsNewResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contractProjects != nil {
                var tmp : [Any] = []
                for k in self.contractProjects! {
                    tmp.append(k.toMap())
                }
                map["ContractProjects"] = tmp
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContractProjects") {
                var tmp : [DescribeAntChainContractProjectsNewResponseBody.Result.ContractProjects] = []
                for v in dict["ContractProjects"] as! [Any] {
                    var model = DescribeAntChainContractProjectsNewResponseBody.Result.ContractProjects()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.contractProjects = tmp
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeAntChainContractProjectsNewResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: DescribeAntChainContractProjectsNewResponseBody.Result?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainContractProjectsNewResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainContractProjectsNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainContractProjectsNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainContractProjectsNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainDownloadPathsRequest : Tea.TeaModel {
    public var antChainId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
    }
}

public class DescribeAntChainDownloadPathsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var caCrtUrl: String?

        public var clientCrtUrl: String?

        public var sdkUrl: String?

        public var trustCaUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.caCrtUrl != nil {
                map["CaCrtUrl"] = self.caCrtUrl!
            }
            if self.clientCrtUrl != nil {
                map["ClientCrtUrl"] = self.clientCrtUrl!
            }
            if self.sdkUrl != nil {
                map["SdkUrl"] = self.sdkUrl!
            }
            if self.trustCaUrl != nil {
                map["TrustCaUrl"] = self.trustCaUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CaCrtUrl") {
                self.caCrtUrl = dict["CaCrtUrl"] as! String
            }
            if dict.keys.contains("ClientCrtUrl") {
                self.clientCrtUrl = dict["ClientCrtUrl"] as! String
            }
            if dict.keys.contains("SdkUrl") {
                self.sdkUrl = dict["SdkUrl"] as! String
            }
            if dict.keys.contains("TrustCaUrl") {
                self.trustCaUrl = dict["TrustCaUrl"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeAntChainDownloadPathsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainDownloadPathsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeAntChainDownloadPathsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainDownloadPathsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainDownloadPathsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainDownloadPathsNewRequest : Tea.TeaModel {
    public var antChainId: String?

    public var consortiumId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
    }
}

public class DescribeAntChainDownloadPathsNewResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var caCrtUrl: String?

        public var clientCrtUrl: String?

        public var sdkUrl: String?

        public var trustCaUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.caCrtUrl != nil {
                map["CaCrtUrl"] = self.caCrtUrl!
            }
            if self.clientCrtUrl != nil {
                map["ClientCrtUrl"] = self.clientCrtUrl!
            }
            if self.sdkUrl != nil {
                map["SdkUrl"] = self.sdkUrl!
            }
            if self.trustCaUrl != nil {
                map["TrustCaUrl"] = self.trustCaUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CaCrtUrl") {
                self.caCrtUrl = dict["CaCrtUrl"] as! String
            }
            if dict.keys.contains("ClientCrtUrl") {
                self.clientCrtUrl = dict["ClientCrtUrl"] as! String
            }
            if dict.keys.contains("SdkUrl") {
                self.sdkUrl = dict["SdkUrl"] as! String
            }
            if dict.keys.contains("TrustCaUrl") {
                self.trustCaUrl = dict["TrustCaUrl"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: DescribeAntChainDownloadPathsNewResponseBody.Result?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainDownloadPathsNewResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainDownloadPathsNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainDownloadPathsNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainDownloadPathsNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainInformationRequest : Tea.TeaModel {
    public var antChainId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
    }
}

public class DescribeAntChainInformationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class NodeInfos : Tea.TeaModel {
            public var blockHeight: Int64?

            public var nodeName: String?

            public var status: Bool?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.blockHeight != nil {
                    map["BlockHeight"] = self.blockHeight!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BlockHeight") {
                    self.blockHeight = dict["BlockHeight"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Bool
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var abnormalNodes: Int32?

        public var antChainId: String?

        public var blockHeight: Int32?

        public var createTime: Int64?

        public var isRole: Bool?

        public var nodeInfos: [DescribeAntChainInformationResponseBody.Result.NodeInfos]?

        public var nodeNumber: Int32?

        public var normal: Bool?

        public var transactionSum: Int32?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.abnormalNodes != nil {
                map["AbnormalNodes"] = self.abnormalNodes!
            }
            if self.antChainId != nil {
                map["AntChainId"] = self.antChainId!
            }
            if self.blockHeight != nil {
                map["BlockHeight"] = self.blockHeight!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.isRole != nil {
                map["IsRole"] = self.isRole!
            }
            if self.nodeInfos != nil {
                var tmp : [Any] = []
                for k in self.nodeInfos! {
                    tmp.append(k.toMap())
                }
                map["NodeInfos"] = tmp
            }
            if self.nodeNumber != nil {
                map["NodeNumber"] = self.nodeNumber!
            }
            if self.normal != nil {
                map["Normal"] = self.normal!
            }
            if self.transactionSum != nil {
                map["TransactionSum"] = self.transactionSum!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AbnormalNodes") {
                self.abnormalNodes = dict["AbnormalNodes"] as! Int32
            }
            if dict.keys.contains("AntChainId") {
                self.antChainId = dict["AntChainId"] as! String
            }
            if dict.keys.contains("BlockHeight") {
                self.blockHeight = dict["BlockHeight"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("IsRole") {
                self.isRole = dict["IsRole"] as! Bool
            }
            if dict.keys.contains("NodeInfos") {
                var tmp : [DescribeAntChainInformationResponseBody.Result.NodeInfos] = []
                for v in dict["NodeInfos"] as! [Any] {
                    var model = DescribeAntChainInformationResponseBody.Result.NodeInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodeInfos = tmp
            }
            if dict.keys.contains("NodeNumber") {
                self.nodeNumber = dict["NodeNumber"] as! Int32
            }
            if dict.keys.contains("Normal") {
                self.normal = dict["Normal"] as! Bool
            }
            if dict.keys.contains("TransactionSum") {
                self.transactionSum = dict["TransactionSum"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeAntChainInformationResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainInformationResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeAntChainInformationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainInformationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainInformationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainInformationNewRequest : Tea.TeaModel {
    public var antChainId: String?

    public var consortiumId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
    }
}

public class DescribeAntChainInformationNewResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class NodeInfos : Tea.TeaModel {
            public var blockHeight: Int64?

            public var nodeName: String?

            public var status: Bool?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.blockHeight != nil {
                    map["BlockHeight"] = self.blockHeight!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BlockHeight") {
                    self.blockHeight = dict["BlockHeight"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Bool
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var abnormalNodes: Int32?

        public var antChainId: String?

        public var blockHeight: Int32?

        public var createTime: Int64?

        public var isRole: Bool?

        public var nodeInfos: [DescribeAntChainInformationNewResponseBody.Result.NodeInfos]?

        public var nodeNumber: Int32?

        public var normal: Bool?

        public var transactionSum: Int32?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.abnormalNodes != nil {
                map["AbnormalNodes"] = self.abnormalNodes!
            }
            if self.antChainId != nil {
                map["AntChainId"] = self.antChainId!
            }
            if self.blockHeight != nil {
                map["BlockHeight"] = self.blockHeight!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.isRole != nil {
                map["IsRole"] = self.isRole!
            }
            if self.nodeInfos != nil {
                var tmp : [Any] = []
                for k in self.nodeInfos! {
                    tmp.append(k.toMap())
                }
                map["NodeInfos"] = tmp
            }
            if self.nodeNumber != nil {
                map["NodeNumber"] = self.nodeNumber!
            }
            if self.normal != nil {
                map["Normal"] = self.normal!
            }
            if self.transactionSum != nil {
                map["TransactionSum"] = self.transactionSum!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AbnormalNodes") {
                self.abnormalNodes = dict["AbnormalNodes"] as! Int32
            }
            if dict.keys.contains("AntChainId") {
                self.antChainId = dict["AntChainId"] as! String
            }
            if dict.keys.contains("BlockHeight") {
                self.blockHeight = dict["BlockHeight"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("IsRole") {
                self.isRole = dict["IsRole"] as! Bool
            }
            if dict.keys.contains("NodeInfos") {
                var tmp : [DescribeAntChainInformationNewResponseBody.Result.NodeInfos] = []
                for v in dict["NodeInfos"] as! [Any] {
                    var model = DescribeAntChainInformationNewResponseBody.Result.NodeInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodeInfos = tmp
            }
            if dict.keys.contains("NodeNumber") {
                self.nodeNumber = dict["NodeNumber"] as! Int32
            }
            if dict.keys.contains("Normal") {
                self.normal = dict["Normal"] as! Bool
            }
            if dict.keys.contains("TransactionSum") {
                self.transactionSum = dict["TransactionSum"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: DescribeAntChainInformationNewResponseBody.Result?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainInformationNewResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainInformationNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainInformationNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainInformationNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainLatestBlocksRequest : Tea.TeaModel {
    public var antChainId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
    }
}

public class DescribeAntChainLatestBlocksResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [[String: Any]]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [[String: Any]]
        }
    }
}

public class DescribeAntChainLatestBlocksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainLatestBlocksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainLatestBlocksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainLatestBlocksNewRequest : Tea.TeaModel {
    public var antChainId: String?

    public var consortiumId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
    }
}

public class DescribeAntChainLatestBlocksNewResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var alias: String?

        public var bizData: String?

        public var blockHash: String?

        public var createTime: Int64?

        public var height: Int64?

        public var previousHash: String?

        public var rootTxHash: String?

        public var size: Int64?

        public var transactionSize: Int64?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alias != nil {
                map["Alias"] = self.alias!
            }
            if self.bizData != nil {
                map["BizData"] = self.bizData!
            }
            if self.blockHash != nil {
                map["BlockHash"] = self.blockHash!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.previousHash != nil {
                map["PreviousHash"] = self.previousHash!
            }
            if self.rootTxHash != nil {
                map["RootTxHash"] = self.rootTxHash!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.transactionSize != nil {
                map["TransactionSize"] = self.transactionSize!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alias") {
                self.alias = dict["Alias"] as! String
            }
            if dict.keys.contains("BizData") {
                self.bizData = dict["BizData"] as! String
            }
            if dict.keys.contains("BlockHash") {
                self.blockHash = dict["BlockHash"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! Int64
            }
            if dict.keys.contains("PreviousHash") {
                self.previousHash = dict["PreviousHash"] as! String
            }
            if dict.keys.contains("RootTxHash") {
                self.rootTxHash = dict["RootTxHash"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
            if dict.keys.contains("TransactionSize") {
                self.transactionSize = dict["TransactionSize"] as! Int64
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: [DescribeAntChainLatestBlocksNewResponseBody.Result]?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeAntChainLatestBlocksNewResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeAntChainLatestBlocksNewResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainLatestBlocksNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainLatestBlocksNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainLatestBlocksNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainLatestTransactionDigestsRequest : Tea.TeaModel {
    public var antChainId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
    }
}

public class DescribeAntChainLatestTransactionDigestsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [[String: Any]]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [[String: Any]]
        }
    }
}

public class DescribeAntChainLatestTransactionDigestsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainLatestTransactionDigestsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainLatestTransactionDigestsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainLatestTransactionDigestsNewRequest : Tea.TeaModel {
    public var antChainId: String?

    public var consortiumId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
    }
}

public class DescribeAntChainLatestTransactionDigestsNewResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: [String]?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String]
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainLatestTransactionDigestsNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainLatestTransactionDigestsNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainLatestTransactionDigestsNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainMembersRequest : Tea.TeaModel {
    public var consortiumId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeAntChainMembersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Members : Tea.TeaModel {
            public var joinTime: Int64?

            public var memberId: String?

            public var memberName: String?

            public var role: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.joinTime != nil {
                    map["JoinTime"] = self.joinTime!
                }
                if self.memberId != nil {
                    map["MemberId"] = self.memberId!
                }
                if self.memberName != nil {
                    map["MemberName"] = self.memberName!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("JoinTime") {
                    self.joinTime = dict["JoinTime"] as! Int64
                }
                if dict.keys.contains("MemberId") {
                    self.memberId = dict["MemberId"] as! String
                }
                if dict.keys.contains("MemberName") {
                    self.memberName = dict["MemberName"] as! String
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var pageNumber: Int32?

            public var pageSize: Int32?

            public var totalCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PageNumber") {
                    self.pageNumber = dict["PageNumber"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("TotalCount") {
                    self.totalCount = dict["TotalCount"] as! Int32
                }
            }
        }
        public var members: [DescribeAntChainMembersResponseBody.Result.Members]?

        public var pagination: DescribeAntChainMembersResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.members != nil {
                var tmp : [Any] = []
                for k in self.members! {
                    tmp.append(k.toMap())
                }
                map["Members"] = tmp
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Members") {
                var tmp : [DescribeAntChainMembersResponseBody.Result.Members] = []
                for v in dict["Members"] as! [Any] {
                    var model = DescribeAntChainMembersResponseBody.Result.Members()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.members = tmp
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeAntChainMembersResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeAntChainMembersResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainMembersResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeAntChainMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainMembersNewRequest : Tea.TeaModel {
    public var consortiumId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeAntChainMembersNewResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Members : Tea.TeaModel {
            public var joinTime: Int64?

            public var memberId: String?

            public var memberName: String?

            public var role: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.joinTime != nil {
                    map["JoinTime"] = self.joinTime!
                }
                if self.memberId != nil {
                    map["MemberId"] = self.memberId!
                }
                if self.memberName != nil {
                    map["MemberName"] = self.memberName!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("JoinTime") {
                    self.joinTime = dict["JoinTime"] as! Int64
                }
                if dict.keys.contains("MemberId") {
                    self.memberId = dict["MemberId"] as! String
                }
                if dict.keys.contains("MemberName") {
                    self.memberName = dict["MemberName"] as! String
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var pageNumber: Int32?

            public var pageSize: Int32?

            public var totalCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PageNumber") {
                    self.pageNumber = dict["PageNumber"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("TotalCount") {
                    self.totalCount = dict["TotalCount"] as! Int32
                }
            }
        }
        public var members: [DescribeAntChainMembersNewResponseBody.Result.Members]?

        public var pagination: DescribeAntChainMembersNewResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.members != nil {
                var tmp : [Any] = []
                for k in self.members! {
                    tmp.append(k.toMap())
                }
                map["Members"] = tmp
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Members") {
                var tmp : [DescribeAntChainMembersNewResponseBody.Result.Members] = []
                for v in dict["Members"] as! [Any] {
                    var model = DescribeAntChainMembersNewResponseBody.Result.Members()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.members = tmp
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeAntChainMembersNewResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: DescribeAntChainMembersNewResponseBody.Result?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainMembersNewResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainMembersNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainMembersNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainMembersNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest : Tea.TeaModel {
    public var antChainId: String?

    public var QRCodeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.QRCodeType != nil {
            map["QRCodeType"] = self.QRCodeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("QRCodeType") {
            self.QRCodeType = dict["QRCodeType"] as! String
        }
    }
}

public class DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessAlipayAccountCount: Int64?

        public var accessCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessAlipayAccountCount != nil {
                map["AccessAlipayAccountCount"] = self.accessAlipayAccountCount!
            }
            if self.accessCount != nil {
                map["AccessCount"] = self.accessCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessAlipayAccountCount") {
                self.accessAlipayAccountCount = dict["AccessAlipayAccountCount"] as! Int64
            }
            if dict.keys.contains("AccessCount") {
                self.accessCount = dict["AccessCount"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var result: DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainMiniAppBrowserQRCodeAccessLogNewRequest : Tea.TeaModel {
    public var antChainId: String?

    public var QRCodeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.QRCodeType != nil {
            map["QRCodeType"] = self.QRCodeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("QRCodeType") {
            self.QRCodeType = dict["QRCodeType"] as! String
        }
    }
}

public class DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessAlipayAccountCount: Int64?

        public var accessCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessAlipayAccountCount != nil {
                map["AccessAlipayAccountCount"] = self.accessAlipayAccountCount!
            }
            if self.accessCount != nil {
                map["AccessCount"] = self.accessCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessAlipayAccountCount") {
                self.accessAlipayAccountCount = dict["AccessAlipayAccountCount"] as! Int64
            }
            if dict.keys.contains("AccessCount") {
                self.accessCount = dict["AccessCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBody.Result?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest : Tea.TeaModel {
    public var antChainId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var QRCodeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.QRCodeType != nil {
            map["QRCodeType"] = self.QRCodeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("QRCodeType") {
            self.QRCodeType = dict["QRCodeType"] as! String
        }
    }
}

public class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class AuthorizedUserList : Tea.TeaModel {
            public var gmtAuthorized: String?

            public var phone: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gmtAuthorized != nil {
                    map["GmtAuthorized"] = self.gmtAuthorized!
                }
                if self.phone != nil {
                    map["Phone"] = self.phone!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GmtAuthorized") {
                    self.gmtAuthorized = dict["GmtAuthorized"] as! String
                }
                if dict.keys.contains("Phone") {
                    self.phone = dict["Phone"] as! String
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var pageNumber: Int32?

            public var pageSize: Int32?

            public var totalCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PageNumber") {
                    self.pageNumber = dict["PageNumber"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("TotalCount") {
                    self.totalCount = dict["TotalCount"] as! Int32
                }
            }
        }
        public var antChainId: String?

        public var authorizationType: String?

        public var authorizedUserList: [DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody.Result.AuthorizedUserList]?

        public var pagination: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody.Result.Pagination?

        public var QRCodeType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.antChainId != nil {
                map["AntChainId"] = self.antChainId!
            }
            if self.authorizationType != nil {
                map["AuthorizationType"] = self.authorizationType!
            }
            if self.authorizedUserList != nil {
                var tmp : [Any] = []
                for k in self.authorizedUserList! {
                    tmp.append(k.toMap())
                }
                map["AuthorizedUserList"] = tmp
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            if self.QRCodeType != nil {
                map["QRCodeType"] = self.QRCodeType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AntChainId") {
                self.antChainId = dict["AntChainId"] as! String
            }
            if dict.keys.contains("AuthorizationType") {
                self.authorizationType = dict["AuthorizationType"] as! String
            }
            if dict.keys.contains("AuthorizedUserList") {
                var tmp : [DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody.Result.AuthorizedUserList] = []
                for v in dict["AuthorizedUserList"] as! [Any] {
                    var model = DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody.Result.AuthorizedUserList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.authorizedUserList = tmp
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
            if dict.keys.contains("QRCodeType") {
                self.QRCodeType = dict["QRCodeType"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewRequest : Tea.TeaModel {
    public var antChainId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var QRCodeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.QRCodeType != nil {
            map["QRCodeType"] = self.QRCodeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("QRCodeType") {
            self.QRCodeType = dict["QRCodeType"] as! String
        }
    }
}

public class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class AuthorizedUserList : Tea.TeaModel {
            public var gmtAuthorized: String?

            public var phone: String?

            public var userId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gmtAuthorized != nil {
                    map["GmtAuthorized"] = self.gmtAuthorized!
                }
                if self.phone != nil {
                    map["Phone"] = self.phone!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GmtAuthorized") {
                    self.gmtAuthorized = dict["GmtAuthorized"] as! String
                }
                if dict.keys.contains("Phone") {
                    self.phone = dict["Phone"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! Int64
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var pageNumber: Int32?

            public var pageSize: Int32?

            public var totalCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PageNumber") {
                    self.pageNumber = dict["PageNumber"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("TotalCount") {
                    self.totalCount = dict["TotalCount"] as! Int32
                }
            }
        }
        public var antChainId: String?

        public var authorizationType: String?

        public var authorizedUserList: [DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody.Result.AuthorizedUserList]?

        public var pagination: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody.Result.Pagination?

        public var QRCodeType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.antChainId != nil {
                map["AntChainId"] = self.antChainId!
            }
            if self.authorizationType != nil {
                map["AuthorizationType"] = self.authorizationType!
            }
            if self.authorizedUserList != nil {
                var tmp : [Any] = []
                for k in self.authorizedUserList! {
                    tmp.append(k.toMap())
                }
                map["AuthorizedUserList"] = tmp
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            if self.QRCodeType != nil {
                map["QRCodeType"] = self.QRCodeType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AntChainId") {
                self.antChainId = dict["AntChainId"] as! String
            }
            if dict.keys.contains("AuthorizationType") {
                self.authorizationType = dict["AuthorizationType"] as! String
            }
            if dict.keys.contains("AuthorizedUserList") {
                var tmp : [DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody.Result.AuthorizedUserList] = []
                for v in dict["AuthorizedUserList"] as! [Any] {
                    var model = DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody.Result.AuthorizedUserList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.authorizedUserList = tmp
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
            if dict.keys.contains("QRCodeType") {
                self.QRCodeType = dict["QRCodeType"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody.Result?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainMiniAppBrowserTransactionQRCodeRequest : Tea.TeaModel {
    public var antChainId: String?

    public var transactionHash: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.transactionHash != nil {
            map["TransactionHash"] = self.transactionHash!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("TransactionHash") {
            self.transactionHash = dict["TransactionHash"] as! String
        }
    }
}

public class DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var antChainId: String?

        public var base64QRCodePNG: String?

        public var QRCodeContent: String?

        public var transactionHash: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.antChainId != nil {
                map["AntChainId"] = self.antChainId!
            }
            if self.base64QRCodePNG != nil {
                map["Base64QRCodePNG"] = self.base64QRCodePNG!
            }
            if self.QRCodeContent != nil {
                map["QRCodeContent"] = self.QRCodeContent!
            }
            if self.transactionHash != nil {
                map["TransactionHash"] = self.transactionHash!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AntChainId") {
                self.antChainId = dict["AntChainId"] as! String
            }
            if dict.keys.contains("Base64QRCodePNG") {
                self.base64QRCodePNG = dict["Base64QRCodePNG"] as! String
            }
            if dict.keys.contains("QRCodeContent") {
                self.QRCodeContent = dict["QRCodeContent"] as! String
            }
            if dict.keys.contains("TransactionHash") {
                self.transactionHash = dict["TransactionHash"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeAntChainMiniAppBrowserTransactionQRCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest : Tea.TeaModel {
    public var antChainId: String?

    public var contractId: String?

    public var transactionHash: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.contractId != nil {
            map["ContractId"] = self.contractId!
        }
        if self.transactionHash != nil {
            map["TransactionHash"] = self.transactionHash!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("ContractId") {
            self.contractId = dict["ContractId"] as! String
        }
        if dict.keys.contains("TransactionHash") {
            self.transactionHash = dict["TransactionHash"] as! String
        }
    }
}

public class DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var antChainId: String?

        public var base64QRCodePNG: String?

        public var QRCodeContent: String?

        public var transactionHash: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.antChainId != nil {
                map["AntChainId"] = self.antChainId!
            }
            if self.base64QRCodePNG != nil {
                map["Base64QRCodePNG"] = self.base64QRCodePNG!
            }
            if self.QRCodeContent != nil {
                map["QRCodeContent"] = self.QRCodeContent!
            }
            if self.transactionHash != nil {
                map["TransactionHash"] = self.transactionHash!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AntChainId") {
                self.antChainId = dict["AntChainId"] as! String
            }
            if dict.keys.contains("Base64QRCodePNG") {
                self.base64QRCodePNG = dict["Base64QRCodePNG"] as! String
            }
            if dict.keys.contains("QRCodeContent") {
                self.QRCodeContent = dict["QRCodeContent"] as! String
            }
            if dict.keys.contains("TransactionHash") {
                self.transactionHash = dict["TransactionHash"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody.Result?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainNodesNewRequest : Tea.TeaModel {
    public var antChainId: String?

    public var consortiumId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
    }
}

public class DescribeAntChainNodesNewResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: [String]?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String]
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainNodesNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainNodesNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainNodesNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainQRCodeAuthorizationRequest : Tea.TeaModel {
    public var antChainId: String?

    public var QRCodeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.QRCodeType != nil {
            map["QRCodeType"] = self.QRCodeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("QRCodeType") {
            self.QRCodeType = dict["QRCodeType"] as! String
        }
    }
}

public class DescribeAntChainQRCodeAuthorizationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var antChainId: String?

        public var authorizationType: String?

        public var QRCodeType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.antChainId != nil {
                map["AntChainId"] = self.antChainId!
            }
            if self.authorizationType != nil {
                map["AuthorizationType"] = self.authorizationType!
            }
            if self.QRCodeType != nil {
                map["QRCodeType"] = self.QRCodeType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AntChainId") {
                self.antChainId = dict["AntChainId"] as! String
            }
            if dict.keys.contains("AuthorizationType") {
                self.authorizationType = dict["AuthorizationType"] as! String
            }
            if dict.keys.contains("QRCodeType") {
                self.QRCodeType = dict["QRCodeType"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeAntChainQRCodeAuthorizationResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainQRCodeAuthorizationResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeAntChainQRCodeAuthorizationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainQRCodeAuthorizationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainQRCodeAuthorizationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainQRCodeAuthorizationNewRequest : Tea.TeaModel {
    public var antChainId: String?

    public var QRCodeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.QRCodeType != nil {
            map["QRCodeType"] = self.QRCodeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("QRCodeType") {
            self.QRCodeType = dict["QRCodeType"] as! String
        }
    }
}

public class DescribeAntChainQRCodeAuthorizationNewResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var antChainId: String?

        public var authorizationType: String?

        public var QRCodeType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.antChainId != nil {
                map["AntChainId"] = self.antChainId!
            }
            if self.authorizationType != nil {
                map["AuthorizationType"] = self.authorizationType!
            }
            if self.QRCodeType != nil {
                map["QRCodeType"] = self.QRCodeType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AntChainId") {
                self.antChainId = dict["AntChainId"] as! String
            }
            if dict.keys.contains("AuthorizationType") {
                self.authorizationType = dict["AuthorizationType"] as! String
            }
            if dict.keys.contains("QRCodeType") {
                self.QRCodeType = dict["QRCodeType"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: DescribeAntChainQRCodeAuthorizationNewResponseBody.Result?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainQRCodeAuthorizationNewResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainQRCodeAuthorizationNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainQRCodeAuthorizationNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainQRCodeAuthorizationNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainRegionNamesRequest : Tea.TeaModel {
    public var locale: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.locale != nil {
            map["Locale"] = self.locale!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Locale") {
            self.locale = dict["Locale"] as! String
        }
    }
}

public class DescribeAntChainRegionNamesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var regionId: String?

        public var regionName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.regionName != nil {
                map["RegionName"] = self.regionName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RegionName") {
                self.regionName = dict["RegionName"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [DescribeAntChainRegionNamesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeAntChainRegionNamesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeAntChainRegionNamesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class DescribeAntChainRegionNamesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainRegionNamesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainRegionNamesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainRegionsForSaleResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var regionId: String?

        public var typeList: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.typeList != nil {
                map["TypeList"] = self.typeList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("TypeList") {
                self.typeList = dict["TypeList"] as! [String]
            }
        }
    }
    public var requestId: String?

    public var result: [DescribeAntChainRegionsForSaleResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeAntChainRegionsForSaleResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeAntChainRegionsForSaleResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class DescribeAntChainRegionsForSaleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainRegionsForSaleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainRegionsForSaleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainResourceTypesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var cpu: Int32?

        public var disk: Int32?

        public var memory: Int32?

        public var typeId: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.disk != nil {
                map["Disk"] = self.disk!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.typeId != nil {
                map["TypeId"] = self.typeId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("Disk") {
                self.disk = dict["Disk"] as! Int32
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Int32
            }
            if dict.keys.contains("TypeId") {
                self.typeId = dict["TypeId"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var result: [DescribeAntChainResourceTypesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeAntChainResourceTypesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeAntChainResourceTypesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class DescribeAntChainResourceTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainResourceTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainResourceTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainRestRequest : Tea.TeaModel {
    public var antChainId: String?

    public var consortiumId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
    }
}

public class DescribeAntChainRestResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessId: String?

        public var createTime: Int64?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessId != nil {
                map["AccessId"] = self.accessId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessId") {
                self.accessId = dict["AccessId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: [DescribeAntChainRestResponseBody.Result]?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeAntChainRestResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeAntChainRestResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainRestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainRestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainRestResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainSubnetListRequest : Tea.TeaModel {
    public var antChainId: String?

    public var consortiumId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
    }
}

public class DescribeAntChainSubnetListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class BlockchainSubnetList : Tea.TeaModel {
            public var antChainId: String?

            public var blockHeight: Int64?

            public var consortiumMember: Bool?

            public var createTime: Int64?

            public var groupId: String?

            public var monitor: Bool?

            public var name: String?

            public var nodeSum: Int32?

            public var rest: String?

            public var status: String?

            public var transactionSum: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.antChainId != nil {
                    map["AntChainId"] = self.antChainId!
                }
                if self.blockHeight != nil {
                    map["BlockHeight"] = self.blockHeight!
                }
                if self.consortiumMember != nil {
                    map["ConsortiumMember"] = self.consortiumMember!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.monitor != nil {
                    map["Monitor"] = self.monitor!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nodeSum != nil {
                    map["NodeSum"] = self.nodeSum!
                }
                if self.rest != nil {
                    map["Rest"] = self.rest!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.transactionSum != nil {
                    map["TransactionSum"] = self.transactionSum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AntChainId") {
                    self.antChainId = dict["AntChainId"] as! String
                }
                if dict.keys.contains("BlockHeight") {
                    self.blockHeight = dict["BlockHeight"] as! Int64
                }
                if dict.keys.contains("ConsortiumMember") {
                    self.consortiumMember = dict["ConsortiumMember"] as! Bool
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("Monitor") {
                    self.monitor = dict["Monitor"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NodeSum") {
                    self.nodeSum = dict["NodeSum"] as! Int32
                }
                if dict.keys.contains("Rest") {
                    self.rest = dict["Rest"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TransactionSum") {
                    self.transactionSum = dict["TransactionSum"] as! Int64
                }
            }
        }
        public var antChainId: String?

        public var blockchainName: String?

        public var blockchainSubnetList: [DescribeAntChainSubnetListResponseBody.Result.BlockchainSubnetList]?

        public var consortiumAdmin: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.antChainId != nil {
                map["AntChainId"] = self.antChainId!
            }
            if self.blockchainName != nil {
                map["BlockchainName"] = self.blockchainName!
            }
            if self.blockchainSubnetList != nil {
                var tmp : [Any] = []
                for k in self.blockchainSubnetList! {
                    tmp.append(k.toMap())
                }
                map["BlockchainSubnetList"] = tmp
            }
            if self.consortiumAdmin != nil {
                map["ConsortiumAdmin"] = self.consortiumAdmin!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AntChainId") {
                self.antChainId = dict["AntChainId"] as! String
            }
            if dict.keys.contains("BlockchainName") {
                self.blockchainName = dict["BlockchainName"] as! String
            }
            if dict.keys.contains("BlockchainSubnetList") {
                var tmp : [DescribeAntChainSubnetListResponseBody.Result.BlockchainSubnetList] = []
                for v in dict["BlockchainSubnetList"] as! [Any] {
                    var model = DescribeAntChainSubnetListResponseBody.Result.BlockchainSubnetList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.blockchainSubnetList = tmp
            }
            if dict.keys.contains("ConsortiumAdmin") {
                self.consortiumAdmin = dict["ConsortiumAdmin"] as! Bool
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: DescribeAntChainSubnetListResponseBody.Result?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainSubnetListResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainSubnetListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainSubnetListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainSubnetListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainSubnetMemberListRequest : Tea.TeaModel {
    public var antChainId: String?

    public var consortiumId: String?

    public var pageNumber: String?

    public var pageSize: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
    }
}

public class DescribeAntChainSubnetMemberListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ConsortiumMemberInfoList : Tea.TeaModel {
            public var joinTime: Int64?

            public var memberId: String?

            public var memberName: String?

            public var role: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.joinTime != nil {
                    map["JoinTime"] = self.joinTime!
                }
                if self.memberId != nil {
                    map["MemberId"] = self.memberId!
                }
                if self.memberName != nil {
                    map["MemberName"] = self.memberName!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("JoinTime") {
                    self.joinTime = dict["JoinTime"] as! Int64
                }
                if dict.keys.contains("MemberId") {
                    self.memberId = dict["MemberId"] as! String
                }
                if dict.keys.contains("MemberName") {
                    self.memberName = dict["MemberName"] as! String
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var pageNumber: Int64?

            public var pageSize: Int64?

            public var totalCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PageNumber") {
                    self.pageNumber = dict["PageNumber"] as! Int64
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int64
                }
                if dict.keys.contains("TotalCount") {
                    self.totalCount = dict["TotalCount"] as! Int64
                }
            }
        }
        public var consortiumAdmin: Bool?

        public var consortiumMemberInfoList: [DescribeAntChainSubnetMemberListResponseBody.Result.ConsortiumMemberInfoList]?

        public var pagination: DescribeAntChainSubnetMemberListResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consortiumAdmin != nil {
                map["ConsortiumAdmin"] = self.consortiumAdmin!
            }
            if self.consortiumMemberInfoList != nil {
                var tmp : [Any] = []
                for k in self.consortiumMemberInfoList! {
                    tmp.append(k.toMap())
                }
                map["ConsortiumMemberInfoList"] = tmp
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsortiumAdmin") {
                self.consortiumAdmin = dict["ConsortiumAdmin"] as! Bool
            }
            if dict.keys.contains("ConsortiumMemberInfoList") {
                var tmp : [DescribeAntChainSubnetMemberListResponseBody.Result.ConsortiumMemberInfoList] = []
                for v in dict["ConsortiumMemberInfoList"] as! [Any] {
                    var model = DescribeAntChainSubnetMemberListResponseBody.Result.ConsortiumMemberInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.consortiumMemberInfoList = tmp
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeAntChainSubnetMemberListResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: DescribeAntChainSubnetMemberListResponseBody.Result?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainSubnetMemberListResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainSubnetMemberListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainSubnetMemberListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainSubnetMemberListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainSubnetNodeListRequest : Tea.TeaModel {
    public var antChainId: String?

    public var consortiumId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
    }
}

public class DescribeAntChainSubnetNodeListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ChainNodeInfoList : Tea.TeaModel {
            public var diskTotal: String?

            public var diskUse: String?

            public var nodeId: String?

            public var nodeIp: String?

            public var nodeName: String?

            public var nodePort: String?

            public var nodeSource: String?

            public var nodeState: String?

            public var nodeType: String?

            public var publicKey: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskTotal != nil {
                    map["DiskTotal"] = self.diskTotal!
                }
                if self.diskUse != nil {
                    map["DiskUse"] = self.diskUse!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeIp != nil {
                    map["NodeIp"] = self.nodeIp!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.nodePort != nil {
                    map["NodePort"] = self.nodePort!
                }
                if self.nodeSource != nil {
                    map["NodeSource"] = self.nodeSource!
                }
                if self.nodeState != nil {
                    map["NodeState"] = self.nodeState!
                }
                if self.nodeType != nil {
                    map["NodeType"] = self.nodeType!
                }
                if self.publicKey != nil {
                    map["PublicKey"] = self.publicKey!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DiskTotal") {
                    self.diskTotal = dict["DiskTotal"] as! String
                }
                if dict.keys.contains("DiskUse") {
                    self.diskUse = dict["DiskUse"] as! String
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! String
                }
                if dict.keys.contains("NodeIp") {
                    self.nodeIp = dict["NodeIp"] as! String
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("NodePort") {
                    self.nodePort = dict["NodePort"] as! String
                }
                if dict.keys.contains("NodeSource") {
                    self.nodeSource = dict["NodeSource"] as! String
                }
                if dict.keys.contains("NodeState") {
                    self.nodeState = dict["NodeState"] as! String
                }
                if dict.keys.contains("NodeType") {
                    self.nodeType = dict["NodeType"] as! String
                }
                if dict.keys.contains("PublicKey") {
                    self.publicKey = dict["PublicKey"] as! String
                }
            }
        }
        public var chainNodeInfoList: [DescribeAntChainSubnetNodeListResponseBody.Result.ChainNodeInfoList]?

        public var consortiumAdmin: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chainNodeInfoList != nil {
                var tmp : [Any] = []
                for k in self.chainNodeInfoList! {
                    tmp.append(k.toMap())
                }
                map["ChainNodeInfoList"] = tmp
            }
            if self.consortiumAdmin != nil {
                map["ConsortiumAdmin"] = self.consortiumAdmin!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChainNodeInfoList") {
                var tmp : [DescribeAntChainSubnetNodeListResponseBody.Result.ChainNodeInfoList] = []
                for v in dict["ChainNodeInfoList"] as! [Any] {
                    var model = DescribeAntChainSubnetNodeListResponseBody.Result.ChainNodeInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.chainNodeInfoList = tmp
            }
            if dict.keys.contains("ConsortiumAdmin") {
                self.consortiumAdmin = dict["ConsortiumAdmin"] as! Bool
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: [DescribeAntChainSubnetNodeListResponseBody.Result]?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeAntChainSubnetNodeListResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeAntChainSubnetNodeListResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainSubnetNodeListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainSubnetNodeListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainSubnetNodeListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainTransactionRequest : Tea.TeaModel {
    public var antChainId: String?

    public var hash: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.hash != nil {
            map["Hash"] = self.hash!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("Hash") {
            self.hash = dict["Hash"] as! String
        }
    }
}

public class DescribeAntChainTransactionResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Transaction : Tea.TeaModel {
            public var data: String?

            public var extentions: [String]?

            public var from: String?

            public var gas: String?

            public var hash: String?

            public var nonce: String?

            public var period: Int64?

            public var signatures: [String]?

            public var timestamp: Int64?

            public var to: String?

            public var txType: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.extentions != nil {
                    map["Extentions"] = self.extentions!
                }
                if self.from != nil {
                    map["From"] = self.from!
                }
                if self.gas != nil {
                    map["Gas"] = self.gas!
                }
                if self.hash != nil {
                    map["Hash"] = self.hash!
                }
                if self.nonce != nil {
                    map["Nonce"] = self.nonce!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.signatures != nil {
                    map["Signatures"] = self.signatures!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.to != nil {
                    map["To"] = self.to!
                }
                if self.txType != nil {
                    map["TxType"] = self.txType!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("Extentions") {
                    self.extentions = dict["Extentions"] as! [String]
                }
                if dict.keys.contains("From") {
                    self.from = dict["From"] as! String
                }
                if dict.keys.contains("Gas") {
                    self.gas = dict["Gas"] as! String
                }
                if dict.keys.contains("Hash") {
                    self.hash = dict["Hash"] as! String
                }
                if dict.keys.contains("Nonce") {
                    self.nonce = dict["Nonce"] as! String
                }
                if dict.keys.contains("Period") {
                    self.period = dict["Period"] as! Int64
                }
                if dict.keys.contains("Signatures") {
                    self.signatures = dict["Signatures"] as! [String]
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
                if dict.keys.contains("To") {
                    self.to = dict["To"] as! String
                }
                if dict.keys.contains("TxType") {
                    self.txType = dict["TxType"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var blockHash: String?

        public var blockHeight: Int64?

        public var blockVersion: String?

        public var createTime: Int64?

        public var hash: String?

        public var transaction: DescribeAntChainTransactionResponseBody.Result.Transaction?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.transaction?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.blockHash != nil {
                map["BlockHash"] = self.blockHash!
            }
            if self.blockHeight != nil {
                map["BlockHeight"] = self.blockHeight!
            }
            if self.blockVersion != nil {
                map["BlockVersion"] = self.blockVersion!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.hash != nil {
                map["Hash"] = self.hash!
            }
            if self.transaction != nil {
                map["Transaction"] = self.transaction?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BlockHash") {
                self.blockHash = dict["BlockHash"] as! String
            }
            if dict.keys.contains("BlockHeight") {
                self.blockHeight = dict["BlockHeight"] as! Int64
            }
            if dict.keys.contains("BlockVersion") {
                self.blockVersion = dict["BlockVersion"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Hash") {
                self.hash = dict["Hash"] as! String
            }
            if dict.keys.contains("Transaction") {
                var model = DescribeAntChainTransactionResponseBody.Result.Transaction()
                model.fromMap(dict["Transaction"] as! [String: Any])
                self.transaction = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeAntChainTransactionResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainTransactionResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeAntChainTransactionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainTransactionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainTransactionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainTransactionNewRequest : Tea.TeaModel {
    public var antChainId: String?

    public var consortiumId: String?

    public var hash: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.hash != nil {
            map["Hash"] = self.hash!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("Hash") {
            self.hash = dict["Hash"] as! String
        }
    }
}

public class DescribeAntChainTransactionNewResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Transaction : Tea.TeaModel {
            public var data: String?

            public var extentions: [String]?

            public var from: String?

            public var gas: String?

            public var hash: String?

            public var nonce: String?

            public var period: Int64?

            public var signatures: [String]?

            public var timestamp: Int64?

            public var to: String?

            public var txType: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.extentions != nil {
                    map["Extentions"] = self.extentions!
                }
                if self.from != nil {
                    map["From"] = self.from!
                }
                if self.gas != nil {
                    map["Gas"] = self.gas!
                }
                if self.hash != nil {
                    map["Hash"] = self.hash!
                }
                if self.nonce != nil {
                    map["Nonce"] = self.nonce!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.signatures != nil {
                    map["Signatures"] = self.signatures!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.to != nil {
                    map["To"] = self.to!
                }
                if self.txType != nil {
                    map["TxType"] = self.txType!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("Extentions") {
                    self.extentions = dict["Extentions"] as! [String]
                }
                if dict.keys.contains("From") {
                    self.from = dict["From"] as! String
                }
                if dict.keys.contains("Gas") {
                    self.gas = dict["Gas"] as! String
                }
                if dict.keys.contains("Hash") {
                    self.hash = dict["Hash"] as! String
                }
                if dict.keys.contains("Nonce") {
                    self.nonce = dict["Nonce"] as! String
                }
                if dict.keys.contains("Period") {
                    self.period = dict["Period"] as! Int64
                }
                if dict.keys.contains("Signatures") {
                    self.signatures = dict["Signatures"] as! [String]
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
                if dict.keys.contains("To") {
                    self.to = dict["To"] as! String
                }
                if dict.keys.contains("TxType") {
                    self.txType = dict["TxType"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var blockHash: String?

        public var blockHeight: Int64?

        public var blockVersion: String?

        public var createTime: Int64?

        public var hash: String?

        public var transaction: DescribeAntChainTransactionNewResponseBody.Result.Transaction?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.transaction?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.blockHash != nil {
                map["BlockHash"] = self.blockHash!
            }
            if self.blockHeight != nil {
                map["BlockHeight"] = self.blockHeight!
            }
            if self.blockVersion != nil {
                map["BlockVersion"] = self.blockVersion!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.hash != nil {
                map["Hash"] = self.hash!
            }
            if self.transaction != nil {
                map["Transaction"] = self.transaction?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BlockHash") {
                self.blockHash = dict["BlockHash"] as! String
            }
            if dict.keys.contains("BlockHeight") {
                self.blockHeight = dict["BlockHeight"] as! Int64
            }
            if dict.keys.contains("BlockVersion") {
                self.blockVersion = dict["BlockVersion"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Hash") {
                self.hash = dict["Hash"] as! String
            }
            if dict.keys.contains("Transaction") {
                var model = DescribeAntChainTransactionNewResponseBody.Result.Transaction()
                model.fromMap(dict["Transaction"] as! [String: Any])
                self.transaction = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: DescribeAntChainTransactionNewResponseBody.Result?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainTransactionNewResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainTransactionNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainTransactionNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainTransactionNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainTransactionReceiptNewRequest : Tea.TeaModel {
    public var antChainId: String?

    public var consortiumId: String?

    public var hash: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.hash != nil {
            map["Hash"] = self.hash!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("Hash") {
            self.hash = dict["Hash"] as! String
        }
    }
}

public class DescribeAntChainTransactionReceiptNewResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var data: String?

        public var gasUsed: String?

        public var logs: [String]?

        public var result: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.gasUsed != nil {
                map["GasUsed"] = self.gasUsed!
            }
            if self.logs != nil {
                map["Logs"] = self.logs!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("GasUsed") {
                self.gasUsed = dict["GasUsed"] as! String
            }
            if dict.keys.contains("Logs") {
                self.logs = dict["Logs"] as! [String]
            }
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! Int64
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: DescribeAntChainTransactionReceiptNewResponseBody.Result?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainTransactionReceiptNewResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainTransactionReceiptNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainTransactionReceiptNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainTransactionReceiptNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainTransactionStatisticsRequest : Tea.TeaModel {
    public var antChainId: String?

    public var end: Int64?

    public var start: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("End") {
            self.end = dict["End"] as! Int64
        }
        if dict.keys.contains("Start") {
            self.start = dict["Start"] as! Int64
        }
    }
}

public class DescribeAntChainTransactionStatisticsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var antChainId: String?

        public var creatTime: Int64?

        public var dt: Int64?

        public var lastSumBlockHeight: Int64?

        public var transCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.antChainId != nil {
                map["AntChainId"] = self.antChainId!
            }
            if self.creatTime != nil {
                map["CreatTime"] = self.creatTime!
            }
            if self.dt != nil {
                map["Dt"] = self.dt!
            }
            if self.lastSumBlockHeight != nil {
                map["LastSumBlockHeight"] = self.lastSumBlockHeight!
            }
            if self.transCount != nil {
                map["TransCount"] = self.transCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AntChainId") {
                self.antChainId = dict["AntChainId"] as! String
            }
            if dict.keys.contains("CreatTime") {
                self.creatTime = dict["CreatTime"] as! Int64
            }
            if dict.keys.contains("Dt") {
                self.dt = dict["Dt"] as! Int64
            }
            if dict.keys.contains("LastSumBlockHeight") {
                self.lastSumBlockHeight = dict["LastSumBlockHeight"] as! Int64
            }
            if dict.keys.contains("TransCount") {
                self.transCount = dict["TransCount"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var result: [DescribeAntChainTransactionStatisticsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeAntChainTransactionStatisticsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeAntChainTransactionStatisticsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class DescribeAntChainTransactionStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainTransactionStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainTransactionStatisticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainTransactionStatisticsNewRequest : Tea.TeaModel {
    public var antChainId: String?

    public var consortiumId: String?

    public var end: Int64?

    public var start: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("End") {
            self.end = dict["End"] as! Int64
        }
        if dict.keys.contains("Start") {
            self.start = dict["Start"] as! Int64
        }
    }
}

public class DescribeAntChainTransactionStatisticsNewResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var antChainId: String?

        public var creatTime: Int64?

        public var dt: Int64?

        public var lastSumBlockHeight: Int64?

        public var transCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.antChainId != nil {
                map["AntChainId"] = self.antChainId!
            }
            if self.creatTime != nil {
                map["CreatTime"] = self.creatTime!
            }
            if self.dt != nil {
                map["Dt"] = self.dt!
            }
            if self.lastSumBlockHeight != nil {
                map["LastSumBlockHeight"] = self.lastSumBlockHeight!
            }
            if self.transCount != nil {
                map["TransCount"] = self.transCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AntChainId") {
                self.antChainId = dict["AntChainId"] as! String
            }
            if dict.keys.contains("CreatTime") {
                self.creatTime = dict["CreatTime"] as! Int64
            }
            if dict.keys.contains("Dt") {
                self.dt = dict["Dt"] as! Int64
            }
            if dict.keys.contains("LastSumBlockHeight") {
                self.lastSumBlockHeight = dict["LastSumBlockHeight"] as! Int64
            }
            if dict.keys.contains("TransCount") {
                self.transCount = dict["TransCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: [DescribeAntChainTransactionStatisticsNewResponseBody.Result]?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeAntChainTransactionStatisticsNewResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeAntChainTransactionStatisticsNewResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainTransactionStatisticsNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainTransactionStatisticsNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainTransactionStatisticsNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainsRequest : Tea.TeaModel {
    public var consortiumId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeAntChainsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class AntChains : Tea.TeaModel {
            public var antChainId: String?

            public var antChainName: String?

            public var chainType: String?

            public var cipherSuit: String?

            public var createTime: Int64?

            public var expireTime: Int64?

            public var isAdmin: Bool?

            public var memberStatus: String?

            public var merkleTreeSuit: String?

            public var network: String?

            public var nodeNum: Int32?

            public var regionId: String?

            public var resourceSize: String?

            public var tlsAlgo: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.antChainId != nil {
                    map["AntChainId"] = self.antChainId!
                }
                if self.antChainName != nil {
                    map["AntChainName"] = self.antChainName!
                }
                if self.chainType != nil {
                    map["ChainType"] = self.chainType!
                }
                if self.cipherSuit != nil {
                    map["CipherSuit"] = self.cipherSuit!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.isAdmin != nil {
                    map["IsAdmin"] = self.isAdmin!
                }
                if self.memberStatus != nil {
                    map["MemberStatus"] = self.memberStatus!
                }
                if self.merkleTreeSuit != nil {
                    map["MerkleTreeSuit"] = self.merkleTreeSuit!
                }
                if self.network != nil {
                    map["Network"] = self.network!
                }
                if self.nodeNum != nil {
                    map["NodeNum"] = self.nodeNum!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceSize != nil {
                    map["ResourceSize"] = self.resourceSize!
                }
                if self.tlsAlgo != nil {
                    map["TlsAlgo"] = self.tlsAlgo!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AntChainId") {
                    self.antChainId = dict["AntChainId"] as! String
                }
                if dict.keys.contains("AntChainName") {
                    self.antChainName = dict["AntChainName"] as! String
                }
                if dict.keys.contains("ChainType") {
                    self.chainType = dict["ChainType"] as! String
                }
                if dict.keys.contains("CipherSuit") {
                    self.cipherSuit = dict["CipherSuit"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("ExpireTime") {
                    self.expireTime = dict["ExpireTime"] as! Int64
                }
                if dict.keys.contains("IsAdmin") {
                    self.isAdmin = dict["IsAdmin"] as! Bool
                }
                if dict.keys.contains("MemberStatus") {
                    self.memberStatus = dict["MemberStatus"] as! String
                }
                if dict.keys.contains("MerkleTreeSuit") {
                    self.merkleTreeSuit = dict["MerkleTreeSuit"] as! String
                }
                if dict.keys.contains("Network") {
                    self.network = dict["Network"] as! String
                }
                if dict.keys.contains("NodeNum") {
                    self.nodeNum = dict["NodeNum"] as! Int32
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceSize") {
                    self.resourceSize = dict["ResourceSize"] as! String
                }
                if dict.keys.contains("TlsAlgo") {
                    self.tlsAlgo = dict["TlsAlgo"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var pageNumber: Int32?

            public var pageSize: Int32?

            public var totalCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PageNumber") {
                    self.pageNumber = dict["PageNumber"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("TotalCount") {
                    self.totalCount = dict["TotalCount"] as! Int32
                }
            }
        }
        public var antChains: [DescribeAntChainsResponseBody.Result.AntChains]?

        public var isExist: Bool?

        public var pagination: DescribeAntChainsResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.antChains != nil {
                var tmp : [Any] = []
                for k in self.antChains! {
                    tmp.append(k.toMap())
                }
                map["AntChains"] = tmp
            }
            if self.isExist != nil {
                map["IsExist"] = self.isExist!
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AntChains") {
                var tmp : [DescribeAntChainsResponseBody.Result.AntChains] = []
                for v in dict["AntChains"] as! [Any] {
                    var model = DescribeAntChainsResponseBody.Result.AntChains()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.antChains = tmp
            }
            if dict.keys.contains("IsExist") {
                self.isExist = dict["IsExist"] as! Bool
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeAntChainsResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeAntChainsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeAntChainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntChainsNewRequest : Tea.TeaModel {
    public var consortiumId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeAntChainsNewResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class AntChains : Tea.TeaModel {
            public var antChainId: String?

            public var antChainName: String?

            public var chainType: String?

            public var cipherSuit: String?

            public var createTime: Int64?

            public var expireTime: Int64?

            public var instanceId: String?

            public var isAdmin: Bool?

            public var memberStatus: String?

            public var merkleTreeSuit: String?

            public var monitorStatus: Bool?

            public var network: String?

            public var nodeNum: Int32?

            public var regionId: String?

            public var resourceSize: String?

            public var restStatus: String?

            public var tlsAlgo: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.antChainId != nil {
                    map["AntChainId"] = self.antChainId!
                }
                if self.antChainName != nil {
                    map["AntChainName"] = self.antChainName!
                }
                if self.chainType != nil {
                    map["ChainType"] = self.chainType!
                }
                if self.cipherSuit != nil {
                    map["CipherSuit"] = self.cipherSuit!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.isAdmin != nil {
                    map["IsAdmin"] = self.isAdmin!
                }
                if self.memberStatus != nil {
                    map["MemberStatus"] = self.memberStatus!
                }
                if self.merkleTreeSuit != nil {
                    map["MerkleTreeSuit"] = self.merkleTreeSuit!
                }
                if self.monitorStatus != nil {
                    map["MonitorStatus"] = self.monitorStatus!
                }
                if self.network != nil {
                    map["Network"] = self.network!
                }
                if self.nodeNum != nil {
                    map["NodeNum"] = self.nodeNum!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceSize != nil {
                    map["ResourceSize"] = self.resourceSize!
                }
                if self.restStatus != nil {
                    map["RestStatus"] = self.restStatus!
                }
                if self.tlsAlgo != nil {
                    map["TlsAlgo"] = self.tlsAlgo!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AntChainId") {
                    self.antChainId = dict["AntChainId"] as! String
                }
                if dict.keys.contains("AntChainName") {
                    self.antChainName = dict["AntChainName"] as! String
                }
                if dict.keys.contains("ChainType") {
                    self.chainType = dict["ChainType"] as! String
                }
                if dict.keys.contains("CipherSuit") {
                    self.cipherSuit = dict["CipherSuit"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("ExpireTime") {
                    self.expireTime = dict["ExpireTime"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("IsAdmin") {
                    self.isAdmin = dict["IsAdmin"] as! Bool
                }
                if dict.keys.contains("MemberStatus") {
                    self.memberStatus = dict["MemberStatus"] as! String
                }
                if dict.keys.contains("MerkleTreeSuit") {
                    self.merkleTreeSuit = dict["MerkleTreeSuit"] as! String
                }
                if dict.keys.contains("MonitorStatus") {
                    self.monitorStatus = dict["MonitorStatus"] as! Bool
                }
                if dict.keys.contains("Network") {
                    self.network = dict["Network"] as! String
                }
                if dict.keys.contains("NodeNum") {
                    self.nodeNum = dict["NodeNum"] as! Int32
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceSize") {
                    self.resourceSize = dict["ResourceSize"] as! String
                }
                if dict.keys.contains("RestStatus") {
                    self.restStatus = dict["RestStatus"] as! String
                }
                if dict.keys.contains("TlsAlgo") {
                    self.tlsAlgo = dict["TlsAlgo"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var pageNumber: Int32?

            public var pageSize: Int32?

            public var totalCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pageNumber != nil {
                    map["PageNumber"] = self.pageNumber!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PageNumber") {
                    self.pageNumber = dict["PageNumber"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("TotalCount") {
                    self.totalCount = dict["TotalCount"] as! Int32
                }
            }
        }
        public var antChains: [DescribeAntChainsNewResponseBody.Result.AntChains]?

        public var isExist: Bool?

        public var pagination: DescribeAntChainsNewResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.antChains != nil {
                var tmp : [Any] = []
                for k in self.antChains! {
                    tmp.append(k.toMap())
                }
                map["AntChains"] = tmp
            }
            if self.isExist != nil {
                map["IsExist"] = self.isExist!
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AntChains") {
                var tmp : [DescribeAntChainsNewResponseBody.Result.AntChains] = []
                for v in dict["AntChains"] as! [Any] {
                    var model = DescribeAntChainsNewResponseBody.Result.AntChains()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.antChains = tmp
            }
            if dict.keys.contains("IsExist") {
                self.isExist = dict["IsExist"] as! Bool
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeAntChainsNewResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var result: DescribeAntChainsNewResponseBody.Result?

    public var resultCode: String?

    public var resultMessage: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.resultCode != nil {
            map["ResultCode"] = self.resultCode!
        }
        if self.resultMessage != nil {
            map["ResultMessage"] = self.resultMessage!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAntChainsNewResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("ResultCode") {
            self.resultCode = dict["ResultCode"] as! String
        }
        if dict.keys.contains("ResultMessage") {
            self.resultMessage = dict["ResultMessage"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeAntChainsNewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntChainsNewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntChainsNewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAntRegionsRequest : Tea.TeaModel {
    public var locale: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.locale != nil {
            map["Locale"] = self.locale!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Locale") {
            self.locale = dict["Locale"] as! String
        }
    }
}

public class DescribeAntRegionsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var localName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.localName != nil {
                map["LocalName"] = self.localName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LocalName") {
                self.localName = dict["LocalName"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [DescribeAntRegionsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeAntRegionsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeAntRegionsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class DescribeAntRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAntRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAntRegionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAppliesRequest : Tea.TeaModel {
    public var bizid: String?

    public var current: Int32?

    public var pageSize: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.current != nil {
            map["Current"] = self.current!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Current") {
            self.current = dict["Current"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeAppliesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ApplyHistoryList : Tea.TeaModel {
            public var bizid: String?

            public var createtime: Int64?

            public var id: Int32?

            public var rejectReason: String?

            public var reqAddr: String?

            public var signedAddr: String?

            public var status: Int32?

            public var updatetime: Int64?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizid != nil {
                    map["Bizid"] = self.bizid!
                }
                if self.createtime != nil {
                    map["Createtime"] = self.createtime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.rejectReason != nil {
                    map["RejectReason"] = self.rejectReason!
                }
                if self.reqAddr != nil {
                    map["ReqAddr"] = self.reqAddr!
                }
                if self.signedAddr != nil {
                    map["SignedAddr"] = self.signedAddr!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.updatetime != nil {
                    map["Updatetime"] = self.updatetime!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bizid") {
                    self.bizid = dict["Bizid"] as! String
                }
                if dict.keys.contains("Createtime") {
                    self.createtime = dict["Createtime"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int32
                }
                if dict.keys.contains("RejectReason") {
                    self.rejectReason = dict["RejectReason"] as! String
                }
                if dict.keys.contains("ReqAddr") {
                    self.reqAddr = dict["ReqAddr"] as! String
                }
                if dict.keys.contains("SignedAddr") {
                    self.signedAddr = dict["SignedAddr"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("Updatetime") {
                    self.updatetime = dict["Updatetime"] as! Int64
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var current: Int32?

            public var pageSize: Int32?

            public var total: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.current != nil {
                    map["Current"] = self.current!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Current") {
                    self.current = dict["Current"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int32
                }
            }
        }
        public var applyHistoryList: [DescribeAppliesResponseBody.Result.ApplyHistoryList]?

        public var pagination: DescribeAppliesResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applyHistoryList != nil {
                var tmp : [Any] = []
                for k in self.applyHistoryList! {
                    tmp.append(k.toMap())
                }
                map["ApplyHistoryList"] = tmp
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplyHistoryList") {
                var tmp : [DescribeAppliesResponseBody.Result.ApplyHistoryList] = []
                for v in dict["ApplyHistoryList"] as! [Any] {
                    var model = DescribeAppliesResponseBody.Result.ApplyHistoryList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.applyHistoryList = tmp
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeAppliesResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeAppliesResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAppliesResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeAppliesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAppliesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAppliesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBcSchemaRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DescribeBcSchemaResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Responses : Tea.TeaModel {
            public class Properties : Tea.TeaModel {
                public class DataSource : Tea.TeaModel {
                    public var allowNull: Int32?

                    public var annotation: String?

                    public var field: String?

                    public var indexes: Int32?

                    public var key: Int32?

                    public var length: Int32?

                    public var reg: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.allowNull != nil {
                            map["AllowNull"] = self.allowNull!
                        }
                        if self.annotation != nil {
                            map["Annotation"] = self.annotation!
                        }
                        if self.field != nil {
                            map["Field"] = self.field!
                        }
                        if self.indexes != nil {
                            map["Indexes"] = self.indexes!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.length != nil {
                            map["Length"] = self.length!
                        }
                        if self.reg != nil {
                            map["Reg"] = self.reg!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AllowNull") {
                            self.allowNull = dict["AllowNull"] as! Int32
                        }
                        if dict.keys.contains("Annotation") {
                            self.annotation = dict["Annotation"] as! String
                        }
                        if dict.keys.contains("Field") {
                            self.field = dict["Field"] as! String
                        }
                        if dict.keys.contains("Indexes") {
                            self.indexes = dict["Indexes"] as! Int32
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! Int32
                        }
                        if dict.keys.contains("Length") {
                            self.length = dict["Length"] as! Int32
                        }
                        if dict.keys.contains("Reg") {
                            self.reg = dict["Reg"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var count: Int32?

                public var dataSource: [DescribeBcSchemaResponseBody.Result.Responses.Properties.DataSource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.dataSource != nil {
                        var tmp : [Any] = []
                        for k in self.dataSource! {
                            tmp.append(k.toMap())
                        }
                        map["DataSource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int32
                    }
                    if dict.keys.contains("DataSource") {
                        var tmp : [DescribeBcSchemaResponseBody.Result.Responses.Properties.DataSource] = []
                        for v in dict["DataSource"] as! [Any] {
                            var model = DescribeBcSchemaResponseBody.Result.Responses.Properties.DataSource()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dataSource = tmp
                    }
                }
            }
            public var category: String?

            public var categoryName: String?

            public var description_: String?

            public var properties: DescribeBcSchemaResponseBody.Result.Responses.Properties?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.properties?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.categoryName != nil {
                    map["CategoryName"] = self.categoryName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.properties != nil {
                    map["Properties"] = self.properties?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CategoryName") {
                    self.categoryName = dict["CategoryName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Properties") {
                    var model = DescribeBcSchemaResponseBody.Result.Responses.Properties()
                    model.fromMap(dict["Properties"] as! [String: Any])
                    self.properties = model
                }
            }
        }
        public class Schema : Tea.TeaModel {
            public var createTime: Int64?

            public var description_: String?

            public var id: Int64?

            public var isTemplate: Bool?

            public var name: String?

            public var updateTime: Int64?

            public var version: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isTemplate != nil {
                    map["IsTemplate"] = self.isTemplate!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IsTemplate") {
                    self.isTemplate = dict["IsTemplate"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! Int64
                }
            }
        }
        public var responses: [DescribeBcSchemaResponseBody.Result.Responses]?

        public var schema: DescribeBcSchemaResponseBody.Result.Schema?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.schema?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.responses != nil {
                var tmp : [Any] = []
                for k in self.responses! {
                    tmp.append(k.toMap())
                }
                map["Responses"] = tmp
            }
            if self.schema != nil {
                map["Schema"] = self.schema?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Responses") {
                var tmp : [DescribeBcSchemaResponseBody.Result.Responses] = []
                for v in dict["Responses"] as! [Any] {
                    var model = DescribeBcSchemaResponseBody.Result.Responses()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.responses = tmp
            }
            if dict.keys.contains("Schema") {
                var model = DescribeBcSchemaResponseBody.Result.Schema()
                model.fromMap(dict["Schema"] as! [String: Any])
                self.schema = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeBcSchemaResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeBcSchemaResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeBcSchemaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBcSchemaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBcSchemaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBlockRequest : Tea.TeaModel {
    public var bizid: String?

    public var height: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Height") {
            self.height = dict["Height"] as! Int64
        }
    }
}

public class DescribeBlockResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var alias: String?

        public var blockHash: String?

        public var createTime: Int64?

        public var height: Int32?

        public var previousHash: String?

        public var rootTxHash: String?

        public var transSummaryList: String?

        public var transactionSize: Int32?

        public var version: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alias != nil {
                map["Alias"] = self.alias!
            }
            if self.blockHash != nil {
                map["BlockHash"] = self.blockHash!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.previousHash != nil {
                map["PreviousHash"] = self.previousHash!
            }
            if self.rootTxHash != nil {
                map["RootTxHash"] = self.rootTxHash!
            }
            if self.transSummaryList != nil {
                map["TransSummaryList"] = self.transSummaryList!
            }
            if self.transactionSize != nil {
                map["TransactionSize"] = self.transactionSize!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alias") {
                self.alias = dict["Alias"] as! String
            }
            if dict.keys.contains("BlockHash") {
                self.blockHash = dict["BlockHash"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! Int32
            }
            if dict.keys.contains("PreviousHash") {
                self.previousHash = dict["PreviousHash"] as! String
            }
            if dict.keys.contains("RootTxHash") {
                self.rootTxHash = dict["RootTxHash"] as! String
            }
            if dict.keys.contains("TransSummaryList") {
                self.transSummaryList = dict["TransSummaryList"] as! String
            }
            if dict.keys.contains("TransactionSize") {
                self.transactionSize = dict["TransactionSize"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var result: DescribeBlockResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeBlockResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeBlockResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBlockResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBlockResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBlockchainApplicationRequest : Tea.TeaModel {
    public var bizid: String?

    public var current: Int32?

    public var pageSize: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.current != nil {
            map["Current"] = self.current!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Current") {
            self.current = dict["Current"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeBlockchainApplicationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ApplyHistoryList : Tea.TeaModel {
            public var bizid: String?

            public var createtime: Int64?

            public var id: Int32?

            public var rejectReason: String?

            public var reqAddr: String?

            public var signedAddr: String?

            public var status: Int32?

            public var updatetime: Int64?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizid != nil {
                    map["Bizid"] = self.bizid!
                }
                if self.createtime != nil {
                    map["Createtime"] = self.createtime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.rejectReason != nil {
                    map["RejectReason"] = self.rejectReason!
                }
                if self.reqAddr != nil {
                    map["ReqAddr"] = self.reqAddr!
                }
                if self.signedAddr != nil {
                    map["SignedAddr"] = self.signedAddr!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.updatetime != nil {
                    map["Updatetime"] = self.updatetime!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bizid") {
                    self.bizid = dict["Bizid"] as! String
                }
                if dict.keys.contains("Createtime") {
                    self.createtime = dict["Createtime"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int32
                }
                if dict.keys.contains("RejectReason") {
                    self.rejectReason = dict["RejectReason"] as! String
                }
                if dict.keys.contains("ReqAddr") {
                    self.reqAddr = dict["ReqAddr"] as! String
                }
                if dict.keys.contains("SignedAddr") {
                    self.signedAddr = dict["SignedAddr"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("Updatetime") {
                    self.updatetime = dict["Updatetime"] as! Int64
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var current: Int32?

            public var pageSize: Int32?

            public var total: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.current != nil {
                    map["Current"] = self.current!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Current") {
                    self.current = dict["Current"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int32
                }
            }
        }
        public var applyHistoryList: [DescribeBlockchainApplicationResponseBody.Result.ApplyHistoryList]?

        public var pagination: DescribeBlockchainApplicationResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applyHistoryList != nil {
                var tmp : [Any] = []
                for k in self.applyHistoryList! {
                    tmp.append(k.toMap())
                }
                map["ApplyHistoryList"] = tmp
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplyHistoryList") {
                var tmp : [DescribeBlockchainApplicationResponseBody.Result.ApplyHistoryList] = []
                for v in dict["ApplyHistoryList"] as! [Any] {
                    var model = DescribeBlockchainApplicationResponseBody.Result.ApplyHistoryList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.applyHistoryList = tmp
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeBlockchainApplicationResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeBlockchainApplicationResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeBlockchainApplicationResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeBlockchainApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBlockchainApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBlockchainApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBlockchainConfigOptionRequest : Tea.TeaModel {
    public var purpose: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.purpose != nil {
            map["Purpose"] = self.purpose!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Purpose") {
            self.purpose = dict["Purpose"] as! String
        }
    }
}

public class DescribeBlockchainConfigOptionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String: Any]
        }
    }
}

public class DescribeBlockchainConfigOptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBlockchainConfigOptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBlockchainConfigOptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBlockchainCreateTaskRequest : Tea.TeaModel {
    public var current: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.current != nil {
            map["Current"] = self.current!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Current") {
            self.current = dict["Current"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeBlockchainCreateTaskResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class BlockchainCreateTasks : Tea.TeaModel {
            public var bizid: String?

            public var createTime: Int64?

            public var memo: String?

            public var name: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizid != nil {
                    map["Bizid"] = self.bizid!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.memo != nil {
                    map["Memo"] = self.memo!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bizid") {
                    self.bizid = dict["Bizid"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Memo") {
                    self.memo = dict["Memo"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var current: Int32?

            public var pageSize: Int32?

            public var total: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.current != nil {
                    map["Current"] = self.current!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Current") {
                    self.current = dict["Current"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int32
                }
            }
        }
        public var blockchainCreateTasks: [DescribeBlockchainCreateTaskResponseBody.Result.BlockchainCreateTasks]?

        public var pagination: DescribeBlockchainCreateTaskResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.blockchainCreateTasks != nil {
                var tmp : [Any] = []
                for k in self.blockchainCreateTasks! {
                    tmp.append(k.toMap())
                }
                map["BlockchainCreateTasks"] = tmp
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BlockchainCreateTasks") {
                var tmp : [DescribeBlockchainCreateTaskResponseBody.Result.BlockchainCreateTasks] = []
                for v in dict["BlockchainCreateTasks"] as! [Any] {
                    var model = DescribeBlockchainCreateTaskResponseBody.Result.BlockchainCreateTasks()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.blockchainCreateTasks = tmp
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeBlockchainCreateTaskResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeBlockchainCreateTaskResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeBlockchainCreateTaskResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeBlockchainCreateTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBlockchainCreateTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBlockchainCreateTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBlockchainCreationConfigOptionsRequest : Tea.TeaModel {
    public var purpose: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.purpose != nil {
            map["Purpose"] = self.purpose!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Purpose") {
            self.purpose = dict["Purpose"] as! String
        }
    }
}

public class DescribeBlockchainCreationConfigOptionsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String: Any]
        }
    }
}

public class DescribeBlockchainCreationConfigOptionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBlockchainCreationConfigOptionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBlockchainCreationConfigOptionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBlockchainInfoRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DescribeBlockchainInfoResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class NodeInfoList : Tea.TeaModel {
            public var blockHeight: Int64?

            public var nodeName: String?

            public var status: Bool?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.blockHeight != nil {
                    map["BlockHeight"] = self.blockHeight!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BlockHeight") {
                    self.blockHeight = dict["BlockHeight"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Bool
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var abnormalNodes: Int32?

        public var bizid: String?

        public var blockHeight: Int32?

        public var createTime: Int64?

        public var isRole: Bool?

        public var nodeInfoList: [DescribeBlockchainInfoResponseBody.Result.NodeInfoList]?

        public var nodeNumber: Int32?

        public var normal: Bool?

        public var transactionSum: Int32?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.abnormalNodes != nil {
                map["AbnormalNodes"] = self.abnormalNodes!
            }
            if self.bizid != nil {
                map["Bizid"] = self.bizid!
            }
            if self.blockHeight != nil {
                map["BlockHeight"] = self.blockHeight!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.isRole != nil {
                map["IsRole"] = self.isRole!
            }
            if self.nodeInfoList != nil {
                var tmp : [Any] = []
                for k in self.nodeInfoList! {
                    tmp.append(k.toMap())
                }
                map["NodeInfoList"] = tmp
            }
            if self.nodeNumber != nil {
                map["NodeNumber"] = self.nodeNumber!
            }
            if self.normal != nil {
                map["Normal"] = self.normal!
            }
            if self.transactionSum != nil {
                map["TransactionSum"] = self.transactionSum!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AbnormalNodes") {
                self.abnormalNodes = dict["AbnormalNodes"] as! Int32
            }
            if dict.keys.contains("Bizid") {
                self.bizid = dict["Bizid"] as! String
            }
            if dict.keys.contains("BlockHeight") {
                self.blockHeight = dict["BlockHeight"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("IsRole") {
                self.isRole = dict["IsRole"] as! Bool
            }
            if dict.keys.contains("NodeInfoList") {
                var tmp : [DescribeBlockchainInfoResponseBody.Result.NodeInfoList] = []
                for v in dict["NodeInfoList"] as! [Any] {
                    var model = DescribeBlockchainInfoResponseBody.Result.NodeInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodeInfoList = tmp
            }
            if dict.keys.contains("NodeNumber") {
                self.nodeNumber = dict["NodeNumber"] as! Int32
            }
            if dict.keys.contains("Normal") {
                self.normal = dict["Normal"] as! Bool
            }
            if dict.keys.contains("TransactionSum") {
                self.transactionSum = dict["TransactionSum"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeBlockchainInfoResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeBlockchainInfoResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeBlockchainInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBlockchainInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBlockchainInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBlockchainSchemaRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DescribeBlockchainSchemaResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Responses : Tea.TeaModel {
            public class Properties : Tea.TeaModel {
                public class DataSource : Tea.TeaModel {
                    public var allowNull: Int32?

                    public var annotation: String?

                    public var field: String?

                    public var indexes: Int32?

                    public var key: Int32?

                    public var length: Int32?

                    public var reg: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.allowNull != nil {
                            map["AllowNull"] = self.allowNull!
                        }
                        if self.annotation != nil {
                            map["Annotation"] = self.annotation!
                        }
                        if self.field != nil {
                            map["Field"] = self.field!
                        }
                        if self.indexes != nil {
                            map["Indexes"] = self.indexes!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.length != nil {
                            map["Length"] = self.length!
                        }
                        if self.reg != nil {
                            map["Reg"] = self.reg!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AllowNull") {
                            self.allowNull = dict["AllowNull"] as! Int32
                        }
                        if dict.keys.contains("Annotation") {
                            self.annotation = dict["Annotation"] as! String
                        }
                        if dict.keys.contains("Field") {
                            self.field = dict["Field"] as! String
                        }
                        if dict.keys.contains("Indexes") {
                            self.indexes = dict["Indexes"] as! Int32
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! Int32
                        }
                        if dict.keys.contains("Length") {
                            self.length = dict["Length"] as! Int32
                        }
                        if dict.keys.contains("Reg") {
                            self.reg = dict["Reg"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var count: Int32?

                public var dataSource: [DescribeBlockchainSchemaResponseBody.Result.Responses.Properties.DataSource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.dataSource != nil {
                        var tmp : [Any] = []
                        for k in self.dataSource! {
                            tmp.append(k.toMap())
                        }
                        map["DataSource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int32
                    }
                    if dict.keys.contains("DataSource") {
                        var tmp : [DescribeBlockchainSchemaResponseBody.Result.Responses.Properties.DataSource] = []
                        for v in dict["DataSource"] as! [Any] {
                            var model = DescribeBlockchainSchemaResponseBody.Result.Responses.Properties.DataSource()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dataSource = tmp
                    }
                }
            }
            public var category: String?

            public var categoryName: String?

            public var description_: String?

            public var properties: DescribeBlockchainSchemaResponseBody.Result.Responses.Properties?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.properties?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.categoryName != nil {
                    map["CategoryName"] = self.categoryName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.properties != nil {
                    map["Properties"] = self.properties?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CategoryName") {
                    self.categoryName = dict["CategoryName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Properties") {
                    var model = DescribeBlockchainSchemaResponseBody.Result.Responses.Properties()
                    model.fromMap(dict["Properties"] as! [String: Any])
                    self.properties = model
                }
            }
        }
        public class Schema : Tea.TeaModel {
            public var createTime: Int64?

            public var description_: String?

            public var id: Int64?

            public var isTemplate: Bool?

            public var name: String?

            public var updateTime: Int64?

            public var version: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isTemplate != nil {
                    map["IsTemplate"] = self.isTemplate!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IsTemplate") {
                    self.isTemplate = dict["IsTemplate"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! Int64
                }
            }
        }
        public var responses: [DescribeBlockchainSchemaResponseBody.Result.Responses]?

        public var schema: DescribeBlockchainSchemaResponseBody.Result.Schema?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.schema?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.responses != nil {
                var tmp : [Any] = []
                for k in self.responses! {
                    tmp.append(k.toMap())
                }
                map["Responses"] = tmp
            }
            if self.schema != nil {
                map["Schema"] = self.schema?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Responses") {
                var tmp : [DescribeBlockchainSchemaResponseBody.Result.Responses] = []
                for v in dict["Responses"] as! [Any] {
                    var model = DescribeBlockchainSchemaResponseBody.Result.Responses()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.responses = tmp
            }
            if dict.keys.contains("Schema") {
                var model = DescribeBlockchainSchemaResponseBody.Result.Schema()
                model.fromMap(dict["Schema"] as! [String: Any])
                self.schema = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeBlockchainSchemaResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeBlockchainSchemaResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeBlockchainSchemaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBlockchainSchemaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBlockchainSchemaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBlockchainSchemaDetailRequest : Tea.TeaModel {
    public var bizid: String?

    public var schemaId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! Int64
        }
    }
}

public class DescribeBlockchainSchemaDetailResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Responses : Tea.TeaModel {
            public class Properties : Tea.TeaModel {
                public class DataSource : Tea.TeaModel {
                    public var allowNull: Int32?

                    public var annotation: String?

                    public var field: String?

                    public var indexes: Int32?

                    public var key: Int32?

                    public var length: Int32?

                    public var reg: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.allowNull != nil {
                            map["AllowNull"] = self.allowNull!
                        }
                        if self.annotation != nil {
                            map["Annotation"] = self.annotation!
                        }
                        if self.field != nil {
                            map["Field"] = self.field!
                        }
                        if self.indexes != nil {
                            map["Indexes"] = self.indexes!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.length != nil {
                            map["Length"] = self.length!
                        }
                        if self.reg != nil {
                            map["Reg"] = self.reg!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AllowNull") {
                            self.allowNull = dict["AllowNull"] as! Int32
                        }
                        if dict.keys.contains("Annotation") {
                            self.annotation = dict["Annotation"] as! String
                        }
                        if dict.keys.contains("Field") {
                            self.field = dict["Field"] as! String
                        }
                        if dict.keys.contains("Indexes") {
                            self.indexes = dict["Indexes"] as! Int32
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! Int32
                        }
                        if dict.keys.contains("Length") {
                            self.length = dict["Length"] as! Int32
                        }
                        if dict.keys.contains("Reg") {
                            self.reg = dict["Reg"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var count: Int32?

                public var dataSource: [DescribeBlockchainSchemaDetailResponseBody.Result.Responses.Properties.DataSource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.dataSource != nil {
                        var tmp : [Any] = []
                        for k in self.dataSource! {
                            tmp.append(k.toMap())
                        }
                        map["DataSource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int32
                    }
                    if dict.keys.contains("DataSource") {
                        var tmp : [DescribeBlockchainSchemaDetailResponseBody.Result.Responses.Properties.DataSource] = []
                        for v in dict["DataSource"] as! [Any] {
                            var model = DescribeBlockchainSchemaDetailResponseBody.Result.Responses.Properties.DataSource()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dataSource = tmp
                    }
                }
            }
            public var category: String?

            public var categoryName: String?

            public var description_: String?

            public var properties: DescribeBlockchainSchemaDetailResponseBody.Result.Responses.Properties?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.properties?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.categoryName != nil {
                    map["CategoryName"] = self.categoryName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.properties != nil {
                    map["Properties"] = self.properties?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CategoryName") {
                    self.categoryName = dict["CategoryName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Properties") {
                    var model = DescribeBlockchainSchemaDetailResponseBody.Result.Responses.Properties()
                    model.fromMap(dict["Properties"] as! [String: Any])
                    self.properties = model
                }
            }
        }
        public class Schema : Tea.TeaModel {
            public var createTime: Int64?

            public var description_: String?

            public var id: Int64?

            public var isTemplate: Bool?

            public var name: String?

            public var updateTime: Int64?

            public var version: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isTemplate != nil {
                    map["IsTemplate"] = self.isTemplate!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IsTemplate") {
                    self.isTemplate = dict["IsTemplate"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! Int64
                }
            }
        }
        public var responses: [DescribeBlockchainSchemaDetailResponseBody.Result.Responses]?

        public var schema: DescribeBlockchainSchemaDetailResponseBody.Result.Schema?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.schema?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.responses != nil {
                var tmp : [Any] = []
                for k in self.responses! {
                    tmp.append(k.toMap())
                }
                map["Responses"] = tmp
            }
            if self.schema != nil {
                map["Schema"] = self.schema?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Responses") {
                var tmp : [DescribeBlockchainSchemaDetailResponseBody.Result.Responses] = []
                for v in dict["Responses"] as! [Any] {
                    var model = DescribeBlockchainSchemaDetailResponseBody.Result.Responses()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.responses = tmp
            }
            if dict.keys.contains("Schema") {
                var model = DescribeBlockchainSchemaDetailResponseBody.Result.Schema()
                model.fromMap(dict["Schema"] as! [String: Any])
                self.schema = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeBlockchainSchemaDetailResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeBlockchainSchemaDetailResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeBlockchainSchemaDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBlockchainSchemaDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBlockchainSchemaDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBlockchainSchemaFileOSSPropertiesRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DescribeBlockchainSchemaFileOSSPropertiesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessKeyId: String?

        public var accessKeySecret: String?

        public var bucketName: String?

        public var endpoint: String?

        public var folderName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessKeyId != nil {
                map["AccessKeyId"] = self.accessKeyId!
            }
            if self.accessKeySecret != nil {
                map["AccessKeySecret"] = self.accessKeySecret!
            }
            if self.bucketName != nil {
                map["BucketName"] = self.bucketName!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.folderName != nil {
                map["FolderName"] = self.folderName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessKeyId") {
                self.accessKeyId = dict["AccessKeyId"] as! String
            }
            if dict.keys.contains("AccessKeySecret") {
                self.accessKeySecret = dict["AccessKeySecret"] as! String
            }
            if dict.keys.contains("BucketName") {
                self.bucketName = dict["BucketName"] as! String
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("FolderName") {
                self.folderName = dict["FolderName"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeBlockchainSchemaFileOSSPropertiesResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeBlockchainSchemaFileOSSPropertiesResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeBlockchainSchemaFileOSSPropertiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBlockchainSchemaFileOSSPropertiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBlockchainSchemaFileOSSPropertiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBlockchainSchemaTemplatesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class SchemaList : Tea.TeaModel {
            public var createTime: Int64?

            public var description_: String?

            public var id: Int64?

            public var isTemplate: Int32?

            public var name: String?

            public var updateTime: Int64?

            public var version: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isTemplate != nil {
                    map["IsTemplate"] = self.isTemplate!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IsTemplate") {
                    self.isTemplate = dict["IsTemplate"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! Int64
                }
            }
        }
        public var schemaList: [DescribeBlockchainSchemaTemplatesResponseBody.Result.SchemaList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.schemaList != nil {
                var tmp : [Any] = []
                for k in self.schemaList! {
                    tmp.append(k.toMap())
                }
                map["SchemaList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SchemaList") {
                var tmp : [DescribeBlockchainSchemaTemplatesResponseBody.Result.SchemaList] = []
                for v in dict["SchemaList"] as! [Any] {
                    var model = DescribeBlockchainSchemaTemplatesResponseBody.Result.SchemaList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.schemaList = tmp
            }
        }
    }
    public var requestId: String?

    public var result: DescribeBlockchainSchemaTemplatesResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeBlockchainSchemaTemplatesResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeBlockchainSchemaTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBlockchainSchemaTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBlockchainSchemaTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCSIGatewayEndpointRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeCSIGatewayEndpointResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeCSIGatewayEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCSIGatewayEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCSIGatewayEndpointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCandidateOrganizationsRequest : Tea.TeaModel {
    public var location: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.location != nil {
            map["Location"] = self.location!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
    }
}

public class DescribeCandidateOrganizationsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var clusterState: String?

        public var organizationId: String?

        public var organizationName: String?

        public var serviceState: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterState != nil {
                map["ClusterState"] = self.clusterState!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.organizationName != nil {
                map["OrganizationName"] = self.organizationName!
            }
            if self.serviceState != nil {
                map["ServiceState"] = self.serviceState!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterState") {
                self.clusterState = dict["ClusterState"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
            if dict.keys.contains("OrganizationName") {
                self.organizationName = dict["OrganizationName"] as! String
            }
            if dict.keys.contains("ServiceState") {
                self.serviceState = dict["ServiceState"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeCandidateOrganizationsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeCandidateOrganizationsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeCandidateOrganizationsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeCandidateOrganizationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCandidateOrganizationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCandidateOrganizationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeChaincodeCollectionConfigRequest : Tea.TeaModel {
    public var chaincodeId: String?

    public var location: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chaincodeId != nil {
            map["ChaincodeId"] = self.chaincodeId!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChaincodeId") {
            self.chaincodeId = dict["ChaincodeId"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
    }
}

public class DescribeChaincodeCollectionConfigResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeChaincodeCollectionConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeChaincodeCollectionConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeChaincodeCollectionConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeChaincodeDefinitionTaskRequest : Tea.TeaModel {
    public var chaincodeId: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chaincodeId != nil {
            map["ChaincodeId"] = self.chaincodeId!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChaincodeId") {
            self.chaincodeId = dict["ChaincodeId"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeChaincodeDefinitionTaskResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public class ChaincodeDefinition : Tea.TeaModel {
                public var chaincodePackageId: String?

                public var collectionConfig: String?

                public var endorsementPolicy: String?

                public var initRequired: Bool?

                public var name: String?

                public var sequence: Int64?

                public var version: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.chaincodePackageId != nil {
                        map["ChaincodePackageId"] = self.chaincodePackageId!
                    }
                    if self.collectionConfig != nil {
                        map["CollectionConfig"] = self.collectionConfig!
                    }
                    if self.endorsementPolicy != nil {
                        map["EndorsementPolicy"] = self.endorsementPolicy!
                    }
                    if self.initRequired != nil {
                        map["InitRequired"] = self.initRequired!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.sequence != nil {
                        map["Sequence"] = self.sequence!
                    }
                    if self.version != nil {
                        map["Version"] = self.version!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ChaincodePackageId") {
                        self.chaincodePackageId = dict["ChaincodePackageId"] as! String
                    }
                    if dict.keys.contains("CollectionConfig") {
                        self.collectionConfig = dict["CollectionConfig"] as! String
                    }
                    if dict.keys.contains("EndorsementPolicy") {
                        self.endorsementPolicy = dict["EndorsementPolicy"] as! String
                    }
                    if dict.keys.contains("InitRequired") {
                        self.initRequired = dict["InitRequired"] as! Bool
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Sequence") {
                        self.sequence = dict["Sequence"] as! Int64
                    }
                    if dict.keys.contains("Version") {
                        self.version = dict["Version"] as! String
                    }
                }
            }
            public var chaincodeDefinition: DescribeChaincodeDefinitionTaskResponseBody.Result.Content.ChaincodeDefinition?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.chaincodeDefinition?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.chaincodeDefinition != nil {
                    map["ChaincodeDefinition"] = self.chaincodeDefinition?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChaincodeDefinition") {
                    var model = DescribeChaincodeDefinitionTaskResponseBody.Result.Content.ChaincodeDefinition()
                    model.fromMap(dict["ChaincodeDefinition"] as! [String: Any])
                    self.chaincodeDefinition = model
                }
            }
        }
        public var approvers: [String]?

        public var channelName: String?

        public var content: DescribeChaincodeDefinitionTaskResponseBody.Result.Content?

        public var createTime: Int64?

        public var creator: String?

        public var description_: String?

        public var status: String?

        public var taskId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.content?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.approvers != nil {
                map["Approvers"] = self.approvers!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.content != nil {
                map["Content"] = self.content?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Approvers") {
                self.approvers = dict["Approvers"] as! [String]
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("Content") {
                var model = DescribeChaincodeDefinitionTaskResponseBody.Result.Content()
                model.fromMap(dict["Content"] as! [String: Any])
                self.content = model
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeChaincodeDefinitionTaskResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeChaincodeDefinitionTaskResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeChaincodeDefinitionTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeChaincodeDefinitionTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeChaincodeDefinitionTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeChaincodeUploadPolicyRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeChaincodeUploadPolicyResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessId: String?

        public var dir: String?

        public var expire: Int32?

        public var host: String?

        public var policy: String?

        public var signature: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessId != nil {
                map["AccessId"] = self.accessId!
            }
            if self.dir != nil {
                map["Dir"] = self.dir!
            }
            if self.expire != nil {
                map["Expire"] = self.expire!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.signature != nil {
                map["Signature"] = self.signature!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessId") {
                self.accessId = dict["AccessId"] as! String
            }
            if dict.keys.contains("Dir") {
                self.dir = dict["Dir"] as! String
            }
            if dict.keys.contains("Expire") {
                self.expire = dict["Expire"] as! Int32
            }
            if dict.keys.contains("Host") {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("Signature") {
                self.signature = dict["Signature"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeChaincodeUploadPolicyResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeChaincodeUploadPolicyResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeChaincodeUploadPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeChaincodeUploadPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeChaincodeUploadPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeChannelChaincodesRequest : Tea.TeaModel {
    public var channelId: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeChannelChaincodesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var binding: Bool?

        public var chaincodeId: String?

        public var channelId: String?

        public var channelName: String?

        public var consortiumId: String?

        public var createTime: String?

        public var creator: String?

        public var deployTime: String?

        public var endorsePolicy: String?

        public var installed: String?

        public var management: Bool?

        public var message: String?

        public var name: String?

        public var state: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.binding != nil {
                map["Binding"] = self.binding!
            }
            if self.chaincodeId != nil {
                map["ChaincodeId"] = self.chaincodeId!
            }
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.deployTime != nil {
                map["DeployTime"] = self.deployTime!
            }
            if self.endorsePolicy != nil {
                map["EndorsePolicy"] = self.endorsePolicy!
            }
            if self.installed != nil {
                map["Installed"] = self.installed!
            }
            if self.management != nil {
                map["Management"] = self.management!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Binding") {
                self.binding = dict["Binding"] as! Bool
            }
            if dict.keys.contains("ChaincodeId") {
                self.chaincodeId = dict["ChaincodeId"] as! String
            }
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("DeployTime") {
                self.deployTime = dict["DeployTime"] as! String
            }
            if dict.keys.contains("EndorsePolicy") {
                self.endorsePolicy = dict["EndorsePolicy"] as! String
            }
            if dict.keys.contains("Installed") {
                self.installed = dict["Installed"] as! String
            }
            if dict.keys.contains("Management") {
                self.management = dict["Management"] as! Bool
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeChannelChaincodesResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeChannelChaincodesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeChannelChaincodesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeChannelChaincodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeChannelChaincodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeChannelChaincodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeChannelMembersRequest : Tea.TeaModel {
    public var channelId: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeChannelMembersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var acceptTime: String?

        public var channelId: String?

        public var description_: String?

        public var domain: String?

        public var inviteTime: String?

        public var name: String?

        public var organizationId: String?

        public var state: String?

        public var withPeer: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acceptTime != nil {
                map["AcceptTime"] = self.acceptTime!
            }
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.inviteTime != nil {
                map["InviteTime"] = self.inviteTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.withPeer != nil {
                map["WithPeer"] = self.withPeer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcceptTime") {
                self.acceptTime = dict["AcceptTime"] as! String
            }
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("InviteTime") {
                self.inviteTime = dict["InviteTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("WithPeer") {
                self.withPeer = dict["WithPeer"] as! Bool
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeChannelMembersResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeChannelMembersResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeChannelMembersResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeChannelMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeChannelMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeChannelMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeChannelTriggersRequest : Tea.TeaModel {
    public var channelId: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeChannelTriggersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Checkpoint : Tea.TeaModel {
            public var errorCount: Int64?

            public var height: Int64?

            public var index: Int64?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCount != nil {
                    map["ErrorCount"] = self.errorCount!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCount") {
                    self.errorCount = dict["ErrorCount"] as! Int64
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int64
                }
                if dict.keys.contains("Index") {
                    self.index = dict["Index"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var channelId: String?

        public var channelName: String?

        public var checkpoint: DescribeChannelTriggersResponseBody.Result.Checkpoint?

        public var createTime: Int64?

        public var errorMessage: String?

        public var name: String?

        public var options: String?

        public var source: String?

        public var status: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkpoint?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.checkpoint != nil {
                map["Checkpoint"] = self.checkpoint?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.options != nil {
                map["Options"] = self.options!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("Checkpoint") {
                var model = DescribeChannelTriggersResponseBody.Result.Checkpoint()
                model.fromMap(dict["Checkpoint"] as! [String: Any])
                self.checkpoint = model
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Options") {
                self.options = dict["Options"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeChannelTriggersResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeChannelTriggersResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeChannelTriggersResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeChannelTriggersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeChannelTriggersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeChannelTriggersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudIntegrationServiceTokenRequest : Tea.TeaModel {
    public var organizationId: String?

    public var service: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.service != nil {
            map["Service"] = self.service!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("Service") {
            self.service = dict["Service"] as! String
        }
    }
}

public class DescribeCloudIntegrationServiceTokenResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class History : Tea.TeaModel {
            public var service: String?

            public var token: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.service != nil {
                    map["Service"] = self.service!
                }
                if self.token != nil {
                    map["Token"] = self.token!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Service") {
                    self.service = dict["Service"] as! String
                }
                if dict.keys.contains("Token") {
                    self.token = dict["Token"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var history: [DescribeCloudIntegrationServiceTokenResponseBody.Result.History]?

        public var service: String?

        public var token: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.history != nil {
                var tmp : [Any] = []
                for k in self.history! {
                    tmp.append(k.toMap())
                }
                map["History"] = tmp
            }
            if self.service != nil {
                map["Service"] = self.service!
            }
            if self.token != nil {
                map["Token"] = self.token!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("History") {
                var tmp : [DescribeCloudIntegrationServiceTokenResponseBody.Result.History] = []
                for v in dict["History"] as! [Any] {
                    var model = DescribeCloudIntegrationServiceTokenResponseBody.Result.History()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.history = tmp
            }
            if dict.keys.contains("Service") {
                self.service = dict["Service"] as! String
            }
            if dict.keys.contains("Token") {
                self.token = dict["Token"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeCloudIntegrationServiceTokenResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeCloudIntegrationServiceTokenResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeCloudIntegrationServiceTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudIntegrationServiceTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudIntegrationServiceTokenResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudServiceOrganizationStatusRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeCloudServiceOrganizationStatusResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var grantPrivilegeUrl: String?

        public var organizationId: String?

        public var serviceOpenStatus: Bool?

        public var serviceOpenUrl: String?

        public var servicePrivilegeStatus: Bool?

        public var serviceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.grantPrivilegeUrl != nil {
                map["GrantPrivilegeUrl"] = self.grantPrivilegeUrl!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.serviceOpenStatus != nil {
                map["ServiceOpenStatus"] = self.serviceOpenStatus!
            }
            if self.serviceOpenUrl != nil {
                map["ServiceOpenUrl"] = self.serviceOpenUrl!
            }
            if self.servicePrivilegeStatus != nil {
                map["ServicePrivilegeStatus"] = self.servicePrivilegeStatus!
            }
            if self.serviceType != nil {
                map["ServiceType"] = self.serviceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GrantPrivilegeUrl") {
                self.grantPrivilegeUrl = dict["GrantPrivilegeUrl"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
            if dict.keys.contains("ServiceOpenStatus") {
                self.serviceOpenStatus = dict["ServiceOpenStatus"] as! Bool
            }
            if dict.keys.contains("ServiceOpenUrl") {
                self.serviceOpenUrl = dict["ServiceOpenUrl"] as! String
            }
            if dict.keys.contains("ServicePrivilegeStatus") {
                self.servicePrivilegeStatus = dict["ServicePrivilegeStatus"] as! Bool
            }
            if dict.keys.contains("ServiceType") {
                self.serviceType = dict["ServiceType"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeCloudServiceOrganizationStatusResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeCloudServiceOrganizationStatusResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeCloudServiceOrganizationStatusResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeCloudServiceOrganizationStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudServiceOrganizationStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudServiceOrganizationStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudServiceTypeStatusRequest : Tea.TeaModel {
    public var organizationId: String?

    public var serviceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("ServiceType") {
            self.serviceType = dict["ServiceType"] as! String
        }
    }
}

public class DescribeCloudServiceTypeStatusResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var grantPrivilegeUrl: String?

        public var organizationId: String?

        public var serviceOpenStatus: Bool?

        public var serviceOpenUrl: String?

        public var servicePrivilegeStatus: Bool?

        public var serviceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.grantPrivilegeUrl != nil {
                map["GrantPrivilegeUrl"] = self.grantPrivilegeUrl!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.serviceOpenStatus != nil {
                map["ServiceOpenStatus"] = self.serviceOpenStatus!
            }
            if self.serviceOpenUrl != nil {
                map["ServiceOpenUrl"] = self.serviceOpenUrl!
            }
            if self.servicePrivilegeStatus != nil {
                map["ServicePrivilegeStatus"] = self.servicePrivilegeStatus!
            }
            if self.serviceType != nil {
                map["ServiceType"] = self.serviceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GrantPrivilegeUrl") {
                self.grantPrivilegeUrl = dict["GrantPrivilegeUrl"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
            if dict.keys.contains("ServiceOpenStatus") {
                self.serviceOpenStatus = dict["ServiceOpenStatus"] as! Bool
            }
            if dict.keys.contains("ServiceOpenUrl") {
                self.serviceOpenUrl = dict["ServiceOpenUrl"] as! String
            }
            if dict.keys.contains("ServicePrivilegeStatus") {
                self.servicePrivilegeStatus = dict["ServicePrivilegeStatus"] as! Bool
            }
            if dict.keys.contains("ServiceType") {
                self.serviceType = dict["ServiceType"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeCloudServiceTypeStatusResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeCloudServiceTypeStatusResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeCloudServiceTypeStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudServiceTypeStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudServiceTypeStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeConsortiumAdminStatusRequest : Tea.TeaModel {
    public var location: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.location != nil {
            map["Location"] = self.location!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
    }
}

public class DescribeConsortiumAdminStatusResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consortiumAdministrator: Bool?

        public var consortiumId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consortiumAdministrator != nil {
                map["ConsortiumAdministrator"] = self.consortiumAdministrator!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsortiumAdministrator") {
                self.consortiumAdministrator = dict["ConsortiumAdministrator"] as! Bool
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeConsortiumAdminStatusResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeConsortiumAdminStatusResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeConsortiumAdminStatusResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeConsortiumAdminStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConsortiumAdminStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeConsortiumAdminStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeConsortiumChaincodesRequest : Tea.TeaModel {
    public var consortiumId: String?

    public var location: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
    }
}

public class DescribeConsortiumChaincodesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var chaincodeId: String?

        public var channelId: String?

        public var channelName: String?

        public var consortiumId: String?

        public var createTime: String?

        public var deployTime: String?

        public var endorsePolicy: String?

        public var input: String?

        public var install: Bool?

        public var management: Bool?

        public var message: String?

        public var name: String?

        public var path: String?

        public var providerId: String?

        public var providerName: String?

        public var state: String?

        public var type: Int32?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chaincodeId != nil {
                map["ChaincodeId"] = self.chaincodeId!
            }
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.deployTime != nil {
                map["DeployTime"] = self.deployTime!
            }
            if self.endorsePolicy != nil {
                map["EndorsePolicy"] = self.endorsePolicy!
            }
            if self.input != nil {
                map["Input"] = self.input!
            }
            if self.install != nil {
                map["Install"] = self.install!
            }
            if self.management != nil {
                map["Management"] = self.management!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.providerId != nil {
                map["ProviderId"] = self.providerId!
            }
            if self.providerName != nil {
                map["ProviderName"] = self.providerName!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChaincodeId") {
                self.chaincodeId = dict["ChaincodeId"] as! String
            }
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DeployTime") {
                self.deployTime = dict["DeployTime"] as! String
            }
            if dict.keys.contains("EndorsePolicy") {
                self.endorsePolicy = dict["EndorsePolicy"] as! String
            }
            if dict.keys.contains("Input") {
                self.input = dict["Input"] as! String
            }
            if dict.keys.contains("Install") {
                self.install = dict["Install"] as! Bool
            }
            if dict.keys.contains("Management") {
                self.management = dict["Management"] as! Bool
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("ProviderId") {
                self.providerId = dict["ProviderId"] as! String
            }
            if dict.keys.contains("ProviderName") {
                self.providerName = dict["ProviderName"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeConsortiumChaincodesResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeConsortiumChaincodesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeConsortiumChaincodesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeConsortiumChaincodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConsortiumChaincodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeConsortiumChaincodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeConsortiumChannelsRequest : Tea.TeaModel {
    public var consortiumId: String?

    public var location: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
    }
}

public class DescribeConsortiumChannelsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var batchTimeout: Int32?

        public var blockCount: Int32?

        public var chaincodeCount: Int32?

        public var channelId: String?

        public var consortiumId: String?

        public var consortiumName: String?

        public var createTime: String?

        public var deleteTime: String?

        public var deleted: Bool?

        public var hybird: Bool?

        public var id: Int32?

        public var maxMessageCount: Int32?

        public var memberCount: Int32?

        public var memberJoinedCount: String?

        public var name: String?

        public var needJoined: Bool?

        public var ownerBid: String?

        public var ownerName: String?

        public var ownerUid: Int32?

        public var preferredMaxBytes: Int32?

        public var requestId: String?

        public var state: String?

        public var supportChannelConfig: Bool?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.batchTimeout != nil {
                map["BatchTimeout"] = self.batchTimeout!
            }
            if self.blockCount != nil {
                map["BlockCount"] = self.blockCount!
            }
            if self.chaincodeCount != nil {
                map["ChaincodeCount"] = self.chaincodeCount!
            }
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.consortiumName != nil {
                map["ConsortiumName"] = self.consortiumName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.deleteTime != nil {
                map["DeleteTime"] = self.deleteTime!
            }
            if self.deleted != nil {
                map["Deleted"] = self.deleted!
            }
            if self.hybird != nil {
                map["Hybird"] = self.hybird!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.maxMessageCount != nil {
                map["MaxMessageCount"] = self.maxMessageCount!
            }
            if self.memberCount != nil {
                map["MemberCount"] = self.memberCount!
            }
            if self.memberJoinedCount != nil {
                map["MemberJoinedCount"] = self.memberJoinedCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.needJoined != nil {
                map["NeedJoined"] = self.needJoined!
            }
            if self.ownerBid != nil {
                map["OwnerBid"] = self.ownerBid!
            }
            if self.ownerName != nil {
                map["OwnerName"] = self.ownerName!
            }
            if self.ownerUid != nil {
                map["OwnerUid"] = self.ownerUid!
            }
            if self.preferredMaxBytes != nil {
                map["PreferredMaxBytes"] = self.preferredMaxBytes!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.supportChannelConfig != nil {
                map["SupportChannelConfig"] = self.supportChannelConfig!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BatchTimeout") {
                self.batchTimeout = dict["BatchTimeout"] as! Int32
            }
            if dict.keys.contains("BlockCount") {
                self.blockCount = dict["BlockCount"] as! Int32
            }
            if dict.keys.contains("ChaincodeCount") {
                self.chaincodeCount = dict["ChaincodeCount"] as! Int32
            }
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("ConsortiumName") {
                self.consortiumName = dict["ConsortiumName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DeleteTime") {
                self.deleteTime = dict["DeleteTime"] as! String
            }
            if dict.keys.contains("Deleted") {
                self.deleted = dict["Deleted"] as! Bool
            }
            if dict.keys.contains("Hybird") {
                self.hybird = dict["Hybird"] as! Bool
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("MaxMessageCount") {
                self.maxMessageCount = dict["MaxMessageCount"] as! Int32
            }
            if dict.keys.contains("MemberCount") {
                self.memberCount = dict["MemberCount"] as! Int32
            }
            if dict.keys.contains("MemberJoinedCount") {
                self.memberJoinedCount = dict["MemberJoinedCount"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NeedJoined") {
                self.needJoined = dict["NeedJoined"] as! Bool
            }
            if dict.keys.contains("OwnerBid") {
                self.ownerBid = dict["OwnerBid"] as! String
            }
            if dict.keys.contains("OwnerName") {
                self.ownerName = dict["OwnerName"] as! String
            }
            if dict.keys.contains("OwnerUid") {
                self.ownerUid = dict["OwnerUid"] as! Int32
            }
            if dict.keys.contains("PreferredMaxBytes") {
                self.preferredMaxBytes = dict["PreferredMaxBytes"] as! Int32
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("SupportChannelConfig") {
                self.supportChannelConfig = dict["SupportChannelConfig"] as! Bool
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeConsortiumChannelsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeConsortiumChannelsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeConsortiumChannelsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeConsortiumChannelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConsortiumChannelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeConsortiumChannelsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeConsortiumConfigResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var channelPolicy: [String]?

        public var ordererType: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelPolicy != nil {
                map["ChannelPolicy"] = self.channelPolicy!
            }
            if self.ordererType != nil {
                map["OrdererType"] = self.ordererType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelPolicy") {
                self.channelPolicy = dict["ChannelPolicy"] as! [String]
            }
            if dict.keys.contains("OrdererType") {
                self.ordererType = dict["OrdererType"] as! [String]
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeConsortiumConfigResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeConsortiumConfigResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeConsortiumConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConsortiumConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeConsortiumConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeConsortiumDeletableRequest : Tea.TeaModel {
    public var consortiumId: String?

    public var location: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
    }
}

public class DescribeConsortiumDeletableResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var codeName: String?

        public var consortiumId: String?

        public var deletable: Bool?

        public var description_: String?

        public var domain: String?

        public var name: String?

        public var regionId: String?

        public var state: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.codeName != nil {
                map["CodeName"] = self.codeName!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.deletable != nil {
                map["Deletable"] = self.deletable!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CodeName") {
                self.codeName = dict["CodeName"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("Deletable") {
                self.deletable = dict["Deletable"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeConsortiumDeletableResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeConsortiumDeletableResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeConsortiumDeletableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConsortiumDeletableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeConsortiumDeletableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeConsortiumMemberApprovalRequest : Tea.TeaModel {
    public var consortiumId: String?

    public var location: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
    }
}

public class DescribeConsortiumMemberApprovalResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var channelCreatePolicy: String?

        public var confirmTime: String?

        public var consortiumId: String?

        public var consortiumName: String?

        public var domainName: String?

        public var organizationId: String?

        public var organizationName: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelCreatePolicy != nil {
                map["ChannelCreatePolicy"] = self.channelCreatePolicy!
            }
            if self.confirmTime != nil {
                map["ConfirmTime"] = self.confirmTime!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.consortiumName != nil {
                map["ConsortiumName"] = self.consortiumName!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.organizationName != nil {
                map["OrganizationName"] = self.organizationName!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelCreatePolicy") {
                self.channelCreatePolicy = dict["ChannelCreatePolicy"] as! String
            }
            if dict.keys.contains("ConfirmTime") {
                self.confirmTime = dict["ConfirmTime"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("ConsortiumName") {
                self.consortiumName = dict["ConsortiumName"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
            if dict.keys.contains("OrganizationName") {
                self.organizationName = dict["OrganizationName"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeConsortiumMemberApprovalResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeConsortiumMemberApprovalResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeConsortiumMemberApprovalResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeConsortiumMemberApprovalResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConsortiumMemberApprovalResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeConsortiumMemberApprovalResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeConsortiumMembersRequest : Tea.TeaModel {
    public var consortiumId: String?

    public var location: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
    }
}

public class DescribeConsortiumMembersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consortiumId: String?

        public var description_: String?

        public var domain: String?

        public var joinedTime: String?

        public var name: String?

        public var organizationId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.joinedTime != nil {
                map["JoinedTime"] = self.joinedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("JoinedTime") {
                self.joinedTime = dict["JoinedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeConsortiumMembersResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeConsortiumMembersResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeConsortiumMembersResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeConsortiumMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConsortiumMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeConsortiumMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeConsortiumOrderersRequest : Tea.TeaModel {
    public var consortiumId: String?

    public var location: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
    }
}

public class DescribeConsortiumOrderersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createTime: String?

        public var domain: String?

        public var instanceType: String?

        public var name: String?

        public var port: Int32?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeConsortiumOrderersResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeConsortiumOrderersResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeConsortiumOrderersResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeConsortiumOrderersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConsortiumOrderersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeConsortiumOrderersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeConsortiumSpecsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var enable: Bool?

        public var name: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeConsortiumSpecsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeConsortiumSpecsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeConsortiumSpecsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeConsortiumSpecsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConsortiumSpecsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeConsortiumSpecsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeConsortiumsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var consortiumId: String?

    public var location: String?

    public var tag: [DescribeConsortiumsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeConsortiumsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeConsortiumsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeConsortiumsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var CAName: String?

        public var CAUrl: String?

        public var channelCount: Int32?

        public var channelPolicy: String?

        public var codeName: String?

        public var consortiumId: String?

        public var createTime: String?

        public var domain: String?

        public var expireState: String?

        public var expiredTime: String?

        public var hybrid: Bool?

        public var MSP: String?

        public var majorVersion: String?

        public var name: String?

        public var ordererCount: Int32?

        public var organizationCount: Int32?

        public var ownerBid: String?

        public var ownerName: String?

        public var ownerUid: Int64?

        public var regionId: String?

        public var requestId: String?

        public var specName: String?

        public var state: String?

        public var supportChannelConfig: Bool?

        public var tags: [DescribeConsortiumsResponseBody.Result.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.CAName != nil {
                map["CAName"] = self.CAName!
            }
            if self.CAUrl != nil {
                map["CAUrl"] = self.CAUrl!
            }
            if self.channelCount != nil {
                map["ChannelCount"] = self.channelCount!
            }
            if self.channelPolicy != nil {
                map["ChannelPolicy"] = self.channelPolicy!
            }
            if self.codeName != nil {
                map["CodeName"] = self.codeName!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.expireState != nil {
                map["ExpireState"] = self.expireState!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.hybrid != nil {
                map["Hybrid"] = self.hybrid!
            }
            if self.MSP != nil {
                map["MSP"] = self.MSP!
            }
            if self.majorVersion != nil {
                map["MajorVersion"] = self.majorVersion!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ordererCount != nil {
                map["OrdererCount"] = self.ordererCount!
            }
            if self.organizationCount != nil {
                map["OrganizationCount"] = self.organizationCount!
            }
            if self.ownerBid != nil {
                map["OwnerBid"] = self.ownerBid!
            }
            if self.ownerName != nil {
                map["OwnerName"] = self.ownerName!
            }
            if self.ownerUid != nil {
                map["OwnerUid"] = self.ownerUid!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.specName != nil {
                map["SpecName"] = self.specName!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.supportChannelConfig != nil {
                map["SupportChannelConfig"] = self.supportChannelConfig!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CAName") {
                self.CAName = dict["CAName"] as! String
            }
            if dict.keys.contains("CAUrl") {
                self.CAUrl = dict["CAUrl"] as! String
            }
            if dict.keys.contains("ChannelCount") {
                self.channelCount = dict["ChannelCount"] as! Int32
            }
            if dict.keys.contains("ChannelPolicy") {
                self.channelPolicy = dict["ChannelPolicy"] as! String
            }
            if dict.keys.contains("CodeName") {
                self.codeName = dict["CodeName"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("ExpireState") {
                self.expireState = dict["ExpireState"] as! String
            }
            if dict.keys.contains("ExpiredTime") {
                self.expiredTime = dict["ExpiredTime"] as! String
            }
            if dict.keys.contains("Hybrid") {
                self.hybrid = dict["Hybrid"] as! Bool
            }
            if dict.keys.contains("MSP") {
                self.MSP = dict["MSP"] as! String
            }
            if dict.keys.contains("MajorVersion") {
                self.majorVersion = dict["MajorVersion"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OrdererCount") {
                self.ordererCount = dict["OrdererCount"] as! Int32
            }
            if dict.keys.contains("OrganizationCount") {
                self.organizationCount = dict["OrganizationCount"] as! Int32
            }
            if dict.keys.contains("OwnerBid") {
                self.ownerBid = dict["OwnerBid"] as! String
            }
            if dict.keys.contains("OwnerName") {
                self.ownerName = dict["OwnerName"] as! String
            }
            if dict.keys.contains("OwnerUid") {
                self.ownerUid = dict["OwnerUid"] as! Int64
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("SpecName") {
                self.specName = dict["SpecName"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("SupportChannelConfig") {
                self.supportChannelConfig = dict["SupportChannelConfig"] as! Bool
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeConsortiumsResponseBody.Result.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeConsortiumsResponseBody.Result.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeConsortiumsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeConsortiumsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeConsortiumsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeConsortiumsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConsortiumsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeConsortiumsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDownloadPathsRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DescribeDownloadPathsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var bizviewUrl: String?

        public var certUrl: String?

        public var sdkUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizviewUrl != nil {
                map["BizviewUrl"] = self.bizviewUrl!
            }
            if self.certUrl != nil {
                map["CertUrl"] = self.certUrl!
            }
            if self.sdkUrl != nil {
                map["SdkUrl"] = self.sdkUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizviewUrl") {
                self.bizviewUrl = dict["BizviewUrl"] as! String
            }
            if dict.keys.contains("CertUrl") {
                self.certUrl = dict["CertUrl"] as! String
            }
            if dict.keys.contains("SdkUrl") {
                self.sdkUrl = dict["SdkUrl"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeDownloadPathsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeDownloadPathsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeDownloadPathsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDownloadPathsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDownloadPathsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDownloadPathsOfContractChainRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DescribeDownloadPathsOfContractChainResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var caUrl: String?

        public var certUrl: String?

        public var trustCaUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.caUrl != nil {
                map["CaUrl"] = self.caUrl!
            }
            if self.certUrl != nil {
                map["CertUrl"] = self.certUrl!
            }
            if self.trustCaUrl != nil {
                map["TrustCaUrl"] = self.trustCaUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CaUrl") {
                self.caUrl = dict["CaUrl"] as! String
            }
            if dict.keys.contains("CertUrl") {
                self.certUrl = dict["CertUrl"] as! String
            }
            if dict.keys.contains("TrustCaUrl") {
                self.trustCaUrl = dict["TrustCaUrl"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeDownloadPathsOfContractChainResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeDownloadPathsOfContractChainResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeDownloadPathsOfContractChainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDownloadPathsOfContractChainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDownloadPathsOfContractChainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDownloadPathsOfNotaryChainRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DescribeDownloadPathsOfNotaryChainResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var bizviewUrl: String?

        public var certUrl: String?

        public var sdkUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizviewUrl != nil {
                map["BizviewUrl"] = self.bizviewUrl!
            }
            if self.certUrl != nil {
                map["CertUrl"] = self.certUrl!
            }
            if self.sdkUrl != nil {
                map["SdkUrl"] = self.sdkUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizviewUrl") {
                self.bizviewUrl = dict["BizviewUrl"] as! String
            }
            if dict.keys.contains("CertUrl") {
                self.certUrl = dict["CertUrl"] as! String
            }
            if dict.keys.contains("SdkUrl") {
                self.sdkUrl = dict["SdkUrl"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeDownloadPathsOfNotaryChainResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeDownloadPathsOfNotaryChainResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeDownloadPathsOfNotaryChainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDownloadPathsOfNotaryChainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDownloadPathsOfNotaryChainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEcosphereSpecsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var enable: Bool?

        public var name: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeEcosphereSpecsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeEcosphereSpecsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeEcosphereSpecsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeEcosphereSpecsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEcosphereSpecsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEcosphereSpecsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEthereumRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class DescribeEthereumResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consensus: String?

        public var creator: String?

        public var description_: String?

        public var id: String?

        public var name: String?

        public var networkId: String?

        public var regionId: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consensus != nil {
                map["Consensus"] = self.consensus!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Consensus") {
                self.consensus = dict["Consensus"] as! String
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NetworkId") {
                self.networkId = dict["NetworkId"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeEthereumResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeEthereumResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeEthereumResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEthereumResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEthereumResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEthereumClientUsersRequest : Tea.TeaModel {
    public var nodeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
    }
}

public class DescribeEthereumClientUsersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.username != nil {
                map["Username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Username") {
                self.username = dict["Username"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeEthereumClientUsersResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeEthereumClientUsersResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeEthereumClientUsersResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeEthereumClientUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEthereumClientUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEthereumClientUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEthereumDeletableRequest : Tea.TeaModel {
    public var ethereumId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ethereumId != nil {
            map["EthereumId"] = self.ethereumId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EthereumId") {
            self.ethereumId = dict["EthereumId"] as! String
        }
    }
}

public class DescribeEthereumDeletableResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var deletable: Bool?

        public var ethereumId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deletable != nil {
                map["Deletable"] = self.deletable!
            }
            if self.ethereumId != nil {
                map["EthereumId"] = self.ethereumId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Deletable") {
                self.deletable = dict["Deletable"] as! Bool
            }
            if dict.keys.contains("EthereumId") {
                self.ethereumId = dict["EthereumId"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeEthereumDeletableResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeEthereumDeletableResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeEthereumDeletableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEthereumDeletableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEthereumDeletableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEthereumInvitaionRequest : Tea.TeaModel {
    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
    }
}

public class DescribeEthereumInvitaionResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consensus: String?

        public var createTime: String?

        public var creator: String?

        public var description_: String?

        public var id: String?

        public var name: String?

        public var networkId: String?

        public var regionId: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consensus != nil {
                map["Consensus"] = self.consensus!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Consensus") {
                self.consensus = dict["Consensus"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NetworkId") {
                self.networkId = dict["NetworkId"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeEthereumInvitaionResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeEthereumInvitaionResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeEthereumInvitaionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEthereumInvitaionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEthereumInvitaionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEthereumInviteeRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class DescribeEthereumInviteeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createTime: String?

        public var creator: String?

        public var description_: String?

        public var ethereumId: String?

        public var ethereumName: String?

        public var id: String?

        public var networkId: Int64?

        public var nodeName: String?

        public var publicIp: String?

        public var regionId: String?

        public var rpcPort: String?

        public var state: String?

        public var wsPort: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ethereumId != nil {
                map["EthereumId"] = self.ethereumId!
            }
            if self.ethereumName != nil {
                map["EthereumName"] = self.ethereumName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.publicIp != nil {
                map["PublicIp"] = self.publicIp!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.rpcPort != nil {
                map["RpcPort"] = self.rpcPort!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.wsPort != nil {
                map["WsPort"] = self.wsPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EthereumId") {
                self.ethereumId = dict["EthereumId"] as! String
            }
            if dict.keys.contains("EthereumName") {
                self.ethereumName = dict["EthereumName"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("NetworkId") {
                self.networkId = dict["NetworkId"] as! Int64
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("PublicIp") {
                self.publicIp = dict["PublicIp"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RpcPort") {
                self.rpcPort = dict["RpcPort"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("WsPort") {
                self.wsPort = dict["WsPort"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeEthereumInviteeResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeEthereumInviteeResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeEthereumInviteeResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeEthereumInviteeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEthereumInviteeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEthereumInviteeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEthereumNodeRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class DescribeEthereumNodeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createTime: Int64?

        public var creator: String?

        public var description_: String?

        public var ethereumId: String?

        public var ethereumName: String?

        public var id: String?

        public var networkId: String?

        public var nodeName: String?

        public var publicIp: String?

        public var regionId: String?

        public var rpcPort: Int32?

        public var state: String?

        public var wsPort: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ethereumId != nil {
                map["EthereumId"] = self.ethereumId!
            }
            if self.ethereumName != nil {
                map["EthereumName"] = self.ethereumName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.publicIp != nil {
                map["PublicIp"] = self.publicIp!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.rpcPort != nil {
                map["RpcPort"] = self.rpcPort!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.wsPort != nil {
                map["WsPort"] = self.wsPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EthereumId") {
                self.ethereumId = dict["EthereumId"] as! String
            }
            if dict.keys.contains("EthereumName") {
                self.ethereumName = dict["EthereumName"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("NetworkId") {
                self.networkId = dict["NetworkId"] as! String
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("PublicIp") {
                self.publicIp = dict["PublicIp"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RpcPort") {
                self.rpcPort = dict["RpcPort"] as! Int32
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("WsPort") {
                self.wsPort = dict["WsPort"] as! Int32
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeEthereumNodeResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeEthereumNodeResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeEthereumNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEthereumNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEthereumNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEthereumNodeConfigurationRequest : Tea.TeaModel {
    public var nodeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
    }
}

public class DescribeEthereumNodeConfigurationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var genesisJson: String?

        public var IP: String?

        public var nodePub: String?

        public var p2pPort: Int32?

        public var permissionedNodesJson: String?

        public var raftPort: Int32?

        public var rpcPort: Int32?

        public var staticNodesJson: String?

        public var TMJson: String?

        public var TMPort: Int32?

        public var TMPub: String?

        public var WSPort: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.genesisJson != nil {
                map["GenesisJson"] = self.genesisJson!
            }
            if self.IP != nil {
                map["IP"] = self.IP!
            }
            if self.nodePub != nil {
                map["NodePub"] = self.nodePub!
            }
            if self.p2pPort != nil {
                map["P2pPort"] = self.p2pPort!
            }
            if self.permissionedNodesJson != nil {
                map["PermissionedNodesJson"] = self.permissionedNodesJson!
            }
            if self.raftPort != nil {
                map["RaftPort"] = self.raftPort!
            }
            if self.rpcPort != nil {
                map["RpcPort"] = self.rpcPort!
            }
            if self.staticNodesJson != nil {
                map["StaticNodesJson"] = self.staticNodesJson!
            }
            if self.TMJson != nil {
                map["TMJson"] = self.TMJson!
            }
            if self.TMPort != nil {
                map["TMPort"] = self.TMPort!
            }
            if self.TMPub != nil {
                map["TMPub"] = self.TMPub!
            }
            if self.WSPort != nil {
                map["WSPort"] = self.WSPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GenesisJson") {
                self.genesisJson = dict["GenesisJson"] as! String
            }
            if dict.keys.contains("IP") {
                self.IP = dict["IP"] as! String
            }
            if dict.keys.contains("NodePub") {
                self.nodePub = dict["NodePub"] as! String
            }
            if dict.keys.contains("P2pPort") {
                self.p2pPort = dict["P2pPort"] as! Int32
            }
            if dict.keys.contains("PermissionedNodesJson") {
                self.permissionedNodesJson = dict["PermissionedNodesJson"] as! String
            }
            if dict.keys.contains("RaftPort") {
                self.raftPort = dict["RaftPort"] as! Int32
            }
            if dict.keys.contains("RpcPort") {
                self.rpcPort = dict["RpcPort"] as! Int32
            }
            if dict.keys.contains("StaticNodesJson") {
                self.staticNodesJson = dict["StaticNodesJson"] as! String
            }
            if dict.keys.contains("TMJson") {
                self.TMJson = dict["TMJson"] as! String
            }
            if dict.keys.contains("TMPort") {
                self.TMPort = dict["TMPort"] as! Int32
            }
            if dict.keys.contains("TMPub") {
                self.TMPub = dict["TMPub"] as! String
            }
            if dict.keys.contains("WSPort") {
                self.WSPort = dict["WSPort"] as! Int32
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeEthereumNodeConfigurationResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeEthereumNodeConfigurationResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeEthereumNodeConfigurationResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeEthereumNodeConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEthereumNodeConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEthereumNodeConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEthereumNodeInfoRequest : Tea.TeaModel {
    public var nodeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
    }
}

public class DescribeEthereumNodeInfoResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeEthereumNodeInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEthereumNodeInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEthereumNodeInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEthereumNodeLogsRequest : Tea.TeaModel {
    public var lines: String?

    public var nodeId: String?

    public var target: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lines != nil {
            map["Lines"] = self.lines!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.target != nil {
            map["Target"] = self.target!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lines") {
            self.lines = dict["Lines"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("Target") {
            self.target = dict["Target"] as! String
        }
    }
}

public class DescribeEthereumNodeLogsResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeEthereumNodeLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEthereumNodeLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEthereumNodeLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEthereumNodesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consensus: String?

        public var createTime: String?

        public var creator: String?

        public var description_: String?

        public var ethereumId: String?

        public var ethereumName: String?

        public var external: Bool?

        public var id: String?

        public var networkId: Int64?

        public var nodeName: String?

        public var publicIp: String?

        public var regionId: String?

        public var rpcPort: String?

        public var state: String?

        public var validator: Bool?

        public var wsPort: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consensus != nil {
                map["Consensus"] = self.consensus!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ethereumId != nil {
                map["EthereumId"] = self.ethereumId!
            }
            if self.ethereumName != nil {
                map["EthereumName"] = self.ethereumName!
            }
            if self.external != nil {
                map["External"] = self.external!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.publicIp != nil {
                map["PublicIp"] = self.publicIp!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.rpcPort != nil {
                map["RpcPort"] = self.rpcPort!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.validator != nil {
                map["Validator"] = self.validator!
            }
            if self.wsPort != nil {
                map["WsPort"] = self.wsPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Consensus") {
                self.consensus = dict["Consensus"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EthereumId") {
                self.ethereumId = dict["EthereumId"] as! String
            }
            if dict.keys.contains("EthereumName") {
                self.ethereumName = dict["EthereumName"] as! String
            }
            if dict.keys.contains("External") {
                self.external = dict["External"] as! Bool
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("NetworkId") {
                self.networkId = dict["NetworkId"] as! Int64
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("PublicIp") {
                self.publicIp = dict["PublicIp"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RpcPort") {
                self.rpcPort = dict["RpcPort"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Validator") {
                self.validator = dict["Validator"] as! Bool
            }
            if dict.keys.contains("WsPort") {
                self.wsPort = dict["WsPort"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeEthereumNodesResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeEthereumNodesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeEthereumNodesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeEthereumNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEthereumNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEthereumNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEthereumsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consensus: String?

        public var createTime: Int64?

        public var creator: String?

        public var deletable: Bool?

        public var description_: String?

        public var id: String?

        public var name: String?

        public var networkId: String?

        public var nodeNumber: Int32?

        public var regionId: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consensus != nil {
                map["Consensus"] = self.consensus!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.deletable != nil {
                map["Deletable"] = self.deletable!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.nodeNumber != nil {
                map["NodeNumber"] = self.nodeNumber!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Consensus") {
                self.consensus = dict["Consensus"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Deletable") {
                self.deletable = dict["Deletable"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NetworkId") {
                self.networkId = dict["NetworkId"] as! String
            }
            if dict.keys.contains("NodeNumber") {
                self.nodeNumber = dict["NodeNumber"] as! Int32
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeEthereumsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeEthereumsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeEthereumsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeEthereumsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEthereumsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEthereumsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExplorerRequest : Tea.TeaModel {
    public var exBody: String?

    public var exMethod: String?

    public var exUrl: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.exBody != nil {
            map["ExBody"] = self.exBody!
        }
        if self.exMethod != nil {
            map["ExMethod"] = self.exMethod!
        }
        if self.exUrl != nil {
            map["ExUrl"] = self.exUrl!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExBody") {
            self.exBody = dict["ExBody"] as! String
        }
        if dict.keys.contains("ExMethod") {
            self.exMethod = dict["ExMethod"] as! String
        }
        if dict.keys.contains("ExUrl") {
            self.exUrl = dict["ExUrl"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeExplorerResponseBody : Tea.TeaModel {
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeExplorerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExplorerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeExplorerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeExplorerURLRequest : Tea.TeaModel {
    public var nodeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
    }
}

public class DescribeExplorerURLResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeExplorerURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExplorerURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeExplorerURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFabricChaincodeEndorsePolicyRequest : Tea.TeaModel {
    public var chaincodeName: String?

    public var channelId: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chaincodeName != nil {
            map["ChaincodeName"] = self.chaincodeName!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChaincodeName") {
            self.chaincodeName = dict["ChaincodeName"] as! String
        }
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeFabricChaincodeEndorsePolicyResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeFabricChaincodeEndorsePolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFabricChaincodeEndorsePolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFabricChaincodeEndorsePolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFabricChaincodeLogsRequest : Tea.TeaModel {
    public var chaincodeId: String?

    public var lines: String?

    public var offset: Int32?

    public var organizationId: String?

    public var peerName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chaincodeId != nil {
            map["ChaincodeId"] = self.chaincodeId!
        }
        if self.lines != nil {
            map["Lines"] = self.lines!
        }
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.peerName != nil {
            map["PeerName"] = self.peerName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChaincodeId") {
            self.chaincodeId = dict["ChaincodeId"] as! String
        }
        if dict.keys.contains("Lines") {
            self.lines = dict["Lines"] as! String
        }
        if dict.keys.contains("Offset") {
            self.offset = dict["Offset"] as! Int32
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("PeerName") {
            self.peerName = dict["PeerName"] as! String
        }
    }
}

public class DescribeFabricChaincodeLogsResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeFabricChaincodeLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFabricChaincodeLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFabricChaincodeLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFabricChannelConfigRequest : Tea.TeaModel {
    public var channelId: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeFabricChannelConfigResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var absoluteMaxBytes: Int64?

        public var batchTimeout: String?

        public var maxMessageCount: Int64?

        public var preferredMaxBytes: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.absoluteMaxBytes != nil {
                map["AbsoluteMaxBytes"] = self.absoluteMaxBytes!
            }
            if self.batchTimeout != nil {
                map["BatchTimeout"] = self.batchTimeout!
            }
            if self.maxMessageCount != nil {
                map["MaxMessageCount"] = self.maxMessageCount!
            }
            if self.preferredMaxBytes != nil {
                map["PreferredMaxBytes"] = self.preferredMaxBytes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AbsoluteMaxBytes") {
                self.absoluteMaxBytes = dict["AbsoluteMaxBytes"] as! Int64
            }
            if dict.keys.contains("BatchTimeout") {
                self.batchTimeout = dict["BatchTimeout"] as! String
            }
            if dict.keys.contains("MaxMessageCount") {
                self.maxMessageCount = dict["MaxMessageCount"] as! Int64
            }
            if dict.keys.contains("PreferredMaxBytes") {
                self.preferredMaxBytes = dict["PreferredMaxBytes"] as! Int64
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeFabricChannelConfigResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeFabricChannelConfigResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeFabricChannelConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFabricChannelConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFabricChannelConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFabricChannelOrdererRequest : Tea.TeaModel {
    public var channelId: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeFabricChannelOrdererResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var address: String?

        public var certificate: String?

        public var key: String?

        public var tlsroot: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.certificate != nil {
                map["Certificate"] = self.certificate!
            }
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.tlsroot != nil {
                map["Tlsroot"] = self.tlsroot!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("Certificate") {
                self.certificate = dict["Certificate"] as! String
            }
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Tlsroot") {
                self.tlsroot = dict["Tlsroot"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeFabricChannelOrdererResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeFabricChannelOrdererResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeFabricChannelOrdererResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeFabricChannelOrdererResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFabricChannelOrdererResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFabricChannelOrdererResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFabricChannelOrganizationsRequest : Tea.TeaModel {
    public var channelId: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeFabricChannelOrganizationsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class AnchorPeers : Tea.TeaModel {
            public var host: String?

            public var port: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
            }
        }
        public class OrdererNodes : Tea.TeaModel {
            public var address: String?

            public var certificate: String?

            public var key: String?

            public var tlsroot: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.certificate != nil {
                    map["Certificate"] = self.certificate!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.tlsroot != nil {
                    map["Tlsroot"] = self.tlsroot!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("Certificate") {
                    self.certificate = dict["Certificate"] as! String
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Tlsroot") {
                    self.tlsroot = dict["Tlsroot"] as! String
                }
            }
        }
        public var anchorPeers: [DescribeFabricChannelOrganizationsResponseBody.Result.AnchorPeers]?

        public var crls: String?

        public var mspId: String?

        public var mspType: String?

        public var orderer: Bool?

        public var ordererNodes: [DescribeFabricChannelOrganizationsResponseBody.Result.OrdererNodes]?

        public var rootCertificates: String?

        public var tlsRootCertificates: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.anchorPeers != nil {
                var tmp : [Any] = []
                for k in self.anchorPeers! {
                    tmp.append(k.toMap())
                }
                map["AnchorPeers"] = tmp
            }
            if self.crls != nil {
                map["Crls"] = self.crls!
            }
            if self.mspId != nil {
                map["MspId"] = self.mspId!
            }
            if self.mspType != nil {
                map["MspType"] = self.mspType!
            }
            if self.orderer != nil {
                map["Orderer"] = self.orderer!
            }
            if self.ordererNodes != nil {
                var tmp : [Any] = []
                for k in self.ordererNodes! {
                    tmp.append(k.toMap())
                }
                map["OrdererNodes"] = tmp
            }
            if self.rootCertificates != nil {
                map["RootCertificates"] = self.rootCertificates!
            }
            if self.tlsRootCertificates != nil {
                map["TlsRootCertificates"] = self.tlsRootCertificates!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AnchorPeers") {
                var tmp : [DescribeFabricChannelOrganizationsResponseBody.Result.AnchorPeers] = []
                for v in dict["AnchorPeers"] as! [Any] {
                    var model = DescribeFabricChannelOrganizationsResponseBody.Result.AnchorPeers()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.anchorPeers = tmp
            }
            if dict.keys.contains("Crls") {
                self.crls = dict["Crls"] as! String
            }
            if dict.keys.contains("MspId") {
                self.mspId = dict["MspId"] as! String
            }
            if dict.keys.contains("MspType") {
                self.mspType = dict["MspType"] as! String
            }
            if dict.keys.contains("Orderer") {
                self.orderer = dict["Orderer"] as! Bool
            }
            if dict.keys.contains("OrdererNodes") {
                var tmp : [DescribeFabricChannelOrganizationsResponseBody.Result.OrdererNodes] = []
                for v in dict["OrdererNodes"] as! [Any] {
                    var model = DescribeFabricChannelOrganizationsResponseBody.Result.OrdererNodes()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ordererNodes = tmp
            }
            if dict.keys.contains("RootCertificates") {
                self.rootCertificates = dict["RootCertificates"] as! String
            }
            if dict.keys.contains("TlsRootCertificates") {
                self.tlsRootCertificates = dict["TlsRootCertificates"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeFabricChannelOrganizationsResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeFabricChannelOrganizationsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeFabricChannelOrganizationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFabricChannelOrganizationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFabricChannelOrganizationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFabricJoinRequestRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeFabricJoinRequestResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeFabricJoinRequestResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFabricJoinRequestResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFabricJoinRequestResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFabricJoinResponseRequest : Tea.TeaModel {
    public var channelId: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeFabricJoinResponseResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeFabricJoinResponseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFabricJoinResponseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFabricJoinResponseResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFabricManagementChaincodesRequest : Tea.TeaModel {
    public var channelId: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeFabricManagementChaincodesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var input: String?

        public var name: String?

        public var path: Int64?

        public var type: Int32?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.input != nil {
                map["Input"] = self.input!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Input") {
                self.input = dict["Input"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! Int64
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeFabricManagementChaincodesResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeFabricManagementChaincodesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeFabricManagementChaincodesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeFabricManagementChaincodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFabricManagementChaincodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFabricManagementChaincodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFabricOrganizationChaincodePackageRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeFabricOrganizationChaincodePackageResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var message: String?

    public var requestId: String?

    public var result: [String]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String]
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeFabricOrganizationChaincodePackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFabricOrganizationChaincodePackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFabricOrganizationChaincodePackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFabricOrganizationEgressRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeFabricOrganizationEgressResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [String]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String]
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeFabricOrganizationEgressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFabricOrganizationEgressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFabricOrganizationEgressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFabricPeerChannelsRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeFabricPeerChannelsResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [String]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String]
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeFabricPeerChannelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFabricPeerChannelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeFabricPeerChannelsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGovernanceTaskRequest : Tea.TeaModel {
    public var channelId: String?

    public var organizationId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribeGovernanceTaskResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public class AddedOrganizations : Tea.TeaModel {
                public class AnchorPeers : Tea.TeaModel {
                    public var host: String?

                    public var port: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.host != nil {
                            map["Host"] = self.host!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Host") {
                            self.host = dict["Host"] as! String
                        }
                        if dict.keys.contains("Port") {
                            self.port = dict["Port"] as! Int32
                        }
                    }
                }
                public class OrdererNodes : Tea.TeaModel {
                    public var address: String?

                    public var certificate: String?

                    public var key: String?

                    public var tlsroot: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.certificate != nil {
                            map["Certificate"] = self.certificate!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.tlsroot != nil {
                            map["Tlsroot"] = self.tlsroot!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Address") {
                            self.address = dict["Address"] as! String
                        }
                        if dict.keys.contains("Certificate") {
                            self.certificate = dict["Certificate"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Tlsroot") {
                            self.tlsroot = dict["Tlsroot"] as! String
                        }
                    }
                }
                public var anchorPeers: [DescribeGovernanceTaskResponseBody.Result.Content.AddedOrganizations.AnchorPeers]?

                public var crls: String?

                public var mspId: String?

                public var mspType: String?

                public var orderer: Bool?

                public var ordererNodes: [DescribeGovernanceTaskResponseBody.Result.Content.AddedOrganizations.OrdererNodes]?

                public var rootCertificates: String?

                public var tlsRootCertificates: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.anchorPeers != nil {
                        var tmp : [Any] = []
                        for k in self.anchorPeers! {
                            tmp.append(k.toMap())
                        }
                        map["AnchorPeers"] = tmp
                    }
                    if self.crls != nil {
                        map["Crls"] = self.crls!
                    }
                    if self.mspId != nil {
                        map["MspId"] = self.mspId!
                    }
                    if self.mspType != nil {
                        map["MspType"] = self.mspType!
                    }
                    if self.orderer != nil {
                        map["Orderer"] = self.orderer!
                    }
                    if self.ordererNodes != nil {
                        var tmp : [Any] = []
                        for k in self.ordererNodes! {
                            tmp.append(k.toMap())
                        }
                        map["OrdererNodes"] = tmp
                    }
                    if self.rootCertificates != nil {
                        map["RootCertificates"] = self.rootCertificates!
                    }
                    if self.tlsRootCertificates != nil {
                        map["TlsRootCertificates"] = self.tlsRootCertificates!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnchorPeers") {
                        var tmp : [DescribeGovernanceTaskResponseBody.Result.Content.AddedOrganizations.AnchorPeers] = []
                        for v in dict["AnchorPeers"] as! [Any] {
                            var model = DescribeGovernanceTaskResponseBody.Result.Content.AddedOrganizations.AnchorPeers()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.anchorPeers = tmp
                    }
                    if dict.keys.contains("Crls") {
                        self.crls = dict["Crls"] as! String
                    }
                    if dict.keys.contains("MspId") {
                        self.mspId = dict["MspId"] as! String
                    }
                    if dict.keys.contains("MspType") {
                        self.mspType = dict["MspType"] as! String
                    }
                    if dict.keys.contains("Orderer") {
                        self.orderer = dict["Orderer"] as! Bool
                    }
                    if dict.keys.contains("OrdererNodes") {
                        var tmp : [DescribeGovernanceTaskResponseBody.Result.Content.AddedOrganizations.OrdererNodes] = []
                        for v in dict["OrdererNodes"] as! [Any] {
                            var model = DescribeGovernanceTaskResponseBody.Result.Content.AddedOrganizations.OrdererNodes()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ordererNodes = tmp
                    }
                    if dict.keys.contains("RootCertificates") {
                        self.rootCertificates = dict["RootCertificates"] as! String
                    }
                    if dict.keys.contains("TlsRootCertificates") {
                        self.tlsRootCertificates = dict["TlsRootCertificates"] as! String
                    }
                }
            }
            public class ChaincodeSpecPkg : Tea.TeaModel {
                public class Cs : Tea.TeaModel {
                    public var input: String?

                    public var name: String?

                    public var path: String?

                    public var type: Int32?

                    public var version: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.input != nil {
                            map["Input"] = self.input!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.path != nil {
                            map["Path"] = self.path!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.version != nil {
                            map["Version"] = self.version!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Input") {
                            self.input = dict["Input"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Path") {
                            self.path = dict["Path"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! Int32
                        }
                        if dict.keys.contains("Version") {
                            self.version = dict["Version"] as! String
                        }
                    }
                }
                public var cs: DescribeGovernanceTaskResponseBody.Result.Content.ChaincodeSpecPkg.Cs?

                public var policy: String?

                public var sha256: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.cs?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cs != nil {
                        map["Cs"] = self.cs?.toMap()
                    }
                    if self.policy != nil {
                        map["Policy"] = self.policy!
                    }
                    if self.sha256 != nil {
                        map["Sha256"] = self.sha256!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cs") {
                        var model = DescribeGovernanceTaskResponseBody.Result.Content.ChaincodeSpecPkg.Cs()
                        model.fromMap(dict["Cs"] as! [String: Any])
                        self.cs = model
                    }
                    if dict.keys.contains("Policy") {
                        self.policy = dict["Policy"] as! String
                    }
                    if dict.keys.contains("Sha256") {
                        self.sha256 = dict["Sha256"] as! String
                    }
                }
            }
            public class OrdererConfig : Tea.TeaModel {
                public var batchTimeout: String?

                public var maxMessageCount: Int32?

                public var preferredMaxBytes: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.batchTimeout != nil {
                        map["BatchTimeout"] = self.batchTimeout!
                    }
                    if self.maxMessageCount != nil {
                        map["MaxMessageCount"] = self.maxMessageCount!
                    }
                    if self.preferredMaxBytes != nil {
                        map["PreferredMaxBytes"] = self.preferredMaxBytes!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BatchTimeout") {
                        self.batchTimeout = dict["BatchTimeout"] as! String
                    }
                    if dict.keys.contains("MaxMessageCount") {
                        self.maxMessageCount = dict["MaxMessageCount"] as! Int32
                    }
                    if dict.keys.contains("PreferredMaxBytes") {
                        self.preferredMaxBytes = dict["PreferredMaxBytes"] as! Int32
                    }
                }
            }
            public class RemovedOrganizations : Tea.TeaModel {
                public class AnchorPeers : Tea.TeaModel {
                    public var host: String?

                    public var port: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.host != nil {
                            map["Host"] = self.host!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Host") {
                            self.host = dict["Host"] as! String
                        }
                        if dict.keys.contains("Port") {
                            self.port = dict["Port"] as! Int32
                        }
                    }
                }
                public class OrdererNodes : Tea.TeaModel {
                    public var address: String?

                    public var certificate: String?

                    public var key: String?

                    public var tlsroot: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.certificate != nil {
                            map["Certificate"] = self.certificate!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.tlsroot != nil {
                            map["Tlsroot"] = self.tlsroot!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Address") {
                            self.address = dict["Address"] as! String
                        }
                        if dict.keys.contains("Certificate") {
                            self.certificate = dict["Certificate"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Tlsroot") {
                            self.tlsroot = dict["Tlsroot"] as! String
                        }
                    }
                }
                public var anchorPeers: [DescribeGovernanceTaskResponseBody.Result.Content.RemovedOrganizations.AnchorPeers]?

                public var crls: String?

                public var mspId: String?

                public var mspType: String?

                public var orderer: Bool?

                public var ordererNodes: [DescribeGovernanceTaskResponseBody.Result.Content.RemovedOrganizations.OrdererNodes]?

                public var rootCertificates: String?

                public var tlsRootCertificates: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.anchorPeers != nil {
                        var tmp : [Any] = []
                        for k in self.anchorPeers! {
                            tmp.append(k.toMap())
                        }
                        map["AnchorPeers"] = tmp
                    }
                    if self.crls != nil {
                        map["Crls"] = self.crls!
                    }
                    if self.mspId != nil {
                        map["MspId"] = self.mspId!
                    }
                    if self.mspType != nil {
                        map["MspType"] = self.mspType!
                    }
                    if self.orderer != nil {
                        map["Orderer"] = self.orderer!
                    }
                    if self.ordererNodes != nil {
                        var tmp : [Any] = []
                        for k in self.ordererNodes! {
                            tmp.append(k.toMap())
                        }
                        map["OrdererNodes"] = tmp
                    }
                    if self.rootCertificates != nil {
                        map["RootCertificates"] = self.rootCertificates!
                    }
                    if self.tlsRootCertificates != nil {
                        map["TlsRootCertificates"] = self.tlsRootCertificates!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnchorPeers") {
                        var tmp : [DescribeGovernanceTaskResponseBody.Result.Content.RemovedOrganizations.AnchorPeers] = []
                        for v in dict["AnchorPeers"] as! [Any] {
                            var model = DescribeGovernanceTaskResponseBody.Result.Content.RemovedOrganizations.AnchorPeers()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.anchorPeers = tmp
                    }
                    if dict.keys.contains("Crls") {
                        self.crls = dict["Crls"] as! String
                    }
                    if dict.keys.contains("MspId") {
                        self.mspId = dict["MspId"] as! String
                    }
                    if dict.keys.contains("MspType") {
                        self.mspType = dict["MspType"] as! String
                    }
                    if dict.keys.contains("Orderer") {
                        self.orderer = dict["Orderer"] as! Bool
                    }
                    if dict.keys.contains("OrdererNodes") {
                        var tmp : [DescribeGovernanceTaskResponseBody.Result.Content.RemovedOrganizations.OrdererNodes] = []
                        for v in dict["OrdererNodes"] as! [Any] {
                            var model = DescribeGovernanceTaskResponseBody.Result.Content.RemovedOrganizations.OrdererNodes()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ordererNodes = tmp
                    }
                    if dict.keys.contains("RootCertificates") {
                        self.rootCertificates = dict["RootCertificates"] as! String
                    }
                    if dict.keys.contains("TlsRootCertificates") {
                        self.tlsRootCertificates = dict["TlsRootCertificates"] as! String
                    }
                }
            }
            public var addedOrganizations: [DescribeGovernanceTaskResponseBody.Result.Content.AddedOrganizations]?

            public var chaincodeSpecPkg: DescribeGovernanceTaskResponseBody.Result.Content.ChaincodeSpecPkg?

            public var ordererConfig: DescribeGovernanceTaskResponseBody.Result.Content.OrdererConfig?

            public var raw: String?

            public var removedOrganizations: [DescribeGovernanceTaskResponseBody.Result.Content.RemovedOrganizations]?

            public var rwSets: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.chaincodeSpecPkg?.validate()
                try self.ordererConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addedOrganizations != nil {
                    var tmp : [Any] = []
                    for k in self.addedOrganizations! {
                        tmp.append(k.toMap())
                    }
                    map["AddedOrganizations"] = tmp
                }
                if self.chaincodeSpecPkg != nil {
                    map["ChaincodeSpecPkg"] = self.chaincodeSpecPkg?.toMap()
                }
                if self.ordererConfig != nil {
                    map["OrdererConfig"] = self.ordererConfig?.toMap()
                }
                if self.raw != nil {
                    map["Raw"] = self.raw!
                }
                if self.removedOrganizations != nil {
                    var tmp : [Any] = []
                    for k in self.removedOrganizations! {
                        tmp.append(k.toMap())
                    }
                    map["RemovedOrganizations"] = tmp
                }
                if self.rwSets != nil {
                    map["RwSets"] = self.rwSets!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddedOrganizations") {
                    var tmp : [DescribeGovernanceTaskResponseBody.Result.Content.AddedOrganizations] = []
                    for v in dict["AddedOrganizations"] as! [Any] {
                        var model = DescribeGovernanceTaskResponseBody.Result.Content.AddedOrganizations()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.addedOrganizations = tmp
                }
                if dict.keys.contains("ChaincodeSpecPkg") {
                    var model = DescribeGovernanceTaskResponseBody.Result.Content.ChaincodeSpecPkg()
                    model.fromMap(dict["ChaincodeSpecPkg"] as! [String: Any])
                    self.chaincodeSpecPkg = model
                }
                if dict.keys.contains("OrdererConfig") {
                    var model = DescribeGovernanceTaskResponseBody.Result.Content.OrdererConfig()
                    model.fromMap(dict["OrdererConfig"] as! [String: Any])
                    self.ordererConfig = model
                }
                if dict.keys.contains("Raw") {
                    self.raw = dict["Raw"] as! String
                }
                if dict.keys.contains("RemovedOrganizations") {
                    var tmp : [DescribeGovernanceTaskResponseBody.Result.Content.RemovedOrganizations] = []
                    for v in dict["RemovedOrganizations"] as! [Any] {
                        var model = DescribeGovernanceTaskResponseBody.Result.Content.RemovedOrganizations()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.removedOrganizations = tmp
                }
                if dict.keys.contains("RwSets") {
                    self.rwSets = dict["RwSets"] as! String
                }
            }
        }
        public var channelName: String?

        public var content: DescribeGovernanceTaskResponseBody.Result.Content?

        public var createTime: Int64?

        public var creator: String?

        public var description_: String?

        public var status: String?

        public var taskId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.content?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.content != nil {
                map["Content"] = self.content?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("Content") {
                var model = DescribeGovernanceTaskResponseBody.Result.Content()
                model.fromMap(dict["Content"] as! [String: Any])
                self.content = model
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeGovernanceTaskResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeGovernanceTaskResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeGovernanceTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGovernanceTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGovernanceTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGovernanceTasksRequest : Tea.TeaModel {
    public var channelId: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeGovernanceTasksResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public class AddedOrganizations : Tea.TeaModel {
                public class AnchorPeers : Tea.TeaModel {
                    public var host: String?

                    public var port: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.host != nil {
                            map["Host"] = self.host!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Host") {
                            self.host = dict["Host"] as! String
                        }
                        if dict.keys.contains("Port") {
                            self.port = dict["Port"] as! Int32
                        }
                    }
                }
                public class OrdererNodes : Tea.TeaModel {
                    public var address: String?

                    public var certificate: String?

                    public var key: String?

                    public var tlsroot: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.certificate != nil {
                            map["Certificate"] = self.certificate!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.tlsroot != nil {
                            map["Tlsroot"] = self.tlsroot!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Address") {
                            self.address = dict["Address"] as! String
                        }
                        if dict.keys.contains("Certificate") {
                            self.certificate = dict["Certificate"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Tlsroot") {
                            self.tlsroot = dict["Tlsroot"] as! String
                        }
                    }
                }
                public var anchorPeers: [DescribeGovernanceTasksResponseBody.Result.Content.AddedOrganizations.AnchorPeers]?

                public var crls: String?

                public var mspId: String?

                public var mspType: String?

                public var orderer: Bool?

                public var ordererNodes: [DescribeGovernanceTasksResponseBody.Result.Content.AddedOrganizations.OrdererNodes]?

                public var rootCertificates: String?

                public var tlsRootCertificates: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.anchorPeers != nil {
                        var tmp : [Any] = []
                        for k in self.anchorPeers! {
                            tmp.append(k.toMap())
                        }
                        map["AnchorPeers"] = tmp
                    }
                    if self.crls != nil {
                        map["Crls"] = self.crls!
                    }
                    if self.mspId != nil {
                        map["MspId"] = self.mspId!
                    }
                    if self.mspType != nil {
                        map["MspType"] = self.mspType!
                    }
                    if self.orderer != nil {
                        map["Orderer"] = self.orderer!
                    }
                    if self.ordererNodes != nil {
                        var tmp : [Any] = []
                        for k in self.ordererNodes! {
                            tmp.append(k.toMap())
                        }
                        map["OrdererNodes"] = tmp
                    }
                    if self.rootCertificates != nil {
                        map["RootCertificates"] = self.rootCertificates!
                    }
                    if self.tlsRootCertificates != nil {
                        map["TlsRootCertificates"] = self.tlsRootCertificates!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnchorPeers") {
                        var tmp : [DescribeGovernanceTasksResponseBody.Result.Content.AddedOrganizations.AnchorPeers] = []
                        for v in dict["AnchorPeers"] as! [Any] {
                            var model = DescribeGovernanceTasksResponseBody.Result.Content.AddedOrganizations.AnchorPeers()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.anchorPeers = tmp
                    }
                    if dict.keys.contains("Crls") {
                        self.crls = dict["Crls"] as! String
                    }
                    if dict.keys.contains("MspId") {
                        self.mspId = dict["MspId"] as! String
                    }
                    if dict.keys.contains("MspType") {
                        self.mspType = dict["MspType"] as! String
                    }
                    if dict.keys.contains("Orderer") {
                        self.orderer = dict["Orderer"] as! Bool
                    }
                    if dict.keys.contains("OrdererNodes") {
                        var tmp : [DescribeGovernanceTasksResponseBody.Result.Content.AddedOrganizations.OrdererNodes] = []
                        for v in dict["OrdererNodes"] as! [Any] {
                            var model = DescribeGovernanceTasksResponseBody.Result.Content.AddedOrganizations.OrdererNodes()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ordererNodes = tmp
                    }
                    if dict.keys.contains("RootCertificates") {
                        self.rootCertificates = dict["RootCertificates"] as! String
                    }
                    if dict.keys.contains("TlsRootCertificates") {
                        self.tlsRootCertificates = dict["TlsRootCertificates"] as! String
                    }
                }
            }
            public class ChaincodeSpecPkg : Tea.TeaModel {
                public class Cs : Tea.TeaModel {
                    public var input: String?

                    public var name: String?

                    public var path: String?

                    public var type: Int32?

                    public var version: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.input != nil {
                            map["Input"] = self.input!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.path != nil {
                            map["Path"] = self.path!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.version != nil {
                            map["Version"] = self.version!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Input") {
                            self.input = dict["Input"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Path") {
                            self.path = dict["Path"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! Int32
                        }
                        if dict.keys.contains("Version") {
                            self.version = dict["Version"] as! String
                        }
                    }
                }
                public var cs: DescribeGovernanceTasksResponseBody.Result.Content.ChaincodeSpecPkg.Cs?

                public var policy: String?

                public var sha256: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.cs?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cs != nil {
                        map["Cs"] = self.cs?.toMap()
                    }
                    if self.policy != nil {
                        map["Policy"] = self.policy!
                    }
                    if self.sha256 != nil {
                        map["Sha256"] = self.sha256!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cs") {
                        var model = DescribeGovernanceTasksResponseBody.Result.Content.ChaincodeSpecPkg.Cs()
                        model.fromMap(dict["Cs"] as! [String: Any])
                        self.cs = model
                    }
                    if dict.keys.contains("Policy") {
                        self.policy = dict["Policy"] as! String
                    }
                    if dict.keys.contains("Sha256") {
                        self.sha256 = dict["Sha256"] as! String
                    }
                }
            }
            public class OrdererConfig : Tea.TeaModel {
                public var batchTimeout: String?

                public var maxMessageCount: Int32?

                public var preferredMaxBytes: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.batchTimeout != nil {
                        map["BatchTimeout"] = self.batchTimeout!
                    }
                    if self.maxMessageCount != nil {
                        map["MaxMessageCount"] = self.maxMessageCount!
                    }
                    if self.preferredMaxBytes != nil {
                        map["PreferredMaxBytes"] = self.preferredMaxBytes!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BatchTimeout") {
                        self.batchTimeout = dict["BatchTimeout"] as! String
                    }
                    if dict.keys.contains("MaxMessageCount") {
                        self.maxMessageCount = dict["MaxMessageCount"] as! Int32
                    }
                    if dict.keys.contains("PreferredMaxBytes") {
                        self.preferredMaxBytes = dict["PreferredMaxBytes"] as! Int32
                    }
                }
            }
            public class RemovedOrganizations : Tea.TeaModel {
                public class AnchorPeers : Tea.TeaModel {
                    public var host: String?

                    public var port: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.host != nil {
                            map["Host"] = self.host!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Host") {
                            self.host = dict["Host"] as! String
                        }
                        if dict.keys.contains("Port") {
                            self.port = dict["Port"] as! Int32
                        }
                    }
                }
                public class OrdererNodes : Tea.TeaModel {
                    public var address: String?

                    public var certificate: String?

                    public var key: String?

                    public var tlsroot: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.certificate != nil {
                            map["Certificate"] = self.certificate!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.tlsroot != nil {
                            map["Tlsroot"] = self.tlsroot!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Address") {
                            self.address = dict["Address"] as! String
                        }
                        if dict.keys.contains("Certificate") {
                            self.certificate = dict["Certificate"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Tlsroot") {
                            self.tlsroot = dict["Tlsroot"] as! String
                        }
                    }
                }
                public var anchorPeers: [DescribeGovernanceTasksResponseBody.Result.Content.RemovedOrganizations.AnchorPeers]?

                public var crls: String?

                public var mspId: String?

                public var mspType: String?

                public var orderer: Bool?

                public var ordererNodes: [DescribeGovernanceTasksResponseBody.Result.Content.RemovedOrganizations.OrdererNodes]?

                public var rootCertificates: String?

                public var tlsRootCertificates: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.anchorPeers != nil {
                        var tmp : [Any] = []
                        for k in self.anchorPeers! {
                            tmp.append(k.toMap())
                        }
                        map["AnchorPeers"] = tmp
                    }
                    if self.crls != nil {
                        map["Crls"] = self.crls!
                    }
                    if self.mspId != nil {
                        map["MspId"] = self.mspId!
                    }
                    if self.mspType != nil {
                        map["MspType"] = self.mspType!
                    }
                    if self.orderer != nil {
                        map["Orderer"] = self.orderer!
                    }
                    if self.ordererNodes != nil {
                        var tmp : [Any] = []
                        for k in self.ordererNodes! {
                            tmp.append(k.toMap())
                        }
                        map["OrdererNodes"] = tmp
                    }
                    if self.rootCertificates != nil {
                        map["RootCertificates"] = self.rootCertificates!
                    }
                    if self.tlsRootCertificates != nil {
                        map["TlsRootCertificates"] = self.tlsRootCertificates!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnchorPeers") {
                        var tmp : [DescribeGovernanceTasksResponseBody.Result.Content.RemovedOrganizations.AnchorPeers] = []
                        for v in dict["AnchorPeers"] as! [Any] {
                            var model = DescribeGovernanceTasksResponseBody.Result.Content.RemovedOrganizations.AnchorPeers()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.anchorPeers = tmp
                    }
                    if dict.keys.contains("Crls") {
                        self.crls = dict["Crls"] as! String
                    }
                    if dict.keys.contains("MspId") {
                        self.mspId = dict["MspId"] as! String
                    }
                    if dict.keys.contains("MspType") {
                        self.mspType = dict["MspType"] as! String
                    }
                    if dict.keys.contains("Orderer") {
                        self.orderer = dict["Orderer"] as! Bool
                    }
                    if dict.keys.contains("OrdererNodes") {
                        var tmp : [DescribeGovernanceTasksResponseBody.Result.Content.RemovedOrganizations.OrdererNodes] = []
                        for v in dict["OrdererNodes"] as! [Any] {
                            var model = DescribeGovernanceTasksResponseBody.Result.Content.RemovedOrganizations.OrdererNodes()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ordererNodes = tmp
                    }
                    if dict.keys.contains("RootCertificates") {
                        self.rootCertificates = dict["RootCertificates"] as! String
                    }
                    if dict.keys.contains("TlsRootCertificates") {
                        self.tlsRootCertificates = dict["TlsRootCertificates"] as! String
                    }
                }
            }
            public var addedOrganizations: [DescribeGovernanceTasksResponseBody.Result.Content.AddedOrganizations]?

            public var chaincodeSpecPkg: DescribeGovernanceTasksResponseBody.Result.Content.ChaincodeSpecPkg?

            public var ordererConfig: DescribeGovernanceTasksResponseBody.Result.Content.OrdererConfig?

            public var raw: String?

            public var removedOrganizations: [DescribeGovernanceTasksResponseBody.Result.Content.RemovedOrganizations]?

            public var rwSets: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.chaincodeSpecPkg?.validate()
                try self.ordererConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addedOrganizations != nil {
                    var tmp : [Any] = []
                    for k in self.addedOrganizations! {
                        tmp.append(k.toMap())
                    }
                    map["AddedOrganizations"] = tmp
                }
                if self.chaincodeSpecPkg != nil {
                    map["ChaincodeSpecPkg"] = self.chaincodeSpecPkg?.toMap()
                }
                if self.ordererConfig != nil {
                    map["OrdererConfig"] = self.ordererConfig?.toMap()
                }
                if self.raw != nil {
                    map["Raw"] = self.raw!
                }
                if self.removedOrganizations != nil {
                    var tmp : [Any] = []
                    for k in self.removedOrganizations! {
                        tmp.append(k.toMap())
                    }
                    map["RemovedOrganizations"] = tmp
                }
                if self.rwSets != nil {
                    map["RwSets"] = self.rwSets!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddedOrganizations") {
                    var tmp : [DescribeGovernanceTasksResponseBody.Result.Content.AddedOrganizations] = []
                    for v in dict["AddedOrganizations"] as! [Any] {
                        var model = DescribeGovernanceTasksResponseBody.Result.Content.AddedOrganizations()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.addedOrganizations = tmp
                }
                if dict.keys.contains("ChaincodeSpecPkg") {
                    var model = DescribeGovernanceTasksResponseBody.Result.Content.ChaincodeSpecPkg()
                    model.fromMap(dict["ChaincodeSpecPkg"] as! [String: Any])
                    self.chaincodeSpecPkg = model
                }
                if dict.keys.contains("OrdererConfig") {
                    var model = DescribeGovernanceTasksResponseBody.Result.Content.OrdererConfig()
                    model.fromMap(dict["OrdererConfig"] as! [String: Any])
                    self.ordererConfig = model
                }
                if dict.keys.contains("Raw") {
                    self.raw = dict["Raw"] as! String
                }
                if dict.keys.contains("RemovedOrganizations") {
                    var tmp : [DescribeGovernanceTasksResponseBody.Result.Content.RemovedOrganizations] = []
                    for v in dict["RemovedOrganizations"] as! [Any] {
                        var model = DescribeGovernanceTasksResponseBody.Result.Content.RemovedOrganizations()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.removedOrganizations = tmp
                }
                if dict.keys.contains("RwSets") {
                    self.rwSets = dict["RwSets"] as! String
                }
            }
        }
        public var channelName: String?

        public var content: DescribeGovernanceTasksResponseBody.Result.Content?

        public var createTime: Int64?

        public var creator: String?

        public var description_: String?

        public var status: String?

        public var taskId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.content?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.content != nil {
                map["Content"] = self.content?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("Content") {
                var model = DescribeGovernanceTasksResponseBody.Result.Content()
                model.fromMap(dict["Content"] as! [String: Any])
                self.content = model
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeGovernanceTasksResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeGovernanceTasksResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeGovernanceTasksResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeGovernanceTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGovernanceTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGovernanceTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInvitationCodeRequest : Tea.TeaModel {
    public var consortiumId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
    }
}

public class DescribeInvitationCodeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accepted: Bool?

        public var code: String?

        public var consortiumId: String?

        public var email: String?

        public var expireTime: String?

        public var id: Int32?

        public var sendTime: String?

        public var senderBid: String?

        public var senderId: Int64?

        public var senderName: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accepted != nil {
                map["Accepted"] = self.accepted!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.sendTime != nil {
                map["SendTime"] = self.sendTime!
            }
            if self.senderBid != nil {
                map["SenderBid"] = self.senderBid!
            }
            if self.senderId != nil {
                map["SenderId"] = self.senderId!
            }
            if self.senderName != nil {
                map["SenderName"] = self.senderName!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Accepted") {
                self.accepted = dict["Accepted"] as! Bool
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("Email") {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("SendTime") {
                self.sendTime = dict["SendTime"] as! String
            }
            if dict.keys.contains("SenderBid") {
                self.senderBid = dict["SenderBid"] as! String
            }
            if dict.keys.contains("SenderId") {
                self.senderId = dict["SenderId"] as! Int64
            }
            if dict.keys.contains("SenderName") {
                self.senderName = dict["SenderName"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeInvitationCodeResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeInvitationCodeResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeInvitationCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInvitationCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInvitationCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInvitationListRequest : Tea.TeaModel {
    public var consortiumId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
    }
}

public class DescribeInvitationListResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var code: String?

        public var consortiumId: String?

        public var email: String?

        public var expireTime: String?

        public var sendTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.sendTime != nil {
                map["SendTime"] = self.sendTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("Email") {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("SendTime") {
                self.sendTime = dict["SendTime"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeInvitationListResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeInvitationListResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeInvitationListResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeInvitationListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInvitationListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInvitationListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInviterRequest : Tea.TeaModel {
    public var code: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
    }
}

public class DescribeInviterResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consortiumId: String?

        public var consortiumName: String?

        public var expireTime: String?

        public var inviterId: Int64?

        public var inviterName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.consortiumName != nil {
                map["ConsortiumName"] = self.consortiumName!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.inviterId != nil {
                map["InviterId"] = self.inviterId!
            }
            if self.inviterName != nil {
                map["InviterName"] = self.inviterName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("ConsortiumName") {
                self.consortiumName = dict["ConsortiumName"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("InviterId") {
                self.inviterId = dict["InviterId"] as! Int64
            }
            if dict.keys.contains("InviterName") {
                self.inviterName = dict["InviterName"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeInviterResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeInviterResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeInviterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInviterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInviterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLatest15BlocksRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DescribeLatest15BlocksResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [[String: Any]]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [[String: Any]]
        }
    }
}

public class DescribeLatest15BlocksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLatest15BlocksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLatest15BlocksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLatest15TransDigestsRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DescribeLatest15TransDigestsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [[String: Any]]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [[String: Any]]
        }
    }
}

public class DescribeLatest15TransDigestsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLatest15TransDigestsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLatest15TransDigestsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLatestBlocksRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DescribeLatestBlocksResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [[String: Any]]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [[String: Any]]
        }
    }
}

public class DescribeLatestBlocksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLatestBlocksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLatestBlocksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLatestTransactionDigestsRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DescribeLatestTransactionDigestsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [[String: Any]]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [[String: Any]]
        }
    }
}

public class DescribeLatestTransactionDigestsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLatestTransactionDigestsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLatestTransactionDigestsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMemberRoleRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DescribeMemberRoleResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var role: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.role != nil {
                map["Role"] = self.role!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Role") {
                self.role = dict["Role"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var result: DescribeMemberRoleResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeMemberRoleResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeMemberRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMemberRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMemberRoleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMembersRequest : Tea.TeaModel {
    public var bizid: String?

    public var current: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.current != nil {
            map["Current"] = self.current!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Current") {
            self.current = dict["Current"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeMembersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Pagination : Tea.TeaModel {
            public var current: Int32?

            public var pageSize: Int32?

            public var total: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.current != nil {
                    map["Current"] = self.current!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Current") {
                    self.current = dict["Current"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int32
                }
            }
        }
        public var memberList: [String]?

        public var pagination: DescribeMembersResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.memberList != nil {
                map["MemberList"] = self.memberList!
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MemberList") {
                self.memberList = dict["MemberList"] as! [String]
            }
            if dict.keys.contains("Pagination") {
                var model = DescribeMembersResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeMembersResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeMembersResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMetricRequest : Tea.TeaModel {
    public var bizid: String?

    public var innerIp: String?

    public var metric: String?

    public var period: String?

    public var port: String?

    public var timeArea: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.innerIp != nil {
            map["InnerIp"] = self.innerIp!
        }
        if self.metric != nil {
            map["Metric"] = self.metric!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.timeArea != nil {
            map["TimeArea"] = self.timeArea!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("InnerIp") {
            self.innerIp = dict["InnerIp"] as! String
        }
        if dict.keys.contains("Metric") {
            self.metric = dict["Metric"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! String
        }
        if dict.keys.contains("TimeArea") {
            self.timeArea = dict["TimeArea"] as! String
        }
    }
}

public class DescribeMetricResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class DescribeMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMetricResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMyBlockchainsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var bizid: String?

        public var createtime: Int64?

        public var id: Int32?

        public var rejectReason: String?

        public var reqAddr: String?

        public var signedAddr: String?

        public var status: Int32?

        public var updatetime: Int64?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizid != nil {
                map["Bizid"] = self.bizid!
            }
            if self.createtime != nil {
                map["Createtime"] = self.createtime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.rejectReason != nil {
                map["RejectReason"] = self.rejectReason!
            }
            if self.reqAddr != nil {
                map["ReqAddr"] = self.reqAddr!
            }
            if self.signedAddr != nil {
                map["SignedAddr"] = self.signedAddr!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updatetime != nil {
                map["Updatetime"] = self.updatetime!
            }
            if self.username != nil {
                map["Username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bizid") {
                self.bizid = dict["Bizid"] as! String
            }
            if dict.keys.contains("Createtime") {
                self.createtime = dict["Createtime"] as! Int64
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("RejectReason") {
                self.rejectReason = dict["RejectReason"] as! String
            }
            if dict.keys.contains("ReqAddr") {
                self.reqAddr = dict["ReqAddr"] as! String
            }
            if dict.keys.contains("SignedAddr") {
                self.signedAddr = dict["SignedAddr"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Updatetime") {
                self.updatetime = dict["Updatetime"] as! Int64
            }
            if dict.keys.contains("Username") {
                self.username = dict["Username"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [DescribeMyBlockchainsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeMyBlockchainsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeMyBlockchainsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class DescribeMyBlockchainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMyBlockchainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMyBlockchainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMyBlockchanInfosResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class NodeInfoList : Tea.TeaModel {
            public var blockHeight: Int64?

            public var nodeName: String?

            public var status: Bool?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.blockHeight != nil {
                    map["BlockHeight"] = self.blockHeight!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BlockHeight") {
                    self.blockHeight = dict["BlockHeight"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Bool
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var abnormalNodes: Int32?

        public var bizid: String?

        public var blockHeight: Int32?

        public var createTime: Int64?

        public var isRole: Bool?

        public var name: String?

        public var nodeInfoList: [DescribeMyBlockchanInfosResponseBody.Result.NodeInfoList]?

        public var nodeNumber: Int32?

        public var normal: Bool?

        public var transactionSum: Int32?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.abnormalNodes != nil {
                map["AbnormalNodes"] = self.abnormalNodes!
            }
            if self.bizid != nil {
                map["Bizid"] = self.bizid!
            }
            if self.blockHeight != nil {
                map["BlockHeight"] = self.blockHeight!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.isRole != nil {
                map["IsRole"] = self.isRole!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nodeInfoList != nil {
                var tmp : [Any] = []
                for k in self.nodeInfoList! {
                    tmp.append(k.toMap())
                }
                map["NodeInfoList"] = tmp
            }
            if self.nodeNumber != nil {
                map["NodeNumber"] = self.nodeNumber!
            }
            if self.normal != nil {
                map["Normal"] = self.normal!
            }
            if self.transactionSum != nil {
                map["TransactionSum"] = self.transactionSum!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AbnormalNodes") {
                self.abnormalNodes = dict["AbnormalNodes"] as! Int32
            }
            if dict.keys.contains("Bizid") {
                self.bizid = dict["Bizid"] as! String
            }
            if dict.keys.contains("BlockHeight") {
                self.blockHeight = dict["BlockHeight"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("IsRole") {
                self.isRole = dict["IsRole"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NodeInfoList") {
                var tmp : [DescribeMyBlockchanInfosResponseBody.Result.NodeInfoList] = []
                for v in dict["NodeInfoList"] as! [Any] {
                    var model = DescribeMyBlockchanInfosResponseBody.Result.NodeInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodeInfoList = tmp
            }
            if dict.keys.contains("NodeNumber") {
                self.nodeNumber = dict["NodeNumber"] as! Int32
            }
            if dict.keys.contains("Normal") {
                self.normal = dict["Normal"] as! Bool
            }
            if dict.keys.contains("TransactionSum") {
                self.transactionSum = dict["TransactionSum"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [DescribeMyBlockchanInfosResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeMyBlockchanInfosResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeMyBlockchanInfosResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class DescribeMyBlockchanInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMyBlockchanInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMyBlockchanInfosResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMySuccessAppliesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class NodeInfoList : Tea.TeaModel {
            public var blockHeight: Int64?

            public var nodeName: String?

            public var status: Bool?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.blockHeight != nil {
                    map["BlockHeight"] = self.blockHeight!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BlockHeight") {
                    self.blockHeight = dict["BlockHeight"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Bool
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var abnormalNodes: Int32?

        public var bizid: String?

        public var blockHeight: Int32?

        public var createTime: Int64?

        public var isRole: Bool?

        public var name: String?

        public var nodeInfoList: [DescribeMySuccessAppliesResponseBody.Result.NodeInfoList]?

        public var nodeNumber: Int32?

        public var normal: Bool?

        public var transactionSum: Int32?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.abnormalNodes != nil {
                map["AbnormalNodes"] = self.abnormalNodes!
            }
            if self.bizid != nil {
                map["Bizid"] = self.bizid!
            }
            if self.blockHeight != nil {
                map["BlockHeight"] = self.blockHeight!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.isRole != nil {
                map["IsRole"] = self.isRole!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nodeInfoList != nil {
                var tmp : [Any] = []
                for k in self.nodeInfoList! {
                    tmp.append(k.toMap())
                }
                map["NodeInfoList"] = tmp
            }
            if self.nodeNumber != nil {
                map["NodeNumber"] = self.nodeNumber!
            }
            if self.normal != nil {
                map["Normal"] = self.normal!
            }
            if self.transactionSum != nil {
                map["TransactionSum"] = self.transactionSum!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AbnormalNodes") {
                self.abnormalNodes = dict["AbnormalNodes"] as! Int32
            }
            if dict.keys.contains("Bizid") {
                self.bizid = dict["Bizid"] as! String
            }
            if dict.keys.contains("BlockHeight") {
                self.blockHeight = dict["BlockHeight"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("IsRole") {
                self.isRole = dict["IsRole"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NodeInfoList") {
                var tmp : [DescribeMySuccessAppliesResponseBody.Result.NodeInfoList] = []
                for v in dict["NodeInfoList"] as! [Any] {
                    var model = DescribeMySuccessAppliesResponseBody.Result.NodeInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodeInfoList = tmp
            }
            if dict.keys.contains("NodeNumber") {
                self.nodeNumber = dict["NodeNumber"] as! Int32
            }
            if dict.keys.contains("Normal") {
                self.normal = dict["Normal"] as! Bool
            }
            if dict.keys.contains("TransactionSum") {
                self.transactionSum = dict["TransactionSum"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [DescribeMySuccessAppliesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeMySuccessAppliesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeMySuccessAppliesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class DescribeMySuccessAppliesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMySuccessAppliesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMySuccessAppliesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeMySuccessfulApplicationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class NodeInfoList : Tea.TeaModel {
            public var blockHeight: Int64?

            public var nodeName: String?

            public var status: Bool?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.blockHeight != nil {
                    map["BlockHeight"] = self.blockHeight!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BlockHeight") {
                    self.blockHeight = dict["BlockHeight"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Bool
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var abnormalNodes: Int32?

        public var bizid: String?

        public var blockHeight: Int32?

        public var createTime: Int64?

        public var isRole: Bool?

        public var name: String?

        public var nodeInfoList: [DescribeMySuccessfulApplicationResponseBody.Result.NodeInfoList]?

        public var nodeNumber: Int32?

        public var normal: Bool?

        public var transactionSum: Int32?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.abnormalNodes != nil {
                map["AbnormalNodes"] = self.abnormalNodes!
            }
            if self.bizid != nil {
                map["Bizid"] = self.bizid!
            }
            if self.blockHeight != nil {
                map["BlockHeight"] = self.blockHeight!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.isRole != nil {
                map["IsRole"] = self.isRole!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nodeInfoList != nil {
                var tmp : [Any] = []
                for k in self.nodeInfoList! {
                    tmp.append(k.toMap())
                }
                map["NodeInfoList"] = tmp
            }
            if self.nodeNumber != nil {
                map["NodeNumber"] = self.nodeNumber!
            }
            if self.normal != nil {
                map["Normal"] = self.normal!
            }
            if self.transactionSum != nil {
                map["TransactionSum"] = self.transactionSum!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AbnormalNodes") {
                self.abnormalNodes = dict["AbnormalNodes"] as! Int32
            }
            if dict.keys.contains("Bizid") {
                self.bizid = dict["Bizid"] as! String
            }
            if dict.keys.contains("BlockHeight") {
                self.blockHeight = dict["BlockHeight"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("IsRole") {
                self.isRole = dict["IsRole"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NodeInfoList") {
                var tmp : [DescribeMySuccessfulApplicationResponseBody.Result.NodeInfoList] = []
                for v in dict["NodeInfoList"] as! [Any] {
                    var model = DescribeMySuccessfulApplicationResponseBody.Result.NodeInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodeInfoList = tmp
            }
            if dict.keys.contains("NodeNumber") {
                self.nodeNumber = dict["NodeNumber"] as! Int32
            }
            if dict.keys.contains("Normal") {
                self.normal = dict["Normal"] as! Bool
            }
            if dict.keys.contains("TransactionSum") {
                self.transactionSum = dict["TransactionSum"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [DescribeMySuccessfulApplicationResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeMySuccessfulApplicationResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeMySuccessfulApplicationResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class DescribeMySuccessfulApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeMySuccessfulApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeMySuccessfulApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNetstatURLRequest : Tea.TeaModel {
    public var id: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
    }
}

public class DescribeNetstatURLResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeNetstatURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetstatURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNetstatURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOrdererLogsRequest : Tea.TeaModel {
    public var consortiumId: String?

    public var lines: String?

    public var ordererName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.lines != nil {
            map["Lines"] = self.lines!
        }
        if self.ordererName != nil {
            map["OrdererName"] = self.ordererName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("Lines") {
            self.lines = dict["Lines"] as! String
        }
        if dict.keys.contains("OrdererName") {
            self.ordererName = dict["OrdererName"] as! String
        }
    }
}

public class DescribeOrdererLogsResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeOrdererLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOrdererLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOrdererLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOrganizationRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var location: String?

    public var organizationId: String?

    public var tag: [DescribeOrganizationRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeOrganizationRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeOrganizationRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeOrganizationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var CAName: String?

        public var CAUrl: String?

        public var codeName: String?

        public var consortiumCount: Int32?

        public var createTime: String?

        public var description_: String?

        public var domain: String?

        public var expiredTime: String?

        public var MSP: String?

        public var name: String?

        public var organizationId: String?

        public var ownerBid: String?

        public var ownerName: String?

        public var ownerUid: Int64?

        public var peerCount: Int32?

        public var regionId: String?

        public var requestId: String?

        public var specName: String?

        public var state: String?

        public var tags: [DescribeOrganizationResponseBody.Result.Tags]?

        public var userCount: Int32?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.CAName != nil {
                map["CAName"] = self.CAName!
            }
            if self.CAUrl != nil {
                map["CAUrl"] = self.CAUrl!
            }
            if self.codeName != nil {
                map["CodeName"] = self.codeName!
            }
            if self.consortiumCount != nil {
                map["ConsortiumCount"] = self.consortiumCount!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.MSP != nil {
                map["MSP"] = self.MSP!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.ownerBid != nil {
                map["OwnerBid"] = self.ownerBid!
            }
            if self.ownerName != nil {
                map["OwnerName"] = self.ownerName!
            }
            if self.ownerUid != nil {
                map["OwnerUid"] = self.ownerUid!
            }
            if self.peerCount != nil {
                map["PeerCount"] = self.peerCount!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.specName != nil {
                map["SpecName"] = self.specName!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.userCount != nil {
                map["UserCount"] = self.userCount!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CAName") {
                self.CAName = dict["CAName"] as! String
            }
            if dict.keys.contains("CAUrl") {
                self.CAUrl = dict["CAUrl"] as! String
            }
            if dict.keys.contains("CodeName") {
                self.codeName = dict["CodeName"] as! String
            }
            if dict.keys.contains("ConsortiumCount") {
                self.consortiumCount = dict["ConsortiumCount"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("ExpiredTime") {
                self.expiredTime = dict["ExpiredTime"] as! String
            }
            if dict.keys.contains("MSP") {
                self.MSP = dict["MSP"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
            if dict.keys.contains("OwnerBid") {
                self.ownerBid = dict["OwnerBid"] as! String
            }
            if dict.keys.contains("OwnerName") {
                self.ownerName = dict["OwnerName"] as! String
            }
            if dict.keys.contains("OwnerUid") {
                self.ownerUid = dict["OwnerUid"] as! Int64
            }
            if dict.keys.contains("PeerCount") {
                self.peerCount = dict["PeerCount"] as! Int32
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("SpecName") {
                self.specName = dict["SpecName"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeOrganizationResponseBody.Result.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeOrganizationResponseBody.Result.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("UserCount") {
                self.userCount = dict["UserCount"] as! Int32
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeOrganizationResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeOrganizationResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeOrganizationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOrganizationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOrganizationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOrganizationChaincodesRequest : Tea.TeaModel {
    public var location: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeOrganizationChaincodesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var binding: Bool?

        public var chaincodeId: String?

        public var chaincodePackageId: String?

        public var channelId: String?

        public var channelName: String?

        public var consortiumId: String?

        public var createTime: String?

        public var creator: String?

        public var deployTime: String?

        public var endorsePolicy: String?

        public var installed: String?

        public var management: Bool?

        public var message: String?

        public var name: String?

        public var state: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.binding != nil {
                map["Binding"] = self.binding!
            }
            if self.chaincodeId != nil {
                map["ChaincodeId"] = self.chaincodeId!
            }
            if self.chaincodePackageId != nil {
                map["ChaincodePackageId"] = self.chaincodePackageId!
            }
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.deployTime != nil {
                map["DeployTime"] = self.deployTime!
            }
            if self.endorsePolicy != nil {
                map["EndorsePolicy"] = self.endorsePolicy!
            }
            if self.installed != nil {
                map["Installed"] = self.installed!
            }
            if self.management != nil {
                map["Management"] = self.management!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Binding") {
                self.binding = dict["Binding"] as! Bool
            }
            if dict.keys.contains("ChaincodeId") {
                self.chaincodeId = dict["ChaincodeId"] as! String
            }
            if dict.keys.contains("ChaincodePackageId") {
                self.chaincodePackageId = dict["ChaincodePackageId"] as! String
            }
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("DeployTime") {
                self.deployTime = dict["DeployTime"] as! String
            }
            if dict.keys.contains("EndorsePolicy") {
                self.endorsePolicy = dict["EndorsePolicy"] as! String
            }
            if dict.keys.contains("Installed") {
                self.installed = dict["Installed"] as! String
            }
            if dict.keys.contains("Management") {
                self.management = dict["Management"] as! Bool
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeOrganizationChaincodesResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeOrganizationChaincodesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeOrganizationChaincodesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeOrganizationChaincodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOrganizationChaincodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOrganizationChaincodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOrganizationChannelsRequest : Tea.TeaModel {
    public var location: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeOrganizationChannelsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var batchTimeout: Int32?

        public var blockCount: Int32?

        public var chaincodeCount: Int32?

        public var channelId: String?

        public var consortiumId: String?

        public var consortiumName: String?

        public var createTime: String?

        public var deleteTime: String?

        public var deleted: Bool?

        public var hybird: Bool?

        public var maxMessageCount: Int32?

        public var memberCount: Int32?

        public var name: String?

        public var ownerBid: String?

        public var ownerName: String?

        public var ownerUid: Int32?

        public var preferredMaxBytes: Int32?

        public var requestId: String?

        public var state: String?

        public var supportChannelConfig: Bool?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.batchTimeout != nil {
                map["BatchTimeout"] = self.batchTimeout!
            }
            if self.blockCount != nil {
                map["BlockCount"] = self.blockCount!
            }
            if self.chaincodeCount != nil {
                map["ChaincodeCount"] = self.chaincodeCount!
            }
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.consortiumName != nil {
                map["ConsortiumName"] = self.consortiumName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.deleteTime != nil {
                map["DeleteTime"] = self.deleteTime!
            }
            if self.deleted != nil {
                map["Deleted"] = self.deleted!
            }
            if self.hybird != nil {
                map["Hybird"] = self.hybird!
            }
            if self.maxMessageCount != nil {
                map["MaxMessageCount"] = self.maxMessageCount!
            }
            if self.memberCount != nil {
                map["MemberCount"] = self.memberCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ownerBid != nil {
                map["OwnerBid"] = self.ownerBid!
            }
            if self.ownerName != nil {
                map["OwnerName"] = self.ownerName!
            }
            if self.ownerUid != nil {
                map["OwnerUid"] = self.ownerUid!
            }
            if self.preferredMaxBytes != nil {
                map["PreferredMaxBytes"] = self.preferredMaxBytes!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.supportChannelConfig != nil {
                map["SupportChannelConfig"] = self.supportChannelConfig!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BatchTimeout") {
                self.batchTimeout = dict["BatchTimeout"] as! Int32
            }
            if dict.keys.contains("BlockCount") {
                self.blockCount = dict["BlockCount"] as! Int32
            }
            if dict.keys.contains("ChaincodeCount") {
                self.chaincodeCount = dict["ChaincodeCount"] as! Int32
            }
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("ConsortiumName") {
                self.consortiumName = dict["ConsortiumName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DeleteTime") {
                self.deleteTime = dict["DeleteTime"] as! String
            }
            if dict.keys.contains("Deleted") {
                self.deleted = dict["Deleted"] as! Bool
            }
            if dict.keys.contains("Hybird") {
                self.hybird = dict["Hybird"] as! Bool
            }
            if dict.keys.contains("MaxMessageCount") {
                self.maxMessageCount = dict["MaxMessageCount"] as! Int32
            }
            if dict.keys.contains("MemberCount") {
                self.memberCount = dict["MemberCount"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OwnerBid") {
                self.ownerBid = dict["OwnerBid"] as! String
            }
            if dict.keys.contains("OwnerName") {
                self.ownerName = dict["OwnerName"] as! String
            }
            if dict.keys.contains("OwnerUid") {
                self.ownerUid = dict["OwnerUid"] as! Int32
            }
            if dict.keys.contains("PreferredMaxBytes") {
                self.preferredMaxBytes = dict["PreferredMaxBytes"] as! Int32
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("SupportChannelConfig") {
                self.supportChannelConfig = dict["SupportChannelConfig"] as! Bool
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeOrganizationChannelsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeOrganizationChannelsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeOrganizationChannelsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeOrganizationChannelsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOrganizationChannelsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOrganizationChannelsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOrganizationDeletableRequest : Tea.TeaModel {
    public var location: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeOrganizationDeletableResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var codeName: String?

        public var deletable: Bool?

        public var description_: String?

        public var domain: String?

        public var name: String?

        public var organizationId: String?

        public var regionId: String?

        public var state: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.codeName != nil {
                map["CodeName"] = self.codeName!
            }
            if self.deletable != nil {
                map["Deletable"] = self.deletable!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CodeName") {
                self.codeName = dict["CodeName"] as! String
            }
            if dict.keys.contains("Deletable") {
                self.deletable = dict["Deletable"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeOrganizationDeletableResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeOrganizationDeletableResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeOrganizationDeletableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOrganizationDeletableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOrganizationDeletableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOrganizationMembersRequest : Tea.TeaModel {
    public var location: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeOrganizationMembersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consortiumId: String?

        public var consortiumName: String?

        public var description_: String?

        public var domain: String?

        public var id: String?

        public var joinedTime: String?

        public var name: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.consortiumName != nil {
                map["ConsortiumName"] = self.consortiumName!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.joinedTime != nil {
                map["JoinedTime"] = self.joinedTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("ConsortiumName") {
                self.consortiumName = dict["ConsortiumName"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("JoinedTime") {
                self.joinedTime = dict["JoinedTime"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeOrganizationMembersResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeOrganizationMembersResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeOrganizationMembersResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeOrganizationMembersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOrganizationMembersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOrganizationMembersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOrganizationPeersRequest : Tea.TeaModel {
    public var location: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeOrganizationPeersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createTime: String?

        public var domain: String?

        public var instanceType: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var isAnchor: Bool?

        public var name: String?

        public var port: Int32?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.isAnchor != nil {
                map["IsAnchor"] = self.isAnchor!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("InternetIp") {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("IsAnchor") {
                self.isAnchor = dict["IsAnchor"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeOrganizationPeersResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeOrganizationPeersResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeOrganizationPeersResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeOrganizationPeersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOrganizationPeersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOrganizationPeersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOrganizationSpecsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var enable: Bool?

        public var name: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeOrganizationSpecsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeOrganizationSpecsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeOrganizationSpecsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeOrganizationSpecsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOrganizationSpecsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOrganizationSpecsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOrganizationTriggersRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeOrganizationTriggersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Checkpoint : Tea.TeaModel {
            public var errorCount: Int64?

            public var height: Int64?

            public var index: Int64?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCount != nil {
                    map["ErrorCount"] = self.errorCount!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCount") {
                    self.errorCount = dict["ErrorCount"] as! Int64
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int64
                }
                if dict.keys.contains("Index") {
                    self.index = dict["Index"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var channelId: String?

        public var channelName: String?

        public var checkpoint: DescribeOrganizationTriggersResponseBody.Result.Checkpoint?

        public var createTime: Int64?

        public var errorMessage: String?

        public var name: String?

        public var options: String?

        public var source: String?

        public var status: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkpoint?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.checkpoint != nil {
                map["Checkpoint"] = self.checkpoint?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.options != nil {
                map["Options"] = self.options!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("Checkpoint") {
                var model = DescribeOrganizationTriggersResponseBody.Result.Checkpoint()
                model.fromMap(dict["Checkpoint"] as! [String: Any])
                self.checkpoint = model
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Options") {
                self.options = dict["Options"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeOrganizationTriggersResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeOrganizationTriggersResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeOrganizationTriggersResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeOrganizationTriggersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOrganizationTriggersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOrganizationTriggersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOrganizationUserCertsRequest : Tea.TeaModel {
    public var organizationId: String?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("Username") {
            self.username = dict["Username"] as! String
        }
    }
}

public class DescribeOrganizationUserCertsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Certificates : Tea.TeaModel {
            public var certData: String?

            public var issuer: String?

            public var name: String?

            public var scope: String?

            public var subject: String?

            public var validFrom: String?

            public var validTo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.certData != nil {
                    map["CertData"] = self.certData!
                }
                if self.issuer != nil {
                    map["Issuer"] = self.issuer!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.scope != nil {
                    map["Scope"] = self.scope!
                }
                if self.subject != nil {
                    map["Subject"] = self.subject!
                }
                if self.validFrom != nil {
                    map["ValidFrom"] = self.validFrom!
                }
                if self.validTo != nil {
                    map["ValidTo"] = self.validTo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CertData") {
                    self.certData = dict["CertData"] as! String
                }
                if dict.keys.contains("Issuer") {
                    self.issuer = dict["Issuer"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Scope") {
                    self.scope = dict["Scope"] as! String
                }
                if dict.keys.contains("Subject") {
                    self.subject = dict["Subject"] as! String
                }
                if dict.keys.contains("ValidFrom") {
                    self.validFrom = dict["ValidFrom"] as! String
                }
                if dict.keys.contains("ValidTo") {
                    self.validTo = dict["ValidTo"] as! String
                }
            }
        }
        public class KeyPair : Tea.TeaModel {
            public var privateKey: String?

            public var publicKey: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.privateKey != nil {
                    map["PrivateKey"] = self.privateKey!
                }
                if self.publicKey != nil {
                    map["PublicKey"] = self.publicKey!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PrivateKey") {
                    self.privateKey = dict["PrivateKey"] as! String
                }
                if dict.keys.contains("PublicKey") {
                    self.publicKey = dict["PublicKey"] as! String
                }
            }
        }
        public var certificates: [DescribeOrganizationUserCertsResponseBody.Result.Certificates]?

        public var keyPair: DescribeOrganizationUserCertsResponseBody.Result.KeyPair?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.keyPair?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certificates != nil {
                var tmp : [Any] = []
                for k in self.certificates! {
                    tmp.append(k.toMap())
                }
                map["Certificates"] = tmp
            }
            if self.keyPair != nil {
                map["KeyPair"] = self.keyPair?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Certificates") {
                var tmp : [DescribeOrganizationUserCertsResponseBody.Result.Certificates] = []
                for v in dict["Certificates"] as! [Any] {
                    var model = DescribeOrganizationUserCertsResponseBody.Result.Certificates()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.certificates = tmp
            }
            if dict.keys.contains("KeyPair") {
                var model = DescribeOrganizationUserCertsResponseBody.Result.KeyPair()
                model.fromMap(dict["KeyPair"] as! [String: Any])
                self.keyPair = model
            }
        }
    }
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeOrganizationUserCertsResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeOrganizationUserCertsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeOrganizationUserCertsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOrganizationUserCertsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOrganizationUserCertsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOrganizationUsersRequest : Tea.TeaModel {
    public var location: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeOrganizationUsersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var attrs: String?

        public var callerBid: String?

        public var callerUid: Int64?

        public var createTime: String?

        public var expireTime: String?

        public var fullName: String?

        public var organizationId: String?

        public var regionId: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attrs != nil {
                map["Attrs"] = self.attrs!
            }
            if self.callerBid != nil {
                map["CallerBid"] = self.callerBid!
            }
            if self.callerUid != nil {
                map["CallerUid"] = self.callerUid!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.fullName != nil {
                map["FullName"] = self.fullName!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.username != nil {
                map["Username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Attrs") {
                self.attrs = dict["Attrs"] as! String
            }
            if dict.keys.contains("CallerBid") {
                self.callerBid = dict["CallerBid"] as! String
            }
            if dict.keys.contains("CallerUid") {
                self.callerUid = dict["CallerUid"] as! Int64
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("FullName") {
                self.fullName = dict["FullName"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Username") {
                self.username = dict["Username"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeOrganizationUsersResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeOrganizationUsersResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeOrganizationUsersResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeOrganizationUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOrganizationUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOrganizationUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOrganizationsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var location: String?

    public var tag: [DescribeOrganizationsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeOrganizationsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeOrganizationsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeOrganizationsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var codeName: String?

        public var consortiumCount: Int32?

        public var createTime: String?

        public var description_: String?

        public var domain: String?

        public var expireState: String?

        public var expiredTime: String?

        public var hybrid: Bool?

        public var majorVersion: String?

        public var name: String?

        public var organizationId: String?

        public var ownerBid: String?

        public var ownerName: String?

        public var ownerUid: Int64?

        public var peerCount: Int32?

        public var regionId: String?

        public var requestId: String?

        public var specName: String?

        public var state: String?

        public var tags: [DescribeOrganizationsResponseBody.Result.Tags]?

        public var userCount: Int32?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.codeName != nil {
                map["CodeName"] = self.codeName!
            }
            if self.consortiumCount != nil {
                map["ConsortiumCount"] = self.consortiumCount!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.expireState != nil {
                map["ExpireState"] = self.expireState!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.hybrid != nil {
                map["Hybrid"] = self.hybrid!
            }
            if self.majorVersion != nil {
                map["MajorVersion"] = self.majorVersion!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.ownerBid != nil {
                map["OwnerBid"] = self.ownerBid!
            }
            if self.ownerName != nil {
                map["OwnerName"] = self.ownerName!
            }
            if self.ownerUid != nil {
                map["OwnerUid"] = self.ownerUid!
            }
            if self.peerCount != nil {
                map["PeerCount"] = self.peerCount!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.specName != nil {
                map["SpecName"] = self.specName!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.userCount != nil {
                map["UserCount"] = self.userCount!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CodeName") {
                self.codeName = dict["CodeName"] as! String
            }
            if dict.keys.contains("ConsortiumCount") {
                self.consortiumCount = dict["ConsortiumCount"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("ExpireState") {
                self.expireState = dict["ExpireState"] as! String
            }
            if dict.keys.contains("ExpiredTime") {
                self.expiredTime = dict["ExpiredTime"] as! String
            }
            if dict.keys.contains("Hybrid") {
                self.hybrid = dict["Hybrid"] as! Bool
            }
            if dict.keys.contains("MajorVersion") {
                self.majorVersion = dict["MajorVersion"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
            if dict.keys.contains("OwnerBid") {
                self.ownerBid = dict["OwnerBid"] as! String
            }
            if dict.keys.contains("OwnerName") {
                self.ownerName = dict["OwnerName"] as! String
            }
            if dict.keys.contains("OwnerUid") {
                self.ownerUid = dict["OwnerUid"] as! Int64
            }
            if dict.keys.contains("PeerCount") {
                self.peerCount = dict["PeerCount"] as! Int32
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("SpecName") {
                self.specName = dict["SpecName"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeOrganizationsResponseBody.Result.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeOrganizationsResponseBody.Result.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("UserCount") {
                self.userCount = dict["UserCount"] as! Int32
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeOrganizationsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeOrganizationsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeOrganizationsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeOrganizationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOrganizationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOrganizationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOrgnaizationChaincodesRequest : Tea.TeaModel {
    public var location: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeOrgnaizationChaincodesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var chaincodeId: String?

        public var channelId: String?

        public var channelName: String?

        public var createTime: String?

        public var creator: String?

        public var deployTime: String?

        public var endorsePolicy: String?

        public var installed: String?

        public var message: String?

        public var name: String?

        public var state: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chaincodeId != nil {
                map["ChaincodeId"] = self.chaincodeId!
            }
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.deployTime != nil {
                map["DeployTime"] = self.deployTime!
            }
            if self.endorsePolicy != nil {
                map["EndorsePolicy"] = self.endorsePolicy!
            }
            if self.installed != nil {
                map["Installed"] = self.installed!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChaincodeId") {
                self.chaincodeId = dict["ChaincodeId"] as! String
            }
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("DeployTime") {
                self.deployTime = dict["DeployTime"] as! String
            }
            if dict.keys.contains("EndorsePolicy") {
                self.endorsePolicy = dict["EndorsePolicy"] as! String
            }
            if dict.keys.contains("Installed") {
                self.installed = dict["Installed"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeOrgnaizationChaincodesResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeOrgnaizationChaincodesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeOrgnaizationChaincodesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeOrgnaizationChaincodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOrgnaizationChaincodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOrgnaizationChaincodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeOssPropertiesRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DescribeOssPropertiesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessKeyId: String?

        public var accessKeySecret: String?

        public var bucketName: String?

        public var endpoint: String?

        public var folderName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessKeyId != nil {
                map["AccessKeyId"] = self.accessKeyId!
            }
            if self.accessKeySecret != nil {
                map["AccessKeySecret"] = self.accessKeySecret!
            }
            if self.bucketName != nil {
                map["BucketName"] = self.bucketName!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.folderName != nil {
                map["FolderName"] = self.folderName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessKeyId") {
                self.accessKeyId = dict["AccessKeyId"] as! String
            }
            if dict.keys.contains("AccessKeySecret") {
                self.accessKeySecret = dict["AccessKeySecret"] as! String
            }
            if dict.keys.contains("BucketName") {
                self.bucketName = dict["BucketName"] as! String
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("FolderName") {
                self.folderName = dict["FolderName"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeOssPropertiesResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeOssPropertiesResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeOssPropertiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOssPropertiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeOssPropertiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePeerLogsRequest : Tea.TeaModel {
    public var lines: String?

    public var organizationId: String?

    public var peerName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lines != nil {
            map["Lines"] = self.lines!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.peerName != nil {
            map["PeerName"] = self.peerName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Lines") {
            self.lines = dict["Lines"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("PeerName") {
            self.peerName = dict["PeerName"] as! String
        }
    }
}

public class DescribePeerLogsResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribePeerLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePeerLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePeerLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePublicAntChainContractProjectContentTreeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var children: [[String: Any]]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.children != nil {
                map["Children"] = self.children!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Children") {
                self.children = dict["Children"] as! [[String: Any]]
            }
        }
    }
    public var requestId: String?

    public var result: DescribePublicAntChainContractProjectContentTreeResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribePublicAntChainContractProjectContentTreeResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribePublicAntChainContractProjectContentTreeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePublicAntChainContractProjectContentTreeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePublicAntChainContractProjectContentTreeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePublicAntChainDownloadPathsRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DescribePublicAntChainDownloadPathsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var caCrtUrl: String?

        public var clientCrtUrl: String?

        public var sdkUrl: String?

        public var trustCaUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.caCrtUrl != nil {
                map["CaCrtUrl"] = self.caCrtUrl!
            }
            if self.clientCrtUrl != nil {
                map["ClientCrtUrl"] = self.clientCrtUrl!
            }
            if self.sdkUrl != nil {
                map["SdkUrl"] = self.sdkUrl!
            }
            if self.trustCaUrl != nil {
                map["TrustCaUrl"] = self.trustCaUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CaCrtUrl") {
                self.caCrtUrl = dict["CaCrtUrl"] as! String
            }
            if dict.keys.contains("ClientCrtUrl") {
                self.clientCrtUrl = dict["ClientCrtUrl"] as! String
            }
            if dict.keys.contains("SdkUrl") {
                self.sdkUrl = dict["SdkUrl"] as! String
            }
            if dict.keys.contains("TrustCaUrl") {
                self.trustCaUrl = dict["TrustCaUrl"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribePublicAntChainDownloadPathsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribePublicAntChainDownloadPathsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribePublicAntChainDownloadPathsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePublicAntChainDownloadPathsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePublicAntChainDownloadPathsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePublicCloudIDEEnvConfigsRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DescribePublicCloudIDEEnvConfigsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var bizid: String?

        public var name: String?

        public var trialAccount: String?

        public var trialAccountPrivateKey: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizid != nil {
                map["Bizid"] = self.bizid!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.trialAccount != nil {
                map["TrialAccount"] = self.trialAccount!
            }
            if self.trialAccountPrivateKey != nil {
                map["TrialAccountPrivateKey"] = self.trialAccountPrivateKey!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bizid") {
                self.bizid = dict["Bizid"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("TrialAccount") {
                self.trialAccount = dict["TrialAccount"] as! String
            }
            if dict.keys.contains("TrialAccountPrivateKey") {
                self.trialAccountPrivateKey = dict["TrialAccountPrivateKey"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [DescribePublicCloudIDEEnvConfigsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribePublicCloudIDEEnvConfigsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribePublicCloudIDEEnvConfigsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class DescribePublicCloudIDEEnvConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePublicCloudIDEEnvConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePublicCloudIDEEnvConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeQRCodeAccessLogRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DescribeQRCodeAccessLogResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessAlipayAccountCount: Int64?

        public var accessCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessAlipayAccountCount != nil {
                map["AccessAlipayAccountCount"] = self.accessAlipayAccountCount!
            }
            if self.accessCount != nil {
                map["AccessCount"] = self.accessCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessAlipayAccountCount") {
                self.accessAlipayAccountCount = dict["AccessAlipayAccountCount"] as! Int64
            }
            if dict.keys.contains("AccessCount") {
                self.accessCount = dict["AccessCount"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var result: DescribeQRCodeAccessLogResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeQRCodeAccessLogResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeQRCodeAccessLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeQRCodeAccessLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeQRCodeAccessLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeQRCodeAuthorityRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DescribeQRCodeAuthorityResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class DescribeQRCodeAuthorityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeQRCodeAuthorityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeQRCodeAuthorityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRegionsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var id: Int32?

        public var online: Bool?

        public var regionId: String?

        public var title: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.online != nil {
                map["Online"] = self.online!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("Online") {
                self.online = dict["Online"] as! Bool
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeRegionsResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeRegionsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeRegionsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRegionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeResourceTypeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var cpu: Int32?

        public var disk: Int32?

        public var memory: Int32?

        public var typeId: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.disk != nil {
                map["Disk"] = self.disk!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.typeId != nil {
                map["TypeId"] = self.typeId!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("Disk") {
                self.disk = dict["Disk"] as! Int32
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Int32
            }
            if dict.keys.contains("TypeId") {
                self.typeId = dict["TypeId"] as! Int32
            }
            if dict.keys.contains("TypeName") {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [DescribeResourceTypeResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeResourceTypeResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeResourceTypeResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class DescribeResourceTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResourceTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeResourceTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeResourceTypesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var cpu: Int32?

        public var disk: Int32?

        public var memory: Int32?

        public var typeId: Int32?

        public var typeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.disk != nil {
                map["Disk"] = self.disk!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.typeId != nil {
                map["TypeId"] = self.typeId!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("Disk") {
                self.disk = dict["Disk"] as! Int32
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Int32
            }
            if dict.keys.contains("TypeId") {
                self.typeId = dict["TypeId"] as! Int32
            }
            if dict.keys.contains("TypeName") {
                self.typeName = dict["TypeName"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [DescribeResourceTypesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeResourceTypesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeResourceTypesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class DescribeResourceTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResourceTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeResourceTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRootDomainResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeRootDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRootDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRootDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSchemaDetailRequest : Tea.TeaModel {
    public var bizid: String?

    public var schemaId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! Int64
        }
    }
}

public class DescribeSchemaDetailResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Responses : Tea.TeaModel {
            public class Properties : Tea.TeaModel {
                public class DataSource : Tea.TeaModel {
                    public var allowNull: Int32?

                    public var annotation: String?

                    public var field: String?

                    public var indexes: Int32?

                    public var key: Int32?

                    public var length: Int32?

                    public var reg: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.allowNull != nil {
                            map["AllowNull"] = self.allowNull!
                        }
                        if self.annotation != nil {
                            map["Annotation"] = self.annotation!
                        }
                        if self.field != nil {
                            map["Field"] = self.field!
                        }
                        if self.indexes != nil {
                            map["Indexes"] = self.indexes!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.length != nil {
                            map["Length"] = self.length!
                        }
                        if self.reg != nil {
                            map["Reg"] = self.reg!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AllowNull") {
                            self.allowNull = dict["AllowNull"] as! Int32
                        }
                        if dict.keys.contains("Annotation") {
                            self.annotation = dict["Annotation"] as! String
                        }
                        if dict.keys.contains("Field") {
                            self.field = dict["Field"] as! String
                        }
                        if dict.keys.contains("Indexes") {
                            self.indexes = dict["Indexes"] as! Int32
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! Int32
                        }
                        if dict.keys.contains("Length") {
                            self.length = dict["Length"] as! Int32
                        }
                        if dict.keys.contains("Reg") {
                            self.reg = dict["Reg"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var count: Int32?

                public var dataSource: [DescribeSchemaDetailResponseBody.Result.Responses.Properties.DataSource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.dataSource != nil {
                        var tmp : [Any] = []
                        for k in self.dataSource! {
                            tmp.append(k.toMap())
                        }
                        map["DataSource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int32
                    }
                    if dict.keys.contains("DataSource") {
                        var tmp : [DescribeSchemaDetailResponseBody.Result.Responses.Properties.DataSource] = []
                        for v in dict["DataSource"] as! [Any] {
                            var model = DescribeSchemaDetailResponseBody.Result.Responses.Properties.DataSource()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dataSource = tmp
                    }
                }
            }
            public var category: String?

            public var categoryName: String?

            public var description_: String?

            public var properties: DescribeSchemaDetailResponseBody.Result.Responses.Properties?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.properties?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.categoryName != nil {
                    map["CategoryName"] = self.categoryName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.properties != nil {
                    map["Properties"] = self.properties?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CategoryName") {
                    self.categoryName = dict["CategoryName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Properties") {
                    var model = DescribeSchemaDetailResponseBody.Result.Responses.Properties()
                    model.fromMap(dict["Properties"] as! [String: Any])
                    self.properties = model
                }
            }
        }
        public class Schema : Tea.TeaModel {
            public var createTime: Int64?

            public var description_: String?

            public var id: Int64?

            public var isTemplate: Bool?

            public var name: String?

            public var updateTime: Int64?

            public var version: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isTemplate != nil {
                    map["IsTemplate"] = self.isTemplate!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IsTemplate") {
                    self.isTemplate = dict["IsTemplate"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! Int64
                }
            }
        }
        public var responses: [DescribeSchemaDetailResponseBody.Result.Responses]?

        public var schema: DescribeSchemaDetailResponseBody.Result.Schema?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.schema?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.responses != nil {
                var tmp : [Any] = []
                for k in self.responses! {
                    tmp.append(k.toMap())
                }
                map["Responses"] = tmp
            }
            if self.schema != nil {
                map["Schema"] = self.schema?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Responses") {
                var tmp : [DescribeSchemaDetailResponseBody.Result.Responses] = []
                for v in dict["Responses"] as! [Any] {
                    var model = DescribeSchemaDetailResponseBody.Result.Responses()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.responses = tmp
            }
            if dict.keys.contains("Schema") {
                var model = DescribeSchemaDetailResponseBody.Result.Schema()
                model.fromMap(dict["Schema"] as! [String: Any])
                self.schema = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeSchemaDetailResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeSchemaDetailResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeSchemaDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSchemaDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSchemaDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSmartContractJobStatusRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DescribeSmartContractJobStatusResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeSmartContractJobStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSmartContractJobStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSmartContractJobStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSmartContractJobsRequest : Tea.TeaModel {
    public var size: Int32?

    public var start: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int32
        }
        if dict.keys.contains("Start") {
            self.start = dict["Start"] as! Int32
        }
    }
}

public class DescribeSmartContractJobsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public var createTime: Int64?

            public var finishedTime: Int64?

            public var jobId: String?

            public var name: String?

            public var sourceType: String?

            public var status: String?

            public var userBid: String?

            public var userId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.finishedTime != nil {
                    map["FinishedTime"] = self.finishedTime!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.userBid != nil {
                    map["UserBid"] = self.userBid!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("FinishedTime") {
                    self.finishedTime = dict["FinishedTime"] as! Int64
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("SourceType") {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("UserBid") {
                    self.userBid = dict["UserBid"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! Int64
                }
            }
        }
        public var content: [DescribeSmartContractJobsResponseBody.Result.Content]?

        public var first: Bool?

        public var last: Bool?

        public var numberOfElements: Int32?

        public var size: Int32?

        public var totalElements: Int32?

        public var totalPages: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                var tmp : [Any] = []
                for k in self.content! {
                    tmp.append(k.toMap())
                }
                map["Content"] = tmp
            }
            if self.first != nil {
                map["First"] = self.first!
            }
            if self.last != nil {
                map["Last"] = self.last!
            }
            if self.numberOfElements != nil {
                map["NumberOfElements"] = self.numberOfElements!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.totalElements != nil {
                map["TotalElements"] = self.totalElements!
            }
            if self.totalPages != nil {
                map["TotalPages"] = self.totalPages!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                var tmp : [DescribeSmartContractJobsResponseBody.Result.Content] = []
                for v in dict["Content"] as! [Any] {
                    var model = DescribeSmartContractJobsResponseBody.Result.Content()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.content = tmp
            }
            if dict.keys.contains("First") {
                self.first = dict["First"] as! Bool
            }
            if dict.keys.contains("Last") {
                self.last = dict["Last"] as! Bool
            }
            if dict.keys.contains("NumberOfElements") {
                self.numberOfElements = dict["NumberOfElements"] as! Int32
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("TotalElements") {
                self.totalElements = dict["TotalElements"] as! Int32
            }
            if dict.keys.contains("TotalPages") {
                self.totalPages = dict["TotalPages"] as! Int32
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeSmartContractJobsResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeSmartContractJobsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeSmartContractJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSmartContractJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSmartContractJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSmartContractJobsByNameRequest : Tea.TeaModel {
    public var name: String?

    public var size: Int32?

    public var start: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int32
        }
        if dict.keys.contains("Start") {
            self.start = dict["Start"] as! Int32
        }
    }
}

public class DescribeSmartContractJobsByNameResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public var createTime: Int64?

            public var finishedTime: Int64?

            public var jobId: String?

            public var name: String?

            public var sourceType: String?

            public var status: String?

            public var userBid: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.finishedTime != nil {
                    map["FinishedTime"] = self.finishedTime!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.sourceType != nil {
                    map["SourceType"] = self.sourceType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.userBid != nil {
                    map["UserBid"] = self.userBid!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("FinishedTime") {
                    self.finishedTime = dict["FinishedTime"] as! Int64
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("SourceType") {
                    self.sourceType = dict["SourceType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("UserBid") {
                    self.userBid = dict["UserBid"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var content: [DescribeSmartContractJobsByNameResponseBody.Result.Content]?

        public var first: Bool?

        public var last: Bool?

        public var numberOfElements: Int32?

        public var size: Int32?

        public var totalElements: Int32?

        public var totalPages: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                var tmp : [Any] = []
                for k in self.content! {
                    tmp.append(k.toMap())
                }
                map["Content"] = tmp
            }
            if self.first != nil {
                map["First"] = self.first!
            }
            if self.last != nil {
                map["Last"] = self.last!
            }
            if self.numberOfElements != nil {
                map["NumberOfElements"] = self.numberOfElements!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.totalElements != nil {
                map["TotalElements"] = self.totalElements!
            }
            if self.totalPages != nil {
                map["TotalPages"] = self.totalPages!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                var tmp : [DescribeSmartContractJobsByNameResponseBody.Result.Content] = []
                for v in dict["Content"] as! [Any] {
                    var model = DescribeSmartContractJobsByNameResponseBody.Result.Content()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.content = tmp
            }
            if dict.keys.contains("First") {
                self.first = dict["First"] as! Bool
            }
            if dict.keys.contains("Last") {
                self.last = dict["Last"] as! Bool
            }
            if dict.keys.contains("NumberOfElements") {
                self.numberOfElements = dict["NumberOfElements"] as! Int32
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("TotalElements") {
                self.totalElements = dict["TotalElements"] as! Int32
            }
            if dict.keys.contains("TotalPages") {
                self.totalPages = dict["TotalPages"] as! Int32
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeSmartContractJobsByNameResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeSmartContractJobsByNameResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeSmartContractJobsByNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSmartContractJobsByNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSmartContractJobsByNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSmartContractResultRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DescribeSmartContractResultResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeSmartContractResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSmartContractResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSmartContractResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSmartContractResultContentRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DescribeSmartContractResultContentResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Diagnostics : Tea.TeaModel {
            public class Range : Tea.TeaModel {
                public var character: Int32?

                public var line: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.character != nil {
                        map["Character"] = self.character!
                    }
                    if self.line != nil {
                        map["Line"] = self.line!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Character") {
                        self.character = dict["Character"] as! Int32
                    }
                    if dict.keys.contains("Line") {
                        self.line = dict["Line"] as! Int32
                    }
                }
            }
            public class Trace : Tea.TeaModel {
                public class Location : Tea.TeaModel {
                    public class Range : Tea.TeaModel {
                        public var character: Int32?

                        public var line: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.character != nil {
                                map["Character"] = self.character!
                            }
                            if self.line != nil {
                                map["Line"] = self.line!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Character") {
                                self.character = dict["Character"] as! Int32
                            }
                            if dict.keys.contains("Line") {
                                self.line = dict["Line"] as! Int32
                            }
                        }
                    }
                    public var range: [DescribeSmartContractResultContentResponseBody.Result.Diagnostics.Trace.Location.Range]?

                    public var uri: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.range != nil {
                            var tmp : [Any] = []
                            for k in self.range! {
                                tmp.append(k.toMap())
                            }
                            map["Range"] = tmp
                        }
                        if self.uri != nil {
                            map["Uri"] = self.uri!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Range") {
                            var tmp : [DescribeSmartContractResultContentResponseBody.Result.Diagnostics.Trace.Location.Range] = []
                            for v in dict["Range"] as! [Any] {
                                var model = DescribeSmartContractResultContentResponseBody.Result.Diagnostics.Trace.Location.Range()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.range = tmp
                        }
                        if dict.keys.contains("Uri") {
                            self.uri = dict["Uri"] as! String
                        }
                    }
                }
                public var location: DescribeSmartContractResultContentResponseBody.Result.Diagnostics.Trace.Location?

                public var message: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.location?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.location != nil {
                        map["Location"] = self.location?.toMap()
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Location") {
                        var model = DescribeSmartContractResultContentResponseBody.Result.Diagnostics.Trace.Location()
                        model.fromMap(dict["Location"] as! [String: Any])
                        self.location = model
                    }
                    if dict.keys.contains("Message") {
                        self.message = dict["Message"] as! String
                    }
                }
            }
            public var advice: String?

            public var code: String?

            public var detail: String?

            public var message: String?

            public var range: [DescribeSmartContractResultContentResponseBody.Result.Diagnostics.Range]?

            public var severity: Int32?

            public var source: String?

            public var trace: [DescribeSmartContractResultContentResponseBody.Result.Diagnostics.Trace]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.advice != nil {
                    map["Advice"] = self.advice!
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.detail != nil {
                    map["Detail"] = self.detail!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.range != nil {
                    var tmp : [Any] = []
                    for k in self.range! {
                        tmp.append(k.toMap())
                    }
                    map["Range"] = tmp
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.trace != nil {
                    var tmp : [Any] = []
                    for k in self.trace! {
                        tmp.append(k.toMap())
                    }
                    map["Trace"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Advice") {
                    self.advice = dict["Advice"] as! String
                }
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Detail") {
                    self.detail = dict["Detail"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Range") {
                    var tmp : [DescribeSmartContractResultContentResponseBody.Result.Diagnostics.Range] = []
                    for v in dict["Range"] as! [Any] {
                        var model = DescribeSmartContractResultContentResponseBody.Result.Diagnostics.Range()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.range = tmp
                }
                if dict.keys.contains("Severity") {
                    self.severity = dict["Severity"] as! Int32
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("Trace") {
                    var tmp : [DescribeSmartContractResultContentResponseBody.Result.Diagnostics.Trace] = []
                    for v in dict["Trace"] as! [Any] {
                        var model = DescribeSmartContractResultContentResponseBody.Result.Diagnostics.Trace()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.trace = tmp
                }
            }
        }
        public var diagnostics: [DescribeSmartContractResultContentResponseBody.Result.Diagnostics]?

        public var uri: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diagnostics != nil {
                var tmp : [Any] = []
                for k in self.diagnostics! {
                    tmp.append(k.toMap())
                }
                map["Diagnostics"] = tmp
            }
            if self.uri != nil {
                map["Uri"] = self.uri!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Diagnostics") {
                var tmp : [DescribeSmartContractResultContentResponseBody.Result.Diagnostics] = []
                for v in dict["Diagnostics"] as! [Any] {
                    var model = DescribeSmartContractResultContentResponseBody.Result.Diagnostics()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.diagnostics = tmp
            }
            if dict.keys.contains("Uri") {
                self.uri = dict["Uri"] as! String
            }
        }
    }
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeSmartContractResultContentResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeSmartContractResultContentResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeSmartContractResultContentResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeSmartContractResultContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSmartContractResultContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSmartContractResultContentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSubscribeCloudServiceIntegrationStateRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeSubscribeCloudServiceIntegrationStateResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeSubscribeCloudServiceIntegrationStateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSubscribeCloudServiceIntegrationStateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSubscribeCloudServiceIntegrationStateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTasksResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var action: String?

        public var assignee: String?

        public var handled: Bool?

        public var operationType: String?

        public var requestTime: Int64?

        public var responseTime: String?

        public var result: String?

        public var sender: String?

        public var target: String?

        public var taskId: Int32?

        public var taskState: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.assignee != nil {
                map["Assignee"] = self.assignee!
            }
            if self.handled != nil {
                map["Handled"] = self.handled!
            }
            if self.operationType != nil {
                map["OperationType"] = self.operationType!
            }
            if self.requestTime != nil {
                map["RequestTime"] = self.requestTime!
            }
            if self.responseTime != nil {
                map["ResponseTime"] = self.responseTime!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.sender != nil {
                map["Sender"] = self.sender!
            }
            if self.target != nil {
                map["Target"] = self.target!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskState != nil {
                map["TaskState"] = self.taskState!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("Assignee") {
                self.assignee = dict["Assignee"] as! String
            }
            if dict.keys.contains("Handled") {
                self.handled = dict["Handled"] as! Bool
            }
            if dict.keys.contains("OperationType") {
                self.operationType = dict["OperationType"] as! String
            }
            if dict.keys.contains("RequestTime") {
                self.requestTime = dict["RequestTime"] as! Int64
            }
            if dict.keys.contains("ResponseTime") {
                self.responseTime = dict["ResponseTime"] as! String
            }
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! String
            }
            if dict.keys.contains("Sender") {
                self.sender = dict["Sender"] as! String
            }
            if dict.keys.contains("Target") {
                self.target = dict["Target"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! Int32
            }
            if dict.keys.contains("TaskState") {
                self.taskState = dict["TaskState"] as! String
            }
        }
    }
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DescribeTasksResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeTasksResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeTasksResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTemplatesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class SchemaList : Tea.TeaModel {
            public var createTime: Int64?

            public var description_: String?

            public var id: Int64?

            public var isTemplate: Int32?

            public var name: String?

            public var updateTime: Int64?

            public var version: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isTemplate != nil {
                    map["IsTemplate"] = self.isTemplate!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IsTemplate") {
                    self.isTemplate = dict["IsTemplate"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! Int64
                }
            }
        }
        public var schemaList: [DescribeTemplatesResponseBody.Result.SchemaList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.schemaList != nil {
                var tmp : [Any] = []
                for k in self.schemaList! {
                    tmp.append(k.toMap())
                }
                map["SchemaList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SchemaList") {
                var tmp : [DescribeTemplatesResponseBody.Result.SchemaList] = []
                for v in dict["SchemaList"] as! [Any] {
                    var model = DescribeTemplatesResponseBody.Result.SchemaList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.schemaList = tmp
            }
        }
    }
    public var requestId: String?

    public var result: DescribeTemplatesResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeTemplatesResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTransactionRequest : Tea.TeaModel {
    public var bizid: String?

    public var hash: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.hash != nil {
            map["Hash"] = self.hash!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Hash") {
            self.hash = dict["Hash"] as! String
        }
    }
}

public class DescribeTransactionResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class TransactionV10 : Tea.TeaModel {
            public var data: String?

            public var extentions: [String]?

            public var from: String?

            public var gas: String?

            public var hash: String?

            public var nonce: String?

            public var period: Int64?

            public var signatureList: [String]?

            public var timestamp: Int64?

            public var to: String?

            public var txType: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.extentions != nil {
                    map["Extentions"] = self.extentions!
                }
                if self.from != nil {
                    map["From"] = self.from!
                }
                if self.gas != nil {
                    map["Gas"] = self.gas!
                }
                if self.hash != nil {
                    map["Hash"] = self.hash!
                }
                if self.nonce != nil {
                    map["Nonce"] = self.nonce!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.signatureList != nil {
                    map["SignatureList"] = self.signatureList!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.to != nil {
                    map["To"] = self.to!
                }
                if self.txType != nil {
                    map["TxType"] = self.txType!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("Extentions") {
                    self.extentions = dict["Extentions"] as! [String]
                }
                if dict.keys.contains("From") {
                    self.from = dict["From"] as! String
                }
                if dict.keys.contains("Gas") {
                    self.gas = dict["Gas"] as! String
                }
                if dict.keys.contains("Hash") {
                    self.hash = dict["Hash"] as! String
                }
                if dict.keys.contains("Nonce") {
                    self.nonce = dict["Nonce"] as! String
                }
                if dict.keys.contains("Period") {
                    self.period = dict["Period"] as! Int64
                }
                if dict.keys.contains("SignatureList") {
                    self.signatureList = dict["SignatureList"] as! [String]
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
                if dict.keys.contains("To") {
                    self.to = dict["To"] as! String
                }
                if dict.keys.contains("TxType") {
                    self.txType = dict["TxType"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var blockHash: String?

        public var blockHeight: Int64?

        public var blockVersion: Int32?

        public var category: Int32?

        public var content: String?

        public var contentHash: String?

        public var createTime: Int64?

        public var hash: String?

        public var keyName: String?

        public var keyWrap: String?

        public var nonce: String?

        public var referenceCount: Int32?

        public var referenceList: [String]?

        public var transTypeV6: String?

        public var transactionV10: DescribeTransactionResponseBody.Result.TransactionV10?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.transactionV10?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.blockHash != nil {
                map["BlockHash"] = self.blockHash!
            }
            if self.blockHeight != nil {
                map["BlockHeight"] = self.blockHeight!
            }
            if self.blockVersion != nil {
                map["BlockVersion"] = self.blockVersion!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.contentHash != nil {
                map["ContentHash"] = self.contentHash!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.hash != nil {
                map["Hash"] = self.hash!
            }
            if self.keyName != nil {
                map["KeyName"] = self.keyName!
            }
            if self.keyWrap != nil {
                map["KeyWrap"] = self.keyWrap!
            }
            if self.nonce != nil {
                map["Nonce"] = self.nonce!
            }
            if self.referenceCount != nil {
                map["ReferenceCount"] = self.referenceCount!
            }
            if self.referenceList != nil {
                map["ReferenceList"] = self.referenceList!
            }
            if self.transTypeV6 != nil {
                map["TransTypeV6"] = self.transTypeV6!
            }
            if self.transactionV10 != nil {
                map["TransactionV10"] = self.transactionV10?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BlockHash") {
                self.blockHash = dict["BlockHash"] as! String
            }
            if dict.keys.contains("BlockHeight") {
                self.blockHeight = dict["BlockHeight"] as! Int64
            }
            if dict.keys.contains("BlockVersion") {
                self.blockVersion = dict["BlockVersion"] as! Int32
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! Int32
            }
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("ContentHash") {
                self.contentHash = dict["ContentHash"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Hash") {
                self.hash = dict["Hash"] as! String
            }
            if dict.keys.contains("KeyName") {
                self.keyName = dict["KeyName"] as! String
            }
            if dict.keys.contains("KeyWrap") {
                self.keyWrap = dict["KeyWrap"] as! String
            }
            if dict.keys.contains("Nonce") {
                self.nonce = dict["Nonce"] as! String
            }
            if dict.keys.contains("ReferenceCount") {
                self.referenceCount = dict["ReferenceCount"] as! Int32
            }
            if dict.keys.contains("ReferenceList") {
                self.referenceList = dict["ReferenceList"] as! [String]
            }
            if dict.keys.contains("TransTypeV6") {
                self.transTypeV6 = dict["TransTypeV6"] as! String
            }
            if dict.keys.contains("TransactionV10") {
                var model = DescribeTransactionResponseBody.Result.TransactionV10()
                model.fromMap(dict["TransactionV10"] as! [String: Any])
                self.transactionV10 = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeTransactionResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeTransactionResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeTransactionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTransactionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTransactionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTransactionFor2CBrowserRequest : Tea.TeaModel {
    public var alipayAuthCode: String?

    public var bizid: String?

    public var hash: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alipayAuthCode != nil {
            map["AlipayAuthCode"] = self.alipayAuthCode!
        }
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.hash != nil {
            map["Hash"] = self.hash!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlipayAuthCode") {
            self.alipayAuthCode = dict["AlipayAuthCode"] as! String
        }
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Hash") {
            self.hash = dict["Hash"] as! String
        }
    }
}

public class DescribeTransactionFor2CBrowserResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class TransactionV10 : Tea.TeaModel {
            public var data: String?

            public var extentions: [String]?

            public var from: String?

            public var gas: String?

            public var hash: String?

            public var nonce: String?

            public var period: Int64?

            public var signatureList: [String]?

            public var timestamp: Int64?

            public var to: String?

            public var txType: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.extentions != nil {
                    map["Extentions"] = self.extentions!
                }
                if self.from != nil {
                    map["From"] = self.from!
                }
                if self.gas != nil {
                    map["Gas"] = self.gas!
                }
                if self.hash != nil {
                    map["Hash"] = self.hash!
                }
                if self.nonce != nil {
                    map["Nonce"] = self.nonce!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.signatureList != nil {
                    map["SignatureList"] = self.signatureList!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.to != nil {
                    map["To"] = self.to!
                }
                if self.txType != nil {
                    map["TxType"] = self.txType!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("Extentions") {
                    self.extentions = dict["Extentions"] as! [String]
                }
                if dict.keys.contains("From") {
                    self.from = dict["From"] as! String
                }
                if dict.keys.contains("Gas") {
                    self.gas = dict["Gas"] as! String
                }
                if dict.keys.contains("Hash") {
                    self.hash = dict["Hash"] as! String
                }
                if dict.keys.contains("Nonce") {
                    self.nonce = dict["Nonce"] as! String
                }
                if dict.keys.contains("Period") {
                    self.period = dict["Period"] as! Int64
                }
                if dict.keys.contains("SignatureList") {
                    self.signatureList = dict["SignatureList"] as! [String]
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
                if dict.keys.contains("To") {
                    self.to = dict["To"] as! String
                }
                if dict.keys.contains("TxType") {
                    self.txType = dict["TxType"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var blockHash: String?

        public var blockHeight: Int64?

        public var blockVersion: Int32?

        public var category: Int32?

        public var content: String?

        public var contentHash: String?

        public var createTime: Int64?

        public var hash: String?

        public var keyName: String?

        public var keyWrap: String?

        public var nonce: String?

        public var referenceCount: Int32?

        public var referenceList: [String]?

        public var transTypeV6: String?

        public var transactionV10: DescribeTransactionFor2CBrowserResponseBody.Result.TransactionV10?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.transactionV10?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.blockHash != nil {
                map["BlockHash"] = self.blockHash!
            }
            if self.blockHeight != nil {
                map["BlockHeight"] = self.blockHeight!
            }
            if self.blockVersion != nil {
                map["BlockVersion"] = self.blockVersion!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.contentHash != nil {
                map["ContentHash"] = self.contentHash!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.hash != nil {
                map["Hash"] = self.hash!
            }
            if self.keyName != nil {
                map["KeyName"] = self.keyName!
            }
            if self.keyWrap != nil {
                map["KeyWrap"] = self.keyWrap!
            }
            if self.nonce != nil {
                map["Nonce"] = self.nonce!
            }
            if self.referenceCount != nil {
                map["ReferenceCount"] = self.referenceCount!
            }
            if self.referenceList != nil {
                map["ReferenceList"] = self.referenceList!
            }
            if self.transTypeV6 != nil {
                map["TransTypeV6"] = self.transTypeV6!
            }
            if self.transactionV10 != nil {
                map["TransactionV10"] = self.transactionV10?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BlockHash") {
                self.blockHash = dict["BlockHash"] as! String
            }
            if dict.keys.contains("BlockHeight") {
                self.blockHeight = dict["BlockHeight"] as! Int64
            }
            if dict.keys.contains("BlockVersion") {
                self.blockVersion = dict["BlockVersion"] as! Int32
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! Int32
            }
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("ContentHash") {
                self.contentHash = dict["ContentHash"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Hash") {
                self.hash = dict["Hash"] as! String
            }
            if dict.keys.contains("KeyName") {
                self.keyName = dict["KeyName"] as! String
            }
            if dict.keys.contains("KeyWrap") {
                self.keyWrap = dict["KeyWrap"] as! String
            }
            if dict.keys.contains("Nonce") {
                self.nonce = dict["Nonce"] as! String
            }
            if dict.keys.contains("ReferenceCount") {
                self.referenceCount = dict["ReferenceCount"] as! Int32
            }
            if dict.keys.contains("ReferenceList") {
                self.referenceList = dict["ReferenceList"] as! [String]
            }
            if dict.keys.contains("TransTypeV6") {
                self.transTypeV6 = dict["TransTypeV6"] as! String
            }
            if dict.keys.contains("TransactionV10") {
                var model = DescribeTransactionFor2CBrowserResponseBody.Result.TransactionV10()
                model.fromMap(dict["TransactionV10"] as! [String: Any])
                self.transactionV10 = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeTransactionFor2CBrowserResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeTransactionFor2CBrowserResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeTransactionFor2CBrowserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTransactionFor2CBrowserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTransactionFor2CBrowserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTransactionQRCodeRequest : Tea.TeaModel {
    public var bizid: String?

    public var hash: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.hash != nil {
            map["Hash"] = self.hash!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Hash") {
            self.hash = dict["Hash"] as! String
        }
    }
}

public class DescribeTransactionQRCodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class DescribeTransactionQRCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTransactionQRCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTransactionQRCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTransactionReceiptFor2CBrowserRequest : Tea.TeaModel {
    public var alipayAuthCode: String?

    public var bizid: String?

    public var hash: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alipayAuthCode != nil {
            map["AlipayAuthCode"] = self.alipayAuthCode!
        }
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.hash != nil {
            map["Hash"] = self.hash!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlipayAuthCode") {
            self.alipayAuthCode = dict["AlipayAuthCode"] as! String
        }
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Hash") {
            self.hash = dict["Hash"] as! String
        }
    }
}

public class DescribeTransactionReceiptFor2CBrowserResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var data: String?

        public var gasUsed: String?

        public var logs: [String]?

        public var result: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.gasUsed != nil {
                map["GasUsed"] = self.gasUsed!
            }
            if self.logs != nil {
                map["Logs"] = self.logs!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("GasUsed") {
                self.gasUsed = dict["GasUsed"] as! String
            }
            if dict.keys.contains("Logs") {
                self.logs = dict["Logs"] as! [String]
            }
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var result: DescribeTransactionReceiptFor2CBrowserResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeTransactionReceiptFor2CBrowserResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeTransactionReceiptFor2CBrowserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTransactionReceiptFor2CBrowserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTransactionReceiptFor2CBrowserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTriggerRequest : Tea.TeaModel {
    public var channelId: String?

    public var name: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DescribeTriggerResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Checkpoint : Tea.TeaModel {
            public var errorCount: Int64?

            public var height: Int64?

            public var index: Int64?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCount != nil {
                    map["ErrorCount"] = self.errorCount!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCount") {
                    self.errorCount = dict["ErrorCount"] as! Int64
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int64
                }
                if dict.keys.contains("Index") {
                    self.index = dict["Index"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var channelId: String?

        public var channelName: String?

        public var checkpoint: DescribeTriggerResponseBody.Result.Checkpoint?

        public var createTime: Int64?

        public var errorMessage: String?

        public var name: String?

        public var options: String?

        public var source: String?

        public var status: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkpoint?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.checkpoint != nil {
                map["Checkpoint"] = self.checkpoint?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.options != nil {
                map["Options"] = self.options!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("Checkpoint") {
                var model = DescribeTriggerResponseBody.Result.Checkpoint()
                model.fromMap(dict["Checkpoint"] as! [String: Any])
                self.checkpoint = model
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Options") {
                self.options = dict["Options"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DescribeTriggerResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeTriggerResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DescribeTriggerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTriggerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTriggerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DestroyConsortiumRequest : Tea.TeaModel {
    public var consortiumId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
    }
}

public class DestroyConsortiumResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consortiumId: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: Int32?

    public var requestId: String?

    public var result: DestroyConsortiumResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DestroyConsortiumResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DestroyConsortiumResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DestroyConsortiumResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DestroyConsortiumResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DestroyEthereumRequest : Tea.TeaModel {
    public var ethereumId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ethereumId != nil {
            map["EthereumId"] = self.ethereumId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EthereumId") {
            self.ethereumId = dict["EthereumId"] as! String
        }
    }
}

public class DestroyEthereumResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consensus: String?

        public var creator: String?

        public var description_: String?

        public var id: String?

        public var name: String?

        public var networkId: String?

        public var regionId: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consensus != nil {
                map["Consensus"] = self.consensus!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Consensus") {
                self.consensus = dict["Consensus"] as! String
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NetworkId") {
                self.networkId = dict["NetworkId"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: DestroyEthereumResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DestroyEthereumResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DestroyEthereumResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DestroyEthereumResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DestroyEthereumResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DestroyOrganizationRequest : Tea.TeaModel {
    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class DestroyOrganizationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var name: String?

        public var organizationId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
        }
    }
    public var dynamicCode: String?

    public var dynamicMessage: String?

    public var errorCode: Int32?

    public var requestId: String?

    public var result: DestroyOrganizationResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dynamicCode != nil {
            map["DynamicCode"] = self.dynamicCode!
        }
        if self.dynamicMessage != nil {
            map["DynamicMessage"] = self.dynamicMessage!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DynamicCode") {
            self.dynamicCode = dict["DynamicCode"] as! String
        }
        if dict.keys.contains("DynamicMessage") {
            self.dynamicMessage = dict["DynamicMessage"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DestroyOrganizationResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DestroyOrganizationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DestroyOrganizationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DestroyOrganizationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DownloadAllRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DownloadAllResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var bizviewUrl: String?

        public var certUrl: String?

        public var sdkUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizviewUrl != nil {
                map["BizviewUrl"] = self.bizviewUrl!
            }
            if self.certUrl != nil {
                map["CertUrl"] = self.certUrl!
            }
            if self.sdkUrl != nil {
                map["SdkUrl"] = self.sdkUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BizviewUrl") {
                self.bizviewUrl = dict["BizviewUrl"] as! String
            }
            if dict.keys.contains("CertUrl") {
                self.certUrl = dict["CertUrl"] as! String
            }
            if dict.keys.contains("SdkUrl") {
                self.sdkUrl = dict["SdkUrl"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DownloadAllResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DownloadAllResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DownloadAllResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DownloadAllResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DownloadAllResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DownloadBizviewRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DownloadBizviewResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class DownloadBizviewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DownloadBizviewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DownloadBizviewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DownloadFabricChannelSDKRequest : Tea.TeaModel {
    public var channelId: String?

    public var location: String?

    public var organizationId: String?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("Username") {
            self.username = dict["Username"] as! String
        }
    }
}

public class DownloadFabricChannelSDKResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var content: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DownloadFabricChannelSDKResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DownloadFabricChannelSDKResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DownloadFabricChannelSDKResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DownloadFabricChannelSDKResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DownloadFabricChannelSDKResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DownloadFabricChannelSDKResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DownloadOrganizationSDKRequest : Tea.TeaModel {
    public var location: String?

    public var organizationId: String?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("Username") {
            self.username = dict["Username"] as! String
        }
    }
}

public class DownloadOrganizationSDKResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var content: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [DownloadOrganizationSDKResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DownloadOrganizationSDKResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DownloadOrganizationSDKResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DownloadOrganizationSDKResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DownloadOrganizationSDKResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DownloadOrganizationSDKResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DownloadSDK2Request : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DownloadSDK2ResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class DownloadSDK2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DownloadSDK2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DownloadSDK2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DownloadSdkRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class DownloadSdkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class DownloadSdkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DownloadSdkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DownloadSdkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DownloadSignedDataRequest : Tea.TeaModel {
    public var bizid: String?

    public var path: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Path") {
            self.path = dict["Path"] as! String
        }
    }
}

public class DownloadSignedDataResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class DownloadSignedDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DownloadSignedDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DownloadSignedDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DuplicateAntChainContractProjectRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var projectId: String?

    public var projectVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectVersion != nil {
            map["ProjectVersion"] = self.projectVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ProjectVersion") {
            self.projectVersion = dict["ProjectVersion"] as! String
        }
    }
}

public class DuplicateAntChainContractProjectResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consortiumId: String?

        public var description_: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: String?

        public var name: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! Int64
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! Int64
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DuplicateAntChainContractProjectResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DuplicateAntChainContractProjectResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DuplicateAntChainContractProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DuplicateAntChainContractProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DuplicateAntChainContractProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class FreezeAccountRequest : Tea.TeaModel {
    public var account: String?

    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.account != nil {
            map["Account"] = self.account!
        }
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Account") {
            self.account = dict["Account"] as! String
        }
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class FreezeAccountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class FreezeAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: FreezeAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = FreezeAccountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class FreezeAntChainAccountRequest : Tea.TeaModel {
    public var account: String?

    public var antChainId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.account != nil {
            map["Account"] = self.account!
        }
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Account") {
            self.account = dict["Account"] as! String
        }
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
    }
}

public class FreezeAntChainAccountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class FreezeAntChainAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: FreezeAntChainAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = FreezeAntChainAccountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAppliesRequest : Tea.TeaModel {
    public var bizid: String?

    public var current: Int32?

    public var pageSize: Int32?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.current != nil {
            map["Current"] = self.current!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Current") {
            self.current = dict["Current"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class GetAppliesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ApplyHistoryList : Tea.TeaModel {
            public var bizid: String?

            public var createtime: Int64?

            public var id: Int32?

            public var rejectReason: String?

            public var reqAddr: String?

            public var signedAddr: String?

            public var status: Int32?

            public var updatetime: Int64?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizid != nil {
                    map["Bizid"] = self.bizid!
                }
                if self.createtime != nil {
                    map["Createtime"] = self.createtime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.rejectReason != nil {
                    map["RejectReason"] = self.rejectReason!
                }
                if self.reqAddr != nil {
                    map["ReqAddr"] = self.reqAddr!
                }
                if self.signedAddr != nil {
                    map["SignedAddr"] = self.signedAddr!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.updatetime != nil {
                    map["Updatetime"] = self.updatetime!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bizid") {
                    self.bizid = dict["Bizid"] as! String
                }
                if dict.keys.contains("Createtime") {
                    self.createtime = dict["Createtime"] as! Int64
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int32
                }
                if dict.keys.contains("RejectReason") {
                    self.rejectReason = dict["RejectReason"] as! String
                }
                if dict.keys.contains("ReqAddr") {
                    self.reqAddr = dict["ReqAddr"] as! String
                }
                if dict.keys.contains("SignedAddr") {
                    self.signedAddr = dict["SignedAddr"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("Updatetime") {
                    self.updatetime = dict["Updatetime"] as! Int64
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var current: Int32?

            public var pageSize: Int32?

            public var total: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.current != nil {
                    map["Current"] = self.current!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Current") {
                    self.current = dict["Current"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int32
                }
            }
        }
        public var applyHistoryList: [GetAppliesResponseBody.Result.ApplyHistoryList]?

        public var pagination: GetAppliesResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applyHistoryList != nil {
                var tmp : [Any] = []
                for k in self.applyHistoryList! {
                    tmp.append(k.toMap())
                }
                map["ApplyHistoryList"] = tmp
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplyHistoryList") {
                var tmp : [GetAppliesResponseBody.Result.ApplyHistoryList] = []
                for v in dict["ApplyHistoryList"] as! [Any] {
                    var model = GetAppliesResponseBody.Result.ApplyHistoryList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.applyHistoryList = tmp
            }
            if dict.keys.contains("Pagination") {
                var model = GetAppliesResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var requestId: String?

    public var result: GetAppliesResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = GetAppliesResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class GetAppliesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAppliesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAppliesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBcSchemaRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class GetBcSchemaResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Responses : Tea.TeaModel {
            public class Properties : Tea.TeaModel {
                public class DataSource : Tea.TeaModel {
                    public var allowNull: Int32?

                    public var annotation: String?

                    public var field: String?

                    public var indexes: Int32?

                    public var key: Int32?

                    public var length: Int32?

                    public var reg: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.allowNull != nil {
                            map["AllowNull"] = self.allowNull!
                        }
                        if self.annotation != nil {
                            map["Annotation"] = self.annotation!
                        }
                        if self.field != nil {
                            map["Field"] = self.field!
                        }
                        if self.indexes != nil {
                            map["Indexes"] = self.indexes!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.length != nil {
                            map["Length"] = self.length!
                        }
                        if self.reg != nil {
                            map["Reg"] = self.reg!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AllowNull") {
                            self.allowNull = dict["AllowNull"] as! Int32
                        }
                        if dict.keys.contains("Annotation") {
                            self.annotation = dict["Annotation"] as! String
                        }
                        if dict.keys.contains("Field") {
                            self.field = dict["Field"] as! String
                        }
                        if dict.keys.contains("Indexes") {
                            self.indexes = dict["Indexes"] as! Int32
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! Int32
                        }
                        if dict.keys.contains("Length") {
                            self.length = dict["Length"] as! Int32
                        }
                        if dict.keys.contains("Reg") {
                            self.reg = dict["Reg"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var count: Int32?

                public var dataSource: [GetBcSchemaResponseBody.Result.Responses.Properties.DataSource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.dataSource != nil {
                        var tmp : [Any] = []
                        for k in self.dataSource! {
                            tmp.append(k.toMap())
                        }
                        map["DataSource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int32
                    }
                    if dict.keys.contains("DataSource") {
                        var tmp : [GetBcSchemaResponseBody.Result.Responses.Properties.DataSource] = []
                        for v in dict["DataSource"] as! [Any] {
                            var model = GetBcSchemaResponseBody.Result.Responses.Properties.DataSource()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dataSource = tmp
                    }
                }
            }
            public var category: String?

            public var categoryName: String?

            public var description_: String?

            public var properties: GetBcSchemaResponseBody.Result.Responses.Properties?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.properties?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.categoryName != nil {
                    map["CategoryName"] = self.categoryName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.properties != nil {
                    map["Properties"] = self.properties?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CategoryName") {
                    self.categoryName = dict["CategoryName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Properties") {
                    var model = GetBcSchemaResponseBody.Result.Responses.Properties()
                    model.fromMap(dict["Properties"] as! [String: Any])
                    self.properties = model
                }
            }
        }
        public class Schema : Tea.TeaModel {
            public var createTime: Int64?

            public var description_: String?

            public var id: Int64?

            public var isTemplate: Bool?

            public var name: String?

            public var updateTime: Int64?

            public var version: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isTemplate != nil {
                    map["IsTemplate"] = self.isTemplate!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IsTemplate") {
                    self.isTemplate = dict["IsTemplate"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! Int64
                }
            }
        }
        public var responses: [GetBcSchemaResponseBody.Result.Responses]?

        public var schema: GetBcSchemaResponseBody.Result.Schema?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.schema?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.responses != nil {
                var tmp : [Any] = []
                for k in self.responses! {
                    tmp.append(k.toMap())
                }
                map["Responses"] = tmp
            }
            if self.schema != nil {
                map["Schema"] = self.schema?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Responses") {
                var tmp : [GetBcSchemaResponseBody.Result.Responses] = []
                for v in dict["Responses"] as! [Any] {
                    var model = GetBcSchemaResponseBody.Result.Responses()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.responses = tmp
            }
            if dict.keys.contains("Schema") {
                var model = GetBcSchemaResponseBody.Result.Schema()
                model.fromMap(dict["Schema"] as! [String: Any])
                self.schema = model
            }
        }
    }
    public var requestId: String?

    public var result: GetBcSchemaResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = GetBcSchemaResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class GetBcSchemaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBcSchemaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetBcSchemaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBlockchainCreateTaskRequest : Tea.TeaModel {
    public var current: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.current != nil {
            map["Current"] = self.current!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Current") {
            self.current = dict["Current"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class GetBlockchainCreateTaskResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class BlockchainCreateTasks : Tea.TeaModel {
            public class BlockchainCreateTasks : Tea.TeaModel {
                public var bizid: String?

                public var createTime: Int64?

                public var memo: String?

                public var name: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizid != nil {
                        map["Bizid"] = self.bizid!
                    }
                    if self.createTime != nil {
                        map["CreateTime"] = self.createTime!
                    }
                    if self.memo != nil {
                        map["Memo"] = self.memo!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bizid") {
                        self.bizid = dict["Bizid"] as! String
                    }
                    if dict.keys.contains("CreateTime") {
                        self.createTime = dict["CreateTime"] as! Int64
                    }
                    if dict.keys.contains("Memo") {
                        self.memo = dict["Memo"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public var blockchainCreateTasks: [GetBlockchainCreateTaskResponseBody.Result.BlockchainCreateTasks.BlockchainCreateTasks]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.blockchainCreateTasks != nil {
                    var tmp : [Any] = []
                    for k in self.blockchainCreateTasks! {
                        tmp.append(k.toMap())
                    }
                    map["BlockchainCreateTasks"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BlockchainCreateTasks") {
                    var tmp : [GetBlockchainCreateTaskResponseBody.Result.BlockchainCreateTasks.BlockchainCreateTasks] = []
                    for v in dict["BlockchainCreateTasks"] as! [Any] {
                        var model = GetBlockchainCreateTaskResponseBody.Result.BlockchainCreateTasks.BlockchainCreateTasks()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.blockchainCreateTasks = tmp
                }
            }
        }
        public class Pagination : Tea.TeaModel {
            public var current: Int32?

            public var pageSize: Int32?

            public var total: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.current != nil {
                    map["Current"] = self.current!
                }
                if self.pageSize != nil {
                    map["PageSize"] = self.pageSize!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Current") {
                    self.current = dict["Current"] as! Int32
                }
                if dict.keys.contains("PageSize") {
                    self.pageSize = dict["PageSize"] as! Int32
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int32
                }
            }
        }
        public var blockchainCreateTasks: GetBlockchainCreateTaskResponseBody.Result.BlockchainCreateTasks?

        public var pagination: GetBlockchainCreateTaskResponseBody.Result.Pagination?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.blockchainCreateTasks?.validate()
            try self.pagination?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.blockchainCreateTasks != nil {
                map["BlockchainCreateTasks"] = self.blockchainCreateTasks?.toMap()
            }
            if self.pagination != nil {
                map["Pagination"] = self.pagination?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BlockchainCreateTasks") {
                var model = GetBlockchainCreateTaskResponseBody.Result.BlockchainCreateTasks()
                model.fromMap(dict["BlockchainCreateTasks"] as! [String: Any])
                self.blockchainCreateTasks = model
            }
            if dict.keys.contains("Pagination") {
                var model = GetBlockchainCreateTaskResponseBody.Result.Pagination()
                model.fromMap(dict["Pagination"] as! [String: Any])
                self.pagination = model
            }
        }
    }
    public var requestId: String?

    public var result: GetBlockchainCreateTaskResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = GetBlockchainCreateTaskResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class GetBlockchainCreateTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBlockchainCreateTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetBlockchainCreateTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBlockchainInfoRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class GetBlockchainInfoResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class NodeInfoList : Tea.TeaModel {
            public var blockHeight: Int64?

            public var nodeName: String?

            public var status: Bool?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.blockHeight != nil {
                    map["BlockHeight"] = self.blockHeight!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BlockHeight") {
                    self.blockHeight = dict["BlockHeight"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Bool
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var abnormalNodes: Int32?

        public var bizid: String?

        public var blockHeight: Int32?

        public var createTime: Int64?

        public var isRole: Bool?

        public var nodeInfoList: [GetBlockchainInfoResponseBody.Result.NodeInfoList]?

        public var nodeNumber: Int32?

        public var normal: Bool?

        public var transactionSum: Int32?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.abnormalNodes != nil {
                map["AbnormalNodes"] = self.abnormalNodes!
            }
            if self.bizid != nil {
                map["Bizid"] = self.bizid!
            }
            if self.blockHeight != nil {
                map["BlockHeight"] = self.blockHeight!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.isRole != nil {
                map["IsRole"] = self.isRole!
            }
            if self.nodeInfoList != nil {
                var tmp : [Any] = []
                for k in self.nodeInfoList! {
                    tmp.append(k.toMap())
                }
                map["NodeInfoList"] = tmp
            }
            if self.nodeNumber != nil {
                map["NodeNumber"] = self.nodeNumber!
            }
            if self.normal != nil {
                map["Normal"] = self.normal!
            }
            if self.transactionSum != nil {
                map["TransactionSum"] = self.transactionSum!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AbnormalNodes") {
                self.abnormalNodes = dict["AbnormalNodes"] as! Int32
            }
            if dict.keys.contains("Bizid") {
                self.bizid = dict["Bizid"] as! String
            }
            if dict.keys.contains("BlockHeight") {
                self.blockHeight = dict["BlockHeight"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("IsRole") {
                self.isRole = dict["IsRole"] as! Bool
            }
            if dict.keys.contains("NodeInfoList") {
                var tmp : [GetBlockchainInfoResponseBody.Result.NodeInfoList] = []
                for v in dict["NodeInfoList"] as! [Any] {
                    var model = GetBlockchainInfoResponseBody.Result.NodeInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodeInfoList = tmp
            }
            if dict.keys.contains("NodeNumber") {
                self.nodeNumber = dict["NodeNumber"] as! Int32
            }
            if dict.keys.contains("Normal") {
                self.normal = dict["Normal"] as! Bool
            }
            if dict.keys.contains("TransactionSum") {
                self.transactionSum = dict["TransactionSum"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: GetBlockchainInfoResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = GetBlockchainInfoResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class GetBlockchainInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBlockchainInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetBlockchainInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMyBlockchainsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var bizid: String?

        public var createtime: Int64?

        public var id: Int32?

        public var rejectReason: String?

        public var reqAddr: String?

        public var signedAddr: String?

        public var status: Int32?

        public var updatetime: Int64?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bizid != nil {
                map["Bizid"] = self.bizid!
            }
            if self.createtime != nil {
                map["Createtime"] = self.createtime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.rejectReason != nil {
                map["RejectReason"] = self.rejectReason!
            }
            if self.reqAddr != nil {
                map["ReqAddr"] = self.reqAddr!
            }
            if self.signedAddr != nil {
                map["SignedAddr"] = self.signedAddr!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updatetime != nil {
                map["Updatetime"] = self.updatetime!
            }
            if self.username != nil {
                map["Username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bizid") {
                self.bizid = dict["Bizid"] as! String
            }
            if dict.keys.contains("Createtime") {
                self.createtime = dict["Createtime"] as! Int64
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("RejectReason") {
                self.rejectReason = dict["RejectReason"] as! String
            }
            if dict.keys.contains("ReqAddr") {
                self.reqAddr = dict["ReqAddr"] as! String
            }
            if dict.keys.contains("SignedAddr") {
                self.signedAddr = dict["SignedAddr"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Updatetime") {
                self.updatetime = dict["Updatetime"] as! Int64
            }
            if dict.keys.contains("Username") {
                self.username = dict["Username"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [GetMyBlockchainsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [GetMyBlockchainsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = GetMyBlockchainsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class GetMyBlockchainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMyBlockchainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMyBlockchainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMySuccessAppliesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class NodeInfoList : Tea.TeaModel {
            public var blockHeight: Int64?

            public var nodeName: String?

            public var status: Bool?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.blockHeight != nil {
                    map["BlockHeight"] = self.blockHeight!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BlockHeight") {
                    self.blockHeight = dict["BlockHeight"] as! Int64
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Bool
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var abnormalNodes: Int32?

        public var bizid: String?

        public var blockHeight: Int32?

        public var createTime: Int64?

        public var isRole: Bool?

        public var name: String?

        public var nodeInfoList: [GetMySuccessAppliesResponseBody.Result.NodeInfoList]?

        public var nodeNumber: Int32?

        public var normal: Bool?

        public var transactionSum: Int32?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.abnormalNodes != nil {
                map["AbnormalNodes"] = self.abnormalNodes!
            }
            if self.bizid != nil {
                map["Bizid"] = self.bizid!
            }
            if self.blockHeight != nil {
                map["BlockHeight"] = self.blockHeight!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.isRole != nil {
                map["IsRole"] = self.isRole!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.nodeInfoList != nil {
                var tmp : [Any] = []
                for k in self.nodeInfoList! {
                    tmp.append(k.toMap())
                }
                map["NodeInfoList"] = tmp
            }
            if self.nodeNumber != nil {
                map["NodeNumber"] = self.nodeNumber!
            }
            if self.normal != nil {
                map["Normal"] = self.normal!
            }
            if self.transactionSum != nil {
                map["TransactionSum"] = self.transactionSum!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AbnormalNodes") {
                self.abnormalNodes = dict["AbnormalNodes"] as! Int32
            }
            if dict.keys.contains("Bizid") {
                self.bizid = dict["Bizid"] as! String
            }
            if dict.keys.contains("BlockHeight") {
                self.blockHeight = dict["BlockHeight"] as! Int32
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("IsRole") {
                self.isRole = dict["IsRole"] as! Bool
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NodeInfoList") {
                var tmp : [GetMySuccessAppliesResponseBody.Result.NodeInfoList] = []
                for v in dict["NodeInfoList"] as! [Any] {
                    var model = GetMySuccessAppliesResponseBody.Result.NodeInfoList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodeInfoList = tmp
            }
            if dict.keys.contains("NodeNumber") {
                self.nodeNumber = dict["NodeNumber"] as! Int32
            }
            if dict.keys.contains("Normal") {
                self.normal = dict["Normal"] as! Bool
            }
            if dict.keys.contains("TransactionSum") {
                self.transactionSum = dict["TransactionSum"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [GetMySuccessAppliesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [GetMySuccessAppliesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = GetMySuccessAppliesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class GetMySuccessAppliesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMySuccessAppliesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMySuccessAppliesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOssPropertiesRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class GetOssPropertiesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var accessKeyId: String?

        public var accessKeySecret: String?

        public var bucketName: String?

        public var endpoint: String?

        public var folderName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessKeyId != nil {
                map["AccessKeyId"] = self.accessKeyId!
            }
            if self.accessKeySecret != nil {
                map["AccessKeySecret"] = self.accessKeySecret!
            }
            if self.bucketName != nil {
                map["BucketName"] = self.bucketName!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.folderName != nil {
                map["FolderName"] = self.folderName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessKeyId") {
                self.accessKeyId = dict["AccessKeyId"] as! String
            }
            if dict.keys.contains("AccessKeySecret") {
                self.accessKeySecret = dict["AccessKeySecret"] as! String
            }
            if dict.keys.contains("BucketName") {
                self.bucketName = dict["BucketName"] as! String
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("FolderName") {
                self.folderName = dict["FolderName"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: GetOssPropertiesResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = GetOssPropertiesResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class GetOssPropertiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOssPropertiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOssPropertiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTemplatesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class SchemaList : Tea.TeaModel {
            public var createTime: Int64?

            public var description_: String?

            public var id: Int64?

            public var isTemplate: Int32?

            public var name: String?

            public var updateTime: Int64?

            public var version: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isTemplate != nil {
                    map["IsTemplate"] = self.isTemplate!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IsTemplate") {
                    self.isTemplate = dict["IsTemplate"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! Int64
                }
            }
        }
        public var schemaList: [GetTemplatesResponseBody.Result.SchemaList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.schemaList != nil {
                var tmp : [Any] = []
                for k in self.schemaList! {
                    tmp.append(k.toMap())
                }
                map["SchemaList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SchemaList") {
                var tmp : [GetTemplatesResponseBody.Result.SchemaList] = []
                for v in dict["SchemaList"] as! [Any] {
                    var model = GetTemplatesResponseBody.Result.SchemaList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.schemaList = tmp
            }
        }
    }
    public var requestId: String?

    public var result: GetTemplatesResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = GetTemplatesResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class GetTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallChaincodeRequest : Tea.TeaModel {
    public var chaincodeId: String?

    public var location: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chaincodeId != nil {
            map["ChaincodeId"] = self.chaincodeId!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChaincodeId") {
            self.chaincodeId = dict["ChaincodeId"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class InstallChaincodeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var chaincodeId: String?

        public var channelName: String?

        public var consortiumId: String?

        public var createTime: String?

        public var deployTime: String?

        public var endorsePolicy: String?

        public var input: String?

        public var install: Bool?

        public var message: String?

        public var name: String?

        public var path: String?

        public var providerId: String?

        public var providerName: String?

        public var state: String?

        public var type: Int32?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chaincodeId != nil {
                map["ChaincodeId"] = self.chaincodeId!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.deployTime != nil {
                map["DeployTime"] = self.deployTime!
            }
            if self.endorsePolicy != nil {
                map["EndorsePolicy"] = self.endorsePolicy!
            }
            if self.input != nil {
                map["Input"] = self.input!
            }
            if self.install != nil {
                map["Install"] = self.install!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.providerId != nil {
                map["ProviderId"] = self.providerId!
            }
            if self.providerName != nil {
                map["ProviderName"] = self.providerName!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChaincodeId") {
                self.chaincodeId = dict["ChaincodeId"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DeployTime") {
                self.deployTime = dict["DeployTime"] as! String
            }
            if dict.keys.contains("EndorsePolicy") {
                self.endorsePolicy = dict["EndorsePolicy"] as! String
            }
            if dict.keys.contains("Input") {
                self.input = dict["Input"] as! String
            }
            if dict.keys.contains("Install") {
                self.install = dict["Install"] as! Bool
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("ProviderId") {
                self.providerId = dict["ProviderId"] as! String
            }
            if dict.keys.contains("ProviderName") {
                self.providerName = dict["ProviderName"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: InstallChaincodeResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = InstallChaincodeResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class InstallChaincodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallChaincodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InstallChaincodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallFabricChaincodePackageRequest : Tea.TeaModel {
    public var chaincodePackageId: String?

    public var location: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chaincodePackageId != nil {
            map["ChaincodePackageId"] = self.chaincodePackageId!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChaincodePackageId") {
            self.chaincodePackageId = dict["ChaincodePackageId"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class InstallFabricChaincodePackageResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var chaincodePackageId: String?

        public var checksum: String?

        public var deleteTime: Int64?

        public var deleted: Bool?

        public var installTime: Int64?

        public var label: String?

        public var md5sum: String?

        public var organizationId: String?

        public var ossBucket: String?

        public var ossURL: String?

        public var providerBid: String?

        public var providerUid: Int64?

        public var state: String?

        public var type: Int32?

        public var typeName: String?

        public var uploadTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chaincodePackageId != nil {
                map["ChaincodePackageId"] = self.chaincodePackageId!
            }
            if self.checksum != nil {
                map["Checksum"] = self.checksum!
            }
            if self.deleteTime != nil {
                map["DeleteTime"] = self.deleteTime!
            }
            if self.deleted != nil {
                map["Deleted"] = self.deleted!
            }
            if self.installTime != nil {
                map["InstallTime"] = self.installTime!
            }
            if self.label != nil {
                map["Label"] = self.label!
            }
            if self.md5sum != nil {
                map["Md5sum"] = self.md5sum!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.ossBucket != nil {
                map["OssBucket"] = self.ossBucket!
            }
            if self.ossURL != nil {
                map["OssURL"] = self.ossURL!
            }
            if self.providerBid != nil {
                map["ProviderBid"] = self.providerBid!
            }
            if self.providerUid != nil {
                map["ProviderUid"] = self.providerUid!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.typeName != nil {
                map["TypeName"] = self.typeName!
            }
            if self.uploadTime != nil {
                map["UploadTime"] = self.uploadTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChaincodePackageId") {
                self.chaincodePackageId = dict["ChaincodePackageId"] as! String
            }
            if dict.keys.contains("Checksum") {
                self.checksum = dict["Checksum"] as! String
            }
            if dict.keys.contains("DeleteTime") {
                self.deleteTime = dict["DeleteTime"] as! Int64
            }
            if dict.keys.contains("Deleted") {
                self.deleted = dict["Deleted"] as! Bool
            }
            if dict.keys.contains("InstallTime") {
                self.installTime = dict["InstallTime"] as! Int64
            }
            if dict.keys.contains("Label") {
                self.label = dict["Label"] as! String
            }
            if dict.keys.contains("Md5sum") {
                self.md5sum = dict["Md5sum"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
            if dict.keys.contains("OssBucket") {
                self.ossBucket = dict["OssBucket"] as! String
            }
            if dict.keys.contains("OssURL") {
                self.ossURL = dict["OssURL"] as! String
            }
            if dict.keys.contains("ProviderBid") {
                self.providerBid = dict["ProviderBid"] as! String
            }
            if dict.keys.contains("ProviderUid") {
                self.providerUid = dict["ProviderUid"] as! Int64
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("TypeName") {
                self.typeName = dict["TypeName"] as! String
            }
            if dict.keys.contains("UploadTime") {
                self.uploadTime = dict["UploadTime"] as! Int64
            }
        }
    }
    public var errorCode: Int32?

    public var message: String?

    public var requestId: String?

    public var result: InstallFabricChaincodePackageResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = InstallFabricChaincodePackageResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class InstallFabricChaincodePackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallFabricChaincodePackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InstallFabricChaincodePackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstantiateChaincodeRequest : Tea.TeaModel {
    public var chaincodeId: String?

    public var collectionConfig: String?

    public var endorsePolicy: String?

    public var location: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chaincodeId != nil {
            map["ChaincodeId"] = self.chaincodeId!
        }
        if self.collectionConfig != nil {
            map["CollectionConfig"] = self.collectionConfig!
        }
        if self.endorsePolicy != nil {
            map["EndorsePolicy"] = self.endorsePolicy!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChaincodeId") {
            self.chaincodeId = dict["ChaincodeId"] as! String
        }
        if dict.keys.contains("CollectionConfig") {
            self.collectionConfig = dict["CollectionConfig"] as! String
        }
        if dict.keys.contains("EndorsePolicy") {
            self.endorsePolicy = dict["EndorsePolicy"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class InstantiateChaincodeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var chaincodeId: String?

        public var channelName: String?

        public var consortiumId: String?

        public var createTime: String?

        public var deployTime: String?

        public var endorsePolicy: String?

        public var input: String?

        public var install: Bool?

        public var message: String?

        public var name: String?

        public var path: String?

        public var providerId: String?

        public var providerName: String?

        public var state: String?

        public var type: Int32?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chaincodeId != nil {
                map["ChaincodeId"] = self.chaincodeId!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.deployTime != nil {
                map["DeployTime"] = self.deployTime!
            }
            if self.endorsePolicy != nil {
                map["EndorsePolicy"] = self.endorsePolicy!
            }
            if self.input != nil {
                map["Input"] = self.input!
            }
            if self.install != nil {
                map["Install"] = self.install!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.providerId != nil {
                map["ProviderId"] = self.providerId!
            }
            if self.providerName != nil {
                map["ProviderName"] = self.providerName!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChaincodeId") {
                self.chaincodeId = dict["ChaincodeId"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DeployTime") {
                self.deployTime = dict["DeployTime"] as! String
            }
            if dict.keys.contains("EndorsePolicy") {
                self.endorsePolicy = dict["EndorsePolicy"] as! String
            }
            if dict.keys.contains("Input") {
                self.input = dict["Input"] as! String
            }
            if dict.keys.contains("Install") {
                self.install = dict["Install"] as! Bool
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("ProviderId") {
                self.providerId = dict["ProviderId"] as! String
            }
            if dict.keys.contains("ProviderName") {
                self.providerName = dict["ProviderName"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: InstantiateChaincodeResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = InstantiateChaincodeResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class InstantiateChaincodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstantiateChaincodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InstantiateChaincodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InviteUserRequest : Tea.TeaModel {
    public var bid: String?

    public var bizid: String?

    public var userEmail: String?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bid != nil {
            map["Bid"] = self.bid!
        }
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.userEmail != nil {
            map["UserEmail"] = self.userEmail!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bid") {
            self.bid = dict["Bid"] as! String
        }
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("UserEmail") {
            self.userEmail = dict["UserEmail"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! Int64
        }
    }
}

public class InviteUserResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var bid: String?

        public var bizid: String?

        public var code: String?

        public var createTime: Int64?

        public var email: String?

        public var fromBid: String?

        public var fromUserId: Int32?

        public var status: Int32?

        public var updateTime: Int64?

        public var userId: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bid != nil {
                map["Bid"] = self.bid!
            }
            if self.bizid != nil {
                map["Bizid"] = self.bizid!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.fromBid != nil {
                map["FromBid"] = self.fromBid!
            }
            if self.fromUserId != nil {
                map["FromUserId"] = self.fromUserId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bid") {
                self.bid = dict["Bid"] as! String
            }
            if dict.keys.contains("Bizid") {
                self.bizid = dict["Bizid"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Email") {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("FromBid") {
                self.fromBid = dict["FromBid"] as! String
            }
            if dict.keys.contains("FromUserId") {
                self.fromUserId = dict["FromUserId"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var result: InviteUserResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = InviteUserResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class InviteUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InviteUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InviteUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class JoinChannelRequest : Tea.TeaModel {
    public var channelId: String?

    public var do_: String?

    public var location: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.do_ != nil {
            map["Do"] = self.do_!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("Do") {
            self.do_ = dict["Do"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
    }
}

public class JoinChannelResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var acceptTime: String?

        public var approveTime: String?

        public var channelId: String?

        public var confirmTime: String?

        public var destroyTime: String?

        public var inviteTime: String?

        public var organizationId: String?

        public var state: String?

        public var withPeer: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acceptTime != nil {
                map["AcceptTime"] = self.acceptTime!
            }
            if self.approveTime != nil {
                map["ApproveTime"] = self.approveTime!
            }
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.confirmTime != nil {
                map["ConfirmTime"] = self.confirmTime!
            }
            if self.destroyTime != nil {
                map["DestroyTime"] = self.destroyTime!
            }
            if self.inviteTime != nil {
                map["InviteTime"] = self.inviteTime!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.withPeer != nil {
                map["WithPeer"] = self.withPeer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcceptTime") {
                self.acceptTime = dict["AcceptTime"] as! String
            }
            if dict.keys.contains("ApproveTime") {
                self.approveTime = dict["ApproveTime"] as! String
            }
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
            if dict.keys.contains("ConfirmTime") {
                self.confirmTime = dict["ConfirmTime"] as! String
            }
            if dict.keys.contains("DestroyTime") {
                self.destroyTime = dict["DestroyTime"] as! String
            }
            if dict.keys.contains("InviteTime") {
                self.inviteTime = dict["InviteTime"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("WithPeer") {
                self.withPeer = dict["WithPeer"] as! Bool
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: [JoinChannelResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [JoinChannelResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = JoinChannelResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class JoinChannelResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: JoinChannelResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = JoinChannelResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var nextToken: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [ListTagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListTagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public var resourceId: String?

        public var resourceType: String?

        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceId != nil {
                map["ResourceId"] = self.resourceId!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ResourceId") {
                self.resourceId = dict["ResourceId"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("TagKey") {
                self.tagKey = dict["TagKey"] as! String
            }
            if dict.keys.contains("TagValue") {
                self.tagValue = dict["TagValue"] as! String
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: [ListTagResourcesResponseBody.TagResources]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            var tmp : [Any] = []
            for k in self.tagResources! {
                tmp.append(k.toMap())
            }
            map["TagResources"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") {
            var tmp : [ListTagResourcesResponseBody.TagResources] = []
            for v in dict["TagResources"] as! [Any] {
                var model = ListTagResourcesResponseBody.TagResources()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tagResources = tmp
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyTriggerRequest : Tea.TeaModel {
    public var channelId: String?

    public var name: String?

    public var options: String?

    public var organizationId: String?

    public var source: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.options != nil {
            map["Options"] = self.options!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Options") {
            self.options = dict["Options"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ModifyTriggerResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Checkpoint : Tea.TeaModel {
            public var errorCount: Int64?

            public var height: Int64?

            public var index: Int64?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCount != nil {
                    map["ErrorCount"] = self.errorCount!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.index != nil {
                    map["Index"] = self.index!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCount") {
                    self.errorCount = dict["ErrorCount"] as! Int64
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! Int64
                }
                if dict.keys.contains("Index") {
                    self.index = dict["Index"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var channelId: String?

        public var channelName: String?

        public var checkpoint: ModifyTriggerResponseBody.Result.Checkpoint?

        public var createTime: Int64?

        public var errorMessage: String?

        public var name: String?

        public var options: String?

        public var source: String?

        public var status: Int32?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.checkpoint?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.checkpoint != nil {
                map["Checkpoint"] = self.checkpoint?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.options != nil {
                map["Options"] = self.options!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("Checkpoint") {
                var model = ModifyTriggerResponseBody.Result.Checkpoint()
                model.fromMap(dict["Checkpoint"] as! [String: Any])
                self.checkpoint = model
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Options") {
                self.options = dict["Options"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: ModifyTriggerResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = ModifyTriggerResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ModifyTriggerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyTriggerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyTriggerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OperateUserRequest : Tea.TeaModel {
    public var bid: String?

    public var bizid: String?

    public var operation: Int32?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bid != nil {
            map["Bid"] = self.bid!
        }
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.operation != nil {
            map["Operation"] = self.operation!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bid") {
            self.bid = dict["Bid"] as! String
        }
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Operation") {
            self.operation = dict["Operation"] as! Int32
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class OperateUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class OperateUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OperateUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OperateUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ProcessCloudIDEContractTransactionRequest : Tea.TeaModel {
    public var antChainId: String?

    public var transaction: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.transaction != nil {
            map["Transaction"] = self.transaction!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("Transaction") {
            self.transaction = dict["Transaction"] as! String
        }
    }
}

public class ProcessCloudIDEContractTransactionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class ProcessCloudIDEContractTransactionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ProcessCloudIDEContractTransactionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ProcessCloudIDEContractTransactionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ProcessPublicCloudIDEContractTransactionRequest : Tea.TeaModel {
    public var bizid: String?

    public var transaction: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.transaction != nil {
            map["Transaction"] = self.transaction!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Transaction") {
            self.transaction = dict["Transaction"] as! String
        }
    }
}

public class ProcessPublicCloudIDEContractTransactionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class ProcessPublicCloudIDEContractTransactionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ProcessPublicCloudIDEContractTransactionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ProcessPublicCloudIDEContractTransactionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryBlockRequest : Tea.TeaModel {
    public var bizid: String?

    public var height: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.height != nil {
            map["Height"] = self.height!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Height") {
            self.height = dict["Height"] as! Int64
        }
    }
}

public class QueryBlockResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var alias: String?

        public var blockHash: String?

        public var createTime: Int64?

        public var height: Int32?

        public var previousHash: String?

        public var rootTxHash: String?

        public var transSummaryList: String?

        public var transactionSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alias != nil {
                map["Alias"] = self.alias!
            }
            if self.blockHash != nil {
                map["BlockHash"] = self.blockHash!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.previousHash != nil {
                map["PreviousHash"] = self.previousHash!
            }
            if self.rootTxHash != nil {
                map["RootTxHash"] = self.rootTxHash!
            }
            if self.transSummaryList != nil {
                map["TransSummaryList"] = self.transSummaryList!
            }
            if self.transactionSize != nil {
                map["TransactionSize"] = self.transactionSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alias") {
                self.alias = dict["Alias"] as! String
            }
            if dict.keys.contains("BlockHash") {
                self.blockHash = dict["BlockHash"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! Int32
            }
            if dict.keys.contains("PreviousHash") {
                self.previousHash = dict["PreviousHash"] as! String
            }
            if dict.keys.contains("RootTxHash") {
                self.rootTxHash = dict["RootTxHash"] as! String
            }
            if dict.keys.contains("TransSummaryList") {
                self.transSummaryList = dict["TransSummaryList"] as! String
            }
            if dict.keys.contains("TransactionSize") {
                self.transactionSize = dict["TransactionSize"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var result: QueryBlockResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = QueryBlockResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class QueryBlockResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryBlockResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryBlockResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryConsortiumDeletableRequest : Tea.TeaModel {
    public var consortiumId: String?

    public var location: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
    }
}

public class QueryConsortiumDeletableResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var codeName: String?

        public var consortiumId: String?

        public var deletable: Bool?

        public var description_: String?

        public var domain: String?

        public var name: String?

        public var regionId: String?

        public var state: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.codeName != nil {
                map["CodeName"] = self.codeName!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.deletable != nil {
                map["Deletable"] = self.deletable!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CodeName") {
                self.codeName = dict["CodeName"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("Deletable") {
                self.deletable = dict["Deletable"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: QueryConsortiumDeletableResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = QueryConsortiumDeletableResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryConsortiumDeletableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryConsortiumDeletableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryConsortiumDeletableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryEthereumDeletableRequest : Tea.TeaModel {
    public var ethereumId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ethereumId != nil {
            map["EthereumId"] = self.ethereumId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EthereumId") {
            self.ethereumId = dict["EthereumId"] as! String
        }
    }
}

public class QueryEthereumDeletableResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var deletable: Bool?

        public var ethereumId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deletable != nil {
                map["Deletable"] = self.deletable!
            }
            if self.ethereumId != nil {
                map["EthereumId"] = self.ethereumId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Deletable") {
                self.deletable = dict["Deletable"] as! Bool
            }
            if dict.keys.contains("EthereumId") {
                self.ethereumId = dict["EthereumId"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: QueryEthereumDeletableResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = QueryEthereumDeletableResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryEthereumDeletableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryEthereumDeletableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryEthereumDeletableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMetricRequest : Tea.TeaModel {
    public var bizid: String?

    public var innerIp: String?

    public var metric: String?

    public var period: String?

    public var port: String?

    public var timeArea: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.innerIp != nil {
            map["InnerIp"] = self.innerIp!
        }
        if self.metric != nil {
            map["Metric"] = self.metric!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.timeArea != nil {
            map["TimeArea"] = self.timeArea!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("InnerIp") {
            self.innerIp = dict["InnerIp"] as! String
        }
        if dict.keys.contains("Metric") {
            self.metric = dict["Metric"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! String
        }
        if dict.keys.contains("TimeArea") {
            self.timeArea = dict["TimeArea"] as! String
        }
    }
}

public class QueryMetricResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class QueryMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMetricResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryOrganizationDeletableRequest : Tea.TeaModel {
    public var location: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class QueryOrganizationDeletableResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var codeName: String?

        public var deletable: Bool?

        public var description_: String?

        public var domain: String?

        public var name: String?

        public var organizationId: String?

        public var regionId: String?

        public var state: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.codeName != nil {
                map["CodeName"] = self.codeName!
            }
            if self.deletable != nil {
                map["Deletable"] = self.deletable!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CodeName") {
                self.codeName = dict["CodeName"] as! String
            }
            if dict.keys.contains("Deletable") {
                self.deletable = dict["Deletable"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Domain") {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: QueryOrganizationDeletableResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = QueryOrganizationDeletableResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class QueryOrganizationDeletableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryOrganizationDeletableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryOrganizationDeletableResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTransactionRequest : Tea.TeaModel {
    public var bizid: String?

    public var hash: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.hash != nil {
            map["Hash"] = self.hash!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Hash") {
            self.hash = dict["Hash"] as! String
        }
    }
}

public class QueryTransactionResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ReferenceList : Tea.TeaModel {
            public var data: String?

            public var length: Int32?

            public var type: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.length != nil {
                    map["Length"] = self.length!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("Length") {
                    self.length = dict["Length"] as! Int32
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! Int32
                }
            }
        }
        public var blockHeight: Int64?

        public var blockVersion: Int32?

        public var category: Int32?

        public var content: String?

        public var contentHash: String?

        public var createTime: Int64?

        public var hash: String?

        public var keyName: String?

        public var keyWrap: String?

        public var nonce: String?

        public var referenceCount: Int32?

        public var referenceList: QueryTransactionResponseBody.Result.ReferenceList?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.referenceList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.blockHeight != nil {
                map["BlockHeight"] = self.blockHeight!
            }
            if self.blockVersion != nil {
                map["BlockVersion"] = self.blockVersion!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.contentHash != nil {
                map["ContentHash"] = self.contentHash!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.hash != nil {
                map["Hash"] = self.hash!
            }
            if self.keyName != nil {
                map["KeyName"] = self.keyName!
            }
            if self.keyWrap != nil {
                map["KeyWrap"] = self.keyWrap!
            }
            if self.nonce != nil {
                map["Nonce"] = self.nonce!
            }
            if self.referenceCount != nil {
                map["ReferenceCount"] = self.referenceCount!
            }
            if self.referenceList != nil {
                map["ReferenceList"] = self.referenceList?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BlockHeight") {
                self.blockHeight = dict["BlockHeight"] as! Int64
            }
            if dict.keys.contains("BlockVersion") {
                self.blockVersion = dict["BlockVersion"] as! Int32
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! Int32
            }
            if dict.keys.contains("Content") {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("ContentHash") {
                self.contentHash = dict["ContentHash"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Hash") {
                self.hash = dict["Hash"] as! String
            }
            if dict.keys.contains("KeyName") {
                self.keyName = dict["KeyName"] as! String
            }
            if dict.keys.contains("KeyWrap") {
                self.keyWrap = dict["KeyWrap"] as! String
            }
            if dict.keys.contains("Nonce") {
                self.nonce = dict["Nonce"] as! String
            }
            if dict.keys.contains("ReferenceCount") {
                self.referenceCount = dict["ReferenceCount"] as! Int32
            }
            if dict.keys.contains("ReferenceList") {
                var model = QueryTransactionResponseBody.Result.ReferenceList()
                model.fromMap(dict["ReferenceList"] as! [String: Any])
                self.referenceList = model
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var result: QueryTransactionResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = QueryTransactionResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class QueryTransactionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTransactionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryTransactionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RejectUserRequest : Tea.TeaModel {
    public var bid: String?

    public var bizid: String?

    public var reason: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bid != nil {
            map["Bid"] = self.bid!
        }
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bid") {
            self.bid = dict["Bid"] as! String
        }
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Reason") {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class RejectUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class RejectUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RejectUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RejectUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenameBlockchainRequest : Tea.TeaModel {
    public var bizid: String?

    public var newName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.newName != nil {
            map["NewName"] = self.newName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("NewName") {
            self.newName = dict["NewName"] as! String
        }
    }
}

public class RenameBlockchainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class RenameBlockchainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenameBlockchainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RenameBlockchainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetAntChainCertificateRequest : Tea.TeaModel {
    public var antChainId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
    }
}

public class ResetAntChainCertificateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class ResetAntChainCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetAntChainCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetAntChainCertificateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetAntChainUserCertificateRequest : Tea.TeaModel {
    public var antChainId: String?

    public var bid: String?

    public var operation: Int32?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.bid != nil {
            map["Bid"] = self.bid!
        }
        if self.operation != nil {
            map["Operation"] = self.operation!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("Bid") {
            self.bid = dict["Bid"] as! String
        }
        if dict.keys.contains("Operation") {
            self.operation = dict["Operation"] as! Int32
        }
        if dict.keys.contains("Username") {
            self.username = dict["Username"] as! String
        }
    }
}

public class ResetAntChainUserCertificateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class ResetAntChainUserCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetAntChainUserCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetAntChainUserCertificateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetCertificateRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class ResetCertificateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class ResetCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetCertificateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetOrganizationUserPasswordRequest : Tea.TeaModel {
    public var location: String?

    public var organizationId: String?

    public var password: String?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("Username") {
            self.username = dict["Username"] as! String
        }
    }
}

public class ResetOrganizationUserPasswordResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createTime: String?

        public var expireTime: String?

        public var fullname: String?

        public var organizationId: String?

        public var password: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.fullname != nil {
                map["Fullname"] = self.fullname!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.username != nil {
                map["Username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("Fullname") {
                self.fullname = dict["Fullname"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("Username") {
                self.username = dict["Username"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: ResetOrganizationUserPasswordResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = ResetOrganizationUserPasswordResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ResetOrganizationUserPasswordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetOrganizationUserPasswordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetOrganizationUserPasswordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetPublicAntChainCertificateRequest : Tea.TeaModel {
    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class ResetPublicAntChainCertificateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class ResetPublicAntChainCertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetPublicAntChainCertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetPublicAntChainCertificateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetUserRequest : Tea.TeaModel {
    public var bid: String?

    public var bizid: String?

    public var operation: Int32?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bid != nil {
            map["Bid"] = self.bid!
        }
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.operation != nil {
            map["Operation"] = self.operation!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bid") {
            self.bid = dict["Bid"] as! String
        }
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Operation") {
            self.operation = dict["Operation"] as! Int32
        }
        if dict.keys.contains("UserName") {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class ResetUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class ResetUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SchemaDetailRequest : Tea.TeaModel {
    public var bizid: String?

    public var schemaId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! Int64
        }
    }
}

public class SchemaDetailResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Responses : Tea.TeaModel {
            public class Properties : Tea.TeaModel {
                public class DataSource : Tea.TeaModel {
                    public var allowNull: Int32?

                    public var annotation: String?

                    public var field: String?

                    public var indexes: Int32?

                    public var key: Int32?

                    public var length: Int32?

                    public var reg: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.allowNull != nil {
                            map["AllowNull"] = self.allowNull!
                        }
                        if self.annotation != nil {
                            map["Annotation"] = self.annotation!
                        }
                        if self.field != nil {
                            map["Field"] = self.field!
                        }
                        if self.indexes != nil {
                            map["Indexes"] = self.indexes!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.length != nil {
                            map["Length"] = self.length!
                        }
                        if self.reg != nil {
                            map["Reg"] = self.reg!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AllowNull") {
                            self.allowNull = dict["AllowNull"] as! Int32
                        }
                        if dict.keys.contains("Annotation") {
                            self.annotation = dict["Annotation"] as! String
                        }
                        if dict.keys.contains("Field") {
                            self.field = dict["Field"] as! String
                        }
                        if dict.keys.contains("Indexes") {
                            self.indexes = dict["Indexes"] as! Int32
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! Int32
                        }
                        if dict.keys.contains("Length") {
                            self.length = dict["Length"] as! Int32
                        }
                        if dict.keys.contains("Reg") {
                            self.reg = dict["Reg"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var count: Int32?

                public var dataSource: [SchemaDetailResponseBody.Result.Responses.Properties.DataSource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.dataSource != nil {
                        var tmp : [Any] = []
                        for k in self.dataSource! {
                            tmp.append(k.toMap())
                        }
                        map["DataSource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int32
                    }
                    if dict.keys.contains("DataSource") {
                        var tmp : [SchemaDetailResponseBody.Result.Responses.Properties.DataSource] = []
                        for v in dict["DataSource"] as! [Any] {
                            var model = SchemaDetailResponseBody.Result.Responses.Properties.DataSource()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dataSource = tmp
                    }
                }
            }
            public var category: String?

            public var categoryName: String?

            public var description_: String?

            public var properties: SchemaDetailResponseBody.Result.Responses.Properties?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.properties?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.categoryName != nil {
                    map["CategoryName"] = self.categoryName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.properties != nil {
                    map["Properties"] = self.properties?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CategoryName") {
                    self.categoryName = dict["CategoryName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Properties") {
                    var model = SchemaDetailResponseBody.Result.Responses.Properties()
                    model.fromMap(dict["Properties"] as! [String: Any])
                    self.properties = model
                }
            }
        }
        public class Schema : Tea.TeaModel {
            public var createTime: Int64?

            public var description_: String?

            public var id: Int64?

            public var isTemplate: Bool?

            public var name: String?

            public var updateTime: Int64?

            public var version: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isTemplate != nil {
                    map["IsTemplate"] = self.isTemplate!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IsTemplate") {
                    self.isTemplate = dict["IsTemplate"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! Int64
                }
            }
        }
        public var responses: [SchemaDetailResponseBody.Result.Responses]?

        public var schema: SchemaDetailResponseBody.Result.Schema?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.schema?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.responses != nil {
                var tmp : [Any] = []
                for k in self.responses! {
                    tmp.append(k.toMap())
                }
                map["Responses"] = tmp
            }
            if self.schema != nil {
                map["Schema"] = self.schema?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Responses") {
                var tmp : [SchemaDetailResponseBody.Result.Responses] = []
                for v in dict["Responses"] as! [Any] {
                    var model = SchemaDetailResponseBody.Result.Responses()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.responses = tmp
            }
            if dict.keys.contains("Schema") {
                var model = SchemaDetailResponseBody.Result.Schema()
                model.fromMap(dict["Schema"] as! [String: Any])
                self.schema = model
            }
        }
    }
    public var requestId: String?

    public var result: SchemaDetailResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = SchemaDetailResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class SchemaDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SchemaDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SchemaDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartSmartContractJobRequest : Tea.TeaModel {
    public var jobId: String?

    public var jobName: String?

    public var sourceOpt: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.sourceOpt != nil {
            map["SourceOpt"] = self.sourceOpt!
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobName") {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("SourceOpt") {
            self.sourceOpt = dict["SourceOpt"] as! String
        }
        if dict.keys.contains("SourceType") {
            self.sourceType = dict["SourceType"] as! String
        }
    }
}

public class StartSmartContractJobResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class StartSmartContractJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartSmartContractJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartSmartContractJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitFabricChaincodeDefinitionRequest : Tea.TeaModel {
    public var chaincodePackageId: String?

    public var chaincodeVersion: String?

    public var channelId: String?

    public var collectionConfig: String?

    public var endorsePolicy: String?

    public var initRequired: Bool?

    public var location: String?

    public var name: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chaincodePackageId != nil {
            map["ChaincodePackageId"] = self.chaincodePackageId!
        }
        if self.chaincodeVersion != nil {
            map["ChaincodeVersion"] = self.chaincodeVersion!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.collectionConfig != nil {
            map["CollectionConfig"] = self.collectionConfig!
        }
        if self.endorsePolicy != nil {
            map["EndorsePolicy"] = self.endorsePolicy!
        }
        if self.initRequired != nil {
            map["InitRequired"] = self.initRequired!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChaincodePackageId") {
            self.chaincodePackageId = dict["ChaincodePackageId"] as! String
        }
        if dict.keys.contains("ChaincodeVersion") {
            self.chaincodeVersion = dict["ChaincodeVersion"] as! String
        }
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("CollectionConfig") {
            self.collectionConfig = dict["CollectionConfig"] as! String
        }
        if dict.keys.contains("EndorsePolicy") {
            self.endorsePolicy = dict["EndorsePolicy"] as! String
        }
        if dict.keys.contains("InitRequired") {
            self.initRequired = dict["InitRequired"] as! Bool
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class SubmitFabricChaincodeDefinitionResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var chaincodeId: String?

        public var channelName: String?

        public var consortiumId: String?

        public var createTime: String?

        public var deployTime: String?

        public var endorsePolicy: String?

        public var input: String?

        public var install: Bool?

        public var message: String?

        public var name: String?

        public var path: String?

        public var providerId: String?

        public var providerName: String?

        public var state: String?

        public var type: Int32?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chaincodeId != nil {
                map["ChaincodeId"] = self.chaincodeId!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.deployTime != nil {
                map["DeployTime"] = self.deployTime!
            }
            if self.endorsePolicy != nil {
                map["EndorsePolicy"] = self.endorsePolicy!
            }
            if self.input != nil {
                map["Input"] = self.input!
            }
            if self.install != nil {
                map["Install"] = self.install!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.providerId != nil {
                map["ProviderId"] = self.providerId!
            }
            if self.providerName != nil {
                map["ProviderName"] = self.providerName!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChaincodeId") {
                self.chaincodeId = dict["ChaincodeId"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DeployTime") {
                self.deployTime = dict["DeployTime"] as! String
            }
            if dict.keys.contains("EndorsePolicy") {
                self.endorsePolicy = dict["EndorsePolicy"] as! String
            }
            if dict.keys.contains("Input") {
                self.input = dict["Input"] as! String
            }
            if dict.keys.contains("Install") {
                self.install = dict["Install"] as! Bool
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("ProviderId") {
                self.providerId = dict["ProviderId"] as! String
            }
            if dict.keys.contains("ProviderName") {
                self.providerName = dict["ProviderName"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var chaincodeDefinitionId: String?

    public var chaincodePackageId: String?

    public var errorCode: Int32?

    public var initRequired: Bool?

    public var requestId: String?

    public var result: SubmitFabricChaincodeDefinitionResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chaincodeDefinitionId != nil {
            map["ChaincodeDefinitionId"] = self.chaincodeDefinitionId!
        }
        if self.chaincodePackageId != nil {
            map["ChaincodePackageId"] = self.chaincodePackageId!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.initRequired != nil {
            map["InitRequired"] = self.initRequired!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChaincodeDefinitionId") {
            self.chaincodeDefinitionId = dict["ChaincodeDefinitionId"] as! String
        }
        if dict.keys.contains("ChaincodePackageId") {
            self.chaincodePackageId = dict["ChaincodePackageId"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("InitRequired") {
            self.initRequired = dict["InitRequired"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = SubmitFabricChaincodeDefinitionResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SubmitFabricChaincodeDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitFabricChaincodeDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitFabricChaincodeDefinitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SyncFabricChaincodeStatusRequest : Tea.TeaModel {
    public var chaincodeId: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chaincodeId != nil {
            map["ChaincodeId"] = self.chaincodeId!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChaincodeId") {
            self.chaincodeId = dict["ChaincodeId"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class SyncFabricChaincodeStatusResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var chaincodeId: String?

        public var input: String?

        public var name: String?

        public var path: Int64?

        public var state: String?

        public var type: Int32?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chaincodeId != nil {
                map["ChaincodeId"] = self.chaincodeId!
            }
            if self.input != nil {
                map["Input"] = self.input!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChaincodeId") {
                self.chaincodeId = dict["ChaincodeId"] as! String
            }
            if dict.keys.contains("Input") {
                self.input = dict["Input"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! Int64
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: SyncFabricChaincodeStatusResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = SyncFabricChaincodeStatusResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SyncFabricChaincodeStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SyncFabricChaincodeStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SyncFabricChaincodeStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SynchronizeChaincodeRequest : Tea.TeaModel {
    public var chaincodeId: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chaincodeId != nil {
            map["ChaincodeId"] = self.chaincodeId!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChaincodeId") {
            self.chaincodeId = dict["ChaincodeId"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class SynchronizeChaincodeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var chaincodeId: String?

        public var channelName: String?

        public var consortiumId: String?

        public var createTime: String?

        public var deployTime: String?

        public var endorsePolicy: String?

        public var input: String?

        public var install: Bool?

        public var message: String?

        public var name: String?

        public var path: String?

        public var providerId: String?

        public var providerName: String?

        public var state: String?

        public var type: Int32?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chaincodeId != nil {
                map["ChaincodeId"] = self.chaincodeId!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.deployTime != nil {
                map["DeployTime"] = self.deployTime!
            }
            if self.endorsePolicy != nil {
                map["EndorsePolicy"] = self.endorsePolicy!
            }
            if self.input != nil {
                map["Input"] = self.input!
            }
            if self.install != nil {
                map["Install"] = self.install!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.providerId != nil {
                map["ProviderId"] = self.providerId!
            }
            if self.providerName != nil {
                map["ProviderName"] = self.providerName!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChaincodeId") {
                self.chaincodeId = dict["ChaincodeId"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DeployTime") {
                self.deployTime = dict["DeployTime"] as! String
            }
            if dict.keys.contains("EndorsePolicy") {
                self.endorsePolicy = dict["EndorsePolicy"] as! String
            }
            if dict.keys.contains("Input") {
                self.input = dict["Input"] as! String
            }
            if dict.keys.contains("Install") {
                self.install = dict["Install"] as! Bool
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("ProviderId") {
                self.providerId = dict["ProviderId"] as! String
            }
            if dict.keys.contains("ProviderName") {
                self.providerName = dict["ProviderName"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: SynchronizeChaincodeResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = SynchronizeChaincodeResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class SynchronizeChaincodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SynchronizeChaincodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SynchronizeChaincodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [TagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = TagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnfreezeAccountRequest : Tea.TeaModel {
    public var account: String?

    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.account != nil {
            map["Account"] = self.account!
        }
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Account") {
            self.account = dict["Account"] as! String
        }
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class UnfreezeAccountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class UnfreezeAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnfreezeAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnfreezeAccountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnfreezeAntChainAccountRequest : Tea.TeaModel {
    public var account: String?

    public var antChainId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.account != nil {
            map["Account"] = self.account!
        }
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Account") {
            self.account = dict["Account"] as! String
        }
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
    }
}

public class UnfreezeAntChainAccountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class UnfreezeAntChainAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnfreezeAntChainAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnfreezeAntChainAccountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKey") {
            self.tagKey = dict["TagKey"] as! [String]
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: Bool?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAntChainRequest : Tea.TeaModel {
    public var antChainId: String?

    public var antChainName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.antChainName != nil {
            map["AntChainName"] = self.antChainName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("AntChainName") {
            self.antChainName = dict["AntChainName"] as! String
        }
    }
}

public class UpdateAntChainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class UpdateAntChainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAntChainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAntChainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAntChainConsortiumRequest : Tea.TeaModel {
    public var consortiumDescription: String?

    public var consortiumId: String?

    public var consortiumName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumDescription != nil {
            map["ConsortiumDescription"] = self.consortiumDescription!
        }
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.consortiumName != nil {
            map["ConsortiumName"] = self.consortiumName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumDescription") {
            self.consortiumDescription = dict["ConsortiumDescription"] as! String
        }
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("ConsortiumName") {
            self.consortiumName = dict["ConsortiumName"] as! String
        }
    }
}

public class UpdateAntChainConsortiumResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class UpdateAntChainConsortiumResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAntChainConsortiumResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAntChainConsortiumResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAntChainContractContentRequest : Tea.TeaModel {
    public var content: String?

    public var contentId: String?

    public var contentName: String?

    public var parentContentId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.contentId != nil {
            map["ContentId"] = self.contentId!
        }
        if self.contentName != nil {
            map["ContentName"] = self.contentName!
        }
        if self.parentContentId != nil {
            map["ParentContentId"] = self.parentContentId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("ContentId") {
            self.contentId = dict["ContentId"] as! String
        }
        if dict.keys.contains("ContentName") {
            self.contentName = dict["ContentName"] as! String
        }
        if dict.keys.contains("ParentContentId") {
            self.parentContentId = dict["ParentContentId"] as! String
        }
    }
}

public class UpdateAntChainContractContentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class UpdateAntChainContractContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAntChainContractContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAntChainContractContentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAntChainContractProjectRequest : Tea.TeaModel {
    public var projectDescription: String?

    public var projectId: String?

    public var projectName: String?

    public var projectVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectDescription != nil {
            map["ProjectDescription"] = self.projectDescription!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        if self.projectVersion != nil {
            map["ProjectVersion"] = self.projectVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectDescription") {
            self.projectDescription = dict["ProjectDescription"] as! String
        }
        if dict.keys.contains("ProjectId") {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ProjectName") {
            self.projectName = dict["ProjectName"] as! String
        }
        if dict.keys.contains("ProjectVersion") {
            self.projectVersion = dict["ProjectVersion"] as! String
        }
    }
}

public class UpdateAntChainContractProjectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class UpdateAntChainContractProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAntChainContractProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAntChainContractProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAntChainMemberRequest : Tea.TeaModel {
    public var consortiumId: String?

    public var memberId: String?

    public var memberName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consortiumId != nil {
            map["ConsortiumId"] = self.consortiumId!
        }
        if self.memberId != nil {
            map["MemberId"] = self.memberId!
        }
        if self.memberName != nil {
            map["MemberName"] = self.memberName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsortiumId") {
            self.consortiumId = dict["ConsortiumId"] as! String
        }
        if dict.keys.contains("MemberId") {
            self.memberId = dict["MemberId"] as! String
        }
        if dict.keys.contains("MemberName") {
            self.memberName = dict["MemberName"] as! String
        }
    }
}

public class UpdateAntChainMemberResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class UpdateAntChainMemberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAntChainMemberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAntChainMemberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAntChainQRCodeAuthorizationRequest : Tea.TeaModel {
    public var antChainId: String?

    public var authorizationType: String?

    public var QRCodeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.antChainId != nil {
            map["AntChainId"] = self.antChainId!
        }
        if self.authorizationType != nil {
            map["AuthorizationType"] = self.authorizationType!
        }
        if self.QRCodeType != nil {
            map["QRCodeType"] = self.QRCodeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AntChainId") {
            self.antChainId = dict["AntChainId"] as! String
        }
        if dict.keys.contains("AuthorizationType") {
            self.authorizationType = dict["AuthorizationType"] as! String
        }
        if dict.keys.contains("QRCodeType") {
            self.QRCodeType = dict["QRCodeType"] as! String
        }
    }
}

public class UpdateAntChainQRCodeAuthorizationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class UpdateAntChainQRCodeAuthorizationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAntChainQRCodeAuthorizationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAntChainQRCodeAuthorizationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateBlockchainSchemaRequest : Tea.TeaModel {
    public var bizid: String?

    public var categoryConfigs: String?

    public var description_: String?

    public var schemaId: Int64?

    public var schemaName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.categoryConfigs != nil {
            map["CategoryConfigs"] = self.categoryConfigs!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("CategoryConfigs") {
            self.categoryConfigs = dict["CategoryConfigs"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! Int64
        }
        if dict.keys.contains("SchemaName") {
            self.schemaName = dict["SchemaName"] as! String
        }
    }
}

public class UpdateBlockchainSchemaResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Responses : Tea.TeaModel {
            public class Properties : Tea.TeaModel {
                public class DataSource : Tea.TeaModel {
                    public var allowNull: Int32?

                    public var annotation: String?

                    public var field: String?

                    public var indexes: Int32?

                    public var key: Int32?

                    public var length: Int32?

                    public var reg: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.allowNull != nil {
                            map["AllowNull"] = self.allowNull!
                        }
                        if self.annotation != nil {
                            map["Annotation"] = self.annotation!
                        }
                        if self.field != nil {
                            map["Field"] = self.field!
                        }
                        if self.indexes != nil {
                            map["Indexes"] = self.indexes!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.length != nil {
                            map["Length"] = self.length!
                        }
                        if self.reg != nil {
                            map["Reg"] = self.reg!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AllowNull") {
                            self.allowNull = dict["AllowNull"] as! Int32
                        }
                        if dict.keys.contains("Annotation") {
                            self.annotation = dict["Annotation"] as! String
                        }
                        if dict.keys.contains("Field") {
                            self.field = dict["Field"] as! String
                        }
                        if dict.keys.contains("Indexes") {
                            self.indexes = dict["Indexes"] as! Int32
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! Int32
                        }
                        if dict.keys.contains("Length") {
                            self.length = dict["Length"] as! Int32
                        }
                        if dict.keys.contains("Reg") {
                            self.reg = dict["Reg"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var count: Int32?

                public var dataSource: [UpdateBlockchainSchemaResponseBody.Result.Responses.Properties.DataSource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.dataSource != nil {
                        var tmp : [Any] = []
                        for k in self.dataSource! {
                            tmp.append(k.toMap())
                        }
                        map["DataSource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int32
                    }
                    if dict.keys.contains("DataSource") {
                        var tmp : [UpdateBlockchainSchemaResponseBody.Result.Responses.Properties.DataSource] = []
                        for v in dict["DataSource"] as! [Any] {
                            var model = UpdateBlockchainSchemaResponseBody.Result.Responses.Properties.DataSource()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dataSource = tmp
                    }
                }
            }
            public var category: String?

            public var categoryName: String?

            public var description_: String?

            public var properties: UpdateBlockchainSchemaResponseBody.Result.Responses.Properties?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.properties?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.categoryName != nil {
                    map["CategoryName"] = self.categoryName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.properties != nil {
                    map["Properties"] = self.properties?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CategoryName") {
                    self.categoryName = dict["CategoryName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Properties") {
                    var model = UpdateBlockchainSchemaResponseBody.Result.Responses.Properties()
                    model.fromMap(dict["Properties"] as! [String: Any])
                    self.properties = model
                }
            }
        }
        public class Schema : Tea.TeaModel {
            public var createTime: Int64?

            public var description_: String?

            public var id: Int64?

            public var isTemplate: Bool?

            public var name: String?

            public var updateTime: Int64?

            public var version: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isTemplate != nil {
                    map["IsTemplate"] = self.isTemplate!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IsTemplate") {
                    self.isTemplate = dict["IsTemplate"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! Int64
                }
            }
        }
        public var responses: [UpdateBlockchainSchemaResponseBody.Result.Responses]?

        public var schema: UpdateBlockchainSchemaResponseBody.Result.Schema?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.schema?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.responses != nil {
                var tmp : [Any] = []
                for k in self.responses! {
                    tmp.append(k.toMap())
                }
                map["Responses"] = tmp
            }
            if self.schema != nil {
                map["Schema"] = self.schema?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Responses") {
                var tmp : [UpdateBlockchainSchemaResponseBody.Result.Responses] = []
                for v in dict["Responses"] as! [Any] {
                    var model = UpdateBlockchainSchemaResponseBody.Result.Responses()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.responses = tmp
            }
            if dict.keys.contains("Schema") {
                var model = UpdateBlockchainSchemaResponseBody.Result.Schema()
                model.fromMap(dict["Schema"] as! [String: Any])
                self.schema = model
            }
        }
    }
    public var requestId: String?

    public var result: UpdateBlockchainSchemaResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdateBlockchainSchemaResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class UpdateBlockchainSchemaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateBlockchainSchemaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateBlockchainSchemaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateChannelConfigRequest : Tea.TeaModel {
    public var batchTimeout: Int32?

    public var channelId: String?

    public var maxMessageCount: Int32?

    public var organizationId: String?

    public var preferredMaxBytes: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchTimeout != nil {
            map["BatchTimeout"] = self.batchTimeout!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.maxMessageCount != nil {
            map["MaxMessageCount"] = self.maxMessageCount!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.preferredMaxBytes != nil {
            map["PreferredMaxBytes"] = self.preferredMaxBytes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchTimeout") {
            self.batchTimeout = dict["BatchTimeout"] as! Int32
        }
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("MaxMessageCount") {
            self.maxMessageCount = dict["MaxMessageCount"] as! Int32
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("PreferredMaxBytes") {
            self.preferredMaxBytes = dict["PreferredMaxBytes"] as! Int32
        }
    }
}

public class UpdateChannelConfigResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var batchTimeout: Int32?

        public var blockCount: Int32?

        public var chaincodeCount: Int32?

        public var channelId: String?

        public var consortiumId: String?

        public var consortiumName: String?

        public var createTime: String?

        public var maxMessageCount: Int32?

        public var memberCount: Int32?

        public var name: String?

        public var ownerBid: String?

        public var ownerName: String?

        public var ownerUid: Int32?

        public var preferredMaxBytes: Int32?

        public var requestId: String?

        public var state: String?

        public var supportConfig: Bool?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.batchTimeout != nil {
                map["BatchTimeout"] = self.batchTimeout!
            }
            if self.blockCount != nil {
                map["BlockCount"] = self.blockCount!
            }
            if self.chaincodeCount != nil {
                map["ChaincodeCount"] = self.chaincodeCount!
            }
            if self.channelId != nil {
                map["ChannelId"] = self.channelId!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.consortiumName != nil {
                map["ConsortiumName"] = self.consortiumName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.maxMessageCount != nil {
                map["MaxMessageCount"] = self.maxMessageCount!
            }
            if self.memberCount != nil {
                map["MemberCount"] = self.memberCount!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ownerBid != nil {
                map["OwnerBid"] = self.ownerBid!
            }
            if self.ownerName != nil {
                map["OwnerName"] = self.ownerName!
            }
            if self.ownerUid != nil {
                map["OwnerUid"] = self.ownerUid!
            }
            if self.preferredMaxBytes != nil {
                map["PreferredMaxBytes"] = self.preferredMaxBytes!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.supportConfig != nil {
                map["SupportConfig"] = self.supportConfig!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BatchTimeout") {
                self.batchTimeout = dict["BatchTimeout"] as! Int32
            }
            if dict.keys.contains("BlockCount") {
                self.blockCount = dict["BlockCount"] as! Int32
            }
            if dict.keys.contains("ChaincodeCount") {
                self.chaincodeCount = dict["ChaincodeCount"] as! Int32
            }
            if dict.keys.contains("ChannelId") {
                self.channelId = dict["ChannelId"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("ConsortiumName") {
                self.consortiumName = dict["ConsortiumName"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("MaxMessageCount") {
                self.maxMessageCount = dict["MaxMessageCount"] as! Int32
            }
            if dict.keys.contains("MemberCount") {
                self.memberCount = dict["MemberCount"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OwnerBid") {
                self.ownerBid = dict["OwnerBid"] as! String
            }
            if dict.keys.contains("OwnerName") {
                self.ownerName = dict["OwnerName"] as! String
            }
            if dict.keys.contains("OwnerUid") {
                self.ownerUid = dict["OwnerUid"] as! Int32
            }
            if dict.keys.contains("PreferredMaxBytes") {
                self.preferredMaxBytes = dict["PreferredMaxBytes"] as! Int32
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("SupportConfig") {
                self.supportConfig = dict["SupportConfig"] as! Bool
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: UpdateChannelConfigResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdateChannelConfigResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateChannelConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateChannelConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateChannelConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEthereumRequest : Tea.TeaModel {
    public var description_: String?

    public var ethereumId: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ethereumId != nil {
            map["EthereumId"] = self.ethereumId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EthereumId") {
            self.ethereumId = dict["EthereumId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class UpdateEthereumResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consensus: String?

        public var creator: String?

        public var description_: String?

        public var id: String?

        public var name: String?

        public var networkId: String?

        public var regionId: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consensus != nil {
                map["Consensus"] = self.consensus!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Consensus") {
                self.consensus = dict["Consensus"] as! String
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NetworkId") {
                self.networkId = dict["NetworkId"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: UpdateEthereumResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdateEthereumResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateEthereumResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEthereumResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateEthereumResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEthereumClientUserPasswordRequest : Tea.TeaModel {
    public var nodeId: String?

    public var password: String?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("Username") {
            self.username = dict["Username"] as! String
        }
    }
}

public class UpdateEthereumClientUserPasswordResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateEthereumClientUserPasswordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEthereumClientUserPasswordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateEthereumClientUserPasswordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEthereumNodeRequest : Tea.TeaModel {
    public var description_: String?

    public var nodeId: String?

    public var nodeName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("NodeName") {
            self.nodeName = dict["NodeName"] as! String
        }
    }
}

public class UpdateEthereumNodeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createTime: Int64?

        public var creator: String?

        public var description_: String?

        public var ethereumId: String?

        public var ethereumName: String?

        public var id: String?

        public var networkId: String?

        public var nodeName: String?

        public var publicIp: String?

        public var regionId: String?

        public var rpcPort: Int32?

        public var state: String?

        public var wsPort: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.ethereumId != nil {
                map["EthereumId"] = self.ethereumId!
            }
            if self.ethereumName != nil {
                map["EthereumName"] = self.ethereumName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.networkId != nil {
                map["NetworkId"] = self.networkId!
            }
            if self.nodeName != nil {
                map["NodeName"] = self.nodeName!
            }
            if self.publicIp != nil {
                map["PublicIp"] = self.publicIp!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.rpcPort != nil {
                map["RpcPort"] = self.rpcPort!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.wsPort != nil {
                map["WsPort"] = self.wsPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EthereumId") {
                self.ethereumId = dict["EthereumId"] as! String
            }
            if dict.keys.contains("EthereumName") {
                self.ethereumName = dict["EthereumName"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("NetworkId") {
                self.networkId = dict["NetworkId"] as! String
            }
            if dict.keys.contains("NodeName") {
                self.nodeName = dict["NodeName"] as! String
            }
            if dict.keys.contains("PublicIp") {
                self.publicIp = dict["PublicIp"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RpcPort") {
                self.rpcPort = dict["RpcPort"] as! Int32
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("WsPort") {
                self.wsPort = dict["WsPort"] as! Int32
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: UpdateEthereumNodeResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdateEthereumNodeResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateEthereumNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEthereumNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateEthereumNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEthereumNodeConfigurationRequest : Tea.TeaModel {
    public var IP: String?

    public var nodeId: String?

    public var nodePub: String?

    public var p2pPort: Int32?

    public var raftPort: Int32?

    public var rpcPort: Int32?

    public var TMPort: Int32?

    public var TMPub: String?

    public var WSPort: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.IP != nil {
            map["IP"] = self.IP!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.nodePub != nil {
            map["NodePub"] = self.nodePub!
        }
        if self.p2pPort != nil {
            map["P2pPort"] = self.p2pPort!
        }
        if self.raftPort != nil {
            map["RaftPort"] = self.raftPort!
        }
        if self.rpcPort != nil {
            map["RpcPort"] = self.rpcPort!
        }
        if self.TMPort != nil {
            map["TMPort"] = self.TMPort!
        }
        if self.TMPub != nil {
            map["TMPub"] = self.TMPub!
        }
        if self.WSPort != nil {
            map["WSPort"] = self.WSPort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IP") {
            self.IP = dict["IP"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("NodePub") {
            self.nodePub = dict["NodePub"] as! String
        }
        if dict.keys.contains("P2pPort") {
            self.p2pPort = dict["P2pPort"] as! Int32
        }
        if dict.keys.contains("RaftPort") {
            self.raftPort = dict["RaftPort"] as! Int32
        }
        if dict.keys.contains("RpcPort") {
            self.rpcPort = dict["RpcPort"] as! Int32
        }
        if dict.keys.contains("TMPort") {
            self.TMPort = dict["TMPort"] as! Int32
        }
        if dict.keys.contains("TMPub") {
            self.TMPub = dict["TMPub"] as! String
        }
        if dict.keys.contains("WSPort") {
            self.WSPort = dict["WSPort"] as! Int32
        }
    }
}

public class UpdateEthereumNodeConfigurationResponseBody : Tea.TeaModel {
    public var errorCode: Int32?

    public var requestId: String?

    public var result: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateEthereumNodeConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEthereumNodeConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateEthereumNodeConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGovernanceTaskRequest : Tea.TeaModel {
    public var channelId: String?

    public var organizationId: String?

    public var taskAction: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        if self.taskAction != nil {
            map["TaskAction"] = self.taskAction!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
        if dict.keys.contains("TaskAction") {
            self.taskAction = dict["TaskAction"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class UpdateGovernanceTaskResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public class AddedOrganizations : Tea.TeaModel {
                public class AnchorPeers : Tea.TeaModel {
                    public var host: String?

                    public var port: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.host != nil {
                            map["Host"] = self.host!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Host") {
                            self.host = dict["Host"] as! String
                        }
                        if dict.keys.contains("Port") {
                            self.port = dict["Port"] as! Int32
                        }
                    }
                }
                public class OrdererNodes : Tea.TeaModel {
                    public var address: String?

                    public var certificate: String?

                    public var key: String?

                    public var tlsroot: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.certificate != nil {
                            map["Certificate"] = self.certificate!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.tlsroot != nil {
                            map["Tlsroot"] = self.tlsroot!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Address") {
                            self.address = dict["Address"] as! String
                        }
                        if dict.keys.contains("Certificate") {
                            self.certificate = dict["Certificate"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Tlsroot") {
                            self.tlsroot = dict["Tlsroot"] as! String
                        }
                    }
                }
                public var anchorPeers: [UpdateGovernanceTaskResponseBody.Result.Content.AddedOrganizations.AnchorPeers]?

                public var crls: String?

                public var mspId: String?

                public var mspType: String?

                public var orderer: Bool?

                public var ordererNodes: [UpdateGovernanceTaskResponseBody.Result.Content.AddedOrganizations.OrdererNodes]?

                public var rootCertificates: String?

                public var tlsRootCertificates: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.anchorPeers != nil {
                        var tmp : [Any] = []
                        for k in self.anchorPeers! {
                            tmp.append(k.toMap())
                        }
                        map["AnchorPeers"] = tmp
                    }
                    if self.crls != nil {
                        map["Crls"] = self.crls!
                    }
                    if self.mspId != nil {
                        map["MspId"] = self.mspId!
                    }
                    if self.mspType != nil {
                        map["MspType"] = self.mspType!
                    }
                    if self.orderer != nil {
                        map["Orderer"] = self.orderer!
                    }
                    if self.ordererNodes != nil {
                        var tmp : [Any] = []
                        for k in self.ordererNodes! {
                            tmp.append(k.toMap())
                        }
                        map["OrdererNodes"] = tmp
                    }
                    if self.rootCertificates != nil {
                        map["RootCertificates"] = self.rootCertificates!
                    }
                    if self.tlsRootCertificates != nil {
                        map["TlsRootCertificates"] = self.tlsRootCertificates!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnchorPeers") {
                        var tmp : [UpdateGovernanceTaskResponseBody.Result.Content.AddedOrganizations.AnchorPeers] = []
                        for v in dict["AnchorPeers"] as! [Any] {
                            var model = UpdateGovernanceTaskResponseBody.Result.Content.AddedOrganizations.AnchorPeers()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.anchorPeers = tmp
                    }
                    if dict.keys.contains("Crls") {
                        self.crls = dict["Crls"] as! String
                    }
                    if dict.keys.contains("MspId") {
                        self.mspId = dict["MspId"] as! String
                    }
                    if dict.keys.contains("MspType") {
                        self.mspType = dict["MspType"] as! String
                    }
                    if dict.keys.contains("Orderer") {
                        self.orderer = dict["Orderer"] as! Bool
                    }
                    if dict.keys.contains("OrdererNodes") {
                        var tmp : [UpdateGovernanceTaskResponseBody.Result.Content.AddedOrganizations.OrdererNodes] = []
                        for v in dict["OrdererNodes"] as! [Any] {
                            var model = UpdateGovernanceTaskResponseBody.Result.Content.AddedOrganizations.OrdererNodes()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ordererNodes = tmp
                    }
                    if dict.keys.contains("RootCertificates") {
                        self.rootCertificates = dict["RootCertificates"] as! String
                    }
                    if dict.keys.contains("TlsRootCertificates") {
                        self.tlsRootCertificates = dict["TlsRootCertificates"] as! String
                    }
                }
            }
            public class ChaincodeSpecPkg : Tea.TeaModel {
                public class Cs : Tea.TeaModel {
                    public var input: String?

                    public var name: String?

                    public var path: String?

                    public var type: Int32?

                    public var version: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.input != nil {
                            map["Input"] = self.input!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.path != nil {
                            map["Path"] = self.path!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.version != nil {
                            map["Version"] = self.version!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Input") {
                            self.input = dict["Input"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Path") {
                            self.path = dict["Path"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! Int32
                        }
                        if dict.keys.contains("Version") {
                            self.version = dict["Version"] as! String
                        }
                    }
                }
                public var cs: UpdateGovernanceTaskResponseBody.Result.Content.ChaincodeSpecPkg.Cs?

                public var policy: String?

                public var sha256: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.cs?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cs != nil {
                        map["Cs"] = self.cs?.toMap()
                    }
                    if self.policy != nil {
                        map["Policy"] = self.policy!
                    }
                    if self.sha256 != nil {
                        map["Sha256"] = self.sha256!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cs") {
                        var model = UpdateGovernanceTaskResponseBody.Result.Content.ChaincodeSpecPkg.Cs()
                        model.fromMap(dict["Cs"] as! [String: Any])
                        self.cs = model
                    }
                    if dict.keys.contains("Policy") {
                        self.policy = dict["Policy"] as! String
                    }
                    if dict.keys.contains("Sha256") {
                        self.sha256 = dict["Sha256"] as! String
                    }
                }
            }
            public class OrdererConfig : Tea.TeaModel {
                public var batchTimeout: String?

                public var maxMessageCount: Int32?

                public var preferredMaxBytes: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.batchTimeout != nil {
                        map["BatchTimeout"] = self.batchTimeout!
                    }
                    if self.maxMessageCount != nil {
                        map["MaxMessageCount"] = self.maxMessageCount!
                    }
                    if self.preferredMaxBytes != nil {
                        map["PreferredMaxBytes"] = self.preferredMaxBytes!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BatchTimeout") {
                        self.batchTimeout = dict["BatchTimeout"] as! String
                    }
                    if dict.keys.contains("MaxMessageCount") {
                        self.maxMessageCount = dict["MaxMessageCount"] as! Int32
                    }
                    if dict.keys.contains("PreferredMaxBytes") {
                        self.preferredMaxBytes = dict["PreferredMaxBytes"] as! Int32
                    }
                }
            }
            public class RemovedOrganizations : Tea.TeaModel {
                public class AnchorPeers : Tea.TeaModel {
                    public var host: String?

                    public var port: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.host != nil {
                            map["Host"] = self.host!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Host") {
                            self.host = dict["Host"] as! String
                        }
                        if dict.keys.contains("Port") {
                            self.port = dict["Port"] as! Int32
                        }
                    }
                }
                public class OrdererNodes : Tea.TeaModel {
                    public var address: String?

                    public var certificate: String?

                    public var key: String?

                    public var tlsroot: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.address != nil {
                            map["Address"] = self.address!
                        }
                        if self.certificate != nil {
                            map["Certificate"] = self.certificate!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.tlsroot != nil {
                            map["Tlsroot"] = self.tlsroot!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Address") {
                            self.address = dict["Address"] as! String
                        }
                        if dict.keys.contains("Certificate") {
                            self.certificate = dict["Certificate"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Tlsroot") {
                            self.tlsroot = dict["Tlsroot"] as! String
                        }
                    }
                }
                public var anchorPeers: [UpdateGovernanceTaskResponseBody.Result.Content.RemovedOrganizations.AnchorPeers]?

                public var crls: String?

                public var mspId: String?

                public var mspType: String?

                public var orderer: Bool?

                public var ordererNodes: [UpdateGovernanceTaskResponseBody.Result.Content.RemovedOrganizations.OrdererNodes]?

                public var rootCertificates: String?

                public var tlsRootCertificates: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.anchorPeers != nil {
                        var tmp : [Any] = []
                        for k in self.anchorPeers! {
                            tmp.append(k.toMap())
                        }
                        map["AnchorPeers"] = tmp
                    }
                    if self.crls != nil {
                        map["Crls"] = self.crls!
                    }
                    if self.mspId != nil {
                        map["MspId"] = self.mspId!
                    }
                    if self.mspType != nil {
                        map["MspType"] = self.mspType!
                    }
                    if self.orderer != nil {
                        map["Orderer"] = self.orderer!
                    }
                    if self.ordererNodes != nil {
                        var tmp : [Any] = []
                        for k in self.ordererNodes! {
                            tmp.append(k.toMap())
                        }
                        map["OrdererNodes"] = tmp
                    }
                    if self.rootCertificates != nil {
                        map["RootCertificates"] = self.rootCertificates!
                    }
                    if self.tlsRootCertificates != nil {
                        map["TlsRootCertificates"] = self.tlsRootCertificates!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnchorPeers") {
                        var tmp : [UpdateGovernanceTaskResponseBody.Result.Content.RemovedOrganizations.AnchorPeers] = []
                        for v in dict["AnchorPeers"] as! [Any] {
                            var model = UpdateGovernanceTaskResponseBody.Result.Content.RemovedOrganizations.AnchorPeers()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.anchorPeers = tmp
                    }
                    if dict.keys.contains("Crls") {
                        self.crls = dict["Crls"] as! String
                    }
                    if dict.keys.contains("MspId") {
                        self.mspId = dict["MspId"] as! String
                    }
                    if dict.keys.contains("MspType") {
                        self.mspType = dict["MspType"] as! String
                    }
                    if dict.keys.contains("Orderer") {
                        self.orderer = dict["Orderer"] as! Bool
                    }
                    if dict.keys.contains("OrdererNodes") {
                        var tmp : [UpdateGovernanceTaskResponseBody.Result.Content.RemovedOrganizations.OrdererNodes] = []
                        for v in dict["OrdererNodes"] as! [Any] {
                            var model = UpdateGovernanceTaskResponseBody.Result.Content.RemovedOrganizations.OrdererNodes()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ordererNodes = tmp
                    }
                    if dict.keys.contains("RootCertificates") {
                        self.rootCertificates = dict["RootCertificates"] as! String
                    }
                    if dict.keys.contains("TlsRootCertificates") {
                        self.tlsRootCertificates = dict["TlsRootCertificates"] as! String
                    }
                }
            }
            public var addedOrganizations: [UpdateGovernanceTaskResponseBody.Result.Content.AddedOrganizations]?

            public var chaincodeSpecPkg: UpdateGovernanceTaskResponseBody.Result.Content.ChaincodeSpecPkg?

            public var ordererConfig: UpdateGovernanceTaskResponseBody.Result.Content.OrdererConfig?

            public var raw: String?

            public var removedOrganizations: [UpdateGovernanceTaskResponseBody.Result.Content.RemovedOrganizations]?

            public var rwSets: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.chaincodeSpecPkg?.validate()
                try self.ordererConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addedOrganizations != nil {
                    var tmp : [Any] = []
                    for k in self.addedOrganizations! {
                        tmp.append(k.toMap())
                    }
                    map["AddedOrganizations"] = tmp
                }
                if self.chaincodeSpecPkg != nil {
                    map["ChaincodeSpecPkg"] = self.chaincodeSpecPkg?.toMap()
                }
                if self.ordererConfig != nil {
                    map["OrdererConfig"] = self.ordererConfig?.toMap()
                }
                if self.raw != nil {
                    map["Raw"] = self.raw!
                }
                if self.removedOrganizations != nil {
                    var tmp : [Any] = []
                    for k in self.removedOrganizations! {
                        tmp.append(k.toMap())
                    }
                    map["RemovedOrganizations"] = tmp
                }
                if self.rwSets != nil {
                    map["RwSets"] = self.rwSets!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddedOrganizations") {
                    var tmp : [UpdateGovernanceTaskResponseBody.Result.Content.AddedOrganizations] = []
                    for v in dict["AddedOrganizations"] as! [Any] {
                        var model = UpdateGovernanceTaskResponseBody.Result.Content.AddedOrganizations()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.addedOrganizations = tmp
                }
                if dict.keys.contains("ChaincodeSpecPkg") {
                    var model = UpdateGovernanceTaskResponseBody.Result.Content.ChaincodeSpecPkg()
                    model.fromMap(dict["ChaincodeSpecPkg"] as! [String: Any])
                    self.chaincodeSpecPkg = model
                }
                if dict.keys.contains("OrdererConfig") {
                    var model = UpdateGovernanceTaskResponseBody.Result.Content.OrdererConfig()
                    model.fromMap(dict["OrdererConfig"] as! [String: Any])
                    self.ordererConfig = model
                }
                if dict.keys.contains("Raw") {
                    self.raw = dict["Raw"] as! String
                }
                if dict.keys.contains("RemovedOrganizations") {
                    var tmp : [UpdateGovernanceTaskResponseBody.Result.Content.RemovedOrganizations] = []
                    for v in dict["RemovedOrganizations"] as! [Any] {
                        var model = UpdateGovernanceTaskResponseBody.Result.Content.RemovedOrganizations()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.removedOrganizations = tmp
                }
                if dict.keys.contains("RwSets") {
                    self.rwSets = dict["RwSets"] as! String
                }
            }
        }
        public var channelName: String?

        public var content: UpdateGovernanceTaskResponseBody.Result.Content?

        public var createTime: Int64?

        public var creator: String?

        public var description_: String?

        public var status: String?

        public var taskId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.content?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.content != nil {
                map["Content"] = self.content?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("Content") {
                var model = UpdateGovernanceTaskResponseBody.Result.Content()
                model.fromMap(dict["Content"] as! [String: Any])
                self.content = model
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: UpdateGovernanceTaskResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdateGovernanceTaskResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateGovernanceTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGovernanceTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGovernanceTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMemberRoleRequest : Tea.TeaModel {
    public var bid: String?

    public var bizid: String?

    public var role: Int32?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bid != nil {
            map["Bid"] = self.bid!
        }
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bid") {
            self.bid = dict["Bid"] as! String
        }
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! Int32
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! Int64
        }
    }
}

public class UpdateMemberRoleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class UpdateMemberRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMemberRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMemberRoleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateQRCodeAuthorityRequest : Tea.TeaModel {
    public var authorized: Bool?

    public var bizid: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorized != nil {
            map["Authorized"] = self.authorized!
        }
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Authorized") {
            self.authorized = dict["Authorized"] as! Bool
        }
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
    }
}

public class UpdateQRCodeAuthorityResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class UpdateQRCodeAuthorityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateQRCodeAuthorityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateQRCodeAuthorityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSchemaRequest : Tea.TeaModel {
    public var bizid: String?

    public var categoryConfigs: String?

    public var description_: String?

    public var schemaId: Int64?

    public var schemaName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizid != nil {
            map["Bizid"] = self.bizid!
        }
        if self.categoryConfigs != nil {
            map["CategoryConfigs"] = self.categoryConfigs!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bizid") {
            self.bizid = dict["Bizid"] as! String
        }
        if dict.keys.contains("CategoryConfigs") {
            self.categoryConfigs = dict["CategoryConfigs"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! Int64
        }
        if dict.keys.contains("SchemaName") {
            self.schemaName = dict["SchemaName"] as! String
        }
    }
}

public class UpdateSchemaResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Responses : Tea.TeaModel {
            public class Properties : Tea.TeaModel {
                public class DataSource : Tea.TeaModel {
                    public var allowNull: Int32?

                    public var annotation: String?

                    public var field: String?

                    public var indexes: Int32?

                    public var key: Int32?

                    public var length: Int32?

                    public var reg: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.allowNull != nil {
                            map["AllowNull"] = self.allowNull!
                        }
                        if self.annotation != nil {
                            map["Annotation"] = self.annotation!
                        }
                        if self.field != nil {
                            map["Field"] = self.field!
                        }
                        if self.indexes != nil {
                            map["Indexes"] = self.indexes!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.length != nil {
                            map["Length"] = self.length!
                        }
                        if self.reg != nil {
                            map["Reg"] = self.reg!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AllowNull") {
                            self.allowNull = dict["AllowNull"] as! Int32
                        }
                        if dict.keys.contains("Annotation") {
                            self.annotation = dict["Annotation"] as! String
                        }
                        if dict.keys.contains("Field") {
                            self.field = dict["Field"] as! String
                        }
                        if dict.keys.contains("Indexes") {
                            self.indexes = dict["Indexes"] as! Int32
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! Int32
                        }
                        if dict.keys.contains("Length") {
                            self.length = dict["Length"] as! Int32
                        }
                        if dict.keys.contains("Reg") {
                            self.reg = dict["Reg"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var count: Int32?

                public var dataSource: [UpdateSchemaResponseBody.Result.Responses.Properties.DataSource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.dataSource != nil {
                        var tmp : [Any] = []
                        for k in self.dataSource! {
                            tmp.append(k.toMap())
                        }
                        map["DataSource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int32
                    }
                    if dict.keys.contains("DataSource") {
                        var tmp : [UpdateSchemaResponseBody.Result.Responses.Properties.DataSource] = []
                        for v in dict["DataSource"] as! [Any] {
                            var model = UpdateSchemaResponseBody.Result.Responses.Properties.DataSource()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.dataSource = tmp
                    }
                }
            }
            public var category: String?

            public var categoryName: String?

            public var description_: String?

            public var properties: UpdateSchemaResponseBody.Result.Responses.Properties?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.properties?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.categoryName != nil {
                    map["CategoryName"] = self.categoryName!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.properties != nil {
                    map["Properties"] = self.properties?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CategoryName") {
                    self.categoryName = dict["CategoryName"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Properties") {
                    var model = UpdateSchemaResponseBody.Result.Responses.Properties()
                    model.fromMap(dict["Properties"] as! [String: Any])
                    self.properties = model
                }
            }
        }
        public class Schema : Tea.TeaModel {
            public var createTime: Int64?

            public var description_: String?

            public var id: Int64?

            public var isTemplate: Bool?

            public var name: String?

            public var updateTime: Int64?

            public var version: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.isTemplate != nil {
                    map["IsTemplate"] = self.isTemplate!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("IsTemplate") {
                    self.isTemplate = dict["IsTemplate"] as! Bool
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! Int64
                }
            }
        }
        public var responses: [UpdateSchemaResponseBody.Result.Responses]?

        public var schema: UpdateSchemaResponseBody.Result.Schema?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.schema?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.responses != nil {
                var tmp : [Any] = []
                for k in self.responses! {
                    tmp.append(k.toMap())
                }
                map["Responses"] = tmp
            }
            if self.schema != nil {
                map["Schema"] = self.schema?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Responses") {
                var tmp : [UpdateSchemaResponseBody.Result.Responses] = []
                for v in dict["Responses"] as! [Any] {
                    var model = UpdateSchemaResponseBody.Result.Responses()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.responses = tmp
            }
            if dict.keys.contains("Schema") {
                var model = UpdateSchemaResponseBody.Result.Schema()
                model.fromMap(dict["Schema"] as! [String: Any])
                self.schema = model
            }
        }
    }
    public var requestId: String?

    public var result: UpdateSchemaResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdateSchemaResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class UpdateSchemaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSchemaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateSchemaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpgradeChaincodeRequest : Tea.TeaModel {
    public var chaincodeId: String?

    public var collectionConfig: String?

    public var endorsePolicy: String?

    public var location: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chaincodeId != nil {
            map["ChaincodeId"] = self.chaincodeId!
        }
        if self.collectionConfig != nil {
            map["CollectionConfig"] = self.collectionConfig!
        }
        if self.endorsePolicy != nil {
            map["EndorsePolicy"] = self.endorsePolicy!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChaincodeId") {
            self.chaincodeId = dict["ChaincodeId"] as! String
        }
        if dict.keys.contains("CollectionConfig") {
            self.collectionConfig = dict["CollectionConfig"] as! String
        }
        if dict.keys.contains("EndorsePolicy") {
            self.endorsePolicy = dict["EndorsePolicy"] as! String
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class UpgradeChaincodeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var chaincodeId: String?

        public var channelName: String?

        public var consortiumId: String?

        public var createTime: String?

        public var deployTime: String?

        public var endorsePolicy: String?

        public var input: String?

        public var install: Bool?

        public var message: String?

        public var name: String?

        public var path: String?

        public var providerId: String?

        public var providerName: String?

        public var state: String?

        public var type: Int32?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chaincodeId != nil {
                map["ChaincodeId"] = self.chaincodeId!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.deployTime != nil {
                map["DeployTime"] = self.deployTime!
            }
            if self.endorsePolicy != nil {
                map["EndorsePolicy"] = self.endorsePolicy!
            }
            if self.input != nil {
                map["Input"] = self.input!
            }
            if self.install != nil {
                map["Install"] = self.install!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.providerId != nil {
                map["ProviderId"] = self.providerId!
            }
            if self.providerName != nil {
                map["ProviderName"] = self.providerName!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChaincodeId") {
                self.chaincodeId = dict["ChaincodeId"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DeployTime") {
                self.deployTime = dict["DeployTime"] as! String
            }
            if dict.keys.contains("EndorsePolicy") {
                self.endorsePolicy = dict["EndorsePolicy"] as! String
            }
            if dict.keys.contains("Input") {
                self.input = dict["Input"] as! String
            }
            if dict.keys.contains("Install") {
                self.install = dict["Install"] as! Bool
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("ProviderId") {
                self.providerId = dict["ProviderId"] as! String
            }
            if dict.keys.contains("ProviderName") {
                self.providerName = dict["ProviderName"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var errorCode: Int32?

    public var requestId: String?

    public var result: UpgradeChaincodeResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpgradeChaincodeResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpgradeChaincodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeChaincodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpgradeChaincodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpgradeFabricChaincodeDefinitionRequest : Tea.TeaModel {
    public var chaincodeId: String?

    public var chaincodePackageId: String?

    public var chaincodeVersion: String?

    public var channelId: String?

    public var collectionConfig: String?

    public var endorsePolicy: String?

    public var initRequired: Bool?

    public var location: String?

    public var organizationId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chaincodeId != nil {
            map["ChaincodeId"] = self.chaincodeId!
        }
        if self.chaincodePackageId != nil {
            map["ChaincodePackageId"] = self.chaincodePackageId!
        }
        if self.chaincodeVersion != nil {
            map["ChaincodeVersion"] = self.chaincodeVersion!
        }
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.collectionConfig != nil {
            map["CollectionConfig"] = self.collectionConfig!
        }
        if self.endorsePolicy != nil {
            map["EndorsePolicy"] = self.endorsePolicy!
        }
        if self.initRequired != nil {
            map["InitRequired"] = self.initRequired!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.organizationId != nil {
            map["OrganizationId"] = self.organizationId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChaincodeId") {
            self.chaincodeId = dict["ChaincodeId"] as! String
        }
        if dict.keys.contains("ChaincodePackageId") {
            self.chaincodePackageId = dict["ChaincodePackageId"] as! String
        }
        if dict.keys.contains("ChaincodeVersion") {
            self.chaincodeVersion = dict["ChaincodeVersion"] as! String
        }
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("CollectionConfig") {
            self.collectionConfig = dict["CollectionConfig"] as! String
        }
        if dict.keys.contains("EndorsePolicy") {
            self.endorsePolicy = dict["EndorsePolicy"] as! String
        }
        if dict.keys.contains("InitRequired") {
            self.initRequired = dict["InitRequired"] as! Bool
        }
        if dict.keys.contains("Location") {
            self.location = dict["Location"] as! String
        }
        if dict.keys.contains("OrganizationId") {
            self.organizationId = dict["OrganizationId"] as! String
        }
    }
}

public class UpgradeFabricChaincodeDefinitionResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var chaincodeId: String?

        public var chaincodeVersion: String?

        public var channelName: String?

        public var consortiumId: String?

        public var createTime: String?

        public var deployTime: String?

        public var endorsePolicy: String?

        public var input: String?

        public var install: Bool?

        public var message: String?

        public var name: String?

        public var path: String?

        public var providerId: String?

        public var providerName: String?

        public var state: String?

        public var type: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chaincodeId != nil {
                map["ChaincodeId"] = self.chaincodeId!
            }
            if self.chaincodeVersion != nil {
                map["ChaincodeVersion"] = self.chaincodeVersion!
            }
            if self.channelName != nil {
                map["ChannelName"] = self.channelName!
            }
            if self.consortiumId != nil {
                map["ConsortiumId"] = self.consortiumId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.deployTime != nil {
                map["DeployTime"] = self.deployTime!
            }
            if self.endorsePolicy != nil {
                map["EndorsePolicy"] = self.endorsePolicy!
            }
            if self.input != nil {
                map["Input"] = self.input!
            }
            if self.install != nil {
                map["Install"] = self.install!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            if self.providerId != nil {
                map["ProviderId"] = self.providerId!
            }
            if self.providerName != nil {
                map["ProviderName"] = self.providerName!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChaincodeId") {
                self.chaincodeId = dict["ChaincodeId"] as! String
            }
            if dict.keys.contains("ChaincodeVersion") {
                self.chaincodeVersion = dict["ChaincodeVersion"] as! String
            }
            if dict.keys.contains("ChannelName") {
                self.channelName = dict["ChannelName"] as! String
            }
            if dict.keys.contains("ConsortiumId") {
                self.consortiumId = dict["ConsortiumId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DeployTime") {
                self.deployTime = dict["DeployTime"] as! String
            }
            if dict.keys.contains("EndorsePolicy") {
                self.endorsePolicy = dict["EndorsePolicy"] as! String
            }
            if dict.keys.contains("Input") {
                self.input = dict["Input"] as! String
            }
            if dict.keys.contains("Install") {
                self.install = dict["Install"] as! Bool
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") {
                self.path = dict["Path"] as! String
            }
            if dict.keys.contains("ProviderId") {
                self.providerId = dict["ProviderId"] as! String
            }
            if dict.keys.contains("ProviderName") {
                self.providerName = dict["ProviderName"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! Int32
            }
        }
    }
    public var chaincodeDefinitionId: String?

    public var chaincodePackageId: String?

    public var errorCode: Int32?

    public var initRequired: Bool?

    public var requestId: String?

    public var result: UpgradeFabricChaincodeDefinitionResponseBody.Result?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chaincodeDefinitionId != nil {
            map["ChaincodeDefinitionId"] = self.chaincodeDefinitionId!
        }
        if self.chaincodePackageId != nil {
            map["ChaincodePackageId"] = self.chaincodePackageId!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.initRequired != nil {
            map["InitRequired"] = self.initRequired!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChaincodeDefinitionId") {
            self.chaincodeDefinitionId = dict["ChaincodeDefinitionId"] as! String
        }
        if dict.keys.contains("ChaincodePackageId") {
            self.chaincodePackageId = dict["ChaincodePackageId"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! Int32
        }
        if dict.keys.contains("InitRequired") {
            self.initRequired = dict["InitRequired"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpgradeFabricChaincodeDefinitionResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpgradeFabricChaincodeDefinitionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeFabricChaincodeDefinitionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpgradeFabricChaincodeDefinitionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
