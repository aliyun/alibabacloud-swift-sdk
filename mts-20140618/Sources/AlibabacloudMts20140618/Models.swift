import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class ActivateMediaWorkflowRequest : Tea.TeaModel {
    public var mediaWorkflowId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowId != nil {
            map["MediaWorkflowId"] = self.mediaWorkflowId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowId") {
            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ActivateMediaWorkflowResponseBody : Tea.TeaModel {
    public class MediaWorkflow : Tea.TeaModel {
        public var creationTime: String?

        public var mediaWorkflowId: String?

        public var name: String?

        public var state: String?

        public var topology: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.mediaWorkflowId != nil {
                map["MediaWorkflowId"] = self.mediaWorkflowId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.topology != nil {
                map["Topology"] = self.topology!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("MediaWorkflowId") {
                self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Topology") {
                self.topology = dict["Topology"] as! String
            }
        }
    }
    public var mediaWorkflow: ActivateMediaWorkflowResponseBody.MediaWorkflow?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflow?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflow != nil {
            map["MediaWorkflow"] = self.mediaWorkflow?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflow") {
            var model = ActivateMediaWorkflowResponseBody.MediaWorkflow()
            model.fromMap(dict["MediaWorkflow"] as! [String: Any])
            self.mediaWorkflow = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ActivateMediaWorkflowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ActivateMediaWorkflowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ActivateMediaWorkflowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMediaRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var coverURL: String?

    public var description_: String?

    public var fileURL: String?

    public var inputUnbind: Bool?

    public var mediaWorkflowId: String?

    public var mediaWorkflowUserData: String?

    public var overrideParams: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.fileURL != nil {
            map["FileURL"] = self.fileURL!
        }
        if self.inputUnbind != nil {
            map["InputUnbind"] = self.inputUnbind!
        }
        if self.mediaWorkflowId != nil {
            map["MediaWorkflowId"] = self.mediaWorkflowId!
        }
        if self.mediaWorkflowUserData != nil {
            map["MediaWorkflowUserData"] = self.mediaWorkflowUserData!
        }
        if self.overrideParams != nil {
            map["OverrideParams"] = self.overrideParams!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("FileURL") {
            self.fileURL = dict["FileURL"] as! String
        }
        if dict.keys.contains("InputUnbind") {
            self.inputUnbind = dict["InputUnbind"] as! Bool
        }
        if dict.keys.contains("MediaWorkflowId") {
            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
        }
        if dict.keys.contains("MediaWorkflowUserData") {
            self.mediaWorkflowUserData = dict["MediaWorkflowUserData"] as! String
        }
        if dict.keys.contains("OverrideParams") {
            self.overrideParams = dict["OverrideParams"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class AddMediaResponseBody : Tea.TeaModel {
    public class Media : Tea.TeaModel {
        public class File : Tea.TeaModel {
            public var state: String?

            public var URL: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.URL != nil {
                    map["URL"] = self.URL!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("URL") {
                    self.URL = dict["URL"] as! String
                }
            }
        }
        public class RunIdList : Tea.TeaModel {
            public var runId: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.runId != nil {
                    map["RunId"] = self.runId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RunId") {
                    self.runId = dict["RunId"] as! [String]
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var tag: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Tag") {
                    self.tag = dict["Tag"] as! [String]
                }
            }
        }
        public var bitrate: String?

        public var cateId: Int64?

        public var censorState: String?

        public var coverURL: String?

        public var creationTime: String?

        public var description_: String?

        public var duration: String?

        public var file: AddMediaResponseBody.Media.File?

        public var format: String?

        public var fps: String?

        public var height: String?

        public var mediaId: String?

        public var publishState: String?

        public var runIdList: AddMediaResponseBody.Media.RunIdList?

        public var size: String?

        public var tags: AddMediaResponseBody.Media.Tags?

        public var title: String?

        public var width: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.file?.validate()
            try self.runIdList?.validate()
            try self.tags?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bitrate != nil {
                map["Bitrate"] = self.bitrate!
            }
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.censorState != nil {
                map["CensorState"] = self.censorState!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.file != nil {
                map["File"] = self.file?.toMap()
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.fps != nil {
                map["Fps"] = self.fps!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.publishState != nil {
                map["PublishState"] = self.publishState!
            }
            if self.runIdList != nil {
                map["RunIdList"] = self.runIdList?.toMap()
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.tags != nil {
                map["Tags"] = self.tags?.toMap()
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bitrate") {
                self.bitrate = dict["Bitrate"] as! String
            }
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CensorState") {
                self.censorState = dict["CensorState"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("File") {
                var model = AddMediaResponseBody.Media.File()
                model.fromMap(dict["File"] as! [String: Any])
                self.file = model
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("Fps") {
                self.fps = dict["Fps"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("PublishState") {
                self.publishState = dict["PublishState"] as! String
            }
            if dict.keys.contains("RunIdList") {
                var model = AddMediaResponseBody.Media.RunIdList()
                model.fromMap(dict["RunIdList"] as! [String: Any])
                self.runIdList = model
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! String
            }
            if dict.keys.contains("Tags") {
                var model = AddMediaResponseBody.Media.Tags()
                model.fromMap(dict["Tags"] as! [String: Any])
                self.tags = model
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! String
            }
        }
    }
    public var media: AddMediaResponseBody.Media?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.media?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.media != nil {
            map["Media"] = self.media?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Media") {
            var model = AddMediaResponseBody.Media()
            model.fromMap(dict["Media"] as! [String: Any])
            self.media = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMediaTagRequest : Tea.TeaModel {
    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! String
        }
    }
}

public class AddMediaTagResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddMediaTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMediaTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddMediaTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddMediaWorkflowRequest : Tea.TeaModel {
    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var topology: String?

    public var triggerMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.topology != nil {
            map["Topology"] = self.topology!
        }
        if self.triggerMode != nil {
            map["TriggerMode"] = self.triggerMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Topology") {
            self.topology = dict["Topology"] as! String
        }
        if dict.keys.contains("TriggerMode") {
            self.triggerMode = dict["TriggerMode"] as! String
        }
    }
}

public class AddMediaWorkflowResponseBody : Tea.TeaModel {
    public class MediaWorkflow : Tea.TeaModel {
        public var creationTime: String?

        public var mediaWorkflowId: String?

        public var name: String?

        public var state: String?

        public var topology: String?

        public var triggerMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.mediaWorkflowId != nil {
                map["MediaWorkflowId"] = self.mediaWorkflowId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.topology != nil {
                map["Topology"] = self.topology!
            }
            if self.triggerMode != nil {
                map["TriggerMode"] = self.triggerMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("MediaWorkflowId") {
                self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Topology") {
                self.topology = dict["Topology"] as! String
            }
            if dict.keys.contains("TriggerMode") {
                self.triggerMode = dict["TriggerMode"] as! String
            }
        }
    }
    public var mediaWorkflow: AddMediaWorkflowResponseBody.MediaWorkflow?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflow?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflow != nil {
            map["MediaWorkflow"] = self.mediaWorkflow?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflow") {
            var model = AddMediaWorkflowResponseBody.MediaWorkflow()
            model.fromMap(dict["MediaWorkflow"] as! [String: Any])
            self.mediaWorkflow = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddMediaWorkflowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddMediaWorkflowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddMediaWorkflowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPipelineRequest : Tea.TeaModel {
    public var name: String?

    public var notifyConfig: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var role: String?

    public var speed: String?

    public var speedLevel: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifyConfig != nil {
            map["NotifyConfig"] = self.notifyConfig!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.speed != nil {
            map["Speed"] = self.speed!
        }
        if self.speedLevel != nil {
            map["SpeedLevel"] = self.speedLevel!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NotifyConfig") {
            self.notifyConfig = dict["NotifyConfig"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! String
        }
        if dict.keys.contains("Speed") {
            self.speed = dict["Speed"] as! String
        }
        if dict.keys.contains("SpeedLevel") {
            self.speedLevel = dict["SpeedLevel"] as! Int64
        }
    }
}

public class AddPipelineResponseBody : Tea.TeaModel {
    public class Pipeline : Tea.TeaModel {
        public class NotifyConfig : Tea.TeaModel {
            public var mqTag: String?

            public var mqTopic: String?

            public var queueName: String?

            public var topic: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mqTag != nil {
                    map["MqTag"] = self.mqTag!
                }
                if self.mqTopic != nil {
                    map["MqTopic"] = self.mqTopic!
                }
                if self.queueName != nil {
                    map["QueueName"] = self.queueName!
                }
                if self.topic != nil {
                    map["Topic"] = self.topic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MqTag") {
                    self.mqTag = dict["MqTag"] as! String
                }
                if dict.keys.contains("MqTopic") {
                    self.mqTopic = dict["MqTopic"] as! String
                }
                if dict.keys.contains("QueueName") {
                    self.queueName = dict["QueueName"] as! String
                }
                if dict.keys.contains("Topic") {
                    self.topic = dict["Topic"] as! String
                }
            }
        }
        public var id: String?

        public var name: String?

        public var notifyConfig: AddPipelineResponseBody.Pipeline.NotifyConfig?

        public var quotaAllocate: Int64?

        public var role: String?

        public var speed: String?

        public var speedLevel: Int64?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.notifyConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifyConfig != nil {
                map["NotifyConfig"] = self.notifyConfig?.toMap()
            }
            if self.quotaAllocate != nil {
                map["QuotaAllocate"] = self.quotaAllocate!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.speed != nil {
                map["Speed"] = self.speed!
            }
            if self.speedLevel != nil {
                map["SpeedLevel"] = self.speedLevel!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NotifyConfig") {
                var model = AddPipelineResponseBody.Pipeline.NotifyConfig()
                model.fromMap(dict["NotifyConfig"] as! [String: Any])
                self.notifyConfig = model
            }
            if dict.keys.contains("QuotaAllocate") {
                self.quotaAllocate = dict["QuotaAllocate"] as! Int64
            }
            if dict.keys.contains("Role") {
                self.role = dict["Role"] as! String
            }
            if dict.keys.contains("Speed") {
                self.speed = dict["Speed"] as! String
            }
            if dict.keys.contains("SpeedLevel") {
                self.speedLevel = dict["SpeedLevel"] as! Int64
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var pipeline: AddPipelineResponseBody.Pipeline?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipeline != nil {
            map["Pipeline"] = self.pipeline?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pipeline") {
            var model = AddPipelineResponseBody.Pipeline()
            model.fromMap(dict["Pipeline"] as! [String: Any])
            self.pipeline = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddPipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddPipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddSmarttagTemplateRequest : Tea.TeaModel {
    public var analyseTypes: String?

    public var faceCategoryIds: String?

    public var faceCustomParamsConfig: String?

    public var industry: String?

    public var isDefault: Bool?

    public var keywordConfig: String?

    public var knowledgeConfig: String?

    public var labelType: String?

    public var labelVersion: String?

    public var landmarkGroupIds: String?

    public var objectGroupIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scene: String?

    public var templateName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.analyseTypes != nil {
            map["AnalyseTypes"] = self.analyseTypes!
        }
        if self.faceCategoryIds != nil {
            map["FaceCategoryIds"] = self.faceCategoryIds!
        }
        if self.faceCustomParamsConfig != nil {
            map["FaceCustomParamsConfig"] = self.faceCustomParamsConfig!
        }
        if self.industry != nil {
            map["Industry"] = self.industry!
        }
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.keywordConfig != nil {
            map["KeywordConfig"] = self.keywordConfig!
        }
        if self.knowledgeConfig != nil {
            map["KnowledgeConfig"] = self.knowledgeConfig!
        }
        if self.labelType != nil {
            map["LabelType"] = self.labelType!
        }
        if self.labelVersion != nil {
            map["LabelVersion"] = self.labelVersion!
        }
        if self.landmarkGroupIds != nil {
            map["LandmarkGroupIds"] = self.landmarkGroupIds!
        }
        if self.objectGroupIds != nil {
            map["ObjectGroupIds"] = self.objectGroupIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scene != nil {
            map["Scene"] = self.scene!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AnalyseTypes") {
            self.analyseTypes = dict["AnalyseTypes"] as! String
        }
        if dict.keys.contains("FaceCategoryIds") {
            self.faceCategoryIds = dict["FaceCategoryIds"] as! String
        }
        if dict.keys.contains("FaceCustomParamsConfig") {
            self.faceCustomParamsConfig = dict["FaceCustomParamsConfig"] as! String
        }
        if dict.keys.contains("Industry") {
            self.industry = dict["Industry"] as! String
        }
        if dict.keys.contains("IsDefault") {
            self.isDefault = dict["IsDefault"] as! Bool
        }
        if dict.keys.contains("KeywordConfig") {
            self.keywordConfig = dict["KeywordConfig"] as! String
        }
        if dict.keys.contains("KnowledgeConfig") {
            self.knowledgeConfig = dict["KnowledgeConfig"] as! String
        }
        if dict.keys.contains("LabelType") {
            self.labelType = dict["LabelType"] as! String
        }
        if dict.keys.contains("LabelVersion") {
            self.labelVersion = dict["LabelVersion"] as! String
        }
        if dict.keys.contains("LandmarkGroupIds") {
            self.landmarkGroupIds = dict["LandmarkGroupIds"] as! String
        }
        if dict.keys.contains("ObjectGroupIds") {
            self.objectGroupIds = dict["ObjectGroupIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Scene") {
            self.scene = dict["Scene"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
    }
}

public class AddSmarttagTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class AddSmarttagTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddSmarttagTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddSmarttagTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddTemplateRequest : Tea.TeaModel {
    public var audio: String?

    public var container: String?

    public var muxConfig: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var transConfig: String?

    public var video: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audio != nil {
            map["Audio"] = self.audio!
        }
        if self.container != nil {
            map["Container"] = self.container!
        }
        if self.muxConfig != nil {
            map["MuxConfig"] = self.muxConfig!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.transConfig != nil {
            map["TransConfig"] = self.transConfig!
        }
        if self.video != nil {
            map["Video"] = self.video!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Audio") {
            self.audio = dict["Audio"] as! String
        }
        if dict.keys.contains("Container") {
            self.container = dict["Container"] as! String
        }
        if dict.keys.contains("MuxConfig") {
            self.muxConfig = dict["MuxConfig"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TransConfig") {
            self.transConfig = dict["TransConfig"] as! String
        }
        if dict.keys.contains("Video") {
            self.video = dict["Video"] as! String
        }
    }
}

public class AddTemplateResponseBody : Tea.TeaModel {
    public class Template : Tea.TeaModel {
        public class Audio : Tea.TeaModel {
            public class Volume : Tea.TeaModel {
                public var integratedLoudnessTarget: String?

                public var level: String?

                public var loudnessRangeTarget: String?

                public var method: String?

                public var peakLevel: String?

                public var truePeak: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.integratedLoudnessTarget != nil {
                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.loudnessRangeTarget != nil {
                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                    }
                    if self.method != nil {
                        map["Method"] = self.method!
                    }
                    if self.peakLevel != nil {
                        map["PeakLevel"] = self.peakLevel!
                    }
                    if self.truePeak != nil {
                        map["TruePeak"] = self.truePeak!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IntegratedLoudnessTarget") {
                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("LoudnessRangeTarget") {
                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                    }
                    if dict.keys.contains("Method") {
                        self.method = dict["Method"] as! String
                    }
                    if dict.keys.contains("PeakLevel") {
                        self.peakLevel = dict["PeakLevel"] as! String
                    }
                    if dict.keys.contains("TruePeak") {
                        self.truePeak = dict["TruePeak"] as! String
                    }
                }
            }
            public var bitrate: String?

            public var channels: String?

            public var codec: String?

            public var profile: String?

            public var qscale: String?

            public var remove: String?

            public var samplerate: String?

            public var volume: AddTemplateResponseBody.Template.Audio.Volume?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.volume?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.qscale != nil {
                    map["Qscale"] = self.qscale!
                }
                if self.remove != nil {
                    map["Remove"] = self.remove!
                }
                if self.samplerate != nil {
                    map["Samplerate"] = self.samplerate!
                }
                if self.volume != nil {
                    map["Volume"] = self.volume?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Channels") {
                    self.channels = dict["Channels"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Qscale") {
                    self.qscale = dict["Qscale"] as! String
                }
                if dict.keys.contains("Remove") {
                    self.remove = dict["Remove"] as! String
                }
                if dict.keys.contains("Samplerate") {
                    self.samplerate = dict["Samplerate"] as! String
                }
                if dict.keys.contains("Volume") {
                    var model = AddTemplateResponseBody.Template.Audio.Volume()
                    model.fromMap(dict["Volume"] as! [String: Any])
                    self.volume = model
                }
            }
        }
        public class Container : Tea.TeaModel {
            public var format: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.format != nil {
                    map["Format"] = self.format!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
            }
        }
        public class MuxConfig : Tea.TeaModel {
            public class Gif : Tea.TeaModel {
                public var ditherMode: String?

                public var finalDelay: String?

                public var isCustomPalette: String?

                public var loop: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ditherMode != nil {
                        map["DitherMode"] = self.ditherMode!
                    }
                    if self.finalDelay != nil {
                        map["FinalDelay"] = self.finalDelay!
                    }
                    if self.isCustomPalette != nil {
                        map["IsCustomPalette"] = self.isCustomPalette!
                    }
                    if self.loop != nil {
                        map["Loop"] = self.loop!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DitherMode") {
                        self.ditherMode = dict["DitherMode"] as! String
                    }
                    if dict.keys.contains("FinalDelay") {
                        self.finalDelay = dict["FinalDelay"] as! String
                    }
                    if dict.keys.contains("IsCustomPalette") {
                        self.isCustomPalette = dict["IsCustomPalette"] as! String
                    }
                    if dict.keys.contains("Loop") {
                        self.loop = dict["Loop"] as! String
                    }
                }
            }
            public class Segment : Tea.TeaModel {
                public var duration: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                }
            }
            public class Webp : Tea.TeaModel {
                public var loop: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.loop != nil {
                        map["Loop"] = self.loop!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Loop") {
                        self.loop = dict["Loop"] as! String
                    }
                }
            }
            public var gif: AddTemplateResponseBody.Template.MuxConfig.Gif?

            public var segment: AddTemplateResponseBody.Template.MuxConfig.Segment?

            public var webp: AddTemplateResponseBody.Template.MuxConfig.Webp?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.gif?.validate()
                try self.segment?.validate()
                try self.webp?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gif != nil {
                    map["Gif"] = self.gif?.toMap()
                }
                if self.segment != nil {
                    map["Segment"] = self.segment?.toMap()
                }
                if self.webp != nil {
                    map["Webp"] = self.webp?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Gif") {
                    var model = AddTemplateResponseBody.Template.MuxConfig.Gif()
                    model.fromMap(dict["Gif"] as! [String: Any])
                    self.gif = model
                }
                if dict.keys.contains("Segment") {
                    var model = AddTemplateResponseBody.Template.MuxConfig.Segment()
                    model.fromMap(dict["Segment"] as! [String: Any])
                    self.segment = model
                }
                if dict.keys.contains("Webp") {
                    var model = AddTemplateResponseBody.Template.MuxConfig.Webp()
                    model.fromMap(dict["Webp"] as! [String: Any])
                    self.webp = model
                }
            }
        }
        public class TransConfig : Tea.TeaModel {
            public var adjDarMethod: String?

            public var isCheckAudioBitrate: String?

            public var isCheckAudioBitrateFail: String?

            public var isCheckReso: String?

            public var isCheckResoFail: String?

            public var isCheckVideoBitrate: String?

            public var isCheckVideoBitrateFail: String?

            public var transMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adjDarMethod != nil {
                    map["AdjDarMethod"] = self.adjDarMethod!
                }
                if self.isCheckAudioBitrate != nil {
                    map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                }
                if self.isCheckAudioBitrateFail != nil {
                    map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                }
                if self.isCheckReso != nil {
                    map["IsCheckReso"] = self.isCheckReso!
                }
                if self.isCheckResoFail != nil {
                    map["IsCheckResoFail"] = self.isCheckResoFail!
                }
                if self.isCheckVideoBitrate != nil {
                    map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                }
                if self.isCheckVideoBitrateFail != nil {
                    map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                }
                if self.transMode != nil {
                    map["TransMode"] = self.transMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdjDarMethod") {
                    self.adjDarMethod = dict["AdjDarMethod"] as! String
                }
                if dict.keys.contains("IsCheckAudioBitrate") {
                    self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                }
                if dict.keys.contains("IsCheckAudioBitrateFail") {
                    self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                }
                if dict.keys.contains("IsCheckReso") {
                    self.isCheckReso = dict["IsCheckReso"] as! String
                }
                if dict.keys.contains("IsCheckResoFail") {
                    self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                }
                if dict.keys.contains("IsCheckVideoBitrate") {
                    self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                }
                if dict.keys.contains("IsCheckVideoBitrateFail") {
                    self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                }
                if dict.keys.contains("TransMode") {
                    self.transMode = dict["TransMode"] as! String
                }
            }
        }
        public class Video : Tea.TeaModel {
            public class BitrateBnd : Tea.TeaModel {
                public var max: String?

                public var min: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.max != nil {
                        map["Max"] = self.max!
                    }
                    if self.min != nil {
                        map["Min"] = self.min!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Max") {
                        self.max = dict["Max"] as! String
                    }
                    if dict.keys.contains("Min") {
                        self.min = dict["Min"] as! String
                    }
                }
            }
            public class NarrowBand : Tea.TeaModel {
                public var abrmax: Double?

                public var maxAbrRatio: Double?

                public var version: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.abrmax != nil {
                        map["Abrmax"] = self.abrmax!
                    }
                    if self.maxAbrRatio != nil {
                        map["MaxAbrRatio"] = self.maxAbrRatio!
                    }
                    if self.version != nil {
                        map["Version"] = self.version!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Abrmax") {
                        self.abrmax = dict["Abrmax"] as! Double
                    }
                    if dict.keys.contains("MaxAbrRatio") {
                        self.maxAbrRatio = dict["MaxAbrRatio"] as! Double
                    }
                    if dict.keys.contains("Version") {
                        self.version = dict["Version"] as! String
                    }
                }
            }
            public var bitrate: String?

            public var bitrateBnd: AddTemplateResponseBody.Template.Video.BitrateBnd?

            public var bufsize: String?

            public var codec: String?

            public var crf: String?

            public var crop: String?

            public var degrain: String?

            public var fps: String?

            public var gop: String?

            public var hdr2sdr: String?

            public var height: String?

            public var longShortMode: String?

            public var maxFps: String?

            public var maxrate: String?

            public var narrowBand: AddTemplateResponseBody.Template.Video.NarrowBand?

            public var pad: String?

            public var pixFmt: String?

            public var preset: String?

            public var profile: String?

            public var qscale: String?

            public var remove: String?

            public var resoPriority: String?

            public var scanMode: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.bitrateBnd?.validate()
                try self.narrowBand?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.bitrateBnd != nil {
                    map["BitrateBnd"] = self.bitrateBnd?.toMap()
                }
                if self.bufsize != nil {
                    map["Bufsize"] = self.bufsize!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.crf != nil {
                    map["Crf"] = self.crf!
                }
                if self.crop != nil {
                    map["Crop"] = self.crop!
                }
                if self.degrain != nil {
                    map["Degrain"] = self.degrain!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.gop != nil {
                    map["Gop"] = self.gop!
                }
                if self.hdr2sdr != nil {
                    map["Hdr2sdr"] = self.hdr2sdr!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.longShortMode != nil {
                    map["LongShortMode"] = self.longShortMode!
                }
                if self.maxFps != nil {
                    map["MaxFps"] = self.maxFps!
                }
                if self.maxrate != nil {
                    map["Maxrate"] = self.maxrate!
                }
                if self.narrowBand != nil {
                    map["NarrowBand"] = self.narrowBand?.toMap()
                }
                if self.pad != nil {
                    map["Pad"] = self.pad!
                }
                if self.pixFmt != nil {
                    map["PixFmt"] = self.pixFmt!
                }
                if self.preset != nil {
                    map["Preset"] = self.preset!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.qscale != nil {
                    map["Qscale"] = self.qscale!
                }
                if self.remove != nil {
                    map["Remove"] = self.remove!
                }
                if self.resoPriority != nil {
                    map["ResoPriority"] = self.resoPriority!
                }
                if self.scanMode != nil {
                    map["ScanMode"] = self.scanMode!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("BitrateBnd") {
                    var model = AddTemplateResponseBody.Template.Video.BitrateBnd()
                    model.fromMap(dict["BitrateBnd"] as! [String: Any])
                    self.bitrateBnd = model
                }
                if dict.keys.contains("Bufsize") {
                    self.bufsize = dict["Bufsize"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Crf") {
                    self.crf = dict["Crf"] as! String
                }
                if dict.keys.contains("Crop") {
                    self.crop = dict["Crop"] as! String
                }
                if dict.keys.contains("Degrain") {
                    self.degrain = dict["Degrain"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Gop") {
                    self.gop = dict["Gop"] as! String
                }
                if dict.keys.contains("Hdr2sdr") {
                    self.hdr2sdr = dict["Hdr2sdr"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("LongShortMode") {
                    self.longShortMode = dict["LongShortMode"] as! String
                }
                if dict.keys.contains("MaxFps") {
                    self.maxFps = dict["MaxFps"] as! String
                }
                if dict.keys.contains("Maxrate") {
                    self.maxrate = dict["Maxrate"] as! String
                }
                if dict.keys.contains("NarrowBand") {
                    var model = AddTemplateResponseBody.Template.Video.NarrowBand()
                    model.fromMap(dict["NarrowBand"] as! [String: Any])
                    self.narrowBand = model
                }
                if dict.keys.contains("Pad") {
                    self.pad = dict["Pad"] as! String
                }
                if dict.keys.contains("PixFmt") {
                    self.pixFmt = dict["PixFmt"] as! String
                }
                if dict.keys.contains("Preset") {
                    self.preset = dict["Preset"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Qscale") {
                    self.qscale = dict["Qscale"] as! String
                }
                if dict.keys.contains("Remove") {
                    self.remove = dict["Remove"] as! String
                }
                if dict.keys.contains("ResoPriority") {
                    self.resoPriority = dict["ResoPriority"] as! String
                }
                if dict.keys.contains("ScanMode") {
                    self.scanMode = dict["ScanMode"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var audio: AddTemplateResponseBody.Template.Audio?

        public var container: AddTemplateResponseBody.Template.Container?

        public var id: String?

        public var muxConfig: AddTemplateResponseBody.Template.MuxConfig?

        public var name: String?

        public var state: String?

        public var transConfig: AddTemplateResponseBody.Template.TransConfig?

        public var video: AddTemplateResponseBody.Template.Video?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.audio?.validate()
            try self.container?.validate()
            try self.muxConfig?.validate()
            try self.transConfig?.validate()
            try self.video?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audio != nil {
                map["Audio"] = self.audio?.toMap()
            }
            if self.container != nil {
                map["Container"] = self.container?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.muxConfig != nil {
                map["MuxConfig"] = self.muxConfig?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.transConfig != nil {
                map["TransConfig"] = self.transConfig?.toMap()
            }
            if self.video != nil {
                map["Video"] = self.video?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Audio") {
                var model = AddTemplateResponseBody.Template.Audio()
                model.fromMap(dict["Audio"] as! [String: Any])
                self.audio = model
            }
            if dict.keys.contains("Container") {
                var model = AddTemplateResponseBody.Template.Container()
                model.fromMap(dict["Container"] as! [String: Any])
                self.container = model
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MuxConfig") {
                var model = AddTemplateResponseBody.Template.MuxConfig()
                model.fromMap(dict["MuxConfig"] as! [String: Any])
                self.muxConfig = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("TransConfig") {
                var model = AddTemplateResponseBody.Template.TransConfig()
                model.fromMap(dict["TransConfig"] as! [String: Any])
                self.transConfig = model
            }
            if dict.keys.contains("Video") {
                var model = AddTemplateResponseBody.Template.Video()
                model.fromMap(dict["Video"] as! [String: Any])
                self.video = model
            }
        }
    }
    public var requestId: String?

    public var template: AddTemplateResponseBody.Template?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.template != nil {
            map["Template"] = self.template?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Template") {
            var model = AddTemplateResponseBody.Template()
            model.fromMap(dict["Template"] as! [String: Any])
            self.template = model
        }
    }
}

public class AddTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddWaterMarkTemplateRequest : Tea.TeaModel {
    public var config: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AddWaterMarkTemplateResponseBody : Tea.TeaModel {
    public class WaterMarkTemplate : Tea.TeaModel {
        public class RatioRefer : Tea.TeaModel {
            public var dx: String?

            public var dy: String?

            public var height: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dx != nil {
                    map["Dx"] = self.dx!
                }
                if self.dy != nil {
                    map["Dy"] = self.dy!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Dx") {
                    self.dx = dict["Dx"] as! String
                }
                if dict.keys.contains("Dy") {
                    self.dy = dict["Dy"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public class Timeline : Tea.TeaModel {
            public var duration: String?

            public var start: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.start != nil {
                    map["Start"] = self.start!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("Start") {
                    self.start = dict["Start"] as! String
                }
            }
        }
        public var dx: String?

        public var dy: String?

        public var height: String?

        public var id: String?

        public var name: String?

        public var ratioRefer: AddWaterMarkTemplateResponseBody.WaterMarkTemplate.RatioRefer?

        public var referPos: String?

        public var state: String?

        public var timeline: AddWaterMarkTemplateResponseBody.WaterMarkTemplate.Timeline?

        public var type: String?

        public var width: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ratioRefer?.validate()
            try self.timeline?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dx != nil {
                map["Dx"] = self.dx!
            }
            if self.dy != nil {
                map["Dy"] = self.dy!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ratioRefer != nil {
                map["RatioRefer"] = self.ratioRefer?.toMap()
            }
            if self.referPos != nil {
                map["ReferPos"] = self.referPos!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Dx") {
                self.dx = dict["Dx"] as! String
            }
            if dict.keys.contains("Dy") {
                self.dy = dict["Dy"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RatioRefer") {
                var model = AddWaterMarkTemplateResponseBody.WaterMarkTemplate.RatioRefer()
                model.fromMap(dict["RatioRefer"] as! [String: Any])
                self.ratioRefer = model
            }
            if dict.keys.contains("ReferPos") {
                self.referPos = dict["ReferPos"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Timeline") {
                var model = AddWaterMarkTemplateResponseBody.WaterMarkTemplate.Timeline()
                model.fromMap(dict["Timeline"] as! [String: Any])
                self.timeline = model
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! String
            }
        }
    }
    public var requestId: String?

    public var waterMarkTemplate: AddWaterMarkTemplateResponseBody.WaterMarkTemplate?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.waterMarkTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.waterMarkTemplate != nil {
            map["WaterMarkTemplate"] = self.waterMarkTemplate?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WaterMarkTemplate") {
            var model = AddWaterMarkTemplateResponseBody.WaterMarkTemplate()
            model.fromMap(dict["WaterMarkTemplate"] as! [String: Any])
            self.waterMarkTemplate = model
        }
    }
}

public class AddWaterMarkTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddWaterMarkTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddWaterMarkTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindInputBucketRequest : Tea.TeaModel {
    public var bucket: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var referer: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucket != nil {
            map["Bucket"] = self.bucket!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.referer != nil {
            map["Referer"] = self.referer!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bucket") {
            self.bucket = dict["Bucket"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Referer") {
            self.referer = dict["Referer"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class BindInputBucketResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BindInputBucketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindInputBucketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BindInputBucketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindOutputBucketRequest : Tea.TeaModel {
    public var bucket: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucket != nil {
            map["Bucket"] = self.bucket!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bucket") {
            self.bucket = dict["Bucket"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class BindOutputBucketResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BindOutputBucketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindOutputBucketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BindOutputBucketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelJobRequest : Tea.TeaModel {
    public var jobId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CancelJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCustomEntityRequest : Tea.TeaModel {
    public var algorithm: String?

    public var customEntityInfo: String?

    public var customEntityName: String?

    public var customGroupId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithm != nil {
            map["Algorithm"] = self.algorithm!
        }
        if self.customEntityInfo != nil {
            map["CustomEntityInfo"] = self.customEntityInfo!
        }
        if self.customEntityName != nil {
            map["CustomEntityName"] = self.customEntityName!
        }
        if self.customGroupId != nil {
            map["CustomGroupId"] = self.customGroupId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Algorithm") {
            self.algorithm = dict["Algorithm"] as! String
        }
        if dict.keys.contains("CustomEntityInfo") {
            self.customEntityInfo = dict["CustomEntityInfo"] as! String
        }
        if dict.keys.contains("CustomEntityName") {
            self.customEntityName = dict["CustomEntityName"] as! String
        }
        if dict.keys.contains("CustomGroupId") {
            self.customGroupId = dict["CustomGroupId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateCustomEntityResponseBody : Tea.TeaModel {
    public var customEntityId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customEntityId != nil {
            map["CustomEntityId"] = self.customEntityId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomEntityId") {
            self.customEntityId = dict["CustomEntityId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCustomEntityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustomEntityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCustomEntityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCustomGroupRequest : Tea.TeaModel {
    public var algorithm: String?

    public var customGroupDescription: String?

    public var customGroupName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithm != nil {
            map["Algorithm"] = self.algorithm!
        }
        if self.customGroupDescription != nil {
            map["CustomGroupDescription"] = self.customGroupDescription!
        }
        if self.customGroupName != nil {
            map["CustomGroupName"] = self.customGroupName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Algorithm") {
            self.algorithm = dict["Algorithm"] as! String
        }
        if dict.keys.contains("CustomGroupDescription") {
            self.customGroupDescription = dict["CustomGroupDescription"] as! String
        }
        if dict.keys.contains("CustomGroupName") {
            self.customGroupName = dict["CustomGroupName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateCustomGroupResponseBody : Tea.TeaModel {
    public var customGroupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customGroupId != nil {
            map["CustomGroupId"] = self.customGroupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomGroupId") {
            self.customGroupId = dict["CustomGroupId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCustomGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustomGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCustomGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFpShotDBRequest : Tea.TeaModel {
    public var config: String?

    public var description_: String?

    public var modelId: Int32?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.modelId != nil {
            map["ModelId"] = self.modelId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ModelId") {
            self.modelId = dict["ModelId"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateFpShotDBResponseBody : Tea.TeaModel {
    public class FpShotDB : Tea.TeaModel {
        public var config: String?

        public var description_: String?

        public var fpDBId: String?

        public var modelId: Int32?

        public var name: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.fpDBId != nil {
                map["FpDBId"] = self.fpDBId!
            }
            if self.modelId != nil {
                map["ModelId"] = self.modelId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Config") {
                self.config = dict["Config"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("FpDBId") {
                self.fpDBId = dict["FpDBId"] as! String
            }
            if dict.keys.contains("ModelId") {
                self.modelId = dict["ModelId"] as! Int32
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var fpShotDB: CreateFpShotDBResponseBody.FpShotDB?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.fpShotDB?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fpShotDB != nil {
            map["FpShotDB"] = self.fpShotDB?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FpShotDB") {
            var model = CreateFpShotDBResponseBody.FpShotDB()
            model.fromMap(dict["FpShotDB"] as! [String: Any])
            self.fpShotDB = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateFpShotDBResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFpShotDBResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateFpShotDBResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeactivateMediaWorkflowRequest : Tea.TeaModel {
    public var mediaWorkflowId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowId != nil {
            map["MediaWorkflowId"] = self.mediaWorkflowId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowId") {
            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeactivateMediaWorkflowResponseBody : Tea.TeaModel {
    public class MediaWorkflow : Tea.TeaModel {
        public var creationTime: String?

        public var mediaWorkflowId: String?

        public var name: String?

        public var state: String?

        public var topology: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.mediaWorkflowId != nil {
                map["MediaWorkflowId"] = self.mediaWorkflowId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.topology != nil {
                map["Topology"] = self.topology!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("MediaWorkflowId") {
                self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Topology") {
                self.topology = dict["Topology"] as! String
            }
        }
    }
    public var mediaWorkflow: DeactivateMediaWorkflowResponseBody.MediaWorkflow?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflow?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflow != nil {
            map["MediaWorkflow"] = self.mediaWorkflow?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflow") {
            var model = DeactivateMediaWorkflowResponseBody.MediaWorkflow()
            model.fromMap(dict["MediaWorkflow"] as! [String: Any])
            self.mediaWorkflow = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeactivateMediaWorkflowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeactivateMediaWorkflowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeactivateMediaWorkflowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomEntityRequest : Tea.TeaModel {
    public var algorithm: String?

    public var customEntityId: String?

    public var customGroupId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithm != nil {
            map["Algorithm"] = self.algorithm!
        }
        if self.customEntityId != nil {
            map["CustomEntityId"] = self.customEntityId!
        }
        if self.customGroupId != nil {
            map["CustomGroupId"] = self.customGroupId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Algorithm") {
            self.algorithm = dict["Algorithm"] as! String
        }
        if dict.keys.contains("CustomEntityId") {
            self.customEntityId = dict["CustomEntityId"] as! String
        }
        if dict.keys.contains("CustomGroupId") {
            self.customGroupId = dict["CustomGroupId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteCustomEntityResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCustomEntityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomEntityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCustomEntityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomGroupRequest : Tea.TeaModel {
    public var algorithm: String?

    public var customGroupId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithm != nil {
            map["Algorithm"] = self.algorithm!
        }
        if self.customGroupId != nil {
            map["CustomGroupId"] = self.customGroupId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Algorithm") {
            self.algorithm = dict["Algorithm"] as! String
        }
        if dict.keys.contains("CustomGroupId") {
            self.customGroupId = dict["CustomGroupId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteCustomGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCustomGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCustomGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomViewRequest : Tea.TeaModel {
    public var algorithm: String?

    public var customEntityId: String?

    public var customGroupId: String?

    public var customViewId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithm != nil {
            map["Algorithm"] = self.algorithm!
        }
        if self.customEntityId != nil {
            map["CustomEntityId"] = self.customEntityId!
        }
        if self.customGroupId != nil {
            map["CustomGroupId"] = self.customGroupId!
        }
        if self.customViewId != nil {
            map["CustomViewId"] = self.customViewId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Algorithm") {
            self.algorithm = dict["Algorithm"] as! String
        }
        if dict.keys.contains("CustomEntityId") {
            self.customEntityId = dict["CustomEntityId"] as! String
        }
        if dict.keys.contains("CustomGroupId") {
            self.customGroupId = dict["CustomGroupId"] as! String
        }
        if dict.keys.contains("CustomViewId") {
            self.customViewId = dict["CustomViewId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteCustomViewResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCustomViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCustomViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaRequest : Tea.TeaModel {
    public var mediaIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteMediaResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaTagRequest : Tea.TeaModel {
    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            self.tag = dict["Tag"] as! String
        }
    }
}

public class DeleteMediaTagResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMediaTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteMediaWorkflowRequest : Tea.TeaModel {
    public var mediaWorkflowId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowId != nil {
            map["MediaWorkflowId"] = self.mediaWorkflowId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowId") {
            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteMediaWorkflowResponseBody : Tea.TeaModel {
    public class MediaWorkflow : Tea.TeaModel {
        public var creationTime: String?

        public var mediaWorkflowId: String?

        public var name: String?

        public var state: String?

        public var topology: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.mediaWorkflowId != nil {
                map["MediaWorkflowId"] = self.mediaWorkflowId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.topology != nil {
                map["Topology"] = self.topology!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("MediaWorkflowId") {
                self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Topology") {
                self.topology = dict["Topology"] as! String
            }
        }
    }
    public var mediaWorkflow: DeleteMediaWorkflowResponseBody.MediaWorkflow?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflow?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflow != nil {
            map["MediaWorkflow"] = self.mediaWorkflow?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflow") {
            var model = DeleteMediaWorkflowResponseBody.MediaWorkflow()
            model.fromMap(dict["MediaWorkflow"] as! [String: Any])
            self.mediaWorkflow = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteMediaWorkflowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteMediaWorkflowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteMediaWorkflowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePipelineRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeletePipelineResponseBody : Tea.TeaModel {
    public var pipelineId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSmarttagTemplateRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteSmarttagTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSmarttagTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSmarttagTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSmarttagTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTemplateRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteWaterMarkTemplateRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var waterMarkTemplateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.waterMarkTemplateId != nil {
            map["WaterMarkTemplateId"] = self.waterMarkTemplateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("WaterMarkTemplateId") {
            self.waterMarkTemplateId = dict["WaterMarkTemplateId"] as! String
        }
    }
}

public class DeleteWaterMarkTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var waterMarkTemplateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.waterMarkTemplateId != nil {
            map["WaterMarkTemplateId"] = self.waterMarkTemplateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WaterMarkTemplateId") {
            self.waterMarkTemplateId = dict["WaterMarkTemplateId"] as! String
        }
    }
}

public class DeleteWaterMarkTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteWaterMarkTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteWaterMarkTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImAuditRequest : Tea.TeaModel {
    public var bizType: String?

    public var contents: String?

    public var images: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scenes: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizType != nil {
            map["BizType"] = self.bizType!
        }
        if self.contents != nil {
            map["Contents"] = self.contents!
        }
        if self.images != nil {
            map["Images"] = self.images!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scenes != nil {
            map["Scenes"] = self.scenes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizType") {
            self.bizType = dict["BizType"] as! String
        }
        if dict.keys.contains("Contents") {
            self.contents = dict["Contents"] as! String
        }
        if dict.keys.contains("Images") {
            self.images = dict["Images"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Scenes") {
            self.scenes = dict["Scenes"] as! String
        }
    }
}

public class ImAuditResponseBody : Tea.TeaModel {
    public class ImageResults : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class Results : Tea.TeaModel {
                public class Frames : Tea.TeaModel {
                    public var rate: Double?

                    public var url: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.rate != nil {
                            map["rate"] = self.rate!
                        }
                        if self.url != nil {
                            map["url"] = self.url!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("rate") {
                            self.rate = dict["rate"] as! Double
                        }
                        if dict.keys.contains("url") {
                            self.url = dict["url"] as! String
                        }
                    }
                }
                public class HintWordsInfo : Tea.TeaModel {
                    public var context: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.context != nil {
                            map["context"] = self.context!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("context") {
                            self.context = dict["context"] as! String
                        }
                    }
                }
                public class LogoData : Tea.TeaModel {
                    public var h: Double?

                    public var name: String?

                    public var type: String?

                    public var w: Double?

                    public var x: Double?

                    public var y: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.h != nil {
                            map["h"] = self.h!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        if self.type != nil {
                            map["type"] = self.type!
                        }
                        if self.w != nil {
                            map["w"] = self.w!
                        }
                        if self.x != nil {
                            map["x"] = self.x!
                        }
                        if self.y != nil {
                            map["y"] = self.y!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("h") {
                            self.h = dict["h"] as! Double
                        }
                        if dict.keys.contains("name") {
                            self.name = dict["name"] as! String
                        }
                        if dict.keys.contains("type") {
                            self.type = dict["type"] as! String
                        }
                        if dict.keys.contains("w") {
                            self.w = dict["w"] as! Double
                        }
                        if dict.keys.contains("x") {
                            self.x = dict["x"] as! Double
                        }
                        if dict.keys.contains("y") {
                            self.y = dict["y"] as! Double
                        }
                    }
                }
                public class ProgramCodeData : Tea.TeaModel {
                    public var h: Double?

                    public var w: Double?

                    public var x: Double?

                    public var y: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.h != nil {
                            map["h"] = self.h!
                        }
                        if self.w != nil {
                            map["w"] = self.w!
                        }
                        if self.x != nil {
                            map["x"] = self.x!
                        }
                        if self.y != nil {
                            map["y"] = self.y!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("h") {
                            self.h = dict["h"] as! Double
                        }
                        if dict.keys.contains("w") {
                            self.w = dict["w"] as! Double
                        }
                        if dict.keys.contains("x") {
                            self.x = dict["x"] as! Double
                        }
                        if dict.keys.contains("y") {
                            self.y = dict["y"] as! Double
                        }
                    }
                }
                public class QrcodeLocations : Tea.TeaModel {
                    public var h: Double?

                    public var qrcode: String?

                    public var w: Double?

                    public var x: Double?

                    public var y: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.h != nil {
                            map["h"] = self.h!
                        }
                        if self.qrcode != nil {
                            map["qrcode"] = self.qrcode!
                        }
                        if self.w != nil {
                            map["w"] = self.w!
                        }
                        if self.x != nil {
                            map["x"] = self.x!
                        }
                        if self.y != nil {
                            map["y"] = self.y!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("h") {
                            self.h = dict["h"] as! Double
                        }
                        if dict.keys.contains("qrcode") {
                            self.qrcode = dict["qrcode"] as! String
                        }
                        if dict.keys.contains("w") {
                            self.w = dict["w"] as! Double
                        }
                        if dict.keys.contains("x") {
                            self.x = dict["x"] as! Double
                        }
                        if dict.keys.contains("y") {
                            self.y = dict["y"] as! Double
                        }
                    }
                }
                public class SfaceData : Tea.TeaModel {
                    public class Faces : Tea.TeaModel {
                        public var idid: String?

                        public var name: String?

                        public var re: Double?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.idid != nil {
                                map["idid"] = self.idid!
                            }
                            if self.name != nil {
                                map["name"] = self.name!
                            }
                            if self.re != nil {
                                map["re"] = self.re!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("idid") {
                                self.idid = dict["idid"] as! String
                            }
                            if dict.keys.contains("name") {
                                self.name = dict["name"] as! String
                            }
                            if dict.keys.contains("re") {
                                self.re = dict["re"] as! Double
                            }
                        }
                    }
                    public var faces: [ImAuditResponseBody.ImageResults.Result.Results.SfaceData.Faces]?

                    public var h: Double?

                    public var w: Double?

                    public var x: Double?

                    public var y: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.faces != nil {
                            var tmp : [Any] = []
                            for k in self.faces! {
                                tmp.append(k.toMap())
                            }
                            map["faces"] = tmp
                        }
                        if self.h != nil {
                            map["h"] = self.h!
                        }
                        if self.w != nil {
                            map["w"] = self.w!
                        }
                        if self.x != nil {
                            map["x"] = self.x!
                        }
                        if self.y != nil {
                            map["y"] = self.y!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("faces") {
                            var tmp : [ImAuditResponseBody.ImageResults.Result.Results.SfaceData.Faces] = []
                            for v in dict["faces"] as! [Any] {
                                var model = ImAuditResponseBody.ImageResults.Result.Results.SfaceData.Faces()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.faces = tmp
                        }
                        if dict.keys.contains("h") {
                            self.h = dict["h"] as! Double
                        }
                        if dict.keys.contains("w") {
                            self.w = dict["w"] as! Double
                        }
                        if dict.keys.contains("x") {
                            self.x = dict["x"] as! Double
                        }
                        if dict.keys.contains("y") {
                            self.y = dict["y"] as! Double
                        }
                    }
                }
                public var label: String?

                public var rate: Double?

                public var scene: String?

                public var suggestion: String?

                public var frames: [ImAuditResponseBody.ImageResults.Result.Results.Frames]?

                public var hintWordsInfo: [ImAuditResponseBody.ImageResults.Result.Results.HintWordsInfo]?

                public var logoData: [ImAuditResponseBody.ImageResults.Result.Results.LogoData]?

                public var ocrData: [String]?

                public var programCodeData: [ImAuditResponseBody.ImageResults.Result.Results.ProgramCodeData]?

                public var qrcodeData: [String]?

                public var qrcodeLocations: [ImAuditResponseBody.ImageResults.Result.Results.QrcodeLocations]?

                public var sfaceData: [ImAuditResponseBody.ImageResults.Result.Results.SfaceData]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    if self.scene != nil {
                        map["Scene"] = self.scene!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    if self.frames != nil {
                        var tmp : [Any] = []
                        for k in self.frames! {
                            tmp.append(k.toMap())
                        }
                        map["frames"] = tmp
                    }
                    if self.hintWordsInfo != nil {
                        var tmp : [Any] = []
                        for k in self.hintWordsInfo! {
                            tmp.append(k.toMap())
                        }
                        map["hintWordsInfo"] = tmp
                    }
                    if self.logoData != nil {
                        var tmp : [Any] = []
                        for k in self.logoData! {
                            tmp.append(k.toMap())
                        }
                        map["logoData"] = tmp
                    }
                    if self.ocrData != nil {
                        map["ocrData"] = self.ocrData!
                    }
                    if self.programCodeData != nil {
                        var tmp : [Any] = []
                        for k in self.programCodeData! {
                            tmp.append(k.toMap())
                        }
                        map["programCodeData"] = tmp
                    }
                    if self.qrcodeData != nil {
                        map["qrcodeData"] = self.qrcodeData!
                    }
                    if self.qrcodeLocations != nil {
                        var tmp : [Any] = []
                        for k in self.qrcodeLocations! {
                            tmp.append(k.toMap())
                        }
                        map["qrcodeLocations"] = tmp
                    }
                    if self.sfaceData != nil {
                        var tmp : [Any] = []
                        for k in self.sfaceData! {
                            tmp.append(k.toMap())
                        }
                        map["sfaceData"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Rate") {
                        self.rate = dict["Rate"] as! Double
                    }
                    if dict.keys.contains("Scene") {
                        self.scene = dict["Scene"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                    if dict.keys.contains("frames") {
                        var tmp : [ImAuditResponseBody.ImageResults.Result.Results.Frames] = []
                        for v in dict["frames"] as! [Any] {
                            var model = ImAuditResponseBody.ImageResults.Result.Results.Frames()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.frames = tmp
                    }
                    if dict.keys.contains("hintWordsInfo") {
                        var tmp : [ImAuditResponseBody.ImageResults.Result.Results.HintWordsInfo] = []
                        for v in dict["hintWordsInfo"] as! [Any] {
                            var model = ImAuditResponseBody.ImageResults.Result.Results.HintWordsInfo()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.hintWordsInfo = tmp
                    }
                    if dict.keys.contains("logoData") {
                        var tmp : [ImAuditResponseBody.ImageResults.Result.Results.LogoData] = []
                        for v in dict["logoData"] as! [Any] {
                            var model = ImAuditResponseBody.ImageResults.Result.Results.LogoData()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.logoData = tmp
                    }
                    if dict.keys.contains("ocrData") {
                        self.ocrData = dict["ocrData"] as! [String]
                    }
                    if dict.keys.contains("programCodeData") {
                        var tmp : [ImAuditResponseBody.ImageResults.Result.Results.ProgramCodeData] = []
                        for v in dict["programCodeData"] as! [Any] {
                            var model = ImAuditResponseBody.ImageResults.Result.Results.ProgramCodeData()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.programCodeData = tmp
                    }
                    if dict.keys.contains("qrcodeData") {
                        self.qrcodeData = dict["qrcodeData"] as! [String]
                    }
                    if dict.keys.contains("qrcodeLocations") {
                        var tmp : [ImAuditResponseBody.ImageResults.Result.Results.QrcodeLocations] = []
                        for v in dict["qrcodeLocations"] as! [Any] {
                            var model = ImAuditResponseBody.ImageResults.Result.Results.QrcodeLocations()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.qrcodeLocations = tmp
                    }
                    if dict.keys.contains("sfaceData") {
                        var tmp : [ImAuditResponseBody.ImageResults.Result.Results.SfaceData] = []
                        for v in dict["sfaceData"] as! [Any] {
                            var model = ImAuditResponseBody.ImageResults.Result.Results.SfaceData()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.sfaceData = tmp
                    }
                }
            }
            public var code: Int64?

            public var dataId: String?

            public var extras: [String: Any]?

            public var msg: String?

            public var results: [ImAuditResponseBody.ImageResults.Result.Results]?

            public var taskId: String?

            public var url: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.dataId != nil {
                    map["dataId"] = self.dataId!
                }
                if self.extras != nil {
                    map["extras"] = self.extras!
                }
                if self.msg != nil {
                    map["msg"] = self.msg!
                }
                if self.results != nil {
                    var tmp : [Any] = []
                    for k in self.results! {
                        tmp.append(k.toMap())
                    }
                    map["results"] = tmp
                }
                if self.taskId != nil {
                    map["taskId"] = self.taskId!
                }
                if self.url != nil {
                    map["url"] = self.url!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! Int64
                }
                if dict.keys.contains("dataId") {
                    self.dataId = dict["dataId"] as! String
                }
                if dict.keys.contains("extras") {
                    self.extras = dict["extras"] as! [String: Any]
                }
                if dict.keys.contains("msg") {
                    self.msg = dict["msg"] as! String
                }
                if dict.keys.contains("results") {
                    var tmp : [ImAuditResponseBody.ImageResults.Result.Results] = []
                    for v in dict["results"] as! [Any] {
                        var model = ImAuditResponseBody.ImageResults.Result.Results()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.results = tmp
                }
                if dict.keys.contains("taskId") {
                    self.taskId = dict["taskId"] as! String
                }
                if dict.keys.contains("url") {
                    self.url = dict["url"] as! String
                }
            }
        }
        public var result: [ImAuditResponseBody.ImageResults.Result]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["result"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("result") {
                var tmp : [ImAuditResponseBody.ImageResults.Result] = []
                for v in dict["result"] as! [Any] {
                    var model = ImAuditResponseBody.ImageResults.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
        }
    }
    public class TextResults : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class Results : Tea.TeaModel {
                public class Details : Tea.TeaModel {
                    public class Contexts : Tea.TeaModel {
                        public var context: String?

                        public var libCode: String?

                        public var libName: String?

                        public var positions: [String]?

                        public var ruleType: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.context != nil {
                                map["context"] = self.context!
                            }
                            if self.libCode != nil {
                                map["libCode"] = self.libCode!
                            }
                            if self.libName != nil {
                                map["libName"] = self.libName!
                            }
                            if self.positions != nil {
                                map["positions"] = self.positions!
                            }
                            if self.ruleType != nil {
                                map["ruleType"] = self.ruleType!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("context") {
                                self.context = dict["context"] as! String
                            }
                            if dict.keys.contains("libCode") {
                                self.libCode = dict["libCode"] as! String
                            }
                            if dict.keys.contains("libName") {
                                self.libName = dict["libName"] as! String
                            }
                            if dict.keys.contains("positions") {
                                self.positions = dict["positions"] as! [String]
                            }
                            if dict.keys.contains("ruleType") {
                                self.ruleType = dict["ruleType"] as! String
                            }
                        }
                    }
                    public var label: String?

                    public var contexts: [ImAuditResponseBody.TextResults.Result.Results.Details.Contexts]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.contexts != nil {
                            var tmp : [Any] = []
                            for k in self.contexts! {
                                tmp.append(k.toMap())
                            }
                            map["contexts"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("contexts") {
                            var tmp : [ImAuditResponseBody.TextResults.Result.Results.Details.Contexts] = []
                            for v in dict["contexts"] as! [Any] {
                                var model = ImAuditResponseBody.TextResults.Result.Results.Details.Contexts()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.contexts = tmp
                        }
                    }
                }
                public var details: [ImAuditResponseBody.TextResults.Result.Results.Details]?

                public var label: String?

                public var rate: Double?

                public var scene: String?

                public var suggestion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.details != nil {
                        var tmp : [Any] = []
                        for k in self.details! {
                            tmp.append(k.toMap())
                        }
                        map["details"] = tmp
                    }
                    if self.label != nil {
                        map["label"] = self.label!
                    }
                    if self.rate != nil {
                        map["rate"] = self.rate!
                    }
                    if self.scene != nil {
                        map["scene"] = self.scene!
                    }
                    if self.suggestion != nil {
                        map["suggestion"] = self.suggestion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("details") {
                        var tmp : [ImAuditResponseBody.TextResults.Result.Results.Details] = []
                        for v in dict["details"] as! [Any] {
                            var model = ImAuditResponseBody.TextResults.Result.Results.Details()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.details = tmp
                    }
                    if dict.keys.contains("label") {
                        self.label = dict["label"] as! String
                    }
                    if dict.keys.contains("rate") {
                        self.rate = dict["rate"] as! Double
                    }
                    if dict.keys.contains("scene") {
                        self.scene = dict["scene"] as! String
                    }
                    if dict.keys.contains("suggestion") {
                        self.suggestion = dict["suggestion"] as! String
                    }
                }
            }
            public var code: Int64?

            public var content: String?

            public var dataId: String?

            public var msg: String?

            public var results: [ImAuditResponseBody.TextResults.Result.Results]?

            public var taskId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["code"] = self.code!
                }
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.dataId != nil {
                    map["dataId"] = self.dataId!
                }
                if self.msg != nil {
                    map["msg"] = self.msg!
                }
                if self.results != nil {
                    var tmp : [Any] = []
                    for k in self.results! {
                        tmp.append(k.toMap())
                    }
                    map["results"] = tmp
                }
                if self.taskId != nil {
                    map["taskId"] = self.taskId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("code") {
                    self.code = dict["code"] as! Int64
                }
                if dict.keys.contains("content") {
                    self.content = dict["content"] as! String
                }
                if dict.keys.contains("dataId") {
                    self.dataId = dict["dataId"] as! String
                }
                if dict.keys.contains("msg") {
                    self.msg = dict["msg"] as! String
                }
                if dict.keys.contains("results") {
                    var tmp : [ImAuditResponseBody.TextResults.Result.Results] = []
                    for v in dict["results"] as! [Any] {
                        var model = ImAuditResponseBody.TextResults.Result.Results()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.results = tmp
                }
                if dict.keys.contains("taskId") {
                    self.taskId = dict["taskId"] as! String
                }
            }
        }
        public var result: [ImAuditResponseBody.TextResults.Result]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["result"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("result") {
                var tmp : [ImAuditResponseBody.TextResults.Result] = []
                for v in dict["result"] as! [Any] {
                    var model = ImAuditResponseBody.TextResults.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
        }
    }
    public var imageQuotaExceed: Bool?

    public var imageResults: ImAuditResponseBody.ImageResults?

    public var requestId: String?

    public var textQuotaExceed: Bool?

    public var textResults: ImAuditResponseBody.TextResults?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageResults?.validate()
        try self.textResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageQuotaExceed != nil {
            map["ImageQuotaExceed"] = self.imageQuotaExceed!
        }
        if self.imageResults != nil {
            map["ImageResults"] = self.imageResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.textQuotaExceed != nil {
            map["TextQuotaExceed"] = self.textQuotaExceed!
        }
        if self.textResults != nil {
            map["TextResults"] = self.textResults?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageQuotaExceed") {
            self.imageQuotaExceed = dict["ImageQuotaExceed"] as! Bool
        }
        if dict.keys.contains("ImageResults") {
            var model = ImAuditResponseBody.ImageResults()
            model.fromMap(dict["ImageResults"] as! [String: Any])
            self.imageResults = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TextQuotaExceed") {
            self.textQuotaExceed = dict["TextQuotaExceed"] as! Bool
        }
        if dict.keys.contains("TextResults") {
            var model = ImAuditResponseBody.TextResults()
            model.fromMap(dict["TextResults"] as! [String: Any])
            self.textResults = model
        }
    }
}

public class ImAuditResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImAuditResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImAuditResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportFpShotJobRequest : Tea.TeaModel {
    public var fpDBId: String?

    public var fpImportConfig: String?

    public var input: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fpDBId != nil {
            map["FpDBId"] = self.fpDBId!
        }
        if self.fpImportConfig != nil {
            map["FpImportConfig"] = self.fpImportConfig!
        }
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FpDBId") {
            self.fpDBId = dict["FpDBId"] as! String
        }
        if dict.keys.contains("FpImportConfig") {
            self.fpImportConfig = dict["FpImportConfig"] as! String
        }
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class ImportFpShotJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ImportFpShotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportFpShotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportFpShotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAllMediaBucketRequest : Tea.TeaModel {
    public var maximumPageSize: Int32?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maximumPageSize != nil {
            map["MaximumPageSize"] = self.maximumPageSize!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaximumPageSize") {
            self.maximumPageSize = dict["MaximumPageSize"] as! Int32
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListAllMediaBucketResponseBody : Tea.TeaModel {
    public class MediaBucketList : Tea.TeaModel {
        public class MediaBucket : Tea.TeaModel {
            public var bucket: String?

            public var referer: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.referer != nil {
                    map["Referer"] = self.referer!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Referer") {
                    self.referer = dict["Referer"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var mediaBucket: [ListAllMediaBucketResponseBody.MediaBucketList.MediaBucket]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaBucket != nil {
                var tmp : [Any] = []
                for k in self.mediaBucket! {
                    tmp.append(k.toMap())
                }
                map["MediaBucket"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaBucket") {
                var tmp : [ListAllMediaBucketResponseBody.MediaBucketList.MediaBucket] = []
                for v in dict["MediaBucket"] as! [Any] {
                    var model = ListAllMediaBucketResponseBody.MediaBucketList.MediaBucket()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaBucket = tmp
            }
        }
    }
    public var mediaBucketList: ListAllMediaBucketResponseBody.MediaBucketList?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaBucketList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaBucketList != nil {
            map["MediaBucketList"] = self.mediaBucketList?.toMap()
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaBucketList") {
            var model = ListAllMediaBucketResponseBody.MediaBucketList()
            model.fromMap(dict["MediaBucketList"] as! [String: Any])
            self.mediaBucketList = model
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAllMediaBucketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAllMediaBucketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAllMediaBucketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomEntitiesRequest : Tea.TeaModel {
    public var algorithm: String?

    public var customGroupId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithm != nil {
            map["Algorithm"] = self.algorithm!
        }
        if self.customGroupId != nil {
            map["CustomGroupId"] = self.customGroupId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Algorithm") {
            self.algorithm = dict["Algorithm"] as! String
        }
        if dict.keys.contains("CustomGroupId") {
            self.customGroupId = dict["CustomGroupId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListCustomEntitiesResponseBody : Tea.TeaModel {
    public class CustomEntities : Tea.TeaModel {
        public class CustomEntity : Tea.TeaModel {
            public var customEntityId: String?

            public var customEntityInfo: String?

            public var customEntityName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customEntityId != nil {
                    map["CustomEntityId"] = self.customEntityId!
                }
                if self.customEntityInfo != nil {
                    map["CustomEntityInfo"] = self.customEntityInfo!
                }
                if self.customEntityName != nil {
                    map["CustomEntityName"] = self.customEntityName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CustomEntityId") {
                    self.customEntityId = dict["CustomEntityId"] as! String
                }
                if dict.keys.contains("CustomEntityInfo") {
                    self.customEntityInfo = dict["CustomEntityInfo"] as! String
                }
                if dict.keys.contains("CustomEntityName") {
                    self.customEntityName = dict["CustomEntityName"] as! String
                }
            }
        }
        public var customEntity: [ListCustomEntitiesResponseBody.CustomEntities.CustomEntity]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customEntity != nil {
                var tmp : [Any] = []
                for k in self.customEntity! {
                    tmp.append(k.toMap())
                }
                map["CustomEntity"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomEntity") {
                var tmp : [ListCustomEntitiesResponseBody.CustomEntities.CustomEntity] = []
                for v in dict["CustomEntity"] as! [Any] {
                    var model = ListCustomEntitiesResponseBody.CustomEntities.CustomEntity()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customEntity = tmp
            }
        }
    }
    public var customEntities: ListCustomEntitiesResponseBody.CustomEntities?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.customEntities?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customEntities != nil {
            map["CustomEntities"] = self.customEntities?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomEntities") {
            var model = ListCustomEntitiesResponseBody.CustomEntities()
            model.fromMap(dict["CustomEntities"] as! [String: Any])
            self.customEntities = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListCustomEntitiesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomEntitiesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCustomEntitiesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomGroupsRequest : Tea.TeaModel {
    public var algorithm: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithm != nil {
            map["Algorithm"] = self.algorithm!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Algorithm") {
            self.algorithm = dict["Algorithm"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListCustomGroupsResponseBody : Tea.TeaModel {
    public class CustomGroups : Tea.TeaModel {
        public class CustomGroup : Tea.TeaModel {
            public var customGroupDescription: String?

            public var customGroupId: String?

            public var customGroupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customGroupDescription != nil {
                    map["CustomGroupDescription"] = self.customGroupDescription!
                }
                if self.customGroupId != nil {
                    map["CustomGroupId"] = self.customGroupId!
                }
                if self.customGroupName != nil {
                    map["CustomGroupName"] = self.customGroupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CustomGroupDescription") {
                    self.customGroupDescription = dict["CustomGroupDescription"] as! String
                }
                if dict.keys.contains("CustomGroupId") {
                    self.customGroupId = dict["CustomGroupId"] as! String
                }
                if dict.keys.contains("CustomGroupName") {
                    self.customGroupName = dict["CustomGroupName"] as! String
                }
            }
        }
        public var customGroup: [ListCustomGroupsResponseBody.CustomGroups.CustomGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customGroup != nil {
                var tmp : [Any] = []
                for k in self.customGroup! {
                    tmp.append(k.toMap())
                }
                map["CustomGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomGroup") {
                var tmp : [ListCustomGroupsResponseBody.CustomGroups.CustomGroup] = []
                for v in dict["CustomGroup"] as! [Any] {
                    var model = ListCustomGroupsResponseBody.CustomGroups.CustomGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customGroup = tmp
            }
        }
    }
    public var customGroups: ListCustomGroupsResponseBody.CustomGroups?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.customGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customGroups != nil {
            map["CustomGroups"] = self.customGroups?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomGroups") {
            var model = ListCustomGroupsResponseBody.CustomGroups()
            model.fromMap(dict["CustomGroups"] as! [String: Any])
            self.customGroups = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListCustomGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCustomGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomPersonsRequest : Tea.TeaModel {
    public var categoryId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var personId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.personId != nil {
            map["PersonId"] = self.personId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CategoryId") {
            self.categoryId = dict["CategoryId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PersonId") {
            self.personId = dict["PersonId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListCustomPersonsResponseBody : Tea.TeaModel {
    public class Categories : Tea.TeaModel {
        public class Category : Tea.TeaModel {
            public class Persons : Tea.TeaModel {
                public class Person : Tea.TeaModel {
                    public class Faces : Tea.TeaModel {
                        public class Face : Tea.TeaModel {
                            public var faceId: String?

                            public var imageUrl: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.faceId != nil {
                                    map["FaceId"] = self.faceId!
                                }
                                if self.imageUrl != nil {
                                    map["ImageUrl"] = self.imageUrl!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("FaceId") {
                                    self.faceId = dict["FaceId"] as! String
                                }
                                if dict.keys.contains("ImageUrl") {
                                    self.imageUrl = dict["ImageUrl"] as! String
                                }
                            }
                        }
                        public var face: [ListCustomPersonsResponseBody.Categories.Category.Persons.Person.Faces.Face]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.face != nil {
                                var tmp : [Any] = []
                                for k in self.face! {
                                    tmp.append(k.toMap())
                                }
                                map["Face"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Face") {
                                var tmp : [ListCustomPersonsResponseBody.Categories.Category.Persons.Person.Faces.Face] = []
                                for v in dict["Face"] as! [Any] {
                                    var model = ListCustomPersonsResponseBody.Categories.Category.Persons.Person.Faces.Face()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.face = tmp
                            }
                        }
                    }
                    public var faces: ListCustomPersonsResponseBody.Categories.Category.Persons.Person.Faces?

                    public var personDescription: String?

                    public var personId: String?

                    public var personName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.faces?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.faces != nil {
                            map["Faces"] = self.faces?.toMap()
                        }
                        if self.personDescription != nil {
                            map["PersonDescription"] = self.personDescription!
                        }
                        if self.personId != nil {
                            map["PersonId"] = self.personId!
                        }
                        if self.personName != nil {
                            map["PersonName"] = self.personName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Faces") {
                            var model = ListCustomPersonsResponseBody.Categories.Category.Persons.Person.Faces()
                            model.fromMap(dict["Faces"] as! [String: Any])
                            self.faces = model
                        }
                        if dict.keys.contains("PersonDescription") {
                            self.personDescription = dict["PersonDescription"] as! String
                        }
                        if dict.keys.contains("PersonId") {
                            self.personId = dict["PersonId"] as! String
                        }
                        if dict.keys.contains("PersonName") {
                            self.personName = dict["PersonName"] as! String
                        }
                    }
                }
                public var person: [ListCustomPersonsResponseBody.Categories.Category.Persons.Person]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.person != nil {
                        var tmp : [Any] = []
                        for k in self.person! {
                            tmp.append(k.toMap())
                        }
                        map["Person"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Person") {
                        var tmp : [ListCustomPersonsResponseBody.Categories.Category.Persons.Person] = []
                        for v in dict["Person"] as! [Any] {
                            var model = ListCustomPersonsResponseBody.Categories.Category.Persons.Person()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.person = tmp
                    }
                }
            }
            public var categoryDescription: String?

            public var categoryId: String?

            public var categoryName: String?

            public var persons: ListCustomPersonsResponseBody.Categories.Category.Persons?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.persons?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.categoryDescription != nil {
                    map["CategoryDescription"] = self.categoryDescription!
                }
                if self.categoryId != nil {
                    map["CategoryId"] = self.categoryId!
                }
                if self.categoryName != nil {
                    map["CategoryName"] = self.categoryName!
                }
                if self.persons != nil {
                    map["Persons"] = self.persons?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CategoryDescription") {
                    self.categoryDescription = dict["CategoryDescription"] as! String
                }
                if dict.keys.contains("CategoryId") {
                    self.categoryId = dict["CategoryId"] as! String
                }
                if dict.keys.contains("CategoryName") {
                    self.categoryName = dict["CategoryName"] as! String
                }
                if dict.keys.contains("Persons") {
                    var model = ListCustomPersonsResponseBody.Categories.Category.Persons()
                    model.fromMap(dict["Persons"] as! [String: Any])
                    self.persons = model
                }
            }
        }
        public var category: [ListCustomPersonsResponseBody.Categories.Category]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                var tmp : [Any] = []
                for k in self.category! {
                    tmp.append(k.toMap())
                }
                map["Category"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                var tmp : [ListCustomPersonsResponseBody.Categories.Category] = []
                for v in dict["Category"] as! [Any] {
                    var model = ListCustomPersonsResponseBody.Categories.Category()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.category = tmp
            }
        }
    }
    public var categories: ListCustomPersonsResponseBody.Categories?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.categories?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categories != nil {
            map["Categories"] = self.categories?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Categories") {
            var model = ListCustomPersonsResponseBody.Categories()
            model.fromMap(dict["Categories"] as! [String: Any])
            self.categories = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCustomPersonsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomPersonsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCustomPersonsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomViewsRequest : Tea.TeaModel {
    public var algorithm: String?

    public var customEntityId: String?

    public var customGroupId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithm != nil {
            map["Algorithm"] = self.algorithm!
        }
        if self.customEntityId != nil {
            map["CustomEntityId"] = self.customEntityId!
        }
        if self.customGroupId != nil {
            map["CustomGroupId"] = self.customGroupId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Algorithm") {
            self.algorithm = dict["Algorithm"] as! String
        }
        if dict.keys.contains("CustomEntityId") {
            self.customEntityId = dict["CustomEntityId"] as! String
        }
        if dict.keys.contains("CustomGroupId") {
            self.customGroupId = dict["CustomGroupId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListCustomViewsResponseBody : Tea.TeaModel {
    public class CustomViews : Tea.TeaModel {
        public class CustomView : Tea.TeaModel {
            public var customViewId: String?

            public var imageUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customViewId != nil {
                    map["CustomViewId"] = self.customViewId!
                }
                if self.imageUrl != nil {
                    map["ImageUrl"] = self.imageUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CustomViewId") {
                    self.customViewId = dict["CustomViewId"] as! String
                }
                if dict.keys.contains("ImageUrl") {
                    self.imageUrl = dict["ImageUrl"] as! String
                }
            }
        }
        public var customView: [ListCustomViewsResponseBody.CustomViews.CustomView]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customView != nil {
                var tmp : [Any] = []
                for k in self.customView! {
                    tmp.append(k.toMap())
                }
                map["CustomView"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomView") {
                var tmp : [ListCustomViewsResponseBody.CustomViews.CustomView] = []
                for v in dict["CustomView"] as! [Any] {
                    var model = ListCustomViewsResponseBody.CustomViews.CustomView()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customView = tmp
            }
        }
    }
    public var customViews: ListCustomViewsResponseBody.CustomViews?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.customViews?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customViews != nil {
            map["CustomViews"] = self.customViews?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomViews") {
            var model = ListCustomViewsResponseBody.CustomViews()
            model.fromMap(dict["CustomViews"] as! [String: Any])
            self.customViews = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListCustomViewsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomViewsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCustomViewsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFpShotDBRequest : Tea.TeaModel {
    public var fpDBIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fpDBIds != nil {
            map["FpDBIds"] = self.fpDBIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FpDBIds") {
            self.fpDBIds = dict["FpDBIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListFpShotDBResponseBody : Tea.TeaModel {
    public class FpShotDBList : Tea.TeaModel {
        public class FpShotDB : Tea.TeaModel {
            public var description_: String?

            public var fpDBId: String?

            public var modelId: Int32?

            public var name: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.fpDBId != nil {
                    map["FpDBId"] = self.fpDBId!
                }
                if self.modelId != nil {
                    map["ModelId"] = self.modelId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("FpDBId") {
                    self.fpDBId = dict["FpDBId"] as! String
                }
                if dict.keys.contains("ModelId") {
                    self.modelId = dict["ModelId"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var fpShotDB: [ListFpShotDBResponseBody.FpShotDBList.FpShotDB]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fpShotDB != nil {
                var tmp : [Any] = []
                for k in self.fpShotDB! {
                    tmp.append(k.toMap())
                }
                map["FpShotDB"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FpShotDB") {
                var tmp : [ListFpShotDBResponseBody.FpShotDBList.FpShotDB] = []
                for v in dict["FpShotDB"] as! [Any] {
                    var model = ListFpShotDBResponseBody.FpShotDBList.FpShotDB()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fpShotDB = tmp
            }
        }
    }
    public class NonExistIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public var fpShotDBList: ListFpShotDBResponseBody.FpShotDBList?

    public var nonExistIds: ListFpShotDBResponseBody.NonExistIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.fpShotDBList?.validate()
        try self.nonExistIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fpShotDBList != nil {
            map["FpShotDBList"] = self.fpShotDBList?.toMap()
        }
        if self.nonExistIds != nil {
            map["NonExistIds"] = self.nonExistIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FpShotDBList") {
            var model = ListFpShotDBResponseBody.FpShotDBList()
            model.fromMap(dict["FpShotDBList"] as! [String: Any])
            self.fpShotDBList = model
        }
        if dict.keys.contains("NonExistIds") {
            var model = ListFpShotDBResponseBody.NonExistIds()
            model.fromMap(dict["NonExistIds"] as! [String: Any])
            self.nonExistIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListFpShotDBResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFpShotDBResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListFpShotDBResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFpShotFilesRequest : Tea.TeaModel {
    public var endTime: String?

    public var fpDBId: String?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageSize: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.fpDBId != nil {
            map["FpDBId"] = self.fpDBId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("FpDBId") {
            self.fpDBId = dict["FpDBId"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ListFpShotFilesResponseBody : Tea.TeaModel {
    public class FpShotFileList : Tea.TeaModel {
        public class FpShotFile : Tea.TeaModel {
            public class InputFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var fileId: String?

            public var inputFile: ListFpShotFilesResponseBody.FpShotFileList.FpShotFile.InputFile?

            public var primaryKey: String?

            public var storeTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.inputFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileId != nil {
                    map["FileId"] = self.fileId!
                }
                if self.inputFile != nil {
                    map["InputFile"] = self.inputFile?.toMap()
                }
                if self.primaryKey != nil {
                    map["PrimaryKey"] = self.primaryKey!
                }
                if self.storeTime != nil {
                    map["StoreTime"] = self.storeTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FileId") {
                    self.fileId = dict["FileId"] as! String
                }
                if dict.keys.contains("InputFile") {
                    var model = ListFpShotFilesResponseBody.FpShotFileList.FpShotFile.InputFile()
                    model.fromMap(dict["InputFile"] as! [String: Any])
                    self.inputFile = model
                }
                if dict.keys.contains("PrimaryKey") {
                    self.primaryKey = dict["PrimaryKey"] as! String
                }
                if dict.keys.contains("StoreTime") {
                    self.storeTime = dict["StoreTime"] as! String
                }
            }
        }
        public var fpShotFile: [ListFpShotFilesResponseBody.FpShotFileList.FpShotFile]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fpShotFile != nil {
                var tmp : [Any] = []
                for k in self.fpShotFile! {
                    tmp.append(k.toMap())
                }
                map["FpShotFile"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FpShotFile") {
                var tmp : [ListFpShotFilesResponseBody.FpShotFileList.FpShotFile] = []
                for v in dict["FpShotFile"] as! [Any] {
                    var model = ListFpShotFilesResponseBody.FpShotFileList.FpShotFile()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fpShotFile = tmp
            }
        }
    }
    public var fpShotFileList: ListFpShotFilesResponseBody.FpShotFileList?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.fpShotFileList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fpShotFileList != nil {
            map["FpShotFileList"] = self.fpShotFileList?.toMap()
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FpShotFileList") {
            var model = ListFpShotFilesResponseBody.FpShotFileList()
            model.fromMap(dict["FpShotFileList"] as! [String: Any])
            self.fpShotFileList = model
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListFpShotFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFpShotFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListFpShotFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFpShotImportJobRequest : Tea.TeaModel {
    public var jobIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListFpShotImportJobResponseBody : Tea.TeaModel {
    public class FpShotImportJobList : Tea.TeaModel {
        public var code: String?

        public var createTime: String?

        public var finishTime: String?

        public var fpDBId: String?

        public var fpImportConfig: String?

        public var id: String?

        public var input: String?

        public var message: String?

        public var pipelineId: String?

        public var processMessage: String?

        public var status: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.fpDBId != nil {
                map["FpDBId"] = self.fpDBId!
            }
            if self.fpImportConfig != nil {
                map["FpImportConfig"] = self.fpImportConfig!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.input != nil {
                map["Input"] = self.input!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.processMessage != nil {
                map["ProcessMessage"] = self.processMessage!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("FpDBId") {
                self.fpDBId = dict["FpDBId"] as! String
            }
            if dict.keys.contains("FpImportConfig") {
                self.fpImportConfig = dict["FpImportConfig"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Input") {
                self.input = dict["Input"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("ProcessMessage") {
                self.processMessage = dict["ProcessMessage"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var fpShotImportJobList: [ListFpShotImportJobResponseBody.FpShotImportJobList]?

    public var nonExistIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fpShotImportJobList != nil {
            var tmp : [Any] = []
            for k in self.fpShotImportJobList! {
                tmp.append(k.toMap())
            }
            map["FpShotImportJobList"] = tmp
        }
        if self.nonExistIds != nil {
            map["NonExistIds"] = self.nonExistIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FpShotImportJobList") {
            var tmp : [ListFpShotImportJobResponseBody.FpShotImportJobList] = []
            for v in dict["FpShotImportJobList"] as! [Any] {
                var model = ListFpShotImportJobResponseBody.FpShotImportJobList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.fpShotImportJobList = tmp
        }
        if dict.keys.contains("NonExistIds") {
            self.nonExistIds = dict["NonExistIds"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListFpShotImportJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFpShotImportJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListFpShotImportJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListJobRequest : Tea.TeaModel {
    public var endOfJobCreatedTimeRange: String?

    public var maximumPageSize: Int64?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startOfJobCreatedTimeRange: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfJobCreatedTimeRange != nil {
            map["EndOfJobCreatedTimeRange"] = self.endOfJobCreatedTimeRange!
        }
        if self.maximumPageSize != nil {
            map["MaximumPageSize"] = self.maximumPageSize!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startOfJobCreatedTimeRange != nil {
            map["StartOfJobCreatedTimeRange"] = self.startOfJobCreatedTimeRange!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfJobCreatedTimeRange") {
            self.endOfJobCreatedTimeRange = dict["EndOfJobCreatedTimeRange"] as! String
        }
        if dict.keys.contains("MaximumPageSize") {
            self.maximumPageSize = dict["MaximumPageSize"] as! Int64
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartOfJobCreatedTimeRange") {
            self.startOfJobCreatedTimeRange = dict["StartOfJobCreatedTimeRange"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class ListJobResponseBody : Tea.TeaModel {
    public class JobList : Tea.TeaModel {
        public class Job : Tea.TeaModel {
            public class Input : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public class MNSMessageResult : Tea.TeaModel {
                public var errorCode: String?

                public var errorMessage: String?

                public var messageId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.messageId != nil {
                        map["MessageId"] = self.messageId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("MessageId") {
                        self.messageId = dict["MessageId"] as! String
                    }
                }
            }
            public class Output : Tea.TeaModel {
                public class Audio : Tea.TeaModel {
                    public class Volume : Tea.TeaModel {
                        public var level: String?

                        public var method: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.level != nil {
                                map["Level"] = self.level!
                            }
                            if self.method != nil {
                                map["Method"] = self.method!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Level") {
                                self.level = dict["Level"] as! String
                            }
                            if dict.keys.contains("Method") {
                                self.method = dict["Method"] as! String
                            }
                        }
                    }
                    public var bitrate: String?

                    public var channels: String?

                    public var codec: String?

                    public var profile: String?

                    public var qscale: String?

                    public var samplerate: String?

                    public var volume: ListJobResponseBody.JobList.Job.Output.Audio.Volume?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.volume?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        if self.codec != nil {
                            map["Codec"] = self.codec!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.qscale != nil {
                            map["Qscale"] = self.qscale!
                        }
                        if self.samplerate != nil {
                            map["Samplerate"] = self.samplerate!
                        }
                        if self.volume != nil {
                            map["Volume"] = self.volume?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Channels") {
                            self.channels = dict["Channels"] as! String
                        }
                        if dict.keys.contains("Codec") {
                            self.codec = dict["Codec"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Qscale") {
                            self.qscale = dict["Qscale"] as! String
                        }
                        if dict.keys.contains("Samplerate") {
                            self.samplerate = dict["Samplerate"] as! String
                        }
                        if dict.keys.contains("Volume") {
                            var model = ListJobResponseBody.JobList.Job.Output.Audio.Volume()
                            model.fromMap(dict["Volume"] as! [String: Any])
                            self.volume = model
                        }
                    }
                }
                public class Clip : Tea.TeaModel {
                    public class TimeSpan : Tea.TeaModel {
                        public var duration: String?

                        public var seek: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.seek != nil {
                                map["Seek"] = self.seek!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("Seek") {
                                self.seek = dict["Seek"] as! String
                            }
                        }
                    }
                    public var timeSpan: ListJobResponseBody.JobList.Job.Output.Clip.TimeSpan?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.timeSpan?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.timeSpan != nil {
                            map["TimeSpan"] = self.timeSpan?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TimeSpan") {
                            var model = ListJobResponseBody.JobList.Job.Output.Clip.TimeSpan()
                            model.fromMap(dict["TimeSpan"] as! [String: Any])
                            self.timeSpan = model
                        }
                    }
                }
                public class Container : Tea.TeaModel {
                    public var format: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var id: String?

                    public var key: String?

                    public var keyType: String?

                    public var keyUri: String?

                    public var skipCnt: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.keyType != nil {
                            map["KeyType"] = self.keyType!
                        }
                        if self.keyUri != nil {
                            map["KeyUri"] = self.keyUri!
                        }
                        if self.skipCnt != nil {
                            map["SkipCnt"] = self.skipCnt!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("KeyType") {
                            self.keyType = dict["KeyType"] as! String
                        }
                        if dict.keys.contains("KeyUri") {
                            self.keyUri = dict["KeyUri"] as! String
                        }
                        if dict.keys.contains("SkipCnt") {
                            self.skipCnt = dict["SkipCnt"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public class M3U8NonStandardSupport : Tea.TeaModel {
                    public class TS : Tea.TeaModel {
                        public var md5Support: Bool?

                        public var sizeSupport: Bool?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.md5Support != nil {
                                map["Md5Support"] = self.md5Support!
                            }
                            if self.sizeSupport != nil {
                                map["SizeSupport"] = self.sizeSupport!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Md5Support") {
                                self.md5Support = dict["Md5Support"] as! Bool
                            }
                            if dict.keys.contains("SizeSupport") {
                                self.sizeSupport = dict["SizeSupport"] as! Bool
                            }
                        }
                    }
                    public var TS: ListJobResponseBody.JobList.Job.Output.M3U8NonStandardSupport.TS?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.TS?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.TS != nil {
                            map["TS"] = self.TS?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TS") {
                            var model = ListJobResponseBody.JobList.Job.Output.M3U8NonStandardSupport.TS()
                            model.fromMap(dict["TS"] as! [String: Any])
                            self.TS = model
                        }
                    }
                }
                public class MergeList : Tea.TeaModel {
                    public class Merge : Tea.TeaModel {
                        public var duration: String?

                        public var mergeURL: String?

                        public var roleArn: String?

                        public var start: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.mergeURL != nil {
                                map["MergeURL"] = self.mergeURL!
                            }
                            if self.roleArn != nil {
                                map["RoleArn"] = self.roleArn!
                            }
                            if self.start != nil {
                                map["Start"] = self.start!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("MergeURL") {
                                self.mergeURL = dict["MergeURL"] as! String
                            }
                            if dict.keys.contains("RoleArn") {
                                self.roleArn = dict["RoleArn"] as! String
                            }
                            if dict.keys.contains("Start") {
                                self.start = dict["Start"] as! String
                            }
                        }
                    }
                    public var merge: [ListJobResponseBody.JobList.Job.Output.MergeList.Merge]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.merge != nil {
                            var tmp : [Any] = []
                            for k in self.merge! {
                                tmp.append(k.toMap())
                            }
                            map["Merge"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Merge") {
                            var tmp : [ListJobResponseBody.JobList.Job.Output.MergeList.Merge] = []
                            for v in dict["Merge"] as! [Any] {
                                var model = ListJobResponseBody.JobList.Job.Output.MergeList.Merge()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.merge = tmp
                        }
                    }
                }
                public class MuxConfig : Tea.TeaModel {
                    public class Gif : Tea.TeaModel {
                        public var ditherMode: String?

                        public var finalDelay: String?

                        public var isCustomPalette: String?

                        public var loop: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.ditherMode != nil {
                                map["DitherMode"] = self.ditherMode!
                            }
                            if self.finalDelay != nil {
                                map["FinalDelay"] = self.finalDelay!
                            }
                            if self.isCustomPalette != nil {
                                map["IsCustomPalette"] = self.isCustomPalette!
                            }
                            if self.loop != nil {
                                map["Loop"] = self.loop!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("DitherMode") {
                                self.ditherMode = dict["DitherMode"] as! String
                            }
                            if dict.keys.contains("FinalDelay") {
                                self.finalDelay = dict["FinalDelay"] as! String
                            }
                            if dict.keys.contains("IsCustomPalette") {
                                self.isCustomPalette = dict["IsCustomPalette"] as! String
                            }
                            if dict.keys.contains("Loop") {
                                self.loop = dict["Loop"] as! String
                            }
                        }
                    }
                    public class Segment : Tea.TeaModel {
                        public var duration: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                        }
                    }
                    public class Webp : Tea.TeaModel {
                        public var loop: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.loop != nil {
                                map["Loop"] = self.loop!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Loop") {
                                self.loop = dict["Loop"] as! String
                            }
                        }
                    }
                    public var gif: ListJobResponseBody.JobList.Job.Output.MuxConfig.Gif?

                    public var segment: ListJobResponseBody.JobList.Job.Output.MuxConfig.Segment?

                    public var webp: ListJobResponseBody.JobList.Job.Output.MuxConfig.Webp?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.gif?.validate()
                        try self.segment?.validate()
                        try self.webp?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.gif != nil {
                            map["Gif"] = self.gif?.toMap()
                        }
                        if self.segment != nil {
                            map["Segment"] = self.segment?.toMap()
                        }
                        if self.webp != nil {
                            map["Webp"] = self.webp?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Gif") {
                            var model = ListJobResponseBody.JobList.Job.Output.MuxConfig.Gif()
                            model.fromMap(dict["Gif"] as! [String: Any])
                            self.gif = model
                        }
                        if dict.keys.contains("Segment") {
                            var model = ListJobResponseBody.JobList.Job.Output.MuxConfig.Segment()
                            model.fromMap(dict["Segment"] as! [String: Any])
                            self.segment = model
                        }
                        if dict.keys.contains("Webp") {
                            var model = ListJobResponseBody.JobList.Job.Output.MuxConfig.Webp()
                            model.fromMap(dict["Webp"] as! [String: Any])
                            self.webp = model
                        }
                    }
                }
                public class OpeningList : Tea.TeaModel {
                    public class Opening : Tea.TeaModel {
                        public var height: String?

                        public var start: String?

                        public var width: String?

                        public var openUrl: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.start != nil {
                                map["Start"] = self.start!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            if self.openUrl != nil {
                                map["openUrl"] = self.openUrl!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("Start") {
                                self.start = dict["Start"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                            if dict.keys.contains("openUrl") {
                                self.openUrl = dict["openUrl"] as! String
                            }
                        }
                    }
                    public var opening: [ListJobResponseBody.JobList.Job.Output.OpeningList.Opening]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.opening != nil {
                            var tmp : [Any] = []
                            for k in self.opening! {
                                tmp.append(k.toMap())
                            }
                            map["Opening"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Opening") {
                            var tmp : [ListJobResponseBody.JobList.Job.Output.OpeningList.Opening] = []
                            for v in dict["Opening"] as! [Any] {
                                var model = ListJobResponseBody.JobList.Job.Output.OpeningList.Opening()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.opening = tmp
                        }
                    }
                }
                public class OutSubtitleList : Tea.TeaModel {
                    public class OutSubtitle : Tea.TeaModel {
                        public class OutSubtitleFile : Tea.TeaModel {
                            public var bucket: String?

                            public var location: String?

                            public var object: String?

                            public var roleArn: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bucket != nil {
                                    map["Bucket"] = self.bucket!
                                }
                                if self.location != nil {
                                    map["Location"] = self.location!
                                }
                                if self.object != nil {
                                    map["Object"] = self.object!
                                }
                                if self.roleArn != nil {
                                    map["RoleArn"] = self.roleArn!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bucket") {
                                    self.bucket = dict["Bucket"] as! String
                                }
                                if dict.keys.contains("Location") {
                                    self.location = dict["Location"] as! String
                                }
                                if dict.keys.contains("Object") {
                                    self.object = dict["Object"] as! String
                                }
                                if dict.keys.contains("RoleArn") {
                                    self.roleArn = dict["RoleArn"] as! String
                                }
                            }
                        }
                        public var map: String?

                        public var message: String?

                        public var outSubtitleFile: ListJobResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle.OutSubtitleFile?

                        public var success: Bool?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.outSubtitleFile?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.map != nil {
                                map["Map"] = self.map!
                            }
                            if self.message != nil {
                                map["Message"] = self.message!
                            }
                            if self.outSubtitleFile != nil {
                                map["OutSubtitleFile"] = self.outSubtitleFile?.toMap()
                            }
                            if self.success != nil {
                                map["Success"] = self.success!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Map") {
                                self.map = dict["Map"] as! String
                            }
                            if dict.keys.contains("Message") {
                                self.message = dict["Message"] as! String
                            }
                            if dict.keys.contains("OutSubtitleFile") {
                                var model = ListJobResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle.OutSubtitleFile()
                                model.fromMap(dict["OutSubtitleFile"] as! [String: Any])
                                self.outSubtitleFile = model
                            }
                            if dict.keys.contains("Success") {
                                self.success = dict["Success"] as! Bool
                            }
                        }
                    }
                    public var outSubtitle: [ListJobResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.outSubtitle != nil {
                            var tmp : [Any] = []
                            for k in self.outSubtitle! {
                                tmp.append(k.toMap())
                            }
                            map["OutSubtitle"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OutSubtitle") {
                            var tmp : [ListJobResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle] = []
                            for v in dict["OutSubtitle"] as! [Any] {
                                var model = ListJobResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.outSubtitle = tmp
                        }
                    }
                }
                public class OutputFile : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public var roleArn: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        if self.roleArn != nil {
                            map["RoleArn"] = self.roleArn!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                        if dict.keys.contains("RoleArn") {
                            self.roleArn = dict["RoleArn"] as! String
                        }
                    }
                }
                public class Properties : Tea.TeaModel {
                    public class Format : Tea.TeaModel {
                        public var bitrate: String?

                        public var duration: String?

                        public var formatLongName: String?

                        public var formatName: String?

                        public var numPrograms: String?

                        public var numStreams: String?

                        public var size: String?

                        public var startTime: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.formatLongName != nil {
                                map["FormatLongName"] = self.formatLongName!
                            }
                            if self.formatName != nil {
                                map["FormatName"] = self.formatName!
                            }
                            if self.numPrograms != nil {
                                map["NumPrograms"] = self.numPrograms!
                            }
                            if self.numStreams != nil {
                                map["NumStreams"] = self.numStreams!
                            }
                            if self.size != nil {
                                map["Size"] = self.size!
                            }
                            if self.startTime != nil {
                                map["StartTime"] = self.startTime!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("FormatLongName") {
                                self.formatLongName = dict["FormatLongName"] as! String
                            }
                            if dict.keys.contains("FormatName") {
                                self.formatName = dict["FormatName"] as! String
                            }
                            if dict.keys.contains("NumPrograms") {
                                self.numPrograms = dict["NumPrograms"] as! String
                            }
                            if dict.keys.contains("NumStreams") {
                                self.numStreams = dict["NumStreams"] as! String
                            }
                            if dict.keys.contains("Size") {
                                self.size = dict["Size"] as! String
                            }
                            if dict.keys.contains("StartTime") {
                                self.startTime = dict["StartTime"] as! String
                            }
                        }
                    }
                    public class Streams : Tea.TeaModel {
                        public class AudioStreamList : Tea.TeaModel {
                            public class AudioStream : Tea.TeaModel {
                                public var bitrate: String?

                                public var channelLayout: String?

                                public var channels: String?

                                public var codecLongName: String?

                                public var codecName: String?

                                public var codecTag: String?

                                public var codecTagString: String?

                                public var codecTimeBase: String?

                                public var duration: String?

                                public var index: String?

                                public var lang: String?

                                public var numFrames: String?

                                public var sampleFmt: String?

                                public var samplerate: String?

                                public var startTime: String?

                                public var timebase: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.bitrate != nil {
                                        map["Bitrate"] = self.bitrate!
                                    }
                                    if self.channelLayout != nil {
                                        map["ChannelLayout"] = self.channelLayout!
                                    }
                                    if self.channels != nil {
                                        map["Channels"] = self.channels!
                                    }
                                    if self.codecLongName != nil {
                                        map["CodecLongName"] = self.codecLongName!
                                    }
                                    if self.codecName != nil {
                                        map["CodecName"] = self.codecName!
                                    }
                                    if self.codecTag != nil {
                                        map["CodecTag"] = self.codecTag!
                                    }
                                    if self.codecTagString != nil {
                                        map["CodecTagString"] = self.codecTagString!
                                    }
                                    if self.codecTimeBase != nil {
                                        map["CodecTimeBase"] = self.codecTimeBase!
                                    }
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.index != nil {
                                        map["Index"] = self.index!
                                    }
                                    if self.lang != nil {
                                        map["Lang"] = self.lang!
                                    }
                                    if self.numFrames != nil {
                                        map["NumFrames"] = self.numFrames!
                                    }
                                    if self.sampleFmt != nil {
                                        map["SampleFmt"] = self.sampleFmt!
                                    }
                                    if self.samplerate != nil {
                                        map["Samplerate"] = self.samplerate!
                                    }
                                    if self.startTime != nil {
                                        map["StartTime"] = self.startTime!
                                    }
                                    if self.timebase != nil {
                                        map["Timebase"] = self.timebase!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Bitrate") {
                                        self.bitrate = dict["Bitrate"] as! String
                                    }
                                    if dict.keys.contains("ChannelLayout") {
                                        self.channelLayout = dict["ChannelLayout"] as! String
                                    }
                                    if dict.keys.contains("Channels") {
                                        self.channels = dict["Channels"] as! String
                                    }
                                    if dict.keys.contains("CodecLongName") {
                                        self.codecLongName = dict["CodecLongName"] as! String
                                    }
                                    if dict.keys.contains("CodecName") {
                                        self.codecName = dict["CodecName"] as! String
                                    }
                                    if dict.keys.contains("CodecTag") {
                                        self.codecTag = dict["CodecTag"] as! String
                                    }
                                    if dict.keys.contains("CodecTagString") {
                                        self.codecTagString = dict["CodecTagString"] as! String
                                    }
                                    if dict.keys.contains("CodecTimeBase") {
                                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                                    }
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("Index") {
                                        self.index = dict["Index"] as! String
                                    }
                                    if dict.keys.contains("Lang") {
                                        self.lang = dict["Lang"] as! String
                                    }
                                    if dict.keys.contains("NumFrames") {
                                        self.numFrames = dict["NumFrames"] as! String
                                    }
                                    if dict.keys.contains("SampleFmt") {
                                        self.sampleFmt = dict["SampleFmt"] as! String
                                    }
                                    if dict.keys.contains("Samplerate") {
                                        self.samplerate = dict["Samplerate"] as! String
                                    }
                                    if dict.keys.contains("StartTime") {
                                        self.startTime = dict["StartTime"] as! String
                                    }
                                    if dict.keys.contains("Timebase") {
                                        self.timebase = dict["Timebase"] as! String
                                    }
                                }
                            }
                            public var audioStream: [ListJobResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList.AudioStream]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.audioStream != nil {
                                    var tmp : [Any] = []
                                    for k in self.audioStream! {
                                        tmp.append(k.toMap())
                                    }
                                    map["AudioStream"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AudioStream") {
                                    var tmp : [ListJobResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList.AudioStream] = []
                                    for v in dict["AudioStream"] as! [Any] {
                                        var model = ListJobResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList.AudioStream()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.audioStream = tmp
                                }
                            }
                        }
                        public class SubtitleStreamList : Tea.TeaModel {
                            public class SubtitleStream : Tea.TeaModel {
                                public var index: String?

                                public var lang: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.index != nil {
                                        map["Index"] = self.index!
                                    }
                                    if self.lang != nil {
                                        map["Lang"] = self.lang!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Index") {
                                        self.index = dict["Index"] as! String
                                    }
                                    if dict.keys.contains("Lang") {
                                        self.lang = dict["Lang"] as! String
                                    }
                                }
                            }
                            public var subtitleStream: [ListJobResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList.SubtitleStream]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.subtitleStream != nil {
                                    var tmp : [Any] = []
                                    for k in self.subtitleStream! {
                                        tmp.append(k.toMap())
                                    }
                                    map["SubtitleStream"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("SubtitleStream") {
                                    var tmp : [ListJobResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList.SubtitleStream] = []
                                    for v in dict["SubtitleStream"] as! [Any] {
                                        var model = ListJobResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList.SubtitleStream()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.subtitleStream = tmp
                                }
                            }
                        }
                        public class VideoStreamList : Tea.TeaModel {
                            public class VideoStream : Tea.TeaModel {
                                public class NetworkCost : Tea.TeaModel {
                                    public var avgBitrate: String?

                                    public var costBandwidth: String?

                                    public var preloadTime: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.avgBitrate != nil {
                                            map["AvgBitrate"] = self.avgBitrate!
                                        }
                                        if self.costBandwidth != nil {
                                            map["CostBandwidth"] = self.costBandwidth!
                                        }
                                        if self.preloadTime != nil {
                                            map["PreloadTime"] = self.preloadTime!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("AvgBitrate") {
                                            self.avgBitrate = dict["AvgBitrate"] as! String
                                        }
                                        if dict.keys.contains("CostBandwidth") {
                                            self.costBandwidth = dict["CostBandwidth"] as! String
                                        }
                                        if dict.keys.contains("PreloadTime") {
                                            self.preloadTime = dict["PreloadTime"] as! String
                                        }
                                    }
                                }
                                public var avgFPS: String?

                                public var bitrate: String?

                                public var codecLongName: String?

                                public var codecName: String?

                                public var codecTag: String?

                                public var codecTagString: String?

                                public var codecTimeBase: String?

                                public var dar: String?

                                public var duration: String?

                                public var fps: String?

                                public var hasBFrames: String?

                                public var height: String?

                                public var index: String?

                                public var lang: String?

                                public var level: String?

                                public var networkCost: ListJobResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream.NetworkCost?

                                public var numFrames: String?

                                public var pixFmt: String?

                                public var profile: String?

                                public var sar: String?

                                public var startTime: String?

                                public var timebase: String?

                                public var width: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                    try self.networkCost?.validate()
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.avgFPS != nil {
                                        map["AvgFPS"] = self.avgFPS!
                                    }
                                    if self.bitrate != nil {
                                        map["Bitrate"] = self.bitrate!
                                    }
                                    if self.codecLongName != nil {
                                        map["CodecLongName"] = self.codecLongName!
                                    }
                                    if self.codecName != nil {
                                        map["CodecName"] = self.codecName!
                                    }
                                    if self.codecTag != nil {
                                        map["CodecTag"] = self.codecTag!
                                    }
                                    if self.codecTagString != nil {
                                        map["CodecTagString"] = self.codecTagString!
                                    }
                                    if self.codecTimeBase != nil {
                                        map["CodecTimeBase"] = self.codecTimeBase!
                                    }
                                    if self.dar != nil {
                                        map["Dar"] = self.dar!
                                    }
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.fps != nil {
                                        map["Fps"] = self.fps!
                                    }
                                    if self.hasBFrames != nil {
                                        map["HasBFrames"] = self.hasBFrames!
                                    }
                                    if self.height != nil {
                                        map["Height"] = self.height!
                                    }
                                    if self.index != nil {
                                        map["Index"] = self.index!
                                    }
                                    if self.lang != nil {
                                        map["Lang"] = self.lang!
                                    }
                                    if self.level != nil {
                                        map["Level"] = self.level!
                                    }
                                    if self.networkCost != nil {
                                        map["NetworkCost"] = self.networkCost?.toMap()
                                    }
                                    if self.numFrames != nil {
                                        map["NumFrames"] = self.numFrames!
                                    }
                                    if self.pixFmt != nil {
                                        map["PixFmt"] = self.pixFmt!
                                    }
                                    if self.profile != nil {
                                        map["Profile"] = self.profile!
                                    }
                                    if self.sar != nil {
                                        map["Sar"] = self.sar!
                                    }
                                    if self.startTime != nil {
                                        map["StartTime"] = self.startTime!
                                    }
                                    if self.timebase != nil {
                                        map["Timebase"] = self.timebase!
                                    }
                                    if self.width != nil {
                                        map["Width"] = self.width!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("AvgFPS") {
                                        self.avgFPS = dict["AvgFPS"] as! String
                                    }
                                    if dict.keys.contains("Bitrate") {
                                        self.bitrate = dict["Bitrate"] as! String
                                    }
                                    if dict.keys.contains("CodecLongName") {
                                        self.codecLongName = dict["CodecLongName"] as! String
                                    }
                                    if dict.keys.contains("CodecName") {
                                        self.codecName = dict["CodecName"] as! String
                                    }
                                    if dict.keys.contains("CodecTag") {
                                        self.codecTag = dict["CodecTag"] as! String
                                    }
                                    if dict.keys.contains("CodecTagString") {
                                        self.codecTagString = dict["CodecTagString"] as! String
                                    }
                                    if dict.keys.contains("CodecTimeBase") {
                                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                                    }
                                    if dict.keys.contains("Dar") {
                                        self.dar = dict["Dar"] as! String
                                    }
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("Fps") {
                                        self.fps = dict["Fps"] as! String
                                    }
                                    if dict.keys.contains("HasBFrames") {
                                        self.hasBFrames = dict["HasBFrames"] as! String
                                    }
                                    if dict.keys.contains("Height") {
                                        self.height = dict["Height"] as! String
                                    }
                                    if dict.keys.contains("Index") {
                                        self.index = dict["Index"] as! String
                                    }
                                    if dict.keys.contains("Lang") {
                                        self.lang = dict["Lang"] as! String
                                    }
                                    if dict.keys.contains("Level") {
                                        self.level = dict["Level"] as! String
                                    }
                                    if dict.keys.contains("NetworkCost") {
                                        var model = ListJobResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream.NetworkCost()
                                        model.fromMap(dict["NetworkCost"] as! [String: Any])
                                        self.networkCost = model
                                    }
                                    if dict.keys.contains("NumFrames") {
                                        self.numFrames = dict["NumFrames"] as! String
                                    }
                                    if dict.keys.contains("PixFmt") {
                                        self.pixFmt = dict["PixFmt"] as! String
                                    }
                                    if dict.keys.contains("Profile") {
                                        self.profile = dict["Profile"] as! String
                                    }
                                    if dict.keys.contains("Sar") {
                                        self.sar = dict["Sar"] as! String
                                    }
                                    if dict.keys.contains("StartTime") {
                                        self.startTime = dict["StartTime"] as! String
                                    }
                                    if dict.keys.contains("Timebase") {
                                        self.timebase = dict["Timebase"] as! String
                                    }
                                    if dict.keys.contains("Width") {
                                        self.width = dict["Width"] as! String
                                    }
                                }
                            }
                            public var videoStream: [ListJobResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.videoStream != nil {
                                    var tmp : [Any] = []
                                    for k in self.videoStream! {
                                        tmp.append(k.toMap())
                                    }
                                    map["VideoStream"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("VideoStream") {
                                    var tmp : [ListJobResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream] = []
                                    for v in dict["VideoStream"] as! [Any] {
                                        var model = ListJobResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.videoStream = tmp
                                }
                            }
                        }
                        public var audioStreamList: ListJobResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList?

                        public var subtitleStreamList: ListJobResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList?

                        public var videoStreamList: ListJobResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audioStreamList?.validate()
                            try self.subtitleStreamList?.validate()
                            try self.videoStreamList?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audioStreamList != nil {
                                map["AudioStreamList"] = self.audioStreamList?.toMap()
                            }
                            if self.subtitleStreamList != nil {
                                map["SubtitleStreamList"] = self.subtitleStreamList?.toMap()
                            }
                            if self.videoStreamList != nil {
                                map["VideoStreamList"] = self.videoStreamList?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AudioStreamList") {
                                var model = ListJobResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList()
                                model.fromMap(dict["AudioStreamList"] as! [String: Any])
                                self.audioStreamList = model
                            }
                            if dict.keys.contains("SubtitleStreamList") {
                                var model = ListJobResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList()
                                model.fromMap(dict["SubtitleStreamList"] as! [String: Any])
                                self.subtitleStreamList = model
                            }
                            if dict.keys.contains("VideoStreamList") {
                                var model = ListJobResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList()
                                model.fromMap(dict["VideoStreamList"] as! [String: Any])
                                self.videoStreamList = model
                            }
                        }
                    }
                    public var bitrate: String?

                    public var duration: String?

                    public var fileFormat: String?

                    public var fileSize: String?

                    public var format: ListJobResponseBody.JobList.Job.Output.Properties.Format?

                    public var fps: String?

                    public var height: String?

                    public var streams: ListJobResponseBody.JobList.Job.Output.Properties.Streams?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.format?.validate()
                        try self.streams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fileFormat != nil {
                            map["FileFormat"] = self.fileFormat!
                        }
                        if self.fileSize != nil {
                            map["FileSize"] = self.fileSize!
                        }
                        if self.format != nil {
                            map["Format"] = self.format?.toMap()
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.streams != nil {
                            map["Streams"] = self.streams?.toMap()
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("FileFormat") {
                            self.fileFormat = dict["FileFormat"] as! String
                        }
                        if dict.keys.contains("FileSize") {
                            self.fileSize = dict["FileSize"] as! String
                        }
                        if dict.keys.contains("Format") {
                            var model = ListJobResponseBody.JobList.Job.Output.Properties.Format()
                            model.fromMap(dict["Format"] as! [String: Any])
                            self.format = model
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("Streams") {
                            var model = ListJobResponseBody.JobList.Job.Output.Properties.Streams()
                            model.fromMap(dict["Streams"] as! [String: Any])
                            self.streams = model
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public class SubtitleConfig : Tea.TeaModel {
                    public class ExtSubtitleList : Tea.TeaModel {
                        public class ExtSubtitle : Tea.TeaModel {
                            public class Input : Tea.TeaModel {
                                public var bucket: String?

                                public var location: String?

                                public var object: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.bucket != nil {
                                        map["Bucket"] = self.bucket!
                                    }
                                    if self.location != nil {
                                        map["Location"] = self.location!
                                    }
                                    if self.object != nil {
                                        map["Object"] = self.object!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Bucket") {
                                        self.bucket = dict["Bucket"] as! String
                                    }
                                    if dict.keys.contains("Location") {
                                        self.location = dict["Location"] as! String
                                    }
                                    if dict.keys.contains("Object") {
                                        self.object = dict["Object"] as! String
                                    }
                                }
                            }
                            public var charEnc: String?

                            public var fontName: String?

                            public var input: ListJobResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle.Input?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.input?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.charEnc != nil {
                                    map["CharEnc"] = self.charEnc!
                                }
                                if self.fontName != nil {
                                    map["FontName"] = self.fontName!
                                }
                                if self.input != nil {
                                    map["Input"] = self.input?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("CharEnc") {
                                    self.charEnc = dict["CharEnc"] as! String
                                }
                                if dict.keys.contains("FontName") {
                                    self.fontName = dict["FontName"] as! String
                                }
                                if dict.keys.contains("Input") {
                                    var model = ListJobResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle.Input()
                                    model.fromMap(dict["Input"] as! [String: Any])
                                    self.input = model
                                }
                            }
                        }
                        public var extSubtitle: [ListJobResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.extSubtitle != nil {
                                var tmp : [Any] = []
                                for k in self.extSubtitle! {
                                    tmp.append(k.toMap())
                                }
                                map["ExtSubtitle"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ExtSubtitle") {
                                var tmp : [ListJobResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle] = []
                                for v in dict["ExtSubtitle"] as! [Any] {
                                    var model = ListJobResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.extSubtitle = tmp
                            }
                        }
                    }
                    public class SubtitleList : Tea.TeaModel {
                        public class Subtitle : Tea.TeaModel {
                            public var map: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.map != nil {
                                    map["Map"] = self.map!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Map") {
                                    self.map = dict["Map"] as! String
                                }
                            }
                        }
                        public var subtitle: [ListJobResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList.Subtitle]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.subtitle != nil {
                                var tmp : [Any] = []
                                for k in self.subtitle! {
                                    tmp.append(k.toMap())
                                }
                                map["Subtitle"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Subtitle") {
                                var tmp : [ListJobResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList.Subtitle] = []
                                for v in dict["Subtitle"] as! [Any] {
                                    var model = ListJobResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList.Subtitle()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.subtitle = tmp
                            }
                        }
                    }
                    public var extSubtitleList: ListJobResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList?

                    public var subtitleList: ListJobResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.extSubtitleList?.validate()
                        try self.subtitleList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.extSubtitleList != nil {
                            map["ExtSubtitleList"] = self.extSubtitleList?.toMap()
                        }
                        if self.subtitleList != nil {
                            map["SubtitleList"] = self.subtitleList?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ExtSubtitleList") {
                            var model = ListJobResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList()
                            model.fromMap(dict["ExtSubtitleList"] as! [String: Any])
                            self.extSubtitleList = model
                        }
                        if dict.keys.contains("SubtitleList") {
                            var model = ListJobResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList()
                            model.fromMap(dict["SubtitleList"] as! [String: Any])
                            self.subtitleList = model
                        }
                    }
                }
                public class SuperReso : Tea.TeaModel {
                    public var isHalfSample: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.isHalfSample != nil {
                            map["IsHalfSample"] = self.isHalfSample!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IsHalfSample") {
                            self.isHalfSample = dict["IsHalfSample"] as! String
                        }
                    }
                }
                public class TailSlateList : Tea.TeaModel {
                    public class TailSlate : Tea.TeaModel {
                        public var bgColor: String?

                        public var blendDuration: String?

                        public var height: String?

                        public var isMergeAudio: Bool?

                        public var start: String?

                        public var tailUrl: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bgColor != nil {
                                map["BgColor"] = self.bgColor!
                            }
                            if self.blendDuration != nil {
                                map["BlendDuration"] = self.blendDuration!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.isMergeAudio != nil {
                                map["IsMergeAudio"] = self.isMergeAudio!
                            }
                            if self.start != nil {
                                map["Start"] = self.start!
                            }
                            if self.tailUrl != nil {
                                map["TailUrl"] = self.tailUrl!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("BgColor") {
                                self.bgColor = dict["BgColor"] as! String
                            }
                            if dict.keys.contains("BlendDuration") {
                                self.blendDuration = dict["BlendDuration"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("IsMergeAudio") {
                                self.isMergeAudio = dict["IsMergeAudio"] as! Bool
                            }
                            if dict.keys.contains("Start") {
                                self.start = dict["Start"] as! String
                            }
                            if dict.keys.contains("TailUrl") {
                                self.tailUrl = dict["TailUrl"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var tailSlate: [ListJobResponseBody.JobList.Job.Output.TailSlateList.TailSlate]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tailSlate != nil {
                            var tmp : [Any] = []
                            for k in self.tailSlate! {
                                tmp.append(k.toMap())
                            }
                            map["TailSlate"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TailSlate") {
                            var tmp : [ListJobResponseBody.JobList.Job.Output.TailSlateList.TailSlate] = []
                            for v in dict["TailSlate"] as! [Any] {
                                var model = ListJobResponseBody.JobList.Job.Output.TailSlateList.TailSlate()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.tailSlate = tmp
                        }
                    }
                }
                public class TransConfig : Tea.TeaModel {
                    public var adjDarMethod: String?

                    public var isCheckAudioBitrate: String?

                    public var isCheckAudioBitrateFail: String?

                    public var isCheckReso: String?

                    public var isCheckResoFail: String?

                    public var isCheckVideoBitrate: String?

                    public var isCheckVideoBitrateFail: String?

                    public var transMode: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.adjDarMethod != nil {
                            map["AdjDarMethod"] = self.adjDarMethod!
                        }
                        if self.isCheckAudioBitrate != nil {
                            map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                        }
                        if self.isCheckAudioBitrateFail != nil {
                            map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                        }
                        if self.isCheckReso != nil {
                            map["IsCheckReso"] = self.isCheckReso!
                        }
                        if self.isCheckResoFail != nil {
                            map["IsCheckResoFail"] = self.isCheckResoFail!
                        }
                        if self.isCheckVideoBitrate != nil {
                            map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                        }
                        if self.isCheckVideoBitrateFail != nil {
                            map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                        }
                        if self.transMode != nil {
                            map["TransMode"] = self.transMode!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AdjDarMethod") {
                            self.adjDarMethod = dict["AdjDarMethod"] as! String
                        }
                        if dict.keys.contains("IsCheckAudioBitrate") {
                            self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                        }
                        if dict.keys.contains("IsCheckAudioBitrateFail") {
                            self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                        }
                        if dict.keys.contains("IsCheckReso") {
                            self.isCheckReso = dict["IsCheckReso"] as! String
                        }
                        if dict.keys.contains("IsCheckResoFail") {
                            self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                        }
                        if dict.keys.contains("IsCheckVideoBitrate") {
                            self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                        }
                        if dict.keys.contains("IsCheckVideoBitrateFail") {
                            self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                        }
                        if dict.keys.contains("TransMode") {
                            self.transMode = dict["TransMode"] as! String
                        }
                    }
                }
                public class Video : Tea.TeaModel {
                    public class BitrateBnd : Tea.TeaModel {
                        public var max: String?

                        public var min: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.max != nil {
                                map["Max"] = self.max!
                            }
                            if self.min != nil {
                                map["Min"] = self.min!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Max") {
                                self.max = dict["Max"] as! String
                            }
                            if dict.keys.contains("Min") {
                                self.min = dict["Min"] as! String
                            }
                        }
                    }
                    public var bitrate: String?

                    public var bitrateBnd: ListJobResponseBody.JobList.Job.Output.Video.BitrateBnd?

                    public var bufsize: String?

                    public var codec: String?

                    public var crf: String?

                    public var crop: String?

                    public var degrain: String?

                    public var fps: String?

                    public var gop: String?

                    public var height: String?

                    public var maxFps: String?

                    public var maxrate: String?

                    public var pad: String?

                    public var pixFmt: String?

                    public var preset: String?

                    public var profile: String?

                    public var qscale: String?

                    public var resoPriority: String?

                    public var scanMode: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.bitrateBnd?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.bitrateBnd != nil {
                            map["BitrateBnd"] = self.bitrateBnd?.toMap()
                        }
                        if self.bufsize != nil {
                            map["Bufsize"] = self.bufsize!
                        }
                        if self.codec != nil {
                            map["Codec"] = self.codec!
                        }
                        if self.crf != nil {
                            map["Crf"] = self.crf!
                        }
                        if self.crop != nil {
                            map["Crop"] = self.crop!
                        }
                        if self.degrain != nil {
                            map["Degrain"] = self.degrain!
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.gop != nil {
                            map["Gop"] = self.gop!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.maxFps != nil {
                            map["MaxFps"] = self.maxFps!
                        }
                        if self.maxrate != nil {
                            map["Maxrate"] = self.maxrate!
                        }
                        if self.pad != nil {
                            map["Pad"] = self.pad!
                        }
                        if self.pixFmt != nil {
                            map["PixFmt"] = self.pixFmt!
                        }
                        if self.preset != nil {
                            map["Preset"] = self.preset!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.qscale != nil {
                            map["Qscale"] = self.qscale!
                        }
                        if self.resoPriority != nil {
                            map["ResoPriority"] = self.resoPriority!
                        }
                        if self.scanMode != nil {
                            map["ScanMode"] = self.scanMode!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("BitrateBnd") {
                            var model = ListJobResponseBody.JobList.Job.Output.Video.BitrateBnd()
                            model.fromMap(dict["BitrateBnd"] as! [String: Any])
                            self.bitrateBnd = model
                        }
                        if dict.keys.contains("Bufsize") {
                            self.bufsize = dict["Bufsize"] as! String
                        }
                        if dict.keys.contains("Codec") {
                            self.codec = dict["Codec"] as! String
                        }
                        if dict.keys.contains("Crf") {
                            self.crf = dict["Crf"] as! String
                        }
                        if dict.keys.contains("Crop") {
                            self.crop = dict["Crop"] as! String
                        }
                        if dict.keys.contains("Degrain") {
                            self.degrain = dict["Degrain"] as! String
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Gop") {
                            self.gop = dict["Gop"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("MaxFps") {
                            self.maxFps = dict["MaxFps"] as! String
                        }
                        if dict.keys.contains("Maxrate") {
                            self.maxrate = dict["Maxrate"] as! String
                        }
                        if dict.keys.contains("Pad") {
                            self.pad = dict["Pad"] as! String
                        }
                        if dict.keys.contains("PixFmt") {
                            self.pixFmt = dict["PixFmt"] as! String
                        }
                        if dict.keys.contains("Preset") {
                            self.preset = dict["Preset"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Qscale") {
                            self.qscale = dict["Qscale"] as! String
                        }
                        if dict.keys.contains("ResoPriority") {
                            self.resoPriority = dict["ResoPriority"] as! String
                        }
                        if dict.keys.contains("ScanMode") {
                            self.scanMode = dict["ScanMode"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public class WaterMarkList : Tea.TeaModel {
                    public class WaterMark : Tea.TeaModel {
                        public class InputFile : Tea.TeaModel {
                            public var bucket: String?

                            public var location: String?

                            public var object: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bucket != nil {
                                    map["Bucket"] = self.bucket!
                                }
                                if self.location != nil {
                                    map["Location"] = self.location!
                                }
                                if self.object != nil {
                                    map["Object"] = self.object!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bucket") {
                                    self.bucket = dict["Bucket"] as! String
                                }
                                if dict.keys.contains("Location") {
                                    self.location = dict["Location"] as! String
                                }
                                if dict.keys.contains("Object") {
                                    self.object = dict["Object"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var height: String?

                        public var inputFile: ListJobResponseBody.JobList.Job.Output.WaterMarkList.WaterMark.InputFile?

                        public var referPos: String?

                        public var type: String?

                        public var waterMarkTemplateId: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.inputFile?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.inputFile != nil {
                                map["InputFile"] = self.inputFile?.toMap()
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            if self.waterMarkTemplateId != nil {
                                map["WaterMarkTemplateId"] = self.waterMarkTemplateId!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("InputFile") {
                                var model = ListJobResponseBody.JobList.Job.Output.WaterMarkList.WaterMark.InputFile()
                                model.fromMap(dict["InputFile"] as! [String: Any])
                                self.inputFile = model
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Type") {
                                self.type = dict["Type"] as! String
                            }
                            if dict.keys.contains("WaterMarkTemplateId") {
                                self.waterMarkTemplateId = dict["WaterMarkTemplateId"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var waterMark: [ListJobResponseBody.JobList.Job.Output.WaterMarkList.WaterMark]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.waterMark != nil {
                            var tmp : [Any] = []
                            for k in self.waterMark! {
                                tmp.append(k.toMap())
                            }
                            map["WaterMark"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("WaterMark") {
                            var tmp : [ListJobResponseBody.JobList.Job.Output.WaterMarkList.WaterMark] = []
                            for v in dict["WaterMark"] as! [Any] {
                                var model = ListJobResponseBody.JobList.Job.Output.WaterMarkList.WaterMark()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.waterMark = tmp
                        }
                    }
                }
                public var audio: ListJobResponseBody.JobList.Job.Output.Audio?

                public var audioStreamMap: String?

                public var clip: ListJobResponseBody.JobList.Job.Output.Clip?

                public var container: ListJobResponseBody.JobList.Job.Output.Container?

                public var deWatermark: String?

                public var encryption: ListJobResponseBody.JobList.Job.Output.Encryption?

                public var m3U8NonStandardSupport: ListJobResponseBody.JobList.Job.Output.M3U8NonStandardSupport?

                public var mergeConfigUrl: String?

                public var mergeList: ListJobResponseBody.JobList.Job.Output.MergeList?

                public var muxConfig: ListJobResponseBody.JobList.Job.Output.MuxConfig?

                public var openingList: ListJobResponseBody.JobList.Job.Output.OpeningList?

                public var outSubtitleList: ListJobResponseBody.JobList.Job.Output.OutSubtitleList?

                public var outputFile: ListJobResponseBody.JobList.Job.Output.OutputFile?

                public var priority: String?

                public var properties: ListJobResponseBody.JobList.Job.Output.Properties?

                public var rotate: String?

                public var subtitleConfig: ListJobResponseBody.JobList.Job.Output.SubtitleConfig?

                public var superReso: ListJobResponseBody.JobList.Job.Output.SuperReso?

                public var tailSlateList: ListJobResponseBody.JobList.Job.Output.TailSlateList?

                public var templateId: String?

                public var transConfig: ListJobResponseBody.JobList.Job.Output.TransConfig?

                public var userData: String?

                public var video: ListJobResponseBody.JobList.Job.Output.Video?

                public var videoStreamMap: String?

                public var waterMarkConfigUrl: String?

                public var waterMarkList: ListJobResponseBody.JobList.Job.Output.WaterMarkList?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.audio?.validate()
                    try self.clip?.validate()
                    try self.container?.validate()
                    try self.encryption?.validate()
                    try self.m3U8NonStandardSupport?.validate()
                    try self.mergeList?.validate()
                    try self.muxConfig?.validate()
                    try self.openingList?.validate()
                    try self.outSubtitleList?.validate()
                    try self.outputFile?.validate()
                    try self.properties?.validate()
                    try self.subtitleConfig?.validate()
                    try self.superReso?.validate()
                    try self.tailSlateList?.validate()
                    try self.transConfig?.validate()
                    try self.video?.validate()
                    try self.waterMarkList?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audio != nil {
                        map["Audio"] = self.audio?.toMap()
                    }
                    if self.audioStreamMap != nil {
                        map["AudioStreamMap"] = self.audioStreamMap!
                    }
                    if self.clip != nil {
                        map["Clip"] = self.clip?.toMap()
                    }
                    if self.container != nil {
                        map["Container"] = self.container?.toMap()
                    }
                    if self.deWatermark != nil {
                        map["DeWatermark"] = self.deWatermark!
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.m3U8NonStandardSupport != nil {
                        map["M3U8NonStandardSupport"] = self.m3U8NonStandardSupport?.toMap()
                    }
                    if self.mergeConfigUrl != nil {
                        map["MergeConfigUrl"] = self.mergeConfigUrl!
                    }
                    if self.mergeList != nil {
                        map["MergeList"] = self.mergeList?.toMap()
                    }
                    if self.muxConfig != nil {
                        map["MuxConfig"] = self.muxConfig?.toMap()
                    }
                    if self.openingList != nil {
                        map["OpeningList"] = self.openingList?.toMap()
                    }
                    if self.outSubtitleList != nil {
                        map["OutSubtitleList"] = self.outSubtitleList?.toMap()
                    }
                    if self.outputFile != nil {
                        map["OutputFile"] = self.outputFile?.toMap()
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    if self.properties != nil {
                        map["Properties"] = self.properties?.toMap()
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.subtitleConfig != nil {
                        map["SubtitleConfig"] = self.subtitleConfig?.toMap()
                    }
                    if self.superReso != nil {
                        map["SuperReso"] = self.superReso?.toMap()
                    }
                    if self.tailSlateList != nil {
                        map["TailSlateList"] = self.tailSlateList?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    if self.transConfig != nil {
                        map["TransConfig"] = self.transConfig?.toMap()
                    }
                    if self.userData != nil {
                        map["UserData"] = self.userData!
                    }
                    if self.video != nil {
                        map["Video"] = self.video?.toMap()
                    }
                    if self.videoStreamMap != nil {
                        map["VideoStreamMap"] = self.videoStreamMap!
                    }
                    if self.waterMarkConfigUrl != nil {
                        map["WaterMarkConfigUrl"] = self.waterMarkConfigUrl!
                    }
                    if self.waterMarkList != nil {
                        map["WaterMarkList"] = self.waterMarkList?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Audio") {
                        var model = ListJobResponseBody.JobList.Job.Output.Audio()
                        model.fromMap(dict["Audio"] as! [String: Any])
                        self.audio = model
                    }
                    if dict.keys.contains("AudioStreamMap") {
                        self.audioStreamMap = dict["AudioStreamMap"] as! String
                    }
                    if dict.keys.contains("Clip") {
                        var model = ListJobResponseBody.JobList.Job.Output.Clip()
                        model.fromMap(dict["Clip"] as! [String: Any])
                        self.clip = model
                    }
                    if dict.keys.contains("Container") {
                        var model = ListJobResponseBody.JobList.Job.Output.Container()
                        model.fromMap(dict["Container"] as! [String: Any])
                        self.container = model
                    }
                    if dict.keys.contains("DeWatermark") {
                        self.deWatermark = dict["DeWatermark"] as! String
                    }
                    if dict.keys.contains("Encryption") {
                        var model = ListJobResponseBody.JobList.Job.Output.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("M3U8NonStandardSupport") {
                        var model = ListJobResponseBody.JobList.Job.Output.M3U8NonStandardSupport()
                        model.fromMap(dict["M3U8NonStandardSupport"] as! [String: Any])
                        self.m3U8NonStandardSupport = model
                    }
                    if dict.keys.contains("MergeConfigUrl") {
                        self.mergeConfigUrl = dict["MergeConfigUrl"] as! String
                    }
                    if dict.keys.contains("MergeList") {
                        var model = ListJobResponseBody.JobList.Job.Output.MergeList()
                        model.fromMap(dict["MergeList"] as! [String: Any])
                        self.mergeList = model
                    }
                    if dict.keys.contains("MuxConfig") {
                        var model = ListJobResponseBody.JobList.Job.Output.MuxConfig()
                        model.fromMap(dict["MuxConfig"] as! [String: Any])
                        self.muxConfig = model
                    }
                    if dict.keys.contains("OpeningList") {
                        var model = ListJobResponseBody.JobList.Job.Output.OpeningList()
                        model.fromMap(dict["OpeningList"] as! [String: Any])
                        self.openingList = model
                    }
                    if dict.keys.contains("OutSubtitleList") {
                        var model = ListJobResponseBody.JobList.Job.Output.OutSubtitleList()
                        model.fromMap(dict["OutSubtitleList"] as! [String: Any])
                        self.outSubtitleList = model
                    }
                    if dict.keys.contains("OutputFile") {
                        var model = ListJobResponseBody.JobList.Job.Output.OutputFile()
                        model.fromMap(dict["OutputFile"] as! [String: Any])
                        self.outputFile = model
                    }
                    if dict.keys.contains("Priority") {
                        self.priority = dict["Priority"] as! String
                    }
                    if dict.keys.contains("Properties") {
                        var model = ListJobResponseBody.JobList.Job.Output.Properties()
                        model.fromMap(dict["Properties"] as! [String: Any])
                        self.properties = model
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("SubtitleConfig") {
                        var model = ListJobResponseBody.JobList.Job.Output.SubtitleConfig()
                        model.fromMap(dict["SubtitleConfig"] as! [String: Any])
                        self.subtitleConfig = model
                    }
                    if dict.keys.contains("SuperReso") {
                        var model = ListJobResponseBody.JobList.Job.Output.SuperReso()
                        model.fromMap(dict["SuperReso"] as! [String: Any])
                        self.superReso = model
                    }
                    if dict.keys.contains("TailSlateList") {
                        var model = ListJobResponseBody.JobList.Job.Output.TailSlateList()
                        model.fromMap(dict["TailSlateList"] as! [String: Any])
                        self.tailSlateList = model
                    }
                    if dict.keys.contains("TemplateId") {
                        self.templateId = dict["TemplateId"] as! String
                    }
                    if dict.keys.contains("TransConfig") {
                        var model = ListJobResponseBody.JobList.Job.Output.TransConfig()
                        model.fromMap(dict["TransConfig"] as! [String: Any])
                        self.transConfig = model
                    }
                    if dict.keys.contains("UserData") {
                        self.userData = dict["UserData"] as! String
                    }
                    if dict.keys.contains("Video") {
                        var model = ListJobResponseBody.JobList.Job.Output.Video()
                        model.fromMap(dict["Video"] as! [String: Any])
                        self.video = model
                    }
                    if dict.keys.contains("VideoStreamMap") {
                        self.videoStreamMap = dict["VideoStreamMap"] as! String
                    }
                    if dict.keys.contains("WaterMarkConfigUrl") {
                        self.waterMarkConfigUrl = dict["WaterMarkConfigUrl"] as! String
                    }
                    if dict.keys.contains("WaterMarkList") {
                        var model = ListJobResponseBody.JobList.Job.Output.WaterMarkList()
                        model.fromMap(dict["WaterMarkList"] as! [String: Any])
                        self.waterMarkList = model
                    }
                }
            }
            public var code: String?

            public var creationTime: String?

            public var finishTime: String?

            public var input: ListJobResponseBody.JobList.Job.Input?

            public var jobId: String?

            public var MNSMessageResult: ListJobResponseBody.JobList.Job.MNSMessageResult?

            public var message: String?

            public var output: ListJobResponseBody.JobList.Job.Output?

            public var percent: Int64?

            public var pipelineId: String?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.input?.validate()
                try self.MNSMessageResult?.validate()
                try self.output?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.MNSMessageResult != nil {
                    map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("Input") {
                    var model = ListJobResponseBody.JobList.Job.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("MNSMessageResult") {
                    var model = ListJobResponseBody.JobList.Job.MNSMessageResult()
                    model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                    self.MNSMessageResult = model
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Output") {
                    var model = ListJobResponseBody.JobList.Job.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! Int64
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
            }
        }
        public var job: [ListJobResponseBody.JobList.Job]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.job != nil {
                var tmp : [Any] = []
                for k in self.job! {
                    tmp.append(k.toMap())
                }
                map["Job"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Job") {
                var tmp : [ListJobResponseBody.JobList.Job] = []
                for v in dict["Job"] as! [Any] {
                    var model = ListJobResponseBody.JobList.Job()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.job = tmp
            }
        }
    }
    public var jobList: ListJobResponseBody.JobList?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobList != nil {
            map["JobList"] = self.jobList?.toMap()
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobList") {
            var model = ListJobResponseBody.JobList()
            model.fromMap(dict["JobList"] as! [String: Any])
            self.jobList = model
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMediaWorkflowExecutionsRequest : Tea.TeaModel {
    public var inputFileURL: String?

    public var maximumPageSize: Int64?

    public var mediaWorkflowId: String?

    public var mediaWorkflowName: String?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.inputFileURL != nil {
            map["InputFileURL"] = self.inputFileURL!
        }
        if self.maximumPageSize != nil {
            map["MaximumPageSize"] = self.maximumPageSize!
        }
        if self.mediaWorkflowId != nil {
            map["MediaWorkflowId"] = self.mediaWorkflowId!
        }
        if self.mediaWorkflowName != nil {
            map["MediaWorkflowName"] = self.mediaWorkflowName!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InputFileURL") {
            self.inputFileURL = dict["InputFileURL"] as! String
        }
        if dict.keys.contains("MaximumPageSize") {
            self.maximumPageSize = dict["MaximumPageSize"] as! Int64
        }
        if dict.keys.contains("MediaWorkflowId") {
            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
        }
        if dict.keys.contains("MediaWorkflowName") {
            self.mediaWorkflowName = dict["MediaWorkflowName"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListMediaWorkflowExecutionsResponseBody : Tea.TeaModel {
    public class MediaWorkflowExecutionList : Tea.TeaModel {
        public class MediaWorkflowExecution : Tea.TeaModel {
            public class ActivityList : Tea.TeaModel {
                public class Activity : Tea.TeaModel {
                    public class MNSMessageResult : Tea.TeaModel {
                        public var errorCode: String?

                        public var errorMessage: String?

                        public var messageId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.errorCode != nil {
                                map["ErrorCode"] = self.errorCode!
                            }
                            if self.errorMessage != nil {
                                map["ErrorMessage"] = self.errorMessage!
                            }
                            if self.messageId != nil {
                                map["MessageId"] = self.messageId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ErrorCode") {
                                self.errorCode = dict["ErrorCode"] as! String
                            }
                            if dict.keys.contains("ErrorMessage") {
                                self.errorMessage = dict["ErrorMessage"] as! String
                            }
                            if dict.keys.contains("MessageId") {
                                self.messageId = dict["MessageId"] as! String
                            }
                        }
                    }
                    public var code: String?

                    public var endTime: String?

                    public var jobId: String?

                    public var MNSMessageResult: ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity.MNSMessageResult?

                    public var message: String?

                    public var name: String?

                    public var startTime: String?

                    public var state: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.MNSMessageResult?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.code != nil {
                            map["Code"] = self.code!
                        }
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.jobId != nil {
                            map["JobId"] = self.jobId!
                        }
                        if self.MNSMessageResult != nil {
                            map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
                        }
                        if self.message != nil {
                            map["Message"] = self.message!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.state != nil {
                            map["State"] = self.state!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Code") {
                            self.code = dict["Code"] as! String
                        }
                        if dict.keys.contains("EndTime") {
                            self.endTime = dict["EndTime"] as! String
                        }
                        if dict.keys.contains("JobId") {
                            self.jobId = dict["JobId"] as! String
                        }
                        if dict.keys.contains("MNSMessageResult") {
                            var model = ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity.MNSMessageResult()
                            model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                            self.MNSMessageResult = model
                        }
                        if dict.keys.contains("Message") {
                            self.message = dict["Message"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                        if dict.keys.contains("State") {
                            self.state = dict["State"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var activity: [ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.activity != nil {
                        var tmp : [Any] = []
                        for k in self.activity! {
                            tmp.append(k.toMap())
                        }
                        map["Activity"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Activity") {
                        var tmp : [ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity] = []
                        for v in dict["Activity"] as! [Any] {
                            var model = ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.activity = tmp
                    }
                }
            }
            public class Input : Tea.TeaModel {
                public class InputFile : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                    }
                }
                public var inputFile: ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.Input.InputFile?

                public var userData: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.inputFile?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.inputFile != nil {
                        map["InputFile"] = self.inputFile?.toMap()
                    }
                    if self.userData != nil {
                        map["UserData"] = self.userData!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InputFile") {
                        var model = ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.Input.InputFile()
                        model.fromMap(dict["InputFile"] as! [String: Any])
                        self.inputFile = model
                    }
                    if dict.keys.contains("UserData") {
                        self.userData = dict["UserData"] as! String
                    }
                }
            }
            public var activityList: ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList?

            public var creationTime: String?

            public var input: ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.Input?

            public var mediaId: String?

            public var mediaWorkflowId: String?

            public var name: String?

            public var runId: String?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.activityList?.validate()
                try self.input?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activityList != nil {
                    map["ActivityList"] = self.activityList?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaWorkflowId != nil {
                    map["MediaWorkflowId"] = self.mediaWorkflowId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.runId != nil {
                    map["RunId"] = self.runId!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActivityList") {
                    var model = ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList()
                    model.fromMap(dict["ActivityList"] as! [String: Any])
                    self.activityList = model
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Input") {
                    var model = ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaWorkflowId") {
                    self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RunId") {
                    self.runId = dict["RunId"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
            }
        }
        public var mediaWorkflowExecution: [ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaWorkflowExecution != nil {
                var tmp : [Any] = []
                for k in self.mediaWorkflowExecution! {
                    tmp.append(k.toMap())
                }
                map["MediaWorkflowExecution"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaWorkflowExecution") {
                var tmp : [ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution] = []
                for v in dict["MediaWorkflowExecution"] as! [Any] {
                    var model = ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaWorkflowExecution = tmp
            }
        }
    }
    public var mediaWorkflowExecutionList: ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList?

    public var nextPageToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflowExecutionList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowExecutionList != nil {
            map["MediaWorkflowExecutionList"] = self.mediaWorkflowExecutionList?.toMap()
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowExecutionList") {
            var model = ListMediaWorkflowExecutionsResponseBody.MediaWorkflowExecutionList()
            model.fromMap(dict["MediaWorkflowExecutionList"] as! [String: Any])
            self.mediaWorkflowExecutionList = model
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMediaWorkflowExecutionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMediaWorkflowExecutionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMediaWorkflowExecutionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryAnalysisJobListRequest : Tea.TeaModel {
    public var analysisJobIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.analysisJobIds != nil {
            map["AnalysisJobIds"] = self.analysisJobIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AnalysisJobIds") {
            self.analysisJobIds = dict["AnalysisJobIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryAnalysisJobListResponseBody : Tea.TeaModel {
    public class AnalysisJobList : Tea.TeaModel {
        public class AnalysisJob : Tea.TeaModel {
            public class AnalysisConfig : Tea.TeaModel {
                public class PropertiesControl : Tea.TeaModel {
                    public class Crop : Tea.TeaModel {
                        public var height: String?

                        public var left_: String?

                        public var mode: String?

                        public var top: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.left_ != nil {
                                map["Left"] = self.left_!
                            }
                            if self.mode != nil {
                                map["Mode"] = self.mode!
                            }
                            if self.top != nil {
                                map["Top"] = self.top!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("Left") {
                                self.left_ = dict["Left"] as! String
                            }
                            if dict.keys.contains("Mode") {
                                self.mode = dict["Mode"] as! String
                            }
                            if dict.keys.contains("Top") {
                                self.top = dict["Top"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var crop: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.AnalysisConfig.PropertiesControl.Crop?

                    public var deinterlace: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.crop?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.crop != nil {
                            map["Crop"] = self.crop?.toMap()
                        }
                        if self.deinterlace != nil {
                            map["Deinterlace"] = self.deinterlace!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Crop") {
                            var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.AnalysisConfig.PropertiesControl.Crop()
                            model.fromMap(dict["Crop"] as! [String: Any])
                            self.crop = model
                        }
                        if dict.keys.contains("Deinterlace") {
                            self.deinterlace = dict["Deinterlace"] as! String
                        }
                    }
                }
                public class QualityControl : Tea.TeaModel {
                    public var methodStreaming: String?

                    public var rateQuality: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.methodStreaming != nil {
                            map["MethodStreaming"] = self.methodStreaming!
                        }
                        if self.rateQuality != nil {
                            map["RateQuality"] = self.rateQuality!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("MethodStreaming") {
                            self.methodStreaming = dict["MethodStreaming"] as! String
                        }
                        if dict.keys.contains("RateQuality") {
                            self.rateQuality = dict["RateQuality"] as! String
                        }
                    }
                }
                public var propertiesControl: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.AnalysisConfig.PropertiesControl?

                public var qualityControl: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.AnalysisConfig.QualityControl?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.propertiesControl?.validate()
                    try self.qualityControl?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.propertiesControl != nil {
                        map["PropertiesControl"] = self.propertiesControl?.toMap()
                    }
                    if self.qualityControl != nil {
                        map["QualityControl"] = self.qualityControl?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PropertiesControl") {
                        var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.AnalysisConfig.PropertiesControl()
                        model.fromMap(dict["PropertiesControl"] as! [String: Any])
                        self.propertiesControl = model
                    }
                    if dict.keys.contains("QualityControl") {
                        var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.AnalysisConfig.QualityControl()
                        model.fromMap(dict["QualityControl"] as! [String: Any])
                        self.qualityControl = model
                    }
                }
            }
            public class InputFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public class MNSMessageResult : Tea.TeaModel {
                public var errorCode: String?

                public var errorMessage: String?

                public var messageId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.messageId != nil {
                        map["MessageId"] = self.messageId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("MessageId") {
                        self.messageId = dict["MessageId"] as! String
                    }
                }
            }
            public class TemplateList : Tea.TeaModel {
                public class Template : Tea.TeaModel {
                    public class Audio : Tea.TeaModel {
                        public var bitrate: String?

                        public var channels: String?

                        public var codec: String?

                        public var profile: String?

                        public var qscale: String?

                        public var samplerate: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.channels != nil {
                                map["Channels"] = self.channels!
                            }
                            if self.codec != nil {
                                map["Codec"] = self.codec!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.qscale != nil {
                                map["Qscale"] = self.qscale!
                            }
                            if self.samplerate != nil {
                                map["Samplerate"] = self.samplerate!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Channels") {
                                self.channels = dict["Channels"] as! String
                            }
                            if dict.keys.contains("Codec") {
                                self.codec = dict["Codec"] as! String
                            }
                            if dict.keys.contains("Profile") {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Qscale") {
                                self.qscale = dict["Qscale"] as! String
                            }
                            if dict.keys.contains("Samplerate") {
                                self.samplerate = dict["Samplerate"] as! String
                            }
                        }
                    }
                    public class Container : Tea.TeaModel {
                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public class MuxConfig : Tea.TeaModel {
                        public class Gif : Tea.TeaModel {
                            public var finalDelay: String?

                            public var loop: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.finalDelay != nil {
                                    map["FinalDelay"] = self.finalDelay!
                                }
                                if self.loop != nil {
                                    map["Loop"] = self.loop!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("FinalDelay") {
                                    self.finalDelay = dict["FinalDelay"] as! String
                                }
                                if dict.keys.contains("Loop") {
                                    self.loop = dict["Loop"] as! String
                                }
                            }
                        }
                        public class Segment : Tea.TeaModel {
                            public var duration: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                            }
                        }
                        public var gif: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.MuxConfig.Gif?

                        public var segment: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.MuxConfig.Segment?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.gif?.validate()
                            try self.segment?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.gif != nil {
                                map["Gif"] = self.gif?.toMap()
                            }
                            if self.segment != nil {
                                map["Segment"] = self.segment?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Gif") {
                                var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.MuxConfig.Gif()
                                model.fromMap(dict["Gif"] as! [String: Any])
                                self.gif = model
                            }
                            if dict.keys.contains("Segment") {
                                var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.MuxConfig.Segment()
                                model.fromMap(dict["Segment"] as! [String: Any])
                                self.segment = model
                            }
                        }
                    }
                    public class TransConfig : Tea.TeaModel {
                        public var transMode: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.transMode != nil {
                                map["TransMode"] = self.transMode!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("TransMode") {
                                self.transMode = dict["TransMode"] as! String
                            }
                        }
                    }
                    public class Video : Tea.TeaModel {
                        public class BitrateBnd : Tea.TeaModel {
                            public var max: String?

                            public var min: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.max != nil {
                                    map["Max"] = self.max!
                                }
                                if self.min != nil {
                                    map["Min"] = self.min!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Max") {
                                    self.max = dict["Max"] as! String
                                }
                                if dict.keys.contains("Min") {
                                    self.min = dict["Min"] as! String
                                }
                            }
                        }
                        public var bitrate: String?

                        public var bitrateBnd: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.Video.BitrateBnd?

                        public var bufsize: String?

                        public var codec: String?

                        public var crf: String?

                        public var degrain: String?

                        public var fps: String?

                        public var gop: String?

                        public var height: String?

                        public var maxrate: String?

                        public var pixFmt: String?

                        public var preset: String?

                        public var profile: String?

                        public var qscale: String?

                        public var scanMode: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.bitrateBnd?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.bitrateBnd != nil {
                                map["BitrateBnd"] = self.bitrateBnd?.toMap()
                            }
                            if self.bufsize != nil {
                                map["Bufsize"] = self.bufsize!
                            }
                            if self.codec != nil {
                                map["Codec"] = self.codec!
                            }
                            if self.crf != nil {
                                map["Crf"] = self.crf!
                            }
                            if self.degrain != nil {
                                map["Degrain"] = self.degrain!
                            }
                            if self.fps != nil {
                                map["Fps"] = self.fps!
                            }
                            if self.gop != nil {
                                map["Gop"] = self.gop!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.maxrate != nil {
                                map["Maxrate"] = self.maxrate!
                            }
                            if self.pixFmt != nil {
                                map["PixFmt"] = self.pixFmt!
                            }
                            if self.preset != nil {
                                map["Preset"] = self.preset!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.qscale != nil {
                                map["Qscale"] = self.qscale!
                            }
                            if self.scanMode != nil {
                                map["ScanMode"] = self.scanMode!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("BitrateBnd") {
                                var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.Video.BitrateBnd()
                                model.fromMap(dict["BitrateBnd"] as! [String: Any])
                                self.bitrateBnd = model
                            }
                            if dict.keys.contains("Bufsize") {
                                self.bufsize = dict["Bufsize"] as! String
                            }
                            if dict.keys.contains("Codec") {
                                self.codec = dict["Codec"] as! String
                            }
                            if dict.keys.contains("Crf") {
                                self.crf = dict["Crf"] as! String
                            }
                            if dict.keys.contains("Degrain") {
                                self.degrain = dict["Degrain"] as! String
                            }
                            if dict.keys.contains("Fps") {
                                self.fps = dict["Fps"] as! String
                            }
                            if dict.keys.contains("Gop") {
                                self.gop = dict["Gop"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("Maxrate") {
                                self.maxrate = dict["Maxrate"] as! String
                            }
                            if dict.keys.contains("PixFmt") {
                                self.pixFmt = dict["PixFmt"] as! String
                            }
                            if dict.keys.contains("Preset") {
                                self.preset = dict["Preset"] as! String
                            }
                            if dict.keys.contains("Profile") {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Qscale") {
                                self.qscale = dict["Qscale"] as! String
                            }
                            if dict.keys.contains("ScanMode") {
                                self.scanMode = dict["ScanMode"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var audio: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.Audio?

                    public var container: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.Container?

                    public var id: String?

                    public var muxConfig: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.MuxConfig?

                    public var name: String?

                    public var state: String?

                    public var transConfig: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.TransConfig?

                    public var video: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.Video?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.audio?.validate()
                        try self.container?.validate()
                        try self.muxConfig?.validate()
                        try self.transConfig?.validate()
                        try self.video?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audio != nil {
                            map["Audio"] = self.audio?.toMap()
                        }
                        if self.container != nil {
                            map["Container"] = self.container?.toMap()
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.muxConfig != nil {
                            map["MuxConfig"] = self.muxConfig?.toMap()
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.state != nil {
                            map["State"] = self.state!
                        }
                        if self.transConfig != nil {
                            map["TransConfig"] = self.transConfig?.toMap()
                        }
                        if self.video != nil {
                            map["Video"] = self.video?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Audio") {
                            var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.Audio()
                            model.fromMap(dict["Audio"] as! [String: Any])
                            self.audio = model
                        }
                        if dict.keys.contains("Container") {
                            var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.Container()
                            model.fromMap(dict["Container"] as! [String: Any])
                            self.container = model
                        }
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("MuxConfig") {
                            var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.MuxConfig()
                            model.fromMap(dict["MuxConfig"] as! [String: Any])
                            self.muxConfig = model
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("State") {
                            self.state = dict["State"] as! String
                        }
                        if dict.keys.contains("TransConfig") {
                            var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.TransConfig()
                            model.fromMap(dict["TransConfig"] as! [String: Any])
                            self.transConfig = model
                        }
                        if dict.keys.contains("Video") {
                            var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template.Video()
                            model.fromMap(dict["Video"] as! [String: Any])
                            self.video = model
                        }
                    }
                }
                public var template: [QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.template != nil {
                        var tmp : [Any] = []
                        for k in self.template! {
                            tmp.append(k.toMap())
                        }
                        map["Template"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Template") {
                        var tmp : [QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template] = []
                        for v in dict["Template"] as! [Any] {
                            var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList.Template()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.template = tmp
                    }
                }
            }
            public var analysisConfig: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.AnalysisConfig?

            public var code: String?

            public var creationTime: String?

            public var id: String?

            public var inputFile: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.InputFile?

            public var MNSMessageResult: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.MNSMessageResult?

            public var message: String?

            public var percent: Int64?

            public var pipelineId: String?

            public var priority: String?

            public var state: String?

            public var templateList: QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.analysisConfig?.validate()
                try self.inputFile?.validate()
                try self.MNSMessageResult?.validate()
                try self.templateList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.analysisConfig != nil {
                    map["AnalysisConfig"] = self.analysisConfig?.toMap()
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.inputFile != nil {
                    map["InputFile"] = self.inputFile?.toMap()
                }
                if self.MNSMessageResult != nil {
                    map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.templateList != nil {
                    map["TemplateList"] = self.templateList?.toMap()
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AnalysisConfig") {
                    var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.AnalysisConfig()
                    model.fromMap(dict["AnalysisConfig"] as! [String: Any])
                    self.analysisConfig = model
                }
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("InputFile") {
                    var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.InputFile()
                    model.fromMap(dict["InputFile"] as! [String: Any])
                    self.inputFile = model
                }
                if dict.keys.contains("MNSMessageResult") {
                    var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.MNSMessageResult()
                    model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                    self.MNSMessageResult = model
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! Int64
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("TemplateList") {
                    var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob.TemplateList()
                    model.fromMap(dict["TemplateList"] as! [String: Any])
                    self.templateList = model
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var analysisJob: [QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.analysisJob != nil {
                var tmp : [Any] = []
                for k in self.analysisJob! {
                    tmp.append(k.toMap())
                }
                map["AnalysisJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AnalysisJob") {
                var tmp : [QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob] = []
                for v in dict["AnalysisJob"] as! [Any] {
                    var model = QueryAnalysisJobListResponseBody.AnalysisJobList.AnalysisJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.analysisJob = tmp
            }
        }
    }
    public class NonExistAnalysisJobIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public var analysisJobList: QueryAnalysisJobListResponseBody.AnalysisJobList?

    public var nonExistAnalysisJobIds: QueryAnalysisJobListResponseBody.NonExistAnalysisJobIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.analysisJobList?.validate()
        try self.nonExistAnalysisJobIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.analysisJobList != nil {
            map["AnalysisJobList"] = self.analysisJobList?.toMap()
        }
        if self.nonExistAnalysisJobIds != nil {
            map["NonExistAnalysisJobIds"] = self.nonExistAnalysisJobIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AnalysisJobList") {
            var model = QueryAnalysisJobListResponseBody.AnalysisJobList()
            model.fromMap(dict["AnalysisJobList"] as! [String: Any])
            self.analysisJobList = model
        }
        if dict.keys.contains("NonExistAnalysisJobIds") {
            var model = QueryAnalysisJobListResponseBody.NonExistAnalysisJobIds()
            model.fromMap(dict["NonExistAnalysisJobIds"] as! [String: Any])
            self.nonExistAnalysisJobIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryAnalysisJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryAnalysisJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryAnalysisJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryCopyrightExtractJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class QueryCopyrightExtractJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var message: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
        }
    }
    public var data: QueryCopyrightExtractJobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var statusCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = QueryCopyrightExtractJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! Int64
        }
    }
}

public class QueryCopyrightExtractJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryCopyrightExtractJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryCopyrightExtractJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryCopyrightJobRequest : Tea.TeaModel {
    public var createTimeEnd: Int64?

    public var createTimeStart: Int64?

    public var jobId: String?

    public var level: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTimeEnd != nil {
            map["CreateTimeEnd"] = self.createTimeEnd!
        }
        if self.createTimeStart != nil {
            map["CreateTimeStart"] = self.createTimeStart!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTimeEnd") {
            self.createTimeEnd = dict["CreateTimeEnd"] as! Int64
        }
        if dict.keys.contains("CreateTimeStart") {
            self.createTimeStart = dict["CreateTimeStart"] as! Int64
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Level") {
            self.level = dict["Level"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class QueryCopyrightJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var callback: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var input: String?

        public var jobId: String?

        public var level: Int64?

        public var message: String?

        public var output: String?

        public var result: String?

        public var status: String?

        public var userData: String?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callback != nil {
                map["Callback"] = self.callback!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.input != nil {
                map["Input"] = self.input!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.output != nil {
                map["Output"] = self.output!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Callback") {
                self.callback = dict["Callback"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! Int64
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! Int64
            }
            if dict.keys.contains("Input") {
                self.input = dict["Input"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! Int64
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Output") {
                self.output = dict["Output"] as! String
            }
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! Int64
            }
        }
    }
    public var data: [QueryCopyrightJobResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var statusCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [QueryCopyrightJobResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryCopyrightJobResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! Int64
        }
    }
}

public class QueryCopyrightJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryCopyrightJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryCopyrightJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryFpDBDeleteJobListRequest : Tea.TeaModel {
    public var jobIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryFpDBDeleteJobListResponseBody : Tea.TeaModel {
    public class FpDBDeleteJobList : Tea.TeaModel {
        public class FpDBDeleteJob : Tea.TeaModel {
            public var code: String?

            public var creationTime: String?

            public var delType: String?

            public var finishTime: String?

            public var fpDBId: String?

            public var id: String?

            public var message: String?

            public var pipelineId: String?

            public var status: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.delType != nil {
                    map["DelType"] = self.delType!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.fpDBId != nil {
                    map["FpDBId"] = self.fpDBId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DelType") {
                    self.delType = dict["DelType"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("FpDBId") {
                    self.fpDBId = dict["FpDBId"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fpDBDeleteJob: [QueryFpDBDeleteJobListResponseBody.FpDBDeleteJobList.FpDBDeleteJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fpDBDeleteJob != nil {
                var tmp : [Any] = []
                for k in self.fpDBDeleteJob! {
                    tmp.append(k.toMap())
                }
                map["FpDBDeleteJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FpDBDeleteJob") {
                var tmp : [QueryFpDBDeleteJobListResponseBody.FpDBDeleteJobList.FpDBDeleteJob] = []
                for v in dict["FpDBDeleteJob"] as! [Any] {
                    var model = QueryFpDBDeleteJobListResponseBody.FpDBDeleteJobList.FpDBDeleteJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fpDBDeleteJob = tmp
            }
        }
    }
    public class NonExistIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public var fpDBDeleteJobList: QueryFpDBDeleteJobListResponseBody.FpDBDeleteJobList?

    public var nonExistIds: QueryFpDBDeleteJobListResponseBody.NonExistIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.fpDBDeleteJobList?.validate()
        try self.nonExistIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fpDBDeleteJobList != nil {
            map["FpDBDeleteJobList"] = self.fpDBDeleteJobList?.toMap()
        }
        if self.nonExistIds != nil {
            map["NonExistIds"] = self.nonExistIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FpDBDeleteJobList") {
            var model = QueryFpDBDeleteJobListResponseBody.FpDBDeleteJobList()
            model.fromMap(dict["FpDBDeleteJobList"] as! [String: Any])
            self.fpDBDeleteJobList = model
        }
        if dict.keys.contains("NonExistIds") {
            var model = QueryFpDBDeleteJobListResponseBody.NonExistIds()
            model.fromMap(dict["NonExistIds"] as! [String: Any])
            self.nonExistIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryFpDBDeleteJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryFpDBDeleteJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryFpDBDeleteJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryFpFileDeleteJobListRequest : Tea.TeaModel {
    public var jobIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryFpFileDeleteJobListResponseBody : Tea.TeaModel {
    public class FpFileDeleteJobList : Tea.TeaModel {
        public class FpFileDeleteJob : Tea.TeaModel {
            public var code: String?

            public var creationTime: String?

            public var fileIds: String?

            public var finishTime: String?

            public var fpDBId: String?

            public var id: String?

            public var message: String?

            public var pipelineId: String?

            public var status: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.fileIds != nil {
                    map["FileIds"] = self.fileIds!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.fpDBId != nil {
                    map["FpDBId"] = self.fpDBId!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("FileIds") {
                    self.fileIds = dict["FileIds"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("FpDBId") {
                    self.fpDBId = dict["FpDBId"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fpFileDeleteJob: [QueryFpFileDeleteJobListResponseBody.FpFileDeleteJobList.FpFileDeleteJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fpFileDeleteJob != nil {
                var tmp : [Any] = []
                for k in self.fpFileDeleteJob! {
                    tmp.append(k.toMap())
                }
                map["FpFileDeleteJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FpFileDeleteJob") {
                var tmp : [QueryFpFileDeleteJobListResponseBody.FpFileDeleteJobList.FpFileDeleteJob] = []
                for v in dict["FpFileDeleteJob"] as! [Any] {
                    var model = QueryFpFileDeleteJobListResponseBody.FpFileDeleteJobList.FpFileDeleteJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fpFileDeleteJob = tmp
            }
        }
    }
    public class NonExistIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public var fpFileDeleteJobList: QueryFpFileDeleteJobListResponseBody.FpFileDeleteJobList?

    public var nonExistIds: QueryFpFileDeleteJobListResponseBody.NonExistIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.fpFileDeleteJobList?.validate()
        try self.nonExistIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fpFileDeleteJobList != nil {
            map["FpFileDeleteJobList"] = self.fpFileDeleteJobList?.toMap()
        }
        if self.nonExistIds != nil {
            map["NonExistIds"] = self.nonExistIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FpFileDeleteJobList") {
            var model = QueryFpFileDeleteJobListResponseBody.FpFileDeleteJobList()
            model.fromMap(dict["FpFileDeleteJobList"] as! [String: Any])
            self.fpFileDeleteJobList = model
        }
        if dict.keys.contains("NonExistIds") {
            var model = QueryFpFileDeleteJobListResponseBody.NonExistIds()
            model.fromMap(dict["NonExistIds"] as! [String: Any])
            self.nonExistIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryFpFileDeleteJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryFpFileDeleteJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryFpFileDeleteJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryFpShotJobListRequest : Tea.TeaModel {
    public var endOfJobCreatedTimeRange: String?

    public var jobIds: String?

    public var maximumPageSize: Int64?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startOfJobCreatedTimeRange: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfJobCreatedTimeRange != nil {
            map["EndOfJobCreatedTimeRange"] = self.endOfJobCreatedTimeRange!
        }
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.maximumPageSize != nil {
            map["MaximumPageSize"] = self.maximumPageSize!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startOfJobCreatedTimeRange != nil {
            map["StartOfJobCreatedTimeRange"] = self.startOfJobCreatedTimeRange!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfJobCreatedTimeRange") {
            self.endOfJobCreatedTimeRange = dict["EndOfJobCreatedTimeRange"] as! String
        }
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("MaximumPageSize") {
            self.maximumPageSize = dict["MaximumPageSize"] as! Int64
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartOfJobCreatedTimeRange") {
            self.startOfJobCreatedTimeRange = dict["StartOfJobCreatedTimeRange"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class QueryFpShotJobListResponseBody : Tea.TeaModel {
    public class FpShotJobList : Tea.TeaModel {
        public class FpShotJob : Tea.TeaModel {
            public class FpShotConfig : Tea.TeaModel {
                public var fpDBId: String?

                public var primaryKey: String?

                public var saveType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fpDBId != nil {
                        map["FpDBId"] = self.fpDBId!
                    }
                    if self.primaryKey != nil {
                        map["PrimaryKey"] = self.primaryKey!
                    }
                    if self.saveType != nil {
                        map["SaveType"] = self.saveType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FpDBId") {
                        self.fpDBId = dict["FpDBId"] as! String
                    }
                    if dict.keys.contains("PrimaryKey") {
                        self.primaryKey = dict["PrimaryKey"] as! String
                    }
                    if dict.keys.contains("SaveType") {
                        self.saveType = dict["SaveType"] as! String
                    }
                }
            }
            public class FpShotResult : Tea.TeaModel {
                public class AudioFpShots : Tea.TeaModel {
                    public class FpShot : Tea.TeaModel {
                        public class FpShotSlices : Tea.TeaModel {
                            public class FpShotSlice : Tea.TeaModel {
                                public class Duplication : Tea.TeaModel {
                                    public var duration: String?

                                    public var start: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.duration != nil {
                                            map["Duration"] = self.duration!
                                        }
                                        if self.start != nil {
                                            map["Start"] = self.start!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Duration") {
                                            self.duration = dict["Duration"] as! String
                                        }
                                        if dict.keys.contains("Start") {
                                            self.start = dict["Start"] as! String
                                        }
                                    }
                                }
                                public class Input : Tea.TeaModel {
                                    public var duration: String?

                                    public var start: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.duration != nil {
                                            map["Duration"] = self.duration!
                                        }
                                        if self.start != nil {
                                            map["Start"] = self.start!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Duration") {
                                            self.duration = dict["Duration"] as! String
                                        }
                                        if dict.keys.contains("Start") {
                                            self.start = dict["Start"] as! String
                                        }
                                    }
                                }
                                public var duplication: QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.AudioFpShots.FpShot.FpShotSlices.FpShotSlice.Duplication?

                                public var input: QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.AudioFpShots.FpShot.FpShotSlices.FpShotSlice.Input?

                                public var similarity: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                    try self.duplication?.validate()
                                    try self.input?.validate()
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duplication != nil {
                                        map["Duplication"] = self.duplication?.toMap()
                                    }
                                    if self.input != nil {
                                        map["Input"] = self.input?.toMap()
                                    }
                                    if self.similarity != nil {
                                        map["Similarity"] = self.similarity!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duplication") {
                                        var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.AudioFpShots.FpShot.FpShotSlices.FpShotSlice.Duplication()
                                        model.fromMap(dict["Duplication"] as! [String: Any])
                                        self.duplication = model
                                    }
                                    if dict.keys.contains("Input") {
                                        var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.AudioFpShots.FpShot.FpShotSlices.FpShotSlice.Input()
                                        model.fromMap(dict["Input"] as! [String: Any])
                                        self.input = model
                                    }
                                    if dict.keys.contains("Similarity") {
                                        self.similarity = dict["Similarity"] as! String
                                    }
                                }
                            }
                            public var fpShotSlice: [QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.AudioFpShots.FpShot.FpShotSlices.FpShotSlice]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.fpShotSlice != nil {
                                    var tmp : [Any] = []
                                    for k in self.fpShotSlice! {
                                        tmp.append(k.toMap())
                                    }
                                    map["FpShotSlice"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("FpShotSlice") {
                                    var tmp : [QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.AudioFpShots.FpShot.FpShotSlices.FpShotSlice] = []
                                    for v in dict["FpShotSlice"] as! [Any] {
                                        var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.AudioFpShots.FpShot.FpShotSlices.FpShotSlice()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.fpShotSlice = tmp
                                }
                            }
                        }
                        public var fpShotSlices: QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.AudioFpShots.FpShot.FpShotSlices?

                        public var primaryKey: String?

                        public var similarity: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.fpShotSlices?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.fpShotSlices != nil {
                                map["FpShotSlices"] = self.fpShotSlices?.toMap()
                            }
                            if self.primaryKey != nil {
                                map["PrimaryKey"] = self.primaryKey!
                            }
                            if self.similarity != nil {
                                map["Similarity"] = self.similarity!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("FpShotSlices") {
                                var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.AudioFpShots.FpShot.FpShotSlices()
                                model.fromMap(dict["FpShotSlices"] as! [String: Any])
                                self.fpShotSlices = model
                            }
                            if dict.keys.contains("PrimaryKey") {
                                self.primaryKey = dict["PrimaryKey"] as! String
                            }
                            if dict.keys.contains("Similarity") {
                                self.similarity = dict["Similarity"] as! String
                            }
                        }
                    }
                    public var fpShot: [QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.AudioFpShots.FpShot]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.fpShot != nil {
                            var tmp : [Any] = []
                            for k in self.fpShot! {
                                tmp.append(k.toMap())
                            }
                            map["FpShot"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("FpShot") {
                            var tmp : [QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.AudioFpShots.FpShot] = []
                            for v in dict["FpShot"] as! [Any] {
                                var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.AudioFpShots.FpShot()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.fpShot = tmp
                        }
                    }
                }
                public class FpShots : Tea.TeaModel {
                    public class FpShot : Tea.TeaModel {
                        public class FpShotSlices : Tea.TeaModel {
                            public class FpShotSlice : Tea.TeaModel {
                                public class Duplication : Tea.TeaModel {
                                    public var duration: String?

                                    public var start: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.duration != nil {
                                            map["Duration"] = self.duration!
                                        }
                                        if self.start != nil {
                                            map["Start"] = self.start!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Duration") {
                                            self.duration = dict["Duration"] as! String
                                        }
                                        if dict.keys.contains("Start") {
                                            self.start = dict["Start"] as! String
                                        }
                                    }
                                }
                                public class Input : Tea.TeaModel {
                                    public var duration: String?

                                    public var start: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.duration != nil {
                                            map["Duration"] = self.duration!
                                        }
                                        if self.start != nil {
                                            map["Start"] = self.start!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Duration") {
                                            self.duration = dict["Duration"] as! String
                                        }
                                        if dict.keys.contains("Start") {
                                            self.start = dict["Start"] as! String
                                        }
                                    }
                                }
                                public var duplication: QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.FpShots.FpShot.FpShotSlices.FpShotSlice.Duplication?

                                public var input: QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.FpShots.FpShot.FpShotSlices.FpShotSlice.Input?

                                public var similarity: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                    try self.duplication?.validate()
                                    try self.input?.validate()
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duplication != nil {
                                        map["Duplication"] = self.duplication?.toMap()
                                    }
                                    if self.input != nil {
                                        map["Input"] = self.input?.toMap()
                                    }
                                    if self.similarity != nil {
                                        map["Similarity"] = self.similarity!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Duplication") {
                                        var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.FpShots.FpShot.FpShotSlices.FpShotSlice.Duplication()
                                        model.fromMap(dict["Duplication"] as! [String: Any])
                                        self.duplication = model
                                    }
                                    if dict.keys.contains("Input") {
                                        var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.FpShots.FpShot.FpShotSlices.FpShotSlice.Input()
                                        model.fromMap(dict["Input"] as! [String: Any])
                                        self.input = model
                                    }
                                    if dict.keys.contains("Similarity") {
                                        self.similarity = dict["Similarity"] as! String
                                    }
                                }
                            }
                            public var fpShotSlice: [QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.FpShots.FpShot.FpShotSlices.FpShotSlice]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.fpShotSlice != nil {
                                    var tmp : [Any] = []
                                    for k in self.fpShotSlice! {
                                        tmp.append(k.toMap())
                                    }
                                    map["FpShotSlice"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("FpShotSlice") {
                                    var tmp : [QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.FpShots.FpShot.FpShotSlices.FpShotSlice] = []
                                    for v in dict["FpShotSlice"] as! [Any] {
                                        var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.FpShots.FpShot.FpShotSlices.FpShotSlice()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.fpShotSlice = tmp
                                }
                            }
                        }
                        public var fpShotSlices: QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.FpShots.FpShot.FpShotSlices?

                        public var primaryKey: String?

                        public var similarity: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.fpShotSlices?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.fpShotSlices != nil {
                                map["FpShotSlices"] = self.fpShotSlices?.toMap()
                            }
                            if self.primaryKey != nil {
                                map["PrimaryKey"] = self.primaryKey!
                            }
                            if self.similarity != nil {
                                map["Similarity"] = self.similarity!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("FpShotSlices") {
                                var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.FpShots.FpShot.FpShotSlices()
                                model.fromMap(dict["FpShotSlices"] as! [String: Any])
                                self.fpShotSlices = model
                            }
                            if dict.keys.contains("PrimaryKey") {
                                self.primaryKey = dict["PrimaryKey"] as! String
                            }
                            if dict.keys.contains("Similarity") {
                                self.similarity = dict["Similarity"] as! String
                            }
                        }
                    }
                    public var fpShot: [QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.FpShots.FpShot]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.fpShot != nil {
                            var tmp : [Any] = []
                            for k in self.fpShot! {
                                tmp.append(k.toMap())
                            }
                            map["FpShot"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("FpShot") {
                            var tmp : [QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.FpShots.FpShot] = []
                            for v in dict["FpShot"] as! [Any] {
                                var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.FpShots.FpShot()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.fpShot = tmp
                        }
                    }
                }
                public class TextFpShots : Tea.TeaModel {
                    public class TextFpShot : Tea.TeaModel {
                        public class TextFpShotSlices : Tea.TeaModel {
                            public class TextFpShotSlice : Tea.TeaModel {
                                public class InputFragment : Tea.TeaModel {
                                    public var duration: String?

                                    public var start: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.duration != nil {
                                            map["Duration"] = self.duration!
                                        }
                                        if self.start != nil {
                                            map["Start"] = self.start!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Duration") {
                                            self.duration = dict["Duration"] as! String
                                        }
                                        if dict.keys.contains("Start") {
                                            self.start = dict["Start"] as! String
                                        }
                                    }
                                }
                                public var duplicationText: String?

                                public var inputFragment: QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.TextFpShots.TextFpShot.TextFpShotSlices.TextFpShotSlice.InputFragment?

                                public var inputText: String?

                                public var similarity: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                    try self.inputFragment?.validate()
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.duplicationText != nil {
                                        map["DuplicationText"] = self.duplicationText!
                                    }
                                    if self.inputFragment != nil {
                                        map["InputFragment"] = self.inputFragment?.toMap()
                                    }
                                    if self.inputText != nil {
                                        map["InputText"] = self.inputText!
                                    }
                                    if self.similarity != nil {
                                        map["Similarity"] = self.similarity!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("DuplicationText") {
                                        self.duplicationText = dict["DuplicationText"] as! String
                                    }
                                    if dict.keys.contains("InputFragment") {
                                        var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.TextFpShots.TextFpShot.TextFpShotSlices.TextFpShotSlice.InputFragment()
                                        model.fromMap(dict["InputFragment"] as! [String: Any])
                                        self.inputFragment = model
                                    }
                                    if dict.keys.contains("InputText") {
                                        self.inputText = dict["InputText"] as! String
                                    }
                                    if dict.keys.contains("Similarity") {
                                        self.similarity = dict["Similarity"] as! String
                                    }
                                }
                            }
                            public var textFpShotSlice: [QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.TextFpShots.TextFpShot.TextFpShotSlices.TextFpShotSlice]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.textFpShotSlice != nil {
                                    var tmp : [Any] = []
                                    for k in self.textFpShotSlice! {
                                        tmp.append(k.toMap())
                                    }
                                    map["TextFpShotSlice"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("TextFpShotSlice") {
                                    var tmp : [QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.TextFpShots.TextFpShot.TextFpShotSlices.TextFpShotSlice] = []
                                    for v in dict["TextFpShotSlice"] as! [Any] {
                                        var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.TextFpShots.TextFpShot.TextFpShotSlices.TextFpShotSlice()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.textFpShotSlice = tmp
                                }
                            }
                        }
                        public var primaryKey: String?

                        public var similarity: String?

                        public var textFpShotSlices: QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.TextFpShots.TextFpShot.TextFpShotSlices?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.textFpShotSlices?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.primaryKey != nil {
                                map["PrimaryKey"] = self.primaryKey!
                            }
                            if self.similarity != nil {
                                map["Similarity"] = self.similarity!
                            }
                            if self.textFpShotSlices != nil {
                                map["TextFpShotSlices"] = self.textFpShotSlices?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("PrimaryKey") {
                                self.primaryKey = dict["PrimaryKey"] as! String
                            }
                            if dict.keys.contains("Similarity") {
                                self.similarity = dict["Similarity"] as! String
                            }
                            if dict.keys.contains("TextFpShotSlices") {
                                var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.TextFpShots.TextFpShot.TextFpShotSlices()
                                model.fromMap(dict["TextFpShotSlices"] as! [String: Any])
                                self.textFpShotSlices = model
                            }
                        }
                    }
                    public var textFpShot: [QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.TextFpShots.TextFpShot]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.textFpShot != nil {
                            var tmp : [Any] = []
                            for k in self.textFpShot! {
                                tmp.append(k.toMap())
                            }
                            map["TextFpShot"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TextFpShot") {
                            var tmp : [QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.TextFpShots.TextFpShot] = []
                            for v in dict["TextFpShot"] as! [Any] {
                                var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.TextFpShots.TextFpShot()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.textFpShot = tmp
                        }
                    }
                }
                public var audioFpShots: QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.AudioFpShots?

                public var fpShots: QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.FpShots?

                public var textFpShots: QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.TextFpShots?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.audioFpShots?.validate()
                    try self.fpShots?.validate()
                    try self.textFpShots?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioFpShots != nil {
                        map["AudioFpShots"] = self.audioFpShots?.toMap()
                    }
                    if self.fpShots != nil {
                        map["FpShots"] = self.fpShots?.toMap()
                    }
                    if self.textFpShots != nil {
                        map["TextFpShots"] = self.textFpShots?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioFpShots") {
                        var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.AudioFpShots()
                        model.fromMap(dict["AudioFpShots"] as! [String: Any])
                        self.audioFpShots = model
                    }
                    if dict.keys.contains("FpShots") {
                        var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.FpShots()
                        model.fromMap(dict["FpShots"] as! [String: Any])
                        self.fpShots = model
                    }
                    if dict.keys.contains("TextFpShots") {
                        var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult.TextFpShots()
                        model.fromMap(dict["TextFpShots"] as! [String: Any])
                        self.textFpShots = model
                    }
                }
            }
            public class InputFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var code: String?

            public var creationTime: String?

            public var duration: Int32?

            public var fileId: String?

            public var finishTime: String?

            public var fpShotConfig: QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotConfig?

            public var fpShotResult: QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult?

            public var id: String?

            public var input: String?

            public var inputFile: QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.InputFile?

            public var message: String?

            public var pipelineId: String?

            public var state: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.fpShotConfig?.validate()
                try self.fpShotResult?.validate()
                try self.inputFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.fileId != nil {
                    map["FileId"] = self.fileId!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.fpShotConfig != nil {
                    map["FpShotConfig"] = self.fpShotConfig?.toMap()
                }
                if self.fpShotResult != nil {
                    map["FpShotResult"] = self.fpShotResult?.toMap()
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.input != nil {
                    map["Input"] = self.input!
                }
                if self.inputFile != nil {
                    map["InputFile"] = self.inputFile?.toMap()
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Int32
                }
                if dict.keys.contains("FileId") {
                    self.fileId = dict["FileId"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("FpShotConfig") {
                    var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotConfig()
                    model.fromMap(dict["FpShotConfig"] as! [String: Any])
                    self.fpShotConfig = model
                }
                if dict.keys.contains("FpShotResult") {
                    var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.FpShotResult()
                    model.fromMap(dict["FpShotResult"] as! [String: Any])
                    self.fpShotResult = model
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Input") {
                    self.input = dict["Input"] as! String
                }
                if dict.keys.contains("InputFile") {
                    var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob.InputFile()
                    model.fromMap(dict["InputFile"] as! [String: Any])
                    self.inputFile = model
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var fpShotJob: [QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fpShotJob != nil {
                var tmp : [Any] = []
                for k in self.fpShotJob! {
                    tmp.append(k.toMap())
                }
                map["FpShotJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FpShotJob") {
                var tmp : [QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob] = []
                for v in dict["FpShotJob"] as! [Any] {
                    var model = QueryFpShotJobListResponseBody.FpShotJobList.FpShotJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.fpShotJob = tmp
            }
        }
    }
    public class NonExistIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public var fpShotJobList: QueryFpShotJobListResponseBody.FpShotJobList?

    public var nextPageToken: String?

    public var nonExistIds: QueryFpShotJobListResponseBody.NonExistIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.fpShotJobList?.validate()
        try self.nonExistIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fpShotJobList != nil {
            map["FpShotJobList"] = self.fpShotJobList?.toMap()
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.nonExistIds != nil {
            map["NonExistIds"] = self.nonExistIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FpShotJobList") {
            var model = QueryFpShotJobListResponseBody.FpShotJobList()
            model.fromMap(dict["FpShotJobList"] as! [String: Any])
            self.fpShotJobList = model
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("NonExistIds") {
            var model = QueryFpShotJobListResponseBody.NonExistIds()
            model.fromMap(dict["NonExistIds"] as! [String: Any])
            self.nonExistIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryFpShotJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryFpShotJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryFpShotJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryIProductionJobRequest : Tea.TeaModel {
    public var jobId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryIProductionJobResponseBody : Tea.TeaModel {
    public var functionName: String?

    public var input: String?

    public var jobId: String?

    public var jobParams: String?

    public var output: String?

    public var pipelineId: String?

    public var requestId: String?

    public var result: String?

    public var state: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobParams != nil {
            map["JobParams"] = self.jobParams!
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FunctionName") {
            self.functionName = dict["FunctionName"] as! String
        }
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobParams") {
            self.jobParams = dict["JobParams"] as! String
        }
        if dict.keys.contains("Output") {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class QueryIProductionJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryIProductionJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryIProductionJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryJobListRequest : Tea.TeaModel {
    public var jobIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryJobListResponseBody : Tea.TeaModel {
    public class JobList : Tea.TeaModel {
        public class Job : Tea.TeaModel {
            public class Input : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public class MNSMessageResult : Tea.TeaModel {
                public var errorCode: String?

                public var errorMessage: String?

                public var messageId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.messageId != nil {
                        map["MessageId"] = self.messageId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("MessageId") {
                        self.messageId = dict["MessageId"] as! String
                    }
                }
            }
            public class Output : Tea.TeaModel {
                public class Audio : Tea.TeaModel {
                    public class Volume : Tea.TeaModel {
                        public var level: String?

                        public var method: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.level != nil {
                                map["Level"] = self.level!
                            }
                            if self.method != nil {
                                map["Method"] = self.method!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Level") {
                                self.level = dict["Level"] as! String
                            }
                            if dict.keys.contains("Method") {
                                self.method = dict["Method"] as! String
                            }
                        }
                    }
                    public var bitrate: String?

                    public var channels: String?

                    public var codec: String?

                    public var profile: String?

                    public var qscale: String?

                    public var samplerate: String?

                    public var volume: QueryJobListResponseBody.JobList.Job.Output.Audio.Volume?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.volume?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        if self.codec != nil {
                            map["Codec"] = self.codec!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.qscale != nil {
                            map["Qscale"] = self.qscale!
                        }
                        if self.samplerate != nil {
                            map["Samplerate"] = self.samplerate!
                        }
                        if self.volume != nil {
                            map["Volume"] = self.volume?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Channels") {
                            self.channels = dict["Channels"] as! String
                        }
                        if dict.keys.contains("Codec") {
                            self.codec = dict["Codec"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Qscale") {
                            self.qscale = dict["Qscale"] as! String
                        }
                        if dict.keys.contains("Samplerate") {
                            self.samplerate = dict["Samplerate"] as! String
                        }
                        if dict.keys.contains("Volume") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.Audio.Volume()
                            model.fromMap(dict["Volume"] as! [String: Any])
                            self.volume = model
                        }
                    }
                }
                public class Clip : Tea.TeaModel {
                    public class TimeSpan : Tea.TeaModel {
                        public var duration: String?

                        public var seek: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.seek != nil {
                                map["Seek"] = self.seek!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("Seek") {
                                self.seek = dict["Seek"] as! String
                            }
                        }
                    }
                    public var timeSpan: QueryJobListResponseBody.JobList.Job.Output.Clip.TimeSpan?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.timeSpan?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.timeSpan != nil {
                            map["TimeSpan"] = self.timeSpan?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TimeSpan") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.Clip.TimeSpan()
                            model.fromMap(dict["TimeSpan"] as! [String: Any])
                            self.timeSpan = model
                        }
                    }
                }
                public class Container : Tea.TeaModel {
                    public var format: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                    }
                }
                public class Encryption : Tea.TeaModel {
                    public var id: String?

                    public var key: String?

                    public var keyType: String?

                    public var keyUri: String?

                    public var skipCnt: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.keyType != nil {
                            map["KeyType"] = self.keyType!
                        }
                        if self.keyUri != nil {
                            map["KeyUri"] = self.keyUri!
                        }
                        if self.skipCnt != nil {
                            map["SkipCnt"] = self.skipCnt!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Id") {
                            self.id = dict["Id"] as! String
                        }
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("KeyType") {
                            self.keyType = dict["KeyType"] as! String
                        }
                        if dict.keys.contains("KeyUri") {
                            self.keyUri = dict["KeyUri"] as! String
                        }
                        if dict.keys.contains("SkipCnt") {
                            self.skipCnt = dict["SkipCnt"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public class M3U8NonStandardSupport : Tea.TeaModel {
                    public class TS : Tea.TeaModel {
                        public var md5Support: Bool?

                        public var sizeSupport: Bool?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.md5Support != nil {
                                map["Md5Support"] = self.md5Support!
                            }
                            if self.sizeSupport != nil {
                                map["SizeSupport"] = self.sizeSupport!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Md5Support") {
                                self.md5Support = dict["Md5Support"] as! Bool
                            }
                            if dict.keys.contains("SizeSupport") {
                                self.sizeSupport = dict["SizeSupport"] as! Bool
                            }
                        }
                    }
                    public var TS: QueryJobListResponseBody.JobList.Job.Output.M3U8NonStandardSupport.TS?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.TS?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.TS != nil {
                            map["TS"] = self.TS?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TS") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.M3U8NonStandardSupport.TS()
                            model.fromMap(dict["TS"] as! [String: Any])
                            self.TS = model
                        }
                    }
                }
                public class MergeList : Tea.TeaModel {
                    public class Merge : Tea.TeaModel {
                        public var duration: String?

                        public var mergeURL: String?

                        public var roleArn: String?

                        public var start: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.mergeURL != nil {
                                map["MergeURL"] = self.mergeURL!
                            }
                            if self.roleArn != nil {
                                map["RoleArn"] = self.roleArn!
                            }
                            if self.start != nil {
                                map["Start"] = self.start!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("MergeURL") {
                                self.mergeURL = dict["MergeURL"] as! String
                            }
                            if dict.keys.contains("RoleArn") {
                                self.roleArn = dict["RoleArn"] as! String
                            }
                            if dict.keys.contains("Start") {
                                self.start = dict["Start"] as! String
                            }
                        }
                    }
                    public var merge: [QueryJobListResponseBody.JobList.Job.Output.MergeList.Merge]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.merge != nil {
                            var tmp : [Any] = []
                            for k in self.merge! {
                                tmp.append(k.toMap())
                            }
                            map["Merge"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Merge") {
                            var tmp : [QueryJobListResponseBody.JobList.Job.Output.MergeList.Merge] = []
                            for v in dict["Merge"] as! [Any] {
                                var model = QueryJobListResponseBody.JobList.Job.Output.MergeList.Merge()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.merge = tmp
                        }
                    }
                }
                public class MultiSpeedInfo : Tea.TeaModel {
                    public var code: String?

                    public var downgradePolicy: String?

                    public var duration: Double?

                    public var enable: String?

                    public var message: String?

                    public var realSpeed: Double?

                    public var settingSpeed: Int32?

                    public var timeCost: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.code != nil {
                            map["Code"] = self.code!
                        }
                        if self.downgradePolicy != nil {
                            map["DowngradePolicy"] = self.downgradePolicy!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.enable != nil {
                            map["Enable"] = self.enable!
                        }
                        if self.message != nil {
                            map["Message"] = self.message!
                        }
                        if self.realSpeed != nil {
                            map["RealSpeed"] = self.realSpeed!
                        }
                        if self.settingSpeed != nil {
                            map["SettingSpeed"] = self.settingSpeed!
                        }
                        if self.timeCost != nil {
                            map["TimeCost"] = self.timeCost!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Code") {
                            self.code = dict["Code"] as! String
                        }
                        if dict.keys.contains("DowngradePolicy") {
                            self.downgradePolicy = dict["DowngradePolicy"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Double
                        }
                        if dict.keys.contains("Enable") {
                            self.enable = dict["Enable"] as! String
                        }
                        if dict.keys.contains("Message") {
                            self.message = dict["Message"] as! String
                        }
                        if dict.keys.contains("RealSpeed") {
                            self.realSpeed = dict["RealSpeed"] as! Double
                        }
                        if dict.keys.contains("SettingSpeed") {
                            self.settingSpeed = dict["SettingSpeed"] as! Int32
                        }
                        if dict.keys.contains("TimeCost") {
                            self.timeCost = dict["TimeCost"] as! Double
                        }
                    }
                }
                public class MuxConfig : Tea.TeaModel {
                    public class Gif : Tea.TeaModel {
                        public var ditherMode: String?

                        public var finalDelay: String?

                        public var isCustomPalette: String?

                        public var loop: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.ditherMode != nil {
                                map["DitherMode"] = self.ditherMode!
                            }
                            if self.finalDelay != nil {
                                map["FinalDelay"] = self.finalDelay!
                            }
                            if self.isCustomPalette != nil {
                                map["IsCustomPalette"] = self.isCustomPalette!
                            }
                            if self.loop != nil {
                                map["Loop"] = self.loop!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("DitherMode") {
                                self.ditherMode = dict["DitherMode"] as! String
                            }
                            if dict.keys.contains("FinalDelay") {
                                self.finalDelay = dict["FinalDelay"] as! String
                            }
                            if dict.keys.contains("IsCustomPalette") {
                                self.isCustomPalette = dict["IsCustomPalette"] as! String
                            }
                            if dict.keys.contains("Loop") {
                                self.loop = dict["Loop"] as! String
                            }
                        }
                    }
                    public class Segment : Tea.TeaModel {
                        public var duration: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                        }
                    }
                    public class Webp : Tea.TeaModel {
                        public var loop: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.loop != nil {
                                map["Loop"] = self.loop!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Loop") {
                                self.loop = dict["Loop"] as! String
                            }
                        }
                    }
                    public var gif: QueryJobListResponseBody.JobList.Job.Output.MuxConfig.Gif?

                    public var segment: QueryJobListResponseBody.JobList.Job.Output.MuxConfig.Segment?

                    public var webp: QueryJobListResponseBody.JobList.Job.Output.MuxConfig.Webp?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.gif?.validate()
                        try self.segment?.validate()
                        try self.webp?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.gif != nil {
                            map["Gif"] = self.gif?.toMap()
                        }
                        if self.segment != nil {
                            map["Segment"] = self.segment?.toMap()
                        }
                        if self.webp != nil {
                            map["Webp"] = self.webp?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Gif") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.MuxConfig.Gif()
                            model.fromMap(dict["Gif"] as! [String: Any])
                            self.gif = model
                        }
                        if dict.keys.contains("Segment") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.MuxConfig.Segment()
                            model.fromMap(dict["Segment"] as! [String: Any])
                            self.segment = model
                        }
                        if dict.keys.contains("Webp") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.MuxConfig.Webp()
                            model.fromMap(dict["Webp"] as! [String: Any])
                            self.webp = model
                        }
                    }
                }
                public class OpeningList : Tea.TeaModel {
                    public class Opening : Tea.TeaModel {
                        public var height: String?

                        public var start: String?

                        public var width: String?

                        public var openUrl: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.start != nil {
                                map["Start"] = self.start!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            if self.openUrl != nil {
                                map["openUrl"] = self.openUrl!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("Start") {
                                self.start = dict["Start"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                            if dict.keys.contains("openUrl") {
                                self.openUrl = dict["openUrl"] as! String
                            }
                        }
                    }
                    public var opening: [QueryJobListResponseBody.JobList.Job.Output.OpeningList.Opening]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.opening != nil {
                            var tmp : [Any] = []
                            for k in self.opening! {
                                tmp.append(k.toMap())
                            }
                            map["Opening"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Opening") {
                            var tmp : [QueryJobListResponseBody.JobList.Job.Output.OpeningList.Opening] = []
                            for v in dict["Opening"] as! [Any] {
                                var model = QueryJobListResponseBody.JobList.Job.Output.OpeningList.Opening()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.opening = tmp
                        }
                    }
                }
                public class OutSubtitleList : Tea.TeaModel {
                    public class OutSubtitle : Tea.TeaModel {
                        public class OutSubtitleFile : Tea.TeaModel {
                            public var bucket: String?

                            public var location: String?

                            public var object: String?

                            public var roleArn: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bucket != nil {
                                    map["Bucket"] = self.bucket!
                                }
                                if self.location != nil {
                                    map["Location"] = self.location!
                                }
                                if self.object != nil {
                                    map["Object"] = self.object!
                                }
                                if self.roleArn != nil {
                                    map["RoleArn"] = self.roleArn!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bucket") {
                                    self.bucket = dict["Bucket"] as! String
                                }
                                if dict.keys.contains("Location") {
                                    self.location = dict["Location"] as! String
                                }
                                if dict.keys.contains("Object") {
                                    self.object = dict["Object"] as! String
                                }
                                if dict.keys.contains("RoleArn") {
                                    self.roleArn = dict["RoleArn"] as! String
                                }
                            }
                        }
                        public var map: String?

                        public var message: String?

                        public var outSubtitleFile: QueryJobListResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle.OutSubtitleFile?

                        public var success: Bool?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.outSubtitleFile?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.map != nil {
                                map["Map"] = self.map!
                            }
                            if self.message != nil {
                                map["Message"] = self.message!
                            }
                            if self.outSubtitleFile != nil {
                                map["OutSubtitleFile"] = self.outSubtitleFile?.toMap()
                            }
                            if self.success != nil {
                                map["Success"] = self.success!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Map") {
                                self.map = dict["Map"] as! String
                            }
                            if dict.keys.contains("Message") {
                                self.message = dict["Message"] as! String
                            }
                            if dict.keys.contains("OutSubtitleFile") {
                                var model = QueryJobListResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle.OutSubtitleFile()
                                model.fromMap(dict["OutSubtitleFile"] as! [String: Any])
                                self.outSubtitleFile = model
                            }
                            if dict.keys.contains("Success") {
                                self.success = dict["Success"] as! Bool
                            }
                        }
                    }
                    public var outSubtitle: [QueryJobListResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.outSubtitle != nil {
                            var tmp : [Any] = []
                            for k in self.outSubtitle! {
                                tmp.append(k.toMap())
                            }
                            map["OutSubtitle"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("OutSubtitle") {
                            var tmp : [QueryJobListResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle] = []
                            for v in dict["OutSubtitle"] as! [Any] {
                                var model = QueryJobListResponseBody.JobList.Job.Output.OutSubtitleList.OutSubtitle()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.outSubtitle = tmp
                        }
                    }
                }
                public class OutputFile : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public var roleArn: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        if self.roleArn != nil {
                            map["RoleArn"] = self.roleArn!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                        if dict.keys.contains("RoleArn") {
                            self.roleArn = dict["RoleArn"] as! String
                        }
                    }
                }
                public class Properties : Tea.TeaModel {
                    public class Format : Tea.TeaModel {
                        public var bitrate: String?

                        public var duration: String?

                        public var formatLongName: String?

                        public var formatName: String?

                        public var numPrograms: String?

                        public var numStreams: String?

                        public var size: String?

                        public var startTime: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.formatLongName != nil {
                                map["FormatLongName"] = self.formatLongName!
                            }
                            if self.formatName != nil {
                                map["FormatName"] = self.formatName!
                            }
                            if self.numPrograms != nil {
                                map["NumPrograms"] = self.numPrograms!
                            }
                            if self.numStreams != nil {
                                map["NumStreams"] = self.numStreams!
                            }
                            if self.size != nil {
                                map["Size"] = self.size!
                            }
                            if self.startTime != nil {
                                map["StartTime"] = self.startTime!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("FormatLongName") {
                                self.formatLongName = dict["FormatLongName"] as! String
                            }
                            if dict.keys.contains("FormatName") {
                                self.formatName = dict["FormatName"] as! String
                            }
                            if dict.keys.contains("NumPrograms") {
                                self.numPrograms = dict["NumPrograms"] as! String
                            }
                            if dict.keys.contains("NumStreams") {
                                self.numStreams = dict["NumStreams"] as! String
                            }
                            if dict.keys.contains("Size") {
                                self.size = dict["Size"] as! String
                            }
                            if dict.keys.contains("StartTime") {
                                self.startTime = dict["StartTime"] as! String
                            }
                        }
                    }
                    public class SourceLogos : Tea.TeaModel {
                        public class SourceLogo : Tea.TeaModel {
                            public var source: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.source != nil {
                                    map["Source"] = self.source!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Source") {
                                    self.source = dict["Source"] as! String
                                }
                            }
                        }
                        public var sourceLogo: [QueryJobListResponseBody.JobList.Job.Output.Properties.SourceLogos.SourceLogo]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.sourceLogo != nil {
                                var tmp : [Any] = []
                                for k in self.sourceLogo! {
                                    tmp.append(k.toMap())
                                }
                                map["SourceLogo"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("SourceLogo") {
                                var tmp : [QueryJobListResponseBody.JobList.Job.Output.Properties.SourceLogos.SourceLogo] = []
                                for v in dict["SourceLogo"] as! [Any] {
                                    var model = QueryJobListResponseBody.JobList.Job.Output.Properties.SourceLogos.SourceLogo()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.sourceLogo = tmp
                            }
                        }
                    }
                    public class Streams : Tea.TeaModel {
                        public class AudioStreamList : Tea.TeaModel {
                            public class AudioStream : Tea.TeaModel {
                                public var bitrate: String?

                                public var channelLayout: String?

                                public var channels: String?

                                public var codecLongName: String?

                                public var codecName: String?

                                public var codecTag: String?

                                public var codecTagString: String?

                                public var codecTimeBase: String?

                                public var duration: String?

                                public var index: String?

                                public var lang: String?

                                public var numFrames: String?

                                public var sampleFmt: String?

                                public var samplerate: String?

                                public var startTime: String?

                                public var timebase: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.bitrate != nil {
                                        map["Bitrate"] = self.bitrate!
                                    }
                                    if self.channelLayout != nil {
                                        map["ChannelLayout"] = self.channelLayout!
                                    }
                                    if self.channels != nil {
                                        map["Channels"] = self.channels!
                                    }
                                    if self.codecLongName != nil {
                                        map["CodecLongName"] = self.codecLongName!
                                    }
                                    if self.codecName != nil {
                                        map["CodecName"] = self.codecName!
                                    }
                                    if self.codecTag != nil {
                                        map["CodecTag"] = self.codecTag!
                                    }
                                    if self.codecTagString != nil {
                                        map["CodecTagString"] = self.codecTagString!
                                    }
                                    if self.codecTimeBase != nil {
                                        map["CodecTimeBase"] = self.codecTimeBase!
                                    }
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.index != nil {
                                        map["Index"] = self.index!
                                    }
                                    if self.lang != nil {
                                        map["Lang"] = self.lang!
                                    }
                                    if self.numFrames != nil {
                                        map["NumFrames"] = self.numFrames!
                                    }
                                    if self.sampleFmt != nil {
                                        map["SampleFmt"] = self.sampleFmt!
                                    }
                                    if self.samplerate != nil {
                                        map["Samplerate"] = self.samplerate!
                                    }
                                    if self.startTime != nil {
                                        map["StartTime"] = self.startTime!
                                    }
                                    if self.timebase != nil {
                                        map["Timebase"] = self.timebase!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Bitrate") {
                                        self.bitrate = dict["Bitrate"] as! String
                                    }
                                    if dict.keys.contains("ChannelLayout") {
                                        self.channelLayout = dict["ChannelLayout"] as! String
                                    }
                                    if dict.keys.contains("Channels") {
                                        self.channels = dict["Channels"] as! String
                                    }
                                    if dict.keys.contains("CodecLongName") {
                                        self.codecLongName = dict["CodecLongName"] as! String
                                    }
                                    if dict.keys.contains("CodecName") {
                                        self.codecName = dict["CodecName"] as! String
                                    }
                                    if dict.keys.contains("CodecTag") {
                                        self.codecTag = dict["CodecTag"] as! String
                                    }
                                    if dict.keys.contains("CodecTagString") {
                                        self.codecTagString = dict["CodecTagString"] as! String
                                    }
                                    if dict.keys.contains("CodecTimeBase") {
                                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                                    }
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("Index") {
                                        self.index = dict["Index"] as! String
                                    }
                                    if dict.keys.contains("Lang") {
                                        self.lang = dict["Lang"] as! String
                                    }
                                    if dict.keys.contains("NumFrames") {
                                        self.numFrames = dict["NumFrames"] as! String
                                    }
                                    if dict.keys.contains("SampleFmt") {
                                        self.sampleFmt = dict["SampleFmt"] as! String
                                    }
                                    if dict.keys.contains("Samplerate") {
                                        self.samplerate = dict["Samplerate"] as! String
                                    }
                                    if dict.keys.contains("StartTime") {
                                        self.startTime = dict["StartTime"] as! String
                                    }
                                    if dict.keys.contains("Timebase") {
                                        self.timebase = dict["Timebase"] as! String
                                    }
                                }
                            }
                            public var audioStream: [QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList.AudioStream]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.audioStream != nil {
                                    var tmp : [Any] = []
                                    for k in self.audioStream! {
                                        tmp.append(k.toMap())
                                    }
                                    map["AudioStream"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AudioStream") {
                                    var tmp : [QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList.AudioStream] = []
                                    for v in dict["AudioStream"] as! [Any] {
                                        var model = QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList.AudioStream()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.audioStream = tmp
                                }
                            }
                        }
                        public class SubtitleStreamList : Tea.TeaModel {
                            public class SubtitleStream : Tea.TeaModel {
                                public var index: String?

                                public var lang: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.index != nil {
                                        map["Index"] = self.index!
                                    }
                                    if self.lang != nil {
                                        map["Lang"] = self.lang!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Index") {
                                        self.index = dict["Index"] as! String
                                    }
                                    if dict.keys.contains("Lang") {
                                        self.lang = dict["Lang"] as! String
                                    }
                                }
                            }
                            public var subtitleStream: [QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList.SubtitleStream]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.subtitleStream != nil {
                                    var tmp : [Any] = []
                                    for k in self.subtitleStream! {
                                        tmp.append(k.toMap())
                                    }
                                    map["SubtitleStream"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("SubtitleStream") {
                                    var tmp : [QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList.SubtitleStream] = []
                                    for v in dict["SubtitleStream"] as! [Any] {
                                        var model = QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList.SubtitleStream()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.subtitleStream = tmp
                                }
                            }
                        }
                        public class VideoStreamList : Tea.TeaModel {
                            public class VideoStream : Tea.TeaModel {
                                public class NetworkCost : Tea.TeaModel {
                                    public var avgBitrate: String?

                                    public var costBandwidth: String?

                                    public var preloadTime: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.avgBitrate != nil {
                                            map["AvgBitrate"] = self.avgBitrate!
                                        }
                                        if self.costBandwidth != nil {
                                            map["CostBandwidth"] = self.costBandwidth!
                                        }
                                        if self.preloadTime != nil {
                                            map["PreloadTime"] = self.preloadTime!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("AvgBitrate") {
                                            self.avgBitrate = dict["AvgBitrate"] as! String
                                        }
                                        if dict.keys.contains("CostBandwidth") {
                                            self.costBandwidth = dict["CostBandwidth"] as! String
                                        }
                                        if dict.keys.contains("PreloadTime") {
                                            self.preloadTime = dict["PreloadTime"] as! String
                                        }
                                    }
                                }
                                public var avgFPS: String?

                                public var bitrate: String?

                                public var codecLongName: String?

                                public var codecName: String?

                                public var codecTag: String?

                                public var codecTagString: String?

                                public var codecTimeBase: String?

                                public var dar: String?

                                public var duration: String?

                                public var fps: String?

                                public var hasBFrames: String?

                                public var height: String?

                                public var index: String?

                                public var lang: String?

                                public var level: String?

                                public var networkCost: QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream.NetworkCost?

                                public var numFrames: String?

                                public var pixFmt: String?

                                public var profile: String?

                                public var sar: String?

                                public var startTime: String?

                                public var timebase: String?

                                public var width: String?

                                public var bitsPerRawSample: String?

                                public var colorPrimaries: String?

                                public var colorTransfer: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                    try self.networkCost?.validate()
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.avgFPS != nil {
                                        map["AvgFPS"] = self.avgFPS!
                                    }
                                    if self.bitrate != nil {
                                        map["Bitrate"] = self.bitrate!
                                    }
                                    if self.codecLongName != nil {
                                        map["CodecLongName"] = self.codecLongName!
                                    }
                                    if self.codecName != nil {
                                        map["CodecName"] = self.codecName!
                                    }
                                    if self.codecTag != nil {
                                        map["CodecTag"] = self.codecTag!
                                    }
                                    if self.codecTagString != nil {
                                        map["CodecTagString"] = self.codecTagString!
                                    }
                                    if self.codecTimeBase != nil {
                                        map["CodecTimeBase"] = self.codecTimeBase!
                                    }
                                    if self.dar != nil {
                                        map["Dar"] = self.dar!
                                    }
                                    if self.duration != nil {
                                        map["Duration"] = self.duration!
                                    }
                                    if self.fps != nil {
                                        map["Fps"] = self.fps!
                                    }
                                    if self.hasBFrames != nil {
                                        map["HasBFrames"] = self.hasBFrames!
                                    }
                                    if self.height != nil {
                                        map["Height"] = self.height!
                                    }
                                    if self.index != nil {
                                        map["Index"] = self.index!
                                    }
                                    if self.lang != nil {
                                        map["Lang"] = self.lang!
                                    }
                                    if self.level != nil {
                                        map["Level"] = self.level!
                                    }
                                    if self.networkCost != nil {
                                        map["NetworkCost"] = self.networkCost?.toMap()
                                    }
                                    if self.numFrames != nil {
                                        map["NumFrames"] = self.numFrames!
                                    }
                                    if self.pixFmt != nil {
                                        map["PixFmt"] = self.pixFmt!
                                    }
                                    if self.profile != nil {
                                        map["Profile"] = self.profile!
                                    }
                                    if self.sar != nil {
                                        map["Sar"] = self.sar!
                                    }
                                    if self.startTime != nil {
                                        map["StartTime"] = self.startTime!
                                    }
                                    if self.timebase != nil {
                                        map["Timebase"] = self.timebase!
                                    }
                                    if self.width != nil {
                                        map["Width"] = self.width!
                                    }
                                    if self.bitsPerRawSample != nil {
                                        map["bitsPerRawSample"] = self.bitsPerRawSample!
                                    }
                                    if self.colorPrimaries != nil {
                                        map["colorPrimaries"] = self.colorPrimaries!
                                    }
                                    if self.colorTransfer != nil {
                                        map["colorTransfer"] = self.colorTransfer!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("AvgFPS") {
                                        self.avgFPS = dict["AvgFPS"] as! String
                                    }
                                    if dict.keys.contains("Bitrate") {
                                        self.bitrate = dict["Bitrate"] as! String
                                    }
                                    if dict.keys.contains("CodecLongName") {
                                        self.codecLongName = dict["CodecLongName"] as! String
                                    }
                                    if dict.keys.contains("CodecName") {
                                        self.codecName = dict["CodecName"] as! String
                                    }
                                    if dict.keys.contains("CodecTag") {
                                        self.codecTag = dict["CodecTag"] as! String
                                    }
                                    if dict.keys.contains("CodecTagString") {
                                        self.codecTagString = dict["CodecTagString"] as! String
                                    }
                                    if dict.keys.contains("CodecTimeBase") {
                                        self.codecTimeBase = dict["CodecTimeBase"] as! String
                                    }
                                    if dict.keys.contains("Dar") {
                                        self.dar = dict["Dar"] as! String
                                    }
                                    if dict.keys.contains("Duration") {
                                        self.duration = dict["Duration"] as! String
                                    }
                                    if dict.keys.contains("Fps") {
                                        self.fps = dict["Fps"] as! String
                                    }
                                    if dict.keys.contains("HasBFrames") {
                                        self.hasBFrames = dict["HasBFrames"] as! String
                                    }
                                    if dict.keys.contains("Height") {
                                        self.height = dict["Height"] as! String
                                    }
                                    if dict.keys.contains("Index") {
                                        self.index = dict["Index"] as! String
                                    }
                                    if dict.keys.contains("Lang") {
                                        self.lang = dict["Lang"] as! String
                                    }
                                    if dict.keys.contains("Level") {
                                        self.level = dict["Level"] as! String
                                    }
                                    if dict.keys.contains("NetworkCost") {
                                        var model = QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream.NetworkCost()
                                        model.fromMap(dict["NetworkCost"] as! [String: Any])
                                        self.networkCost = model
                                    }
                                    if dict.keys.contains("NumFrames") {
                                        self.numFrames = dict["NumFrames"] as! String
                                    }
                                    if dict.keys.contains("PixFmt") {
                                        self.pixFmt = dict["PixFmt"] as! String
                                    }
                                    if dict.keys.contains("Profile") {
                                        self.profile = dict["Profile"] as! String
                                    }
                                    if dict.keys.contains("Sar") {
                                        self.sar = dict["Sar"] as! String
                                    }
                                    if dict.keys.contains("StartTime") {
                                        self.startTime = dict["StartTime"] as! String
                                    }
                                    if dict.keys.contains("Timebase") {
                                        self.timebase = dict["Timebase"] as! String
                                    }
                                    if dict.keys.contains("Width") {
                                        self.width = dict["Width"] as! String
                                    }
                                    if dict.keys.contains("bitsPerRawSample") {
                                        self.bitsPerRawSample = dict["bitsPerRawSample"] as! String
                                    }
                                    if dict.keys.contains("colorPrimaries") {
                                        self.colorPrimaries = dict["colorPrimaries"] as! String
                                    }
                                    if dict.keys.contains("colorTransfer") {
                                        self.colorTransfer = dict["colorTransfer"] as! String
                                    }
                                }
                            }
                            public var videoStream: [QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.videoStream != nil {
                                    var tmp : [Any] = []
                                    for k in self.videoStream! {
                                        tmp.append(k.toMap())
                                    }
                                    map["VideoStream"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("VideoStream") {
                                    var tmp : [QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream] = []
                                    for v in dict["VideoStream"] as! [Any] {
                                        var model = QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList.VideoStream()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.videoStream = tmp
                                }
                            }
                        }
                        public var audioStreamList: QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList?

                        public var subtitleStreamList: QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList?

                        public var videoStreamList: QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.audioStreamList?.validate()
                            try self.subtitleStreamList?.validate()
                            try self.videoStreamList?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audioStreamList != nil {
                                map["AudioStreamList"] = self.audioStreamList?.toMap()
                            }
                            if self.subtitleStreamList != nil {
                                map["SubtitleStreamList"] = self.subtitleStreamList?.toMap()
                            }
                            if self.videoStreamList != nil {
                                map["VideoStreamList"] = self.videoStreamList?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AudioStreamList") {
                                var model = QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.AudioStreamList()
                                model.fromMap(dict["AudioStreamList"] as! [String: Any])
                                self.audioStreamList = model
                            }
                            if dict.keys.contains("SubtitleStreamList") {
                                var model = QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.SubtitleStreamList()
                                model.fromMap(dict["SubtitleStreamList"] as! [String: Any])
                                self.subtitleStreamList = model
                            }
                            if dict.keys.contains("VideoStreamList") {
                                var model = QueryJobListResponseBody.JobList.Job.Output.Properties.Streams.VideoStreamList()
                                model.fromMap(dict["VideoStreamList"] as! [String: Any])
                                self.videoStreamList = model
                            }
                        }
                    }
                    public var bitrate: String?

                    public var duration: String?

                    public var fileFormat: String?

                    public var fileSize: String?

                    public var format: QueryJobListResponseBody.JobList.Job.Output.Properties.Format?

                    public var fps: String?

                    public var height: String?

                    public var sourceLogos: QueryJobListResponseBody.JobList.Job.Output.Properties.SourceLogos?

                    public var streams: QueryJobListResponseBody.JobList.Job.Output.Properties.Streams?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.format?.validate()
                        try self.sourceLogos?.validate()
                        try self.streams?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.fileFormat != nil {
                            map["FileFormat"] = self.fileFormat!
                        }
                        if self.fileSize != nil {
                            map["FileSize"] = self.fileSize!
                        }
                        if self.format != nil {
                            map["Format"] = self.format?.toMap()
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.sourceLogos != nil {
                            map["SourceLogos"] = self.sourceLogos?.toMap()
                        }
                        if self.streams != nil {
                            map["Streams"] = self.streams?.toMap()
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("FileFormat") {
                            self.fileFormat = dict["FileFormat"] as! String
                        }
                        if dict.keys.contains("FileSize") {
                            self.fileSize = dict["FileSize"] as! String
                        }
                        if dict.keys.contains("Format") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.Properties.Format()
                            model.fromMap(dict["Format"] as! [String: Any])
                            self.format = model
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("SourceLogos") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.Properties.SourceLogos()
                            model.fromMap(dict["SourceLogos"] as! [String: Any])
                            self.sourceLogos = model
                        }
                        if dict.keys.contains("Streams") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.Properties.Streams()
                            model.fromMap(dict["Streams"] as! [String: Any])
                            self.streams = model
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public class SubtitleConfig : Tea.TeaModel {
                    public class ExtSubtitleList : Tea.TeaModel {
                        public class ExtSubtitle : Tea.TeaModel {
                            public class Input : Tea.TeaModel {
                                public var bucket: String?

                                public var location: String?

                                public var object: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.bucket != nil {
                                        map["Bucket"] = self.bucket!
                                    }
                                    if self.location != nil {
                                        map["Location"] = self.location!
                                    }
                                    if self.object != nil {
                                        map["Object"] = self.object!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Bucket") {
                                        self.bucket = dict["Bucket"] as! String
                                    }
                                    if dict.keys.contains("Location") {
                                        self.location = dict["Location"] as! String
                                    }
                                    if dict.keys.contains("Object") {
                                        self.object = dict["Object"] as! String
                                    }
                                }
                            }
                            public var charEnc: String?

                            public var fontName: String?

                            public var input: QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle.Input?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.input?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.charEnc != nil {
                                    map["CharEnc"] = self.charEnc!
                                }
                                if self.fontName != nil {
                                    map["FontName"] = self.fontName!
                                }
                                if self.input != nil {
                                    map["Input"] = self.input?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("CharEnc") {
                                    self.charEnc = dict["CharEnc"] as! String
                                }
                                if dict.keys.contains("FontName") {
                                    self.fontName = dict["FontName"] as! String
                                }
                                if dict.keys.contains("Input") {
                                    var model = QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle.Input()
                                    model.fromMap(dict["Input"] as! [String: Any])
                                    self.input = model
                                }
                            }
                        }
                        public var extSubtitle: [QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.extSubtitle != nil {
                                var tmp : [Any] = []
                                for k in self.extSubtitle! {
                                    tmp.append(k.toMap())
                                }
                                map["ExtSubtitle"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ExtSubtitle") {
                                var tmp : [QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle] = []
                                for v in dict["ExtSubtitle"] as! [Any] {
                                    var model = QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.extSubtitle = tmp
                            }
                        }
                    }
                    public class SubtitleList : Tea.TeaModel {
                        public class Subtitle : Tea.TeaModel {
                            public var map: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.map != nil {
                                    map["Map"] = self.map!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Map") {
                                    self.map = dict["Map"] as! String
                                }
                            }
                        }
                        public var subtitle: [QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList.Subtitle]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.subtitle != nil {
                                var tmp : [Any] = []
                                for k in self.subtitle! {
                                    tmp.append(k.toMap())
                                }
                                map["Subtitle"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Subtitle") {
                                var tmp : [QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList.Subtitle] = []
                                for v in dict["Subtitle"] as! [Any] {
                                    var model = QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList.Subtitle()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.subtitle = tmp
                            }
                        }
                    }
                    public var extSubtitleList: QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList?

                    public var subtitleList: QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.extSubtitleList?.validate()
                        try self.subtitleList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.extSubtitleList != nil {
                            map["ExtSubtitleList"] = self.extSubtitleList?.toMap()
                        }
                        if self.subtitleList != nil {
                            map["SubtitleList"] = self.subtitleList?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ExtSubtitleList") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.ExtSubtitleList()
                            model.fromMap(dict["ExtSubtitleList"] as! [String: Any])
                            self.extSubtitleList = model
                        }
                        if dict.keys.contains("SubtitleList") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig.SubtitleList()
                            model.fromMap(dict["SubtitleList"] as! [String: Any])
                            self.subtitleList = model
                        }
                    }
                }
                public class SuperReso : Tea.TeaModel {
                    public var isHalfSample: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.isHalfSample != nil {
                            map["IsHalfSample"] = self.isHalfSample!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IsHalfSample") {
                            self.isHalfSample = dict["IsHalfSample"] as! String
                        }
                    }
                }
                public class TailSlateList : Tea.TeaModel {
                    public class TailSlate : Tea.TeaModel {
                        public var bgColor: String?

                        public var blendDuration: String?

                        public var height: String?

                        public var isMergeAudio: Bool?

                        public var start: String?

                        public var tailUrl: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bgColor != nil {
                                map["BgColor"] = self.bgColor!
                            }
                            if self.blendDuration != nil {
                                map["BlendDuration"] = self.blendDuration!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.isMergeAudio != nil {
                                map["IsMergeAudio"] = self.isMergeAudio!
                            }
                            if self.start != nil {
                                map["Start"] = self.start!
                            }
                            if self.tailUrl != nil {
                                map["TailUrl"] = self.tailUrl!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("BgColor") {
                                self.bgColor = dict["BgColor"] as! String
                            }
                            if dict.keys.contains("BlendDuration") {
                                self.blendDuration = dict["BlendDuration"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("IsMergeAudio") {
                                self.isMergeAudio = dict["IsMergeAudio"] as! Bool
                            }
                            if dict.keys.contains("Start") {
                                self.start = dict["Start"] as! String
                            }
                            if dict.keys.contains("TailUrl") {
                                self.tailUrl = dict["TailUrl"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var tailSlate: [QueryJobListResponseBody.JobList.Job.Output.TailSlateList.TailSlate]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tailSlate != nil {
                            var tmp : [Any] = []
                            for k in self.tailSlate! {
                                tmp.append(k.toMap())
                            }
                            map["TailSlate"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TailSlate") {
                            var tmp : [QueryJobListResponseBody.JobList.Job.Output.TailSlateList.TailSlate] = []
                            for v in dict["TailSlate"] as! [Any] {
                                var model = QueryJobListResponseBody.JobList.Job.Output.TailSlateList.TailSlate()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.tailSlate = tmp
                        }
                    }
                }
                public class TransConfig : Tea.TeaModel {
                    public var adjDarMethod: String?

                    public var isCheckAudioBitrate: String?

                    public var isCheckAudioBitrateFail: String?

                    public var isCheckReso: String?

                    public var isCheckResoFail: String?

                    public var isCheckVideoBitrate: String?

                    public var isCheckVideoBitrateFail: String?

                    public var transMode: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.adjDarMethod != nil {
                            map["AdjDarMethod"] = self.adjDarMethod!
                        }
                        if self.isCheckAudioBitrate != nil {
                            map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                        }
                        if self.isCheckAudioBitrateFail != nil {
                            map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                        }
                        if self.isCheckReso != nil {
                            map["IsCheckReso"] = self.isCheckReso!
                        }
                        if self.isCheckResoFail != nil {
                            map["IsCheckResoFail"] = self.isCheckResoFail!
                        }
                        if self.isCheckVideoBitrate != nil {
                            map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                        }
                        if self.isCheckVideoBitrateFail != nil {
                            map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                        }
                        if self.transMode != nil {
                            map["TransMode"] = self.transMode!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AdjDarMethod") {
                            self.adjDarMethod = dict["AdjDarMethod"] as! String
                        }
                        if dict.keys.contains("IsCheckAudioBitrate") {
                            self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                        }
                        if dict.keys.contains("IsCheckAudioBitrateFail") {
                            self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                        }
                        if dict.keys.contains("IsCheckReso") {
                            self.isCheckReso = dict["IsCheckReso"] as! String
                        }
                        if dict.keys.contains("IsCheckResoFail") {
                            self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                        }
                        if dict.keys.contains("IsCheckVideoBitrate") {
                            self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                        }
                        if dict.keys.contains("IsCheckVideoBitrateFail") {
                            self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                        }
                        if dict.keys.contains("TransMode") {
                            self.transMode = dict["TransMode"] as! String
                        }
                    }
                }
                public class Video : Tea.TeaModel {
                    public class BitrateBnd : Tea.TeaModel {
                        public var max: String?

                        public var min: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.max != nil {
                                map["Max"] = self.max!
                            }
                            if self.min != nil {
                                map["Min"] = self.min!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Max") {
                                self.max = dict["Max"] as! String
                            }
                            if dict.keys.contains("Min") {
                                self.min = dict["Min"] as! String
                            }
                        }
                    }
                    public var bitrate: String?

                    public var bitrateBnd: QueryJobListResponseBody.JobList.Job.Output.Video.BitrateBnd?

                    public var bufsize: String?

                    public var codec: String?

                    public var crf: String?

                    public var crop: String?

                    public var degrain: String?

                    public var fps: String?

                    public var gop: String?

                    public var height: String?

                    public var maxFps: String?

                    public var maxrate: String?

                    public var pad: String?

                    public var pixFmt: String?

                    public var preset: String?

                    public var profile: String?

                    public var qscale: String?

                    public var resoPriority: String?

                    public var scanMode: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.bitrateBnd?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.bitrateBnd != nil {
                            map["BitrateBnd"] = self.bitrateBnd?.toMap()
                        }
                        if self.bufsize != nil {
                            map["Bufsize"] = self.bufsize!
                        }
                        if self.codec != nil {
                            map["Codec"] = self.codec!
                        }
                        if self.crf != nil {
                            map["Crf"] = self.crf!
                        }
                        if self.crop != nil {
                            map["Crop"] = self.crop!
                        }
                        if self.degrain != nil {
                            map["Degrain"] = self.degrain!
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.gop != nil {
                            map["Gop"] = self.gop!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.maxFps != nil {
                            map["MaxFps"] = self.maxFps!
                        }
                        if self.maxrate != nil {
                            map["Maxrate"] = self.maxrate!
                        }
                        if self.pad != nil {
                            map["Pad"] = self.pad!
                        }
                        if self.pixFmt != nil {
                            map["PixFmt"] = self.pixFmt!
                        }
                        if self.preset != nil {
                            map["Preset"] = self.preset!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.qscale != nil {
                            map["Qscale"] = self.qscale!
                        }
                        if self.resoPriority != nil {
                            map["ResoPriority"] = self.resoPriority!
                        }
                        if self.scanMode != nil {
                            map["ScanMode"] = self.scanMode!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("BitrateBnd") {
                            var model = QueryJobListResponseBody.JobList.Job.Output.Video.BitrateBnd()
                            model.fromMap(dict["BitrateBnd"] as! [String: Any])
                            self.bitrateBnd = model
                        }
                        if dict.keys.contains("Bufsize") {
                            self.bufsize = dict["Bufsize"] as! String
                        }
                        if dict.keys.contains("Codec") {
                            self.codec = dict["Codec"] as! String
                        }
                        if dict.keys.contains("Crf") {
                            self.crf = dict["Crf"] as! String
                        }
                        if dict.keys.contains("Crop") {
                            self.crop = dict["Crop"] as! String
                        }
                        if dict.keys.contains("Degrain") {
                            self.degrain = dict["Degrain"] as! String
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Gop") {
                            self.gop = dict["Gop"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("MaxFps") {
                            self.maxFps = dict["MaxFps"] as! String
                        }
                        if dict.keys.contains("Maxrate") {
                            self.maxrate = dict["Maxrate"] as! String
                        }
                        if dict.keys.contains("Pad") {
                            self.pad = dict["Pad"] as! String
                        }
                        if dict.keys.contains("PixFmt") {
                            self.pixFmt = dict["PixFmt"] as! String
                        }
                        if dict.keys.contains("Preset") {
                            self.preset = dict["Preset"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Qscale") {
                            self.qscale = dict["Qscale"] as! String
                        }
                        if dict.keys.contains("ResoPriority") {
                            self.resoPriority = dict["ResoPriority"] as! String
                        }
                        if dict.keys.contains("ScanMode") {
                            self.scanMode = dict["ScanMode"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public class WaterMarkList : Tea.TeaModel {
                    public class WaterMark : Tea.TeaModel {
                        public class InputFile : Tea.TeaModel {
                            public var bucket: String?

                            public var location: String?

                            public var object: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bucket != nil {
                                    map["Bucket"] = self.bucket!
                                }
                                if self.location != nil {
                                    map["Location"] = self.location!
                                }
                                if self.object != nil {
                                    map["Object"] = self.object!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bucket") {
                                    self.bucket = dict["Bucket"] as! String
                                }
                                if dict.keys.contains("Location") {
                                    self.location = dict["Location"] as! String
                                }
                                if dict.keys.contains("Object") {
                                    self.object = dict["Object"] as! String
                                }
                            }
                        }
                        public var dx: String?

                        public var dy: String?

                        public var height: String?

                        public var inputFile: QueryJobListResponseBody.JobList.Job.Output.WaterMarkList.WaterMark.InputFile?

                        public var referPos: String?

                        public var type: String?

                        public var waterMarkTemplateId: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.inputFile?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.dx != nil {
                                map["Dx"] = self.dx!
                            }
                            if self.dy != nil {
                                map["Dy"] = self.dy!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.inputFile != nil {
                                map["InputFile"] = self.inputFile?.toMap()
                            }
                            if self.referPos != nil {
                                map["ReferPos"] = self.referPos!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            if self.waterMarkTemplateId != nil {
                                map["WaterMarkTemplateId"] = self.waterMarkTemplateId!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Dx") {
                                self.dx = dict["Dx"] as! String
                            }
                            if dict.keys.contains("Dy") {
                                self.dy = dict["Dy"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("InputFile") {
                                var model = QueryJobListResponseBody.JobList.Job.Output.WaterMarkList.WaterMark.InputFile()
                                model.fromMap(dict["InputFile"] as! [String: Any])
                                self.inputFile = model
                            }
                            if dict.keys.contains("ReferPos") {
                                self.referPos = dict["ReferPos"] as! String
                            }
                            if dict.keys.contains("Type") {
                                self.type = dict["Type"] as! String
                            }
                            if dict.keys.contains("WaterMarkTemplateId") {
                                self.waterMarkTemplateId = dict["WaterMarkTemplateId"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var waterMark: [QueryJobListResponseBody.JobList.Job.Output.WaterMarkList.WaterMark]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.waterMark != nil {
                            var tmp : [Any] = []
                            for k in self.waterMark! {
                                tmp.append(k.toMap())
                            }
                            map["WaterMark"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("WaterMark") {
                            var tmp : [QueryJobListResponseBody.JobList.Job.Output.WaterMarkList.WaterMark] = []
                            for v in dict["WaterMark"] as! [Any] {
                                var model = QueryJobListResponseBody.JobList.Job.Output.WaterMarkList.WaterMark()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.waterMark = tmp
                        }
                    }
                }
                public var audio: QueryJobListResponseBody.JobList.Job.Output.Audio?

                public var audioStreamMap: String?

                public var clip: QueryJobListResponseBody.JobList.Job.Output.Clip?

                public var container: QueryJobListResponseBody.JobList.Job.Output.Container?

                public var deWatermark: String?

                public var encryption: QueryJobListResponseBody.JobList.Job.Output.Encryption?

                public var extendData: String?

                public var m3U8NonStandardSupport: QueryJobListResponseBody.JobList.Job.Output.M3U8NonStandardSupport?

                public var mergeConfigUrl: String?

                public var mergeList: QueryJobListResponseBody.JobList.Job.Output.MergeList?

                public var multiSpeedInfo: QueryJobListResponseBody.JobList.Job.Output.MultiSpeedInfo?

                public var muxConfig: QueryJobListResponseBody.JobList.Job.Output.MuxConfig?

                public var openingList: QueryJobListResponseBody.JobList.Job.Output.OpeningList?

                public var outSubtitleList: QueryJobListResponseBody.JobList.Job.Output.OutSubtitleList?

                public var outputFile: QueryJobListResponseBody.JobList.Job.Output.OutputFile?

                public var priority: String?

                public var properties: QueryJobListResponseBody.JobList.Job.Output.Properties?

                public var rotate: String?

                public var subtitleConfig: QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig?

                public var superReso: QueryJobListResponseBody.JobList.Job.Output.SuperReso?

                public var tailSlateList: QueryJobListResponseBody.JobList.Job.Output.TailSlateList?

                public var templateId: String?

                public var transConfig: QueryJobListResponseBody.JobList.Job.Output.TransConfig?

                public var userData: String?

                public var video: QueryJobListResponseBody.JobList.Job.Output.Video?

                public var videoStreamMap: String?

                public var waterMarkConfigUrl: String?

                public var waterMarkList: QueryJobListResponseBody.JobList.Job.Output.WaterMarkList?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.audio?.validate()
                    try self.clip?.validate()
                    try self.container?.validate()
                    try self.encryption?.validate()
                    try self.m3U8NonStandardSupport?.validate()
                    try self.mergeList?.validate()
                    try self.multiSpeedInfo?.validate()
                    try self.muxConfig?.validate()
                    try self.openingList?.validate()
                    try self.outSubtitleList?.validate()
                    try self.outputFile?.validate()
                    try self.properties?.validate()
                    try self.subtitleConfig?.validate()
                    try self.superReso?.validate()
                    try self.tailSlateList?.validate()
                    try self.transConfig?.validate()
                    try self.video?.validate()
                    try self.waterMarkList?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audio != nil {
                        map["Audio"] = self.audio?.toMap()
                    }
                    if self.audioStreamMap != nil {
                        map["AudioStreamMap"] = self.audioStreamMap!
                    }
                    if self.clip != nil {
                        map["Clip"] = self.clip?.toMap()
                    }
                    if self.container != nil {
                        map["Container"] = self.container?.toMap()
                    }
                    if self.deWatermark != nil {
                        map["DeWatermark"] = self.deWatermark!
                    }
                    if self.encryption != nil {
                        map["Encryption"] = self.encryption?.toMap()
                    }
                    if self.extendData != nil {
                        map["ExtendData"] = self.extendData!
                    }
                    if self.m3U8NonStandardSupport != nil {
                        map["M3U8NonStandardSupport"] = self.m3U8NonStandardSupport?.toMap()
                    }
                    if self.mergeConfigUrl != nil {
                        map["MergeConfigUrl"] = self.mergeConfigUrl!
                    }
                    if self.mergeList != nil {
                        map["MergeList"] = self.mergeList?.toMap()
                    }
                    if self.multiSpeedInfo != nil {
                        map["MultiSpeedInfo"] = self.multiSpeedInfo?.toMap()
                    }
                    if self.muxConfig != nil {
                        map["MuxConfig"] = self.muxConfig?.toMap()
                    }
                    if self.openingList != nil {
                        map["OpeningList"] = self.openingList?.toMap()
                    }
                    if self.outSubtitleList != nil {
                        map["OutSubtitleList"] = self.outSubtitleList?.toMap()
                    }
                    if self.outputFile != nil {
                        map["OutputFile"] = self.outputFile?.toMap()
                    }
                    if self.priority != nil {
                        map["Priority"] = self.priority!
                    }
                    if self.properties != nil {
                        map["Properties"] = self.properties?.toMap()
                    }
                    if self.rotate != nil {
                        map["Rotate"] = self.rotate!
                    }
                    if self.subtitleConfig != nil {
                        map["SubtitleConfig"] = self.subtitleConfig?.toMap()
                    }
                    if self.superReso != nil {
                        map["SuperReso"] = self.superReso?.toMap()
                    }
                    if self.tailSlateList != nil {
                        map["TailSlateList"] = self.tailSlateList?.toMap()
                    }
                    if self.templateId != nil {
                        map["TemplateId"] = self.templateId!
                    }
                    if self.transConfig != nil {
                        map["TransConfig"] = self.transConfig?.toMap()
                    }
                    if self.userData != nil {
                        map["UserData"] = self.userData!
                    }
                    if self.video != nil {
                        map["Video"] = self.video?.toMap()
                    }
                    if self.videoStreamMap != nil {
                        map["VideoStreamMap"] = self.videoStreamMap!
                    }
                    if self.waterMarkConfigUrl != nil {
                        map["WaterMarkConfigUrl"] = self.waterMarkConfigUrl!
                    }
                    if self.waterMarkList != nil {
                        map["WaterMarkList"] = self.waterMarkList?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Audio") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.Audio()
                        model.fromMap(dict["Audio"] as! [String: Any])
                        self.audio = model
                    }
                    if dict.keys.contains("AudioStreamMap") {
                        self.audioStreamMap = dict["AudioStreamMap"] as! String
                    }
                    if dict.keys.contains("Clip") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.Clip()
                        model.fromMap(dict["Clip"] as! [String: Any])
                        self.clip = model
                    }
                    if dict.keys.contains("Container") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.Container()
                        model.fromMap(dict["Container"] as! [String: Any])
                        self.container = model
                    }
                    if dict.keys.contains("DeWatermark") {
                        self.deWatermark = dict["DeWatermark"] as! String
                    }
                    if dict.keys.contains("Encryption") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.Encryption()
                        model.fromMap(dict["Encryption"] as! [String: Any])
                        self.encryption = model
                    }
                    if dict.keys.contains("ExtendData") {
                        self.extendData = dict["ExtendData"] as! String
                    }
                    if dict.keys.contains("M3U8NonStandardSupport") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.M3U8NonStandardSupport()
                        model.fromMap(dict["M3U8NonStandardSupport"] as! [String: Any])
                        self.m3U8NonStandardSupport = model
                    }
                    if dict.keys.contains("MergeConfigUrl") {
                        self.mergeConfigUrl = dict["MergeConfigUrl"] as! String
                    }
                    if dict.keys.contains("MergeList") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.MergeList()
                        model.fromMap(dict["MergeList"] as! [String: Any])
                        self.mergeList = model
                    }
                    if dict.keys.contains("MultiSpeedInfo") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.MultiSpeedInfo()
                        model.fromMap(dict["MultiSpeedInfo"] as! [String: Any])
                        self.multiSpeedInfo = model
                    }
                    if dict.keys.contains("MuxConfig") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.MuxConfig()
                        model.fromMap(dict["MuxConfig"] as! [String: Any])
                        self.muxConfig = model
                    }
                    if dict.keys.contains("OpeningList") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.OpeningList()
                        model.fromMap(dict["OpeningList"] as! [String: Any])
                        self.openingList = model
                    }
                    if dict.keys.contains("OutSubtitleList") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.OutSubtitleList()
                        model.fromMap(dict["OutSubtitleList"] as! [String: Any])
                        self.outSubtitleList = model
                    }
                    if dict.keys.contains("OutputFile") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.OutputFile()
                        model.fromMap(dict["OutputFile"] as! [String: Any])
                        self.outputFile = model
                    }
                    if dict.keys.contains("Priority") {
                        self.priority = dict["Priority"] as! String
                    }
                    if dict.keys.contains("Properties") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.Properties()
                        model.fromMap(dict["Properties"] as! [String: Any])
                        self.properties = model
                    }
                    if dict.keys.contains("Rotate") {
                        self.rotate = dict["Rotate"] as! String
                    }
                    if dict.keys.contains("SubtitleConfig") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.SubtitleConfig()
                        model.fromMap(dict["SubtitleConfig"] as! [String: Any])
                        self.subtitleConfig = model
                    }
                    if dict.keys.contains("SuperReso") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.SuperReso()
                        model.fromMap(dict["SuperReso"] as! [String: Any])
                        self.superReso = model
                    }
                    if dict.keys.contains("TailSlateList") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.TailSlateList()
                        model.fromMap(dict["TailSlateList"] as! [String: Any])
                        self.tailSlateList = model
                    }
                    if dict.keys.contains("TemplateId") {
                        self.templateId = dict["TemplateId"] as! String
                    }
                    if dict.keys.contains("TransConfig") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.TransConfig()
                        model.fromMap(dict["TransConfig"] as! [String: Any])
                        self.transConfig = model
                    }
                    if dict.keys.contains("UserData") {
                        self.userData = dict["UserData"] as! String
                    }
                    if dict.keys.contains("Video") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.Video()
                        model.fromMap(dict["Video"] as! [String: Any])
                        self.video = model
                    }
                    if dict.keys.contains("VideoStreamMap") {
                        self.videoStreamMap = dict["VideoStreamMap"] as! String
                    }
                    if dict.keys.contains("WaterMarkConfigUrl") {
                        self.waterMarkConfigUrl = dict["WaterMarkConfigUrl"] as! String
                    }
                    if dict.keys.contains("WaterMarkList") {
                        var model = QueryJobListResponseBody.JobList.Job.Output.WaterMarkList()
                        model.fromMap(dict["WaterMarkList"] as! [String: Any])
                        self.waterMarkList = model
                    }
                }
            }
            public var code: String?

            public var creationTime: String?

            public var finishTime: String?

            public var input: QueryJobListResponseBody.JobList.Job.Input?

            public var jobId: String?

            public var MNSMessageResult: QueryJobListResponseBody.JobList.Job.MNSMessageResult?

            public var message: String?

            public var output: QueryJobListResponseBody.JobList.Job.Output?

            public var percent: Int64?

            public var pipelineId: String?

            public var state: String?

            public var submitTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.input?.validate()
                try self.MNSMessageResult?.validate()
                try self.output?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.MNSMessageResult != nil {
                    map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.output != nil {
                    map["Output"] = self.output?.toMap()
                }
                if self.percent != nil {
                    map["Percent"] = self.percent!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.submitTime != nil {
                    map["SubmitTime"] = self.submitTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("Input") {
                    var model = QueryJobListResponseBody.JobList.Job.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("MNSMessageResult") {
                    var model = QueryJobListResponseBody.JobList.Job.MNSMessageResult()
                    model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                    self.MNSMessageResult = model
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Output") {
                    var model = QueryJobListResponseBody.JobList.Job.Output()
                    model.fromMap(dict["Output"] as! [String: Any])
                    self.output = model
                }
                if dict.keys.contains("Percent") {
                    self.percent = dict["Percent"] as! Int64
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("SubmitTime") {
                    self.submitTime = dict["SubmitTime"] as! String
                }
            }
        }
        public var job: [QueryJobListResponseBody.JobList.Job]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.job != nil {
                var tmp : [Any] = []
                for k in self.job! {
                    tmp.append(k.toMap())
                }
                map["Job"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Job") {
                var tmp : [QueryJobListResponseBody.JobList.Job] = []
                for v in dict["Job"] as! [Any] {
                    var model = QueryJobListResponseBody.JobList.Job()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.job = tmp
            }
        }
    }
    public class NonExistJobIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public var jobList: QueryJobListResponseBody.JobList?

    public var nonExistJobIds: QueryJobListResponseBody.NonExistJobIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobList?.validate()
        try self.nonExistJobIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobList != nil {
            map["JobList"] = self.jobList?.toMap()
        }
        if self.nonExistJobIds != nil {
            map["NonExistJobIds"] = self.nonExistJobIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobList") {
            var model = QueryJobListResponseBody.JobList()
            model.fromMap(dict["JobList"] as! [String: Any])
            self.jobList = model
        }
        if dict.keys.contains("NonExistJobIds") {
            var model = QueryJobListResponseBody.NonExistJobIds()
            model.fromMap(dict["NonExistJobIds"] as! [String: Any])
            self.nonExistJobIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaCensorJobDetailRequest : Tea.TeaModel {
    public var jobId: String?

    public var maximumPageSize: Int64?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.maximumPageSize != nil {
            map["MaximumPageSize"] = self.maximumPageSize!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MaximumPageSize") {
            self.maximumPageSize = dict["MaximumPageSize"] as! Int64
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryMediaCensorJobDetailResponseBody : Tea.TeaModel {
    public class MediaCensorJobDetail : Tea.TeaModel {
        public class AudioCensorResult : Tea.TeaModel {
            public class AudioDetailResultList : Tea.TeaModel {
                public class AudioDetailResult : Tea.TeaModel {
                    public var endTime: Int32?

                    public var label: String?

                    public var startTime: Int32?

                    public var text: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.text != nil {
                            map["Text"] = self.text!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EndTime") {
                            self.endTime = dict["EndTime"] as! Int32
                        }
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! Int32
                        }
                        if dict.keys.contains("Text") {
                            self.text = dict["Text"] as! String
                        }
                    }
                }
                public var audioDetailResult: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.AudioCensorResult.AudioDetailResultList.AudioDetailResult]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioDetailResult != nil {
                        var tmp : [Any] = []
                        for k in self.audioDetailResult! {
                            tmp.append(k.toMap())
                        }
                        map["AudioDetailResult"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioDetailResult") {
                        var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.AudioCensorResult.AudioDetailResultList.AudioDetailResult] = []
                        for v in dict["AudioDetailResult"] as! [Any] {
                            var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.AudioCensorResult.AudioDetailResultList.AudioDetailResult()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.audioDetailResult = tmp
                    }
                }
            }
            public var audioDetailResultList: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.AudioCensorResult.AudioDetailResultList?

            public var label: String?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audioDetailResultList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioDetailResultList != nil {
                    map["AudioDetailResultList"] = self.audioDetailResultList?.toMap()
                }
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioDetailResultList") {
                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.AudioCensorResult.AudioDetailResultList()
                    model.fromMap(dict["AudioDetailResultList"] as! [String: Any])
                    self.audioDetailResultList = model
                }
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class BarrageCensorResult : Tea.TeaModel {
            public var label: String?

            public var rate: String?

            public var scene: String?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Rate") {
                    self.rate = dict["Rate"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class CoverImageCensorResults : Tea.TeaModel {
            public class CoverImageCensorResult : Tea.TeaModel {
                public class Results : Tea.TeaModel {
                    public class Result : Tea.TeaModel {
                        public var label: String?

                        public var rate: String?

                        public var scene: String?

                        public var suggestion: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.rate != nil {
                                map["Rate"] = self.rate!
                            }
                            if self.scene != nil {
                                map["Scene"] = self.scene!
                            }
                            if self.suggestion != nil {
                                map["Suggestion"] = self.suggestion!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Rate") {
                                self.rate = dict["Rate"] as! String
                            }
                            if dict.keys.contains("Scene") {
                                self.scene = dict["Scene"] as! String
                            }
                            if dict.keys.contains("Suggestion") {
                                self.suggestion = dict["Suggestion"] as! String
                            }
                        }
                    }
                    public var result: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results.Result]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.result != nil {
                            var tmp : [Any] = []
                            for k in self.result! {
                                tmp.append(k.toMap())
                            }
                            map["Result"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Result") {
                            var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results.Result] = []
                            for v in dict["Result"] as! [Any] {
                                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results.Result()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.result = tmp
                        }
                    }
                }
                public var bucket: String?

                public var location: String?

                public var object: String?

                public var results: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.results?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    if self.results != nil {
                        map["Results"] = self.results?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                    if dict.keys.contains("Results") {
                        var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult.Results()
                        model.fromMap(dict["Results"] as! [String: Any])
                        self.results = model
                    }
                }
            }
            public var coverImageCensorResult: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coverImageCensorResult != nil {
                    var tmp : [Any] = []
                    for k in self.coverImageCensorResult! {
                        tmp.append(k.toMap())
                    }
                    map["CoverImageCensorResult"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CoverImageCensorResult") {
                    var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult] = []
                    for v in dict["CoverImageCensorResult"] as! [Any] {
                        var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults.CoverImageCensorResult()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.coverImageCensorResult = tmp
                }
            }
        }
        public class DescCensorResult : Tea.TeaModel {
            public var label: String?

            public var rate: String?

            public var scene: String?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Rate") {
                    self.rate = dict["Rate"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class Input : Tea.TeaModel {
            public var bucket: String?

            public var location: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("Object") {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public class TitleCensorResult : Tea.TeaModel {
            public var label: String?

            public var rate: String?

            public var scene: String?

            public var suggestion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.label != nil {
                    map["Label"] = self.label!
                }
                if self.rate != nil {
                    map["Rate"] = self.rate!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Label") {
                    self.label = dict["Label"] as! String
                }
                if dict.keys.contains("Rate") {
                    self.rate = dict["Rate"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
            }
        }
        public class VensorCensorResult : Tea.TeaModel {
            public class CensorResults : Tea.TeaModel {
                public class CensorResult : Tea.TeaModel {
                    public var label: String?

                    public var rate: String?

                    public var scene: String?

                    public var suggestion: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.label != nil {
                            map["Label"] = self.label!
                        }
                        if self.rate != nil {
                            map["Rate"] = self.rate!
                        }
                        if self.scene != nil {
                            map["Scene"] = self.scene!
                        }
                        if self.suggestion != nil {
                            map["Suggestion"] = self.suggestion!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Label") {
                            self.label = dict["Label"] as! String
                        }
                        if dict.keys.contains("Rate") {
                            self.rate = dict["Rate"] as! String
                        }
                        if dict.keys.contains("Scene") {
                            self.scene = dict["Scene"] as! String
                        }
                        if dict.keys.contains("Suggestion") {
                            self.suggestion = dict["Suggestion"] as! String
                        }
                    }
                }
                public var censorResult: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults.CensorResult]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.censorResult != nil {
                        var tmp : [Any] = []
                        for k in self.censorResult! {
                            tmp.append(k.toMap())
                        }
                        map["CensorResult"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CensorResult") {
                        var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults.CensorResult] = []
                        for v in dict["CensorResult"] as! [Any] {
                            var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults.CensorResult()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.censorResult = tmp
                    }
                }
            }
            public class VideoTimelines : Tea.TeaModel {
                public class VideoTimeline : Tea.TeaModel {
                    public class CensorResults : Tea.TeaModel {
                        public class CensorResult : Tea.TeaModel {
                            public var label: String?

                            public var rate: String?

                            public var scene: String?

                            public var suggestion: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.label != nil {
                                    map["Label"] = self.label!
                                }
                                if self.rate != nil {
                                    map["Rate"] = self.rate!
                                }
                                if self.scene != nil {
                                    map["Scene"] = self.scene!
                                }
                                if self.suggestion != nil {
                                    map["Suggestion"] = self.suggestion!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Label") {
                                    self.label = dict["Label"] as! String
                                }
                                if dict.keys.contains("Rate") {
                                    self.rate = dict["Rate"] as! String
                                }
                                if dict.keys.contains("Scene") {
                                    self.scene = dict["Scene"] as! String
                                }
                                if dict.keys.contains("Suggestion") {
                                    self.suggestion = dict["Suggestion"] as! String
                                }
                            }
                        }
                        public var censorResult: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.censorResult != nil {
                                var tmp : [Any] = []
                                for k in self.censorResult! {
                                    tmp.append(k.toMap())
                                }
                                map["CensorResult"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CensorResult") {
                                var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult] = []
                                for v in dict["CensorResult"] as! [Any] {
                                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.censorResult = tmp
                            }
                        }
                    }
                    public var censorResults: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults?

                    public var object: String?

                    public var timestamp: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.censorResults?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.censorResults != nil {
                            map["CensorResults"] = self.censorResults?.toMap()
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        if self.timestamp != nil {
                            map["Timestamp"] = self.timestamp!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CensorResults") {
                            var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults()
                            model.fromMap(dict["CensorResults"] as! [String: Any])
                            self.censorResults = model
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                        if dict.keys.contains("Timestamp") {
                            self.timestamp = dict["Timestamp"] as! String
                        }
                    }
                }
                public var videoTimeline: [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.videoTimeline != nil {
                        var tmp : [Any] = []
                        for k in self.videoTimeline! {
                            tmp.append(k.toMap())
                        }
                        map["VideoTimeline"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("VideoTimeline") {
                        var tmp : [QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline] = []
                        for v in dict["VideoTimeline"] as! [Any] {
                            var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines.VideoTimeline()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.videoTimeline = tmp
                    }
                }
            }
            public var censorResults: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults?

            public var nextPageToken: String?

            public var videoTimelines: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.censorResults?.validate()
                try self.videoTimelines?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.censorResults != nil {
                    map["CensorResults"] = self.censorResults?.toMap()
                }
                if self.nextPageToken != nil {
                    map["NextPageToken"] = self.nextPageToken!
                }
                if self.videoTimelines != nil {
                    map["VideoTimelines"] = self.videoTimelines?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CensorResults") {
                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.CensorResults()
                    model.fromMap(dict["CensorResults"] as! [String: Any])
                    self.censorResults = model
                }
                if dict.keys.contains("NextPageToken") {
                    self.nextPageToken = dict["NextPageToken"] as! String
                }
                if dict.keys.contains("VideoTimelines") {
                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult.VideoTimelines()
                    model.fromMap(dict["VideoTimelines"] as! [String: Any])
                    self.videoTimelines = model
                }
            }
        }
        public class VideoCensorConfig : Tea.TeaModel {
            public class OutputFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public var bizType: String?

            public var outputFile: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig.OutputFile?

            public var videoCensor: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputFile?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizType != nil {
                    map["BizType"] = self.bizType!
                }
                if self.outputFile != nil {
                    map["OutputFile"] = self.outputFile?.toMap()
                }
                if self.videoCensor != nil {
                    map["VideoCensor"] = self.videoCensor!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizType") {
                    self.bizType = dict["BizType"] as! String
                }
                if dict.keys.contains("OutputFile") {
                    var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig.OutputFile()
                    model.fromMap(dict["OutputFile"] as! [String: Any])
                    self.outputFile = model
                }
                if dict.keys.contains("VideoCensor") {
                    self.videoCensor = dict["VideoCensor"] as! String
                }
            }
        }
        public var audioCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.AudioCensorResult?

        public var barrageCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.BarrageCensorResult?

        public var code: String?

        public var coverImageCensorResults: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults?

        public var creationTime: String?

        public var descCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.DescCensorResult?

        public var finishTime: String?

        public var input: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.Input?

        public var jobId: String?

        public var message: String?

        public var pipelineId: String?

        public var state: String?

        public var suggestion: String?

        public var titleCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.TitleCensorResult?

        public var userData: String?

        public var vensorCensorResult: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult?

        public var videoCensorConfig: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.audioCensorResult?.validate()
            try self.barrageCensorResult?.validate()
            try self.coverImageCensorResults?.validate()
            try self.descCensorResult?.validate()
            try self.input?.validate()
            try self.titleCensorResult?.validate()
            try self.vensorCensorResult?.validate()
            try self.videoCensorConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioCensorResult != nil {
                map["AudioCensorResult"] = self.audioCensorResult?.toMap()
            }
            if self.barrageCensorResult != nil {
                map["BarrageCensorResult"] = self.barrageCensorResult?.toMap()
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.coverImageCensorResults != nil {
                map["CoverImageCensorResults"] = self.coverImageCensorResults?.toMap()
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.descCensorResult != nil {
                map["DescCensorResult"] = self.descCensorResult?.toMap()
            }
            if self.finishTime != nil {
                map["FinishTime"] = self.finishTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.suggestion != nil {
                map["Suggestion"] = self.suggestion!
            }
            if self.titleCensorResult != nil {
                map["TitleCensorResult"] = self.titleCensorResult?.toMap()
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.vensorCensorResult != nil {
                map["VensorCensorResult"] = self.vensorCensorResult?.toMap()
            }
            if self.videoCensorConfig != nil {
                map["VideoCensorConfig"] = self.videoCensorConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioCensorResult") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.AudioCensorResult()
                model.fromMap(dict["AudioCensorResult"] as! [String: Any])
                self.audioCensorResult = model
            }
            if dict.keys.contains("BarrageCensorResult") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.BarrageCensorResult()
                model.fromMap(dict["BarrageCensorResult"] as! [String: Any])
                self.barrageCensorResult = model
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CoverImageCensorResults") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.CoverImageCensorResults()
                model.fromMap(dict["CoverImageCensorResults"] as! [String: Any])
                self.coverImageCensorResults = model
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DescCensorResult") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.DescCensorResult()
                model.fromMap(dict["DescCensorResult"] as! [String: Any])
                self.descCensorResult = model
            }
            if dict.keys.contains("FinishTime") {
                self.finishTime = dict["FinishTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Suggestion") {
                self.suggestion = dict["Suggestion"] as! String
            }
            if dict.keys.contains("TitleCensorResult") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.TitleCensorResult()
                model.fromMap(dict["TitleCensorResult"] as! [String: Any])
                self.titleCensorResult = model
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("VensorCensorResult") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VensorCensorResult()
                model.fromMap(dict["VensorCensorResult"] as! [String: Any])
                self.vensorCensorResult = model
            }
            if dict.keys.contains("VideoCensorConfig") {
                var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail.VideoCensorConfig()
                model.fromMap(dict["VideoCensorConfig"] as! [String: Any])
                self.videoCensorConfig = model
            }
        }
    }
    public var mediaCensorJobDetail: QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaCensorJobDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaCensorJobDetail != nil {
            map["MediaCensorJobDetail"] = self.mediaCensorJobDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaCensorJobDetail") {
            var model = QueryMediaCensorJobDetailResponseBody.MediaCensorJobDetail()
            model.fromMap(dict["MediaCensorJobDetail"] as! [String: Any])
            self.mediaCensorJobDetail = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMediaCensorJobDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaCensorJobDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMediaCensorJobDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaCensorJobListRequest : Tea.TeaModel {
    public var endOfJobCreatedTimeRange: String?

    public var jobIds: String?

    public var maximumPageSize: Int64?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startOfJobCreatedTimeRange: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfJobCreatedTimeRange != nil {
            map["EndOfJobCreatedTimeRange"] = self.endOfJobCreatedTimeRange!
        }
        if self.jobIds != nil {
            map["JobIds"] = self.jobIds!
        }
        if self.maximumPageSize != nil {
            map["MaximumPageSize"] = self.maximumPageSize!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startOfJobCreatedTimeRange != nil {
            map["StartOfJobCreatedTimeRange"] = self.startOfJobCreatedTimeRange!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfJobCreatedTimeRange") {
            self.endOfJobCreatedTimeRange = dict["EndOfJobCreatedTimeRange"] as! String
        }
        if dict.keys.contains("JobIds") {
            self.jobIds = dict["JobIds"] as! String
        }
        if dict.keys.contains("MaximumPageSize") {
            self.maximumPageSize = dict["MaximumPageSize"] as! Int64
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartOfJobCreatedTimeRange") {
            self.startOfJobCreatedTimeRange = dict["StartOfJobCreatedTimeRange"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class QueryMediaCensorJobListResponseBody : Tea.TeaModel {
    public class MediaCensorJobList : Tea.TeaModel {
        public class MediaCensorJob : Tea.TeaModel {
            public class AudioCensorResult : Tea.TeaModel {
                public var label: String?

                public var suggestion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                }
            }
            public class BarrageCensorResult : Tea.TeaModel {
                public var label: String?

                public var rate: String?

                public var scene: String?

                public var suggestion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    if self.scene != nil {
                        map["Scene"] = self.scene!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Rate") {
                        self.rate = dict["Rate"] as! String
                    }
                    if dict.keys.contains("Scene") {
                        self.scene = dict["Scene"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                }
            }
            public class CoverImageCensorResults : Tea.TeaModel {
                public class CoverImageCensorResult : Tea.TeaModel {
                    public class Results : Tea.TeaModel {
                        public class Result : Tea.TeaModel {
                            public var label: String?

                            public var rate: String?

                            public var scene: String?

                            public var suggestion: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.label != nil {
                                    map["Label"] = self.label!
                                }
                                if self.rate != nil {
                                    map["Rate"] = self.rate!
                                }
                                if self.scene != nil {
                                    map["Scene"] = self.scene!
                                }
                                if self.suggestion != nil {
                                    map["Suggestion"] = self.suggestion!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Label") {
                                    self.label = dict["Label"] as! String
                                }
                                if dict.keys.contains("Rate") {
                                    self.rate = dict["Rate"] as! String
                                }
                                if dict.keys.contains("Scene") {
                                    self.scene = dict["Scene"] as! String
                                }
                                if dict.keys.contains("Suggestion") {
                                    self.suggestion = dict["Suggestion"] as! String
                                }
                            }
                        }
                        public var result: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results.Result]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.result != nil {
                                var tmp : [Any] = []
                                for k in self.result! {
                                    tmp.append(k.toMap())
                                }
                                map["Result"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Result") {
                                var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results.Result] = []
                                for v in dict["Result"] as! [Any] {
                                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results.Result()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.result = tmp
                            }
                        }
                    }
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public var results: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.results?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        if self.results != nil {
                            map["Results"] = self.results?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                        if dict.keys.contains("Results") {
                            var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult.Results()
                            model.fromMap(dict["Results"] as! [String: Any])
                            self.results = model
                        }
                    }
                }
                public var coverImageCensorResult: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.coverImageCensorResult != nil {
                        var tmp : [Any] = []
                        for k in self.coverImageCensorResult! {
                            tmp.append(k.toMap())
                        }
                        map["CoverImageCensorResult"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CoverImageCensorResult") {
                        var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult] = []
                        for v in dict["CoverImageCensorResult"] as! [Any] {
                            var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults.CoverImageCensorResult()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.coverImageCensorResult = tmp
                    }
                }
            }
            public class DescCensorResult : Tea.TeaModel {
                public var label: String?

                public var rate: String?

                public var scene: String?

                public var suggestion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    if self.scene != nil {
                        map["Scene"] = self.scene!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Rate") {
                        self.rate = dict["Rate"] as! String
                    }
                    if dict.keys.contains("Scene") {
                        self.scene = dict["Scene"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                }
            }
            public class Input : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public class TitleCensorResult : Tea.TeaModel {
                public var label: String?

                public var rate: String?

                public var scene: String?

                public var suggestion: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.label != nil {
                        map["Label"] = self.label!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    if self.scene != nil {
                        map["Scene"] = self.scene!
                    }
                    if self.suggestion != nil {
                        map["Suggestion"] = self.suggestion!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Label") {
                        self.label = dict["Label"] as! String
                    }
                    if dict.keys.contains("Rate") {
                        self.rate = dict["Rate"] as! String
                    }
                    if dict.keys.contains("Scene") {
                        self.scene = dict["Scene"] as! String
                    }
                    if dict.keys.contains("Suggestion") {
                        self.suggestion = dict["Suggestion"] as! String
                    }
                }
            }
            public class VensorCensorResult : Tea.TeaModel {
                public class CensorResults : Tea.TeaModel {
                    public class CensorResult : Tea.TeaModel {
                        public var label: String?

                        public var rate: String?

                        public var scene: String?

                        public var suggestion: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.label != nil {
                                map["Label"] = self.label!
                            }
                            if self.rate != nil {
                                map["Rate"] = self.rate!
                            }
                            if self.scene != nil {
                                map["Scene"] = self.scene!
                            }
                            if self.suggestion != nil {
                                map["Suggestion"] = self.suggestion!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Label") {
                                self.label = dict["Label"] as! String
                            }
                            if dict.keys.contains("Rate") {
                                self.rate = dict["Rate"] as! String
                            }
                            if dict.keys.contains("Scene") {
                                self.scene = dict["Scene"] as! String
                            }
                            if dict.keys.contains("Suggestion") {
                                self.suggestion = dict["Suggestion"] as! String
                            }
                        }
                    }
                    public var censorResult: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults.CensorResult]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.censorResult != nil {
                            var tmp : [Any] = []
                            for k in self.censorResult! {
                                tmp.append(k.toMap())
                            }
                            map["CensorResult"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CensorResult") {
                            var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults.CensorResult] = []
                            for v in dict["CensorResult"] as! [Any] {
                                var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults.CensorResult()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.censorResult = tmp
                        }
                    }
                }
                public class VideoTimelines : Tea.TeaModel {
                    public class VideoTimeline : Tea.TeaModel {
                        public class CensorResults : Tea.TeaModel {
                            public class CensorResult : Tea.TeaModel {
                                public var label: String?

                                public var rate: String?

                                public var scene: String?

                                public var suggestion: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.label != nil {
                                        map["Label"] = self.label!
                                    }
                                    if self.rate != nil {
                                        map["Rate"] = self.rate!
                                    }
                                    if self.scene != nil {
                                        map["Scene"] = self.scene!
                                    }
                                    if self.suggestion != nil {
                                        map["Suggestion"] = self.suggestion!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Label") {
                                        self.label = dict["Label"] as! String
                                    }
                                    if dict.keys.contains("Rate") {
                                        self.rate = dict["Rate"] as! String
                                    }
                                    if dict.keys.contains("Scene") {
                                        self.scene = dict["Scene"] as! String
                                    }
                                    if dict.keys.contains("Suggestion") {
                                        self.suggestion = dict["Suggestion"] as! String
                                    }
                                }
                            }
                            public var censorResult: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.censorResult != nil {
                                    var tmp : [Any] = []
                                    for k in self.censorResult! {
                                        tmp.append(k.toMap())
                                    }
                                    map["CensorResult"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("CensorResult") {
                                    var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult] = []
                                    for v in dict["CensorResult"] as! [Any] {
                                        var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults.CensorResult()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.censorResult = tmp
                                }
                            }
                        }
                        public var censorResults: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults?

                        public var object: String?

                        public var timestamp: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.censorResults?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.censorResults != nil {
                                map["CensorResults"] = self.censorResults?.toMap()
                            }
                            if self.object != nil {
                                map["Object"] = self.object!
                            }
                            if self.timestamp != nil {
                                map["Timestamp"] = self.timestamp!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CensorResults") {
                                var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline.CensorResults()
                                model.fromMap(dict["CensorResults"] as! [String: Any])
                                self.censorResults = model
                            }
                            if dict.keys.contains("Object") {
                                self.object = dict["Object"] as! String
                            }
                            if dict.keys.contains("Timestamp") {
                                self.timestamp = dict["Timestamp"] as! String
                            }
                        }
                    }
                    public var videoTimeline: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.videoTimeline != nil {
                            var tmp : [Any] = []
                            for k in self.videoTimeline! {
                                tmp.append(k.toMap())
                            }
                            map["VideoTimeline"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("VideoTimeline") {
                            var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline] = []
                            for v in dict["VideoTimeline"] as! [Any] {
                                var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines.VideoTimeline()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.videoTimeline = tmp
                        }
                    }
                }
                public var censorResults: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults?

                public var nextPageToken: String?

                public var videoTimelines: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.censorResults?.validate()
                    try self.videoTimelines?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.censorResults != nil {
                        map["CensorResults"] = self.censorResults?.toMap()
                    }
                    if self.nextPageToken != nil {
                        map["NextPageToken"] = self.nextPageToken!
                    }
                    if self.videoTimelines != nil {
                        map["VideoTimelines"] = self.videoTimelines?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CensorResults") {
                        var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.CensorResults()
                        model.fromMap(dict["CensorResults"] as! [String: Any])
                        self.censorResults = model
                    }
                    if dict.keys.contains("NextPageToken") {
                        self.nextPageToken = dict["NextPageToken"] as! String
                    }
                    if dict.keys.contains("VideoTimelines") {
                        var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult.VideoTimelines()
                        model.fromMap(dict["VideoTimelines"] as! [String: Any])
                        self.videoTimelines = model
                    }
                }
            }
            public class VideoCensorConfig : Tea.TeaModel {
                public class OutputFile : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                    }
                }
                public var bizType: String?

                public var outputFile: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VideoCensorConfig.OutputFile?

                public var videoCensor: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.outputFile?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bizType != nil {
                        map["BizType"] = self.bizType!
                    }
                    if self.outputFile != nil {
                        map["OutputFile"] = self.outputFile?.toMap()
                    }
                    if self.videoCensor != nil {
                        map["VideoCensor"] = self.videoCensor!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BizType") {
                        self.bizType = dict["BizType"] as! String
                    }
                    if dict.keys.contains("OutputFile") {
                        var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VideoCensorConfig.OutputFile()
                        model.fromMap(dict["OutputFile"] as! [String: Any])
                        self.outputFile = model
                    }
                    if dict.keys.contains("VideoCensor") {
                        self.videoCensor = dict["VideoCensor"] as! String
                    }
                }
            }
            public var audioCensorResult: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.AudioCensorResult?

            public var barrageCensorResult: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.BarrageCensorResult?

            public var code: String?

            public var coverImageCensorResults: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults?

            public var creationTime: String?

            public var descCensorResult: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.DescCensorResult?

            public var finishTime: String?

            public var input: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.Input?

            public var jobId: String?

            public var message: String?

            public var pipelineId: String?

            public var state: String?

            public var suggestion: String?

            public var titleCensorResult: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.TitleCensorResult?

            public var userData: String?

            public var vensorCensorResult: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult?

            public var videoCensorConfig: QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VideoCensorConfig?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audioCensorResult?.validate()
                try self.barrageCensorResult?.validate()
                try self.coverImageCensorResults?.validate()
                try self.descCensorResult?.validate()
                try self.input?.validate()
                try self.titleCensorResult?.validate()
                try self.vensorCensorResult?.validate()
                try self.videoCensorConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioCensorResult != nil {
                    map["AudioCensorResult"] = self.audioCensorResult?.toMap()
                }
                if self.barrageCensorResult != nil {
                    map["BarrageCensorResult"] = self.barrageCensorResult?.toMap()
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.coverImageCensorResults != nil {
                    map["CoverImageCensorResults"] = self.coverImageCensorResults?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.descCensorResult != nil {
                    map["DescCensorResult"] = self.descCensorResult?.toMap()
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.suggestion != nil {
                    map["Suggestion"] = self.suggestion!
                }
                if self.titleCensorResult != nil {
                    map["TitleCensorResult"] = self.titleCensorResult?.toMap()
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                if self.vensorCensorResult != nil {
                    map["VensorCensorResult"] = self.vensorCensorResult?.toMap()
                }
                if self.videoCensorConfig != nil {
                    map["VideoCensorConfig"] = self.videoCensorConfig?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioCensorResult") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.AudioCensorResult()
                    model.fromMap(dict["AudioCensorResult"] as! [String: Any])
                    self.audioCensorResult = model
                }
                if dict.keys.contains("BarrageCensorResult") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.BarrageCensorResult()
                    model.fromMap(dict["BarrageCensorResult"] as! [String: Any])
                    self.barrageCensorResult = model
                }
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CoverImageCensorResults") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.CoverImageCensorResults()
                    model.fromMap(dict["CoverImageCensorResults"] as! [String: Any])
                    self.coverImageCensorResults = model
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DescCensorResult") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.DescCensorResult()
                    model.fromMap(dict["DescCensorResult"] as! [String: Any])
                    self.descCensorResult = model
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("Input") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Suggestion") {
                    self.suggestion = dict["Suggestion"] as! String
                }
                if dict.keys.contains("TitleCensorResult") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.TitleCensorResult()
                    model.fromMap(dict["TitleCensorResult"] as! [String: Any])
                    self.titleCensorResult = model
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
                if dict.keys.contains("VensorCensorResult") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VensorCensorResult()
                    model.fromMap(dict["VensorCensorResult"] as! [String: Any])
                    self.vensorCensorResult = model
                }
                if dict.keys.contains("VideoCensorConfig") {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob.VideoCensorConfig()
                    model.fromMap(dict["VideoCensorConfig"] as! [String: Any])
                    self.videoCensorConfig = model
                }
            }
        }
        public var mediaCensorJob: [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaCensorJob != nil {
                var tmp : [Any] = []
                for k in self.mediaCensorJob! {
                    tmp.append(k.toMap())
                }
                map["MediaCensorJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaCensorJob") {
                var tmp : [QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob] = []
                for v in dict["MediaCensorJob"] as! [Any] {
                    var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList.MediaCensorJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaCensorJob = tmp
            }
        }
    }
    public class NonExistIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public var mediaCensorJobList: QueryMediaCensorJobListResponseBody.MediaCensorJobList?

    public var nextPageToken: String?

    public var nonExistIds: QueryMediaCensorJobListResponseBody.NonExistIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaCensorJobList?.validate()
        try self.nonExistIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaCensorJobList != nil {
            map["MediaCensorJobList"] = self.mediaCensorJobList?.toMap()
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.nonExistIds != nil {
            map["NonExistIds"] = self.nonExistIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaCensorJobList") {
            var model = QueryMediaCensorJobListResponseBody.MediaCensorJobList()
            model.fromMap(dict["MediaCensorJobList"] as! [String: Any])
            self.mediaCensorJobList = model
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("NonExistIds") {
            var model = QueryMediaCensorJobListResponseBody.NonExistIds()
            model.fromMap(dict["NonExistIds"] as! [String: Any])
            self.nonExistIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMediaCensorJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaCensorJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMediaCensorJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaInfoJobListRequest : Tea.TeaModel {
    public var mediaInfoJobIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfoJobIds != nil {
            map["MediaInfoJobIds"] = self.mediaInfoJobIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfoJobIds") {
            self.mediaInfoJobIds = dict["MediaInfoJobIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryMediaInfoJobListResponseBody : Tea.TeaModel {
    public class MediaInfoJobList : Tea.TeaModel {
        public class MediaInfoJob : Tea.TeaModel {
            public class Input : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                }
            }
            public class MNSMessageResult : Tea.TeaModel {
                public var errorCode: String?

                public var errorMessage: String?

                public var messageId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.messageId != nil {
                        map["MessageId"] = self.messageId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("MessageId") {
                        self.messageId = dict["MessageId"] as! String
                    }
                }
            }
            public class Properties : Tea.TeaModel {
                public class Format : Tea.TeaModel {
                    public var bitrate: String?

                    public var duration: String?

                    public var formatLongName: String?

                    public var formatName: String?

                    public var numPrograms: String?

                    public var numStreams: String?

                    public var size: String?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.formatLongName != nil {
                            map["FormatLongName"] = self.formatLongName!
                        }
                        if self.formatName != nil {
                            map["FormatName"] = self.formatName!
                        }
                        if self.numPrograms != nil {
                            map["NumPrograms"] = self.numPrograms!
                        }
                        if self.numStreams != nil {
                            map["NumStreams"] = self.numStreams!
                        }
                        if self.size != nil {
                            map["Size"] = self.size!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("FormatLongName") {
                            self.formatLongName = dict["FormatLongName"] as! String
                        }
                        if dict.keys.contains("FormatName") {
                            self.formatName = dict["FormatName"] as! String
                        }
                        if dict.keys.contains("NumPrograms") {
                            self.numPrograms = dict["NumPrograms"] as! String
                        }
                        if dict.keys.contains("NumStreams") {
                            self.numStreams = dict["NumStreams"] as! String
                        }
                        if dict.keys.contains("Size") {
                            self.size = dict["Size"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                    }
                }
                public class Streams : Tea.TeaModel {
                    public class AudioStreamList : Tea.TeaModel {
                        public class AudioStream : Tea.TeaModel {
                            public var bitrate: String?

                            public var channelLayout: String?

                            public var channels: String?

                            public var codecLongName: String?

                            public var codecName: String?

                            public var codecTag: String?

                            public var codecTagString: String?

                            public var codecTimeBase: String?

                            public var duration: String?

                            public var index: String?

                            public var lang: String?

                            public var numFrames: String?

                            public var sampleFmt: String?

                            public var samplerate: String?

                            public var startTime: String?

                            public var timebase: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channelLayout != nil {
                                    map["ChannelLayout"] = self.channelLayout!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codecLongName != nil {
                                    map["CodecLongName"] = self.codecLongName!
                                }
                                if self.codecName != nil {
                                    map["CodecName"] = self.codecName!
                                }
                                if self.codecTag != nil {
                                    map["CodecTag"] = self.codecTag!
                                }
                                if self.codecTagString != nil {
                                    map["CodecTagString"] = self.codecTagString!
                                }
                                if self.codecTimeBase != nil {
                                    map["CodecTimeBase"] = self.codecTimeBase!
                                }
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.index != nil {
                                    map["Index"] = self.index!
                                }
                                if self.lang != nil {
                                    map["Lang"] = self.lang!
                                }
                                if self.numFrames != nil {
                                    map["NumFrames"] = self.numFrames!
                                }
                                if self.sampleFmt != nil {
                                    map["SampleFmt"] = self.sampleFmt!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                if self.timebase != nil {
                                    map["Timebase"] = self.timebase!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("ChannelLayout") {
                                    self.channelLayout = dict["ChannelLayout"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("CodecLongName") {
                                    self.codecLongName = dict["CodecLongName"] as! String
                                }
                                if dict.keys.contains("CodecName") {
                                    self.codecName = dict["CodecName"] as! String
                                }
                                if dict.keys.contains("CodecTag") {
                                    self.codecTag = dict["CodecTag"] as! String
                                }
                                if dict.keys.contains("CodecTagString") {
                                    self.codecTagString = dict["CodecTagString"] as! String
                                }
                                if dict.keys.contains("CodecTimeBase") {
                                    self.codecTimeBase = dict["CodecTimeBase"] as! String
                                }
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Index") {
                                    self.index = dict["Index"] as! String
                                }
                                if dict.keys.contains("Lang") {
                                    self.lang = dict["Lang"] as! String
                                }
                                if dict.keys.contains("NumFrames") {
                                    self.numFrames = dict["NumFrames"] as! String
                                }
                                if dict.keys.contains("SampleFmt") {
                                    self.sampleFmt = dict["SampleFmt"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("StartTime") {
                                    self.startTime = dict["StartTime"] as! String
                                }
                                if dict.keys.contains("Timebase") {
                                    self.timebase = dict["Timebase"] as! String
                                }
                            }
                        }
                        public var audioStream: [QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.AudioStreamList.AudioStream]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audioStream != nil {
                                var tmp : [Any] = []
                                for k in self.audioStream! {
                                    tmp.append(k.toMap())
                                }
                                map["AudioStream"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AudioStream") {
                                var tmp : [QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.AudioStreamList.AudioStream] = []
                                for v in dict["AudioStream"] as! [Any] {
                                    var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.AudioStreamList.AudioStream()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.audioStream = tmp
                            }
                        }
                    }
                    public class SubtitleStreamList : Tea.TeaModel {
                        public class SubtitleStream : Tea.TeaModel {
                            public var codecLongName: String?

                            public var codecName: String?

                            public var codecTag: String?

                            public var codecTagString: String?

                            public var codecTimeBase: String?

                            public var duration: String?

                            public var index: String?

                            public var lang: String?

                            public var startTime: String?

                            public var timebase: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.codecLongName != nil {
                                    map["CodecLongName"] = self.codecLongName!
                                }
                                if self.codecName != nil {
                                    map["CodecName"] = self.codecName!
                                }
                                if self.codecTag != nil {
                                    map["CodecTag"] = self.codecTag!
                                }
                                if self.codecTagString != nil {
                                    map["CodecTagString"] = self.codecTagString!
                                }
                                if self.codecTimeBase != nil {
                                    map["CodecTimeBase"] = self.codecTimeBase!
                                }
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.index != nil {
                                    map["Index"] = self.index!
                                }
                                if self.lang != nil {
                                    map["Lang"] = self.lang!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                if self.timebase != nil {
                                    map["Timebase"] = self.timebase!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("CodecLongName") {
                                    self.codecLongName = dict["CodecLongName"] as! String
                                }
                                if dict.keys.contains("CodecName") {
                                    self.codecName = dict["CodecName"] as! String
                                }
                                if dict.keys.contains("CodecTag") {
                                    self.codecTag = dict["CodecTag"] as! String
                                }
                                if dict.keys.contains("CodecTagString") {
                                    self.codecTagString = dict["CodecTagString"] as! String
                                }
                                if dict.keys.contains("CodecTimeBase") {
                                    self.codecTimeBase = dict["CodecTimeBase"] as! String
                                }
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Index") {
                                    self.index = dict["Index"] as! String
                                }
                                if dict.keys.contains("Lang") {
                                    self.lang = dict["Lang"] as! String
                                }
                                if dict.keys.contains("StartTime") {
                                    self.startTime = dict["StartTime"] as! String
                                }
                                if dict.keys.contains("Timebase") {
                                    self.timebase = dict["Timebase"] as! String
                                }
                            }
                        }
                        public var subtitleStream: [QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.SubtitleStreamList.SubtitleStream]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.subtitleStream != nil {
                                var tmp : [Any] = []
                                for k in self.subtitleStream! {
                                    tmp.append(k.toMap())
                                }
                                map["SubtitleStream"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("SubtitleStream") {
                                var tmp : [QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.SubtitleStreamList.SubtitleStream] = []
                                for v in dict["SubtitleStream"] as! [Any] {
                                    var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.SubtitleStreamList.SubtitleStream()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.subtitleStream = tmp
                            }
                        }
                    }
                    public class VideoStreamList : Tea.TeaModel {
                        public class VideoStream : Tea.TeaModel {
                            public class NetworkCost : Tea.TeaModel {
                                public var avgBitrate: String?

                                public var costBandwidth: String?

                                public var preloadTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.avgBitrate != nil {
                                        map["AvgBitrate"] = self.avgBitrate!
                                    }
                                    if self.costBandwidth != nil {
                                        map["CostBandwidth"] = self.costBandwidth!
                                    }
                                    if self.preloadTime != nil {
                                        map["PreloadTime"] = self.preloadTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("AvgBitrate") {
                                        self.avgBitrate = dict["AvgBitrate"] as! String
                                    }
                                    if dict.keys.contains("CostBandwidth") {
                                        self.costBandwidth = dict["CostBandwidth"] as! String
                                    }
                                    if dict.keys.contains("PreloadTime") {
                                        self.preloadTime = dict["PreloadTime"] as! String
                                    }
                                }
                            }
                            public var avgFPS: String?

                            public var bitrate: String?

                            public var codecLongName: String?

                            public var codecName: String?

                            public var codecTag: String?

                            public var codecTagString: String?

                            public var codecTimeBase: String?

                            public var colorPrimaries: String?

                            public var colorRange: String?

                            public var colorTransfer: String?

                            public var dar: String?

                            public var duration: String?

                            public var fps: String?

                            public var hasBFrames: String?

                            public var height: String?

                            public var index: String?

                            public var lang: String?

                            public var level: String?

                            public var networkCost: QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream.NetworkCost?

                            public var numFrames: String?

                            public var pixFmt: String?

                            public var profile: String?

                            public var rotate: String?

                            public var sar: String?

                            public var startTime: String?

                            public var timebase: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.networkCost?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.avgFPS != nil {
                                    map["AvgFPS"] = self.avgFPS!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.codecLongName != nil {
                                    map["CodecLongName"] = self.codecLongName!
                                }
                                if self.codecName != nil {
                                    map["CodecName"] = self.codecName!
                                }
                                if self.codecTag != nil {
                                    map["CodecTag"] = self.codecTag!
                                }
                                if self.codecTagString != nil {
                                    map["CodecTagString"] = self.codecTagString!
                                }
                                if self.codecTimeBase != nil {
                                    map["CodecTimeBase"] = self.codecTimeBase!
                                }
                                if self.colorPrimaries != nil {
                                    map["ColorPrimaries"] = self.colorPrimaries!
                                }
                                if self.colorRange != nil {
                                    map["ColorRange"] = self.colorRange!
                                }
                                if self.colorTransfer != nil {
                                    map["ColorTransfer"] = self.colorTransfer!
                                }
                                if self.dar != nil {
                                    map["Dar"] = self.dar!
                                }
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.hasBFrames != nil {
                                    map["HasBFrames"] = self.hasBFrames!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.index != nil {
                                    map["Index"] = self.index!
                                }
                                if self.lang != nil {
                                    map["Lang"] = self.lang!
                                }
                                if self.level != nil {
                                    map["Level"] = self.level!
                                }
                                if self.networkCost != nil {
                                    map["NetworkCost"] = self.networkCost?.toMap()
                                }
                                if self.numFrames != nil {
                                    map["NumFrames"] = self.numFrames!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.rotate != nil {
                                    map["Rotate"] = self.rotate!
                                }
                                if self.sar != nil {
                                    map["Sar"] = self.sar!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                if self.timebase != nil {
                                    map["Timebase"] = self.timebase!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AvgFPS") {
                                    self.avgFPS = dict["AvgFPS"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("CodecLongName") {
                                    self.codecLongName = dict["CodecLongName"] as! String
                                }
                                if dict.keys.contains("CodecName") {
                                    self.codecName = dict["CodecName"] as! String
                                }
                                if dict.keys.contains("CodecTag") {
                                    self.codecTag = dict["CodecTag"] as! String
                                }
                                if dict.keys.contains("CodecTagString") {
                                    self.codecTagString = dict["CodecTagString"] as! String
                                }
                                if dict.keys.contains("CodecTimeBase") {
                                    self.codecTimeBase = dict["CodecTimeBase"] as! String
                                }
                                if dict.keys.contains("ColorPrimaries") {
                                    self.colorPrimaries = dict["ColorPrimaries"] as! String
                                }
                                if dict.keys.contains("ColorRange") {
                                    self.colorRange = dict["ColorRange"] as! String
                                }
                                if dict.keys.contains("ColorTransfer") {
                                    self.colorTransfer = dict["ColorTransfer"] as! String
                                }
                                if dict.keys.contains("Dar") {
                                    self.dar = dict["Dar"] as! String
                                }
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("HasBFrames") {
                                    self.hasBFrames = dict["HasBFrames"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("Index") {
                                    self.index = dict["Index"] as! String
                                }
                                if dict.keys.contains("Lang") {
                                    self.lang = dict["Lang"] as! String
                                }
                                if dict.keys.contains("Level") {
                                    self.level = dict["Level"] as! String
                                }
                                if dict.keys.contains("NetworkCost") {
                                    var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream.NetworkCost()
                                    model.fromMap(dict["NetworkCost"] as! [String: Any])
                                    self.networkCost = model
                                }
                                if dict.keys.contains("NumFrames") {
                                    self.numFrames = dict["NumFrames"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Rotate") {
                                    self.rotate = dict["Rotate"] as! String
                                }
                                if dict.keys.contains("Sar") {
                                    self.sar = dict["Sar"] as! String
                                }
                                if dict.keys.contains("StartTime") {
                                    self.startTime = dict["StartTime"] as! String
                                }
                                if dict.keys.contains("Timebase") {
                                    self.timebase = dict["Timebase"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var videoStream: [QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.videoStream != nil {
                                var tmp : [Any] = []
                                for k in self.videoStream! {
                                    tmp.append(k.toMap())
                                }
                                map["VideoStream"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("VideoStream") {
                                var tmp : [QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream] = []
                                for v in dict["VideoStream"] as! [Any] {
                                    var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.videoStream = tmp
                            }
                        }
                    }
                    public var audioStreamList: QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.AudioStreamList?

                    public var subtitleStreamList: QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.SubtitleStreamList?

                    public var videoStreamList: QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.VideoStreamList?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.audioStreamList?.validate()
                        try self.subtitleStreamList?.validate()
                        try self.videoStreamList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioStreamList != nil {
                            map["AudioStreamList"] = self.audioStreamList?.toMap()
                        }
                        if self.subtitleStreamList != nil {
                            map["SubtitleStreamList"] = self.subtitleStreamList?.toMap()
                        }
                        if self.videoStreamList != nil {
                            map["VideoStreamList"] = self.videoStreamList?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioStreamList") {
                            var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.AudioStreamList()
                            model.fromMap(dict["AudioStreamList"] as! [String: Any])
                            self.audioStreamList = model
                        }
                        if dict.keys.contains("SubtitleStreamList") {
                            var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.SubtitleStreamList()
                            model.fromMap(dict["SubtitleStreamList"] as! [String: Any])
                            self.subtitleStreamList = model
                        }
                        if dict.keys.contains("VideoStreamList") {
                            var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams.VideoStreamList()
                            model.fromMap(dict["VideoStreamList"] as! [String: Any])
                            self.videoStreamList = model
                        }
                    }
                }
                public var bitrate: String?

                public var duration: String?

                public var fileFormat: String?

                public var fileSize: String?

                public var format: QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Format?

                public var fps: String?

                public var height: String?

                public var streams: QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.format?.validate()
                    try self.streams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.fileFormat != nil {
                        map["FileFormat"] = self.fileFormat!
                    }
                    if self.fileSize != nil {
                        map["FileSize"] = self.fileSize!
                    }
                    if self.format != nil {
                        map["Format"] = self.format?.toMap()
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.streams != nil {
                        map["Streams"] = self.streams?.toMap()
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FileFormat") {
                        self.fileFormat = dict["FileFormat"] as! String
                    }
                    if dict.keys.contains("FileSize") {
                        self.fileSize = dict["FileSize"] as! String
                    }
                    if dict.keys.contains("Format") {
                        var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Format()
                        model.fromMap(dict["Format"] as! [String: Any])
                        self.format = model
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Streams") {
                        var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties.Streams()
                        model.fromMap(dict["Streams"] as! [String: Any])
                        self.streams = model
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var async: Bool?

            public var code: String?

            public var creationTime: String?

            public var input: QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Input?

            public var jobId: String?

            public var MNSMessageResult: QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.MNSMessageResult?

            public var message: String?

            public var pipelineId: String?

            public var properties: QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties?

            public var state: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.input?.validate()
                try self.MNSMessageResult?.validate()
                try self.properties?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.async != nil {
                    map["Async"] = self.async!
                }
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.MNSMessageResult != nil {
                    map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.properties != nil {
                    map["Properties"] = self.properties?.toMap()
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Async") {
                    self.async = dict["Async"] as! Bool
                }
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Input") {
                    var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("MNSMessageResult") {
                    var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.MNSMessageResult()
                    model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                    self.MNSMessageResult = model
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("Properties") {
                    var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob.Properties()
                    model.fromMap(dict["Properties"] as! [String: Any])
                    self.properties = model
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var mediaInfoJob: [QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaInfoJob != nil {
                var tmp : [Any] = []
                for k in self.mediaInfoJob! {
                    tmp.append(k.toMap())
                }
                map["MediaInfoJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaInfoJob") {
                var tmp : [QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob] = []
                for v in dict["MediaInfoJob"] as! [Any] {
                    var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList.MediaInfoJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaInfoJob = tmp
            }
        }
    }
    public class NonExistMediaInfoJobIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public var mediaInfoJobList: QueryMediaInfoJobListResponseBody.MediaInfoJobList?

    public var nonExistMediaInfoJobIds: QueryMediaInfoJobListResponseBody.NonExistMediaInfoJobIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfoJobList?.validate()
        try self.nonExistMediaInfoJobIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfoJobList != nil {
            map["MediaInfoJobList"] = self.mediaInfoJobList?.toMap()
        }
        if self.nonExistMediaInfoJobIds != nil {
            map["NonExistMediaInfoJobIds"] = self.nonExistMediaInfoJobIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfoJobList") {
            var model = QueryMediaInfoJobListResponseBody.MediaInfoJobList()
            model.fromMap(dict["MediaInfoJobList"] as! [String: Any])
            self.mediaInfoJobList = model
        }
        if dict.keys.contains("NonExistMediaInfoJobIds") {
            var model = QueryMediaInfoJobListResponseBody.NonExistMediaInfoJobIds()
            model.fromMap(dict["NonExistMediaInfoJobIds"] as! [String: Any])
            self.nonExistMediaInfoJobIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMediaInfoJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaInfoJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMediaInfoJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaListRequest : Tea.TeaModel {
    public var includeMediaInfo: Bool?

    public var includePlayList: Bool?

    public var includeSnapshotList: Bool?

    public var includeSummaryList: Bool?

    public var mediaIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.includeMediaInfo != nil {
            map["IncludeMediaInfo"] = self.includeMediaInfo!
        }
        if self.includePlayList != nil {
            map["IncludePlayList"] = self.includePlayList!
        }
        if self.includeSnapshotList != nil {
            map["IncludeSnapshotList"] = self.includeSnapshotList!
        }
        if self.includeSummaryList != nil {
            map["IncludeSummaryList"] = self.includeSummaryList!
        }
        if self.mediaIds != nil {
            map["MediaIds"] = self.mediaIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IncludeMediaInfo") {
            self.includeMediaInfo = dict["IncludeMediaInfo"] as! Bool
        }
        if dict.keys.contains("IncludePlayList") {
            self.includePlayList = dict["IncludePlayList"] as! Bool
        }
        if dict.keys.contains("IncludeSnapshotList") {
            self.includeSnapshotList = dict["IncludeSnapshotList"] as! Bool
        }
        if dict.keys.contains("IncludeSummaryList") {
            self.includeSummaryList = dict["IncludeSummaryList"] as! Bool
        }
        if dict.keys.contains("MediaIds") {
            self.mediaIds = dict["MediaIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryMediaListResponseBody : Tea.TeaModel {
    public class MediaList : Tea.TeaModel {
        public class Media : Tea.TeaModel {
            public class File : Tea.TeaModel {
                public var state: String?

                public var URL: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    if self.URL != nil {
                        map["URL"] = self.URL!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! String
                    }
                    if dict.keys.contains("URL") {
                        self.URL = dict["URL"] as! String
                    }
                }
            }
            public class MediaInfo : Tea.TeaModel {
                public class Format : Tea.TeaModel {
                    public var bitrate: String?

                    public var duration: String?

                    public var formatLongName: String?

                    public var formatName: String?

                    public var numPrograms: String?

                    public var numStreams: String?

                    public var size: String?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.formatLongName != nil {
                            map["FormatLongName"] = self.formatLongName!
                        }
                        if self.formatName != nil {
                            map["FormatName"] = self.formatName!
                        }
                        if self.numPrograms != nil {
                            map["NumPrograms"] = self.numPrograms!
                        }
                        if self.numStreams != nil {
                            map["NumStreams"] = self.numStreams!
                        }
                        if self.size != nil {
                            map["Size"] = self.size!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("FormatLongName") {
                            self.formatLongName = dict["FormatLongName"] as! String
                        }
                        if dict.keys.contains("FormatName") {
                            self.formatName = dict["FormatName"] as! String
                        }
                        if dict.keys.contains("NumPrograms") {
                            self.numPrograms = dict["NumPrograms"] as! String
                        }
                        if dict.keys.contains("NumStreams") {
                            self.numStreams = dict["NumStreams"] as! String
                        }
                        if dict.keys.contains("Size") {
                            self.size = dict["Size"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                    }
                }
                public class Streams : Tea.TeaModel {
                    public class AudioStreamList : Tea.TeaModel {
                        public class AudioStream : Tea.TeaModel {
                            public var bitrate: String?

                            public var channelLayout: String?

                            public var channels: String?

                            public var codecLongName: String?

                            public var codecName: String?

                            public var codecTag: String?

                            public var codecTagString: String?

                            public var codecTimeBase: String?

                            public var duration: String?

                            public var index: String?

                            public var lang: String?

                            public var numFrames: String?

                            public var sampleFmt: String?

                            public var samplerate: String?

                            public var startTime: String?

                            public var timebase: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channelLayout != nil {
                                    map["ChannelLayout"] = self.channelLayout!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codecLongName != nil {
                                    map["CodecLongName"] = self.codecLongName!
                                }
                                if self.codecName != nil {
                                    map["CodecName"] = self.codecName!
                                }
                                if self.codecTag != nil {
                                    map["CodecTag"] = self.codecTag!
                                }
                                if self.codecTagString != nil {
                                    map["CodecTagString"] = self.codecTagString!
                                }
                                if self.codecTimeBase != nil {
                                    map["CodecTimeBase"] = self.codecTimeBase!
                                }
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.index != nil {
                                    map["Index"] = self.index!
                                }
                                if self.lang != nil {
                                    map["Lang"] = self.lang!
                                }
                                if self.numFrames != nil {
                                    map["NumFrames"] = self.numFrames!
                                }
                                if self.sampleFmt != nil {
                                    map["SampleFmt"] = self.sampleFmt!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                if self.timebase != nil {
                                    map["Timebase"] = self.timebase!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("ChannelLayout") {
                                    self.channelLayout = dict["ChannelLayout"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("CodecLongName") {
                                    self.codecLongName = dict["CodecLongName"] as! String
                                }
                                if dict.keys.contains("CodecName") {
                                    self.codecName = dict["CodecName"] as! String
                                }
                                if dict.keys.contains("CodecTag") {
                                    self.codecTag = dict["CodecTag"] as! String
                                }
                                if dict.keys.contains("CodecTagString") {
                                    self.codecTagString = dict["CodecTagString"] as! String
                                }
                                if dict.keys.contains("CodecTimeBase") {
                                    self.codecTimeBase = dict["CodecTimeBase"] as! String
                                }
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Index") {
                                    self.index = dict["Index"] as! String
                                }
                                if dict.keys.contains("Lang") {
                                    self.lang = dict["Lang"] as! String
                                }
                                if dict.keys.contains("NumFrames") {
                                    self.numFrames = dict["NumFrames"] as! String
                                }
                                if dict.keys.contains("SampleFmt") {
                                    self.sampleFmt = dict["SampleFmt"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("StartTime") {
                                    self.startTime = dict["StartTime"] as! String
                                }
                                if dict.keys.contains("Timebase") {
                                    self.timebase = dict["Timebase"] as! String
                                }
                            }
                        }
                        public var audioStream: [QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList.AudioStream]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audioStream != nil {
                                var tmp : [Any] = []
                                for k in self.audioStream! {
                                    tmp.append(k.toMap())
                                }
                                map["AudioStream"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AudioStream") {
                                var tmp : [QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList.AudioStream] = []
                                for v in dict["AudioStream"] as! [Any] {
                                    var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList.AudioStream()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.audioStream = tmp
                            }
                        }
                    }
                    public class SubtitleStreamList : Tea.TeaModel {
                        public class SubtitleStream : Tea.TeaModel {
                            public var index: String?

                            public var lang: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.index != nil {
                                    map["Index"] = self.index!
                                }
                                if self.lang != nil {
                                    map["Lang"] = self.lang!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Index") {
                                    self.index = dict["Index"] as! String
                                }
                                if dict.keys.contains("Lang") {
                                    self.lang = dict["Lang"] as! String
                                }
                            }
                        }
                        public var subtitleStream: [QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList.SubtitleStream]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.subtitleStream != nil {
                                var tmp : [Any] = []
                                for k in self.subtitleStream! {
                                    tmp.append(k.toMap())
                                }
                                map["SubtitleStream"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("SubtitleStream") {
                                var tmp : [QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList.SubtitleStream] = []
                                for v in dict["SubtitleStream"] as! [Any] {
                                    var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList.SubtitleStream()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.subtitleStream = tmp
                            }
                        }
                    }
                    public class VideoStreamList : Tea.TeaModel {
                        public class VideoStream : Tea.TeaModel {
                            public class NetworkCost : Tea.TeaModel {
                                public var avgBitrate: String?

                                public var costBandwidth: String?

                                public var preloadTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.avgBitrate != nil {
                                        map["AvgBitrate"] = self.avgBitrate!
                                    }
                                    if self.costBandwidth != nil {
                                        map["CostBandwidth"] = self.costBandwidth!
                                    }
                                    if self.preloadTime != nil {
                                        map["PreloadTime"] = self.preloadTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("AvgBitrate") {
                                        self.avgBitrate = dict["AvgBitrate"] as! String
                                    }
                                    if dict.keys.contains("CostBandwidth") {
                                        self.costBandwidth = dict["CostBandwidth"] as! String
                                    }
                                    if dict.keys.contains("PreloadTime") {
                                        self.preloadTime = dict["PreloadTime"] as! String
                                    }
                                }
                            }
                            public var avgFPS: String?

                            public var bitrate: String?

                            public var codecLongName: String?

                            public var codecName: String?

                            public var codecTag: String?

                            public var codecTagString: String?

                            public var codecTimeBase: String?

                            public var dar: String?

                            public var duration: String?

                            public var fps: String?

                            public var hasBFrames: String?

                            public var height: String?

                            public var index: String?

                            public var lang: String?

                            public var level: String?

                            public var networkCost: QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream.NetworkCost?

                            public var numFrames: String?

                            public var pixFmt: String?

                            public var profile: String?

                            public var rotate: String?

                            public var sar: String?

                            public var startTime: String?

                            public var timebase: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.networkCost?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.avgFPS != nil {
                                    map["AvgFPS"] = self.avgFPS!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.codecLongName != nil {
                                    map["CodecLongName"] = self.codecLongName!
                                }
                                if self.codecName != nil {
                                    map["CodecName"] = self.codecName!
                                }
                                if self.codecTag != nil {
                                    map["CodecTag"] = self.codecTag!
                                }
                                if self.codecTagString != nil {
                                    map["CodecTagString"] = self.codecTagString!
                                }
                                if self.codecTimeBase != nil {
                                    map["CodecTimeBase"] = self.codecTimeBase!
                                }
                                if self.dar != nil {
                                    map["Dar"] = self.dar!
                                }
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.hasBFrames != nil {
                                    map["HasBFrames"] = self.hasBFrames!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.index != nil {
                                    map["Index"] = self.index!
                                }
                                if self.lang != nil {
                                    map["Lang"] = self.lang!
                                }
                                if self.level != nil {
                                    map["Level"] = self.level!
                                }
                                if self.networkCost != nil {
                                    map["NetworkCost"] = self.networkCost?.toMap()
                                }
                                if self.numFrames != nil {
                                    map["NumFrames"] = self.numFrames!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.rotate != nil {
                                    map["Rotate"] = self.rotate!
                                }
                                if self.sar != nil {
                                    map["Sar"] = self.sar!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                if self.timebase != nil {
                                    map["Timebase"] = self.timebase!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AvgFPS") {
                                    self.avgFPS = dict["AvgFPS"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("CodecLongName") {
                                    self.codecLongName = dict["CodecLongName"] as! String
                                }
                                if dict.keys.contains("CodecName") {
                                    self.codecName = dict["CodecName"] as! String
                                }
                                if dict.keys.contains("CodecTag") {
                                    self.codecTag = dict["CodecTag"] as! String
                                }
                                if dict.keys.contains("CodecTagString") {
                                    self.codecTagString = dict["CodecTagString"] as! String
                                }
                                if dict.keys.contains("CodecTimeBase") {
                                    self.codecTimeBase = dict["CodecTimeBase"] as! String
                                }
                                if dict.keys.contains("Dar") {
                                    self.dar = dict["Dar"] as! String
                                }
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("HasBFrames") {
                                    self.hasBFrames = dict["HasBFrames"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("Index") {
                                    self.index = dict["Index"] as! String
                                }
                                if dict.keys.contains("Lang") {
                                    self.lang = dict["Lang"] as! String
                                }
                                if dict.keys.contains("Level") {
                                    self.level = dict["Level"] as! String
                                }
                                if dict.keys.contains("NetworkCost") {
                                    var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream.NetworkCost()
                                    model.fromMap(dict["NetworkCost"] as! [String: Any])
                                    self.networkCost = model
                                }
                                if dict.keys.contains("NumFrames") {
                                    self.numFrames = dict["NumFrames"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Rotate") {
                                    self.rotate = dict["Rotate"] as! String
                                }
                                if dict.keys.contains("Sar") {
                                    self.sar = dict["Sar"] as! String
                                }
                                if dict.keys.contains("StartTime") {
                                    self.startTime = dict["StartTime"] as! String
                                }
                                if dict.keys.contains("Timebase") {
                                    self.timebase = dict["Timebase"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var videoStream: [QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.videoStream != nil {
                                var tmp : [Any] = []
                                for k in self.videoStream! {
                                    tmp.append(k.toMap())
                                }
                                map["VideoStream"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("VideoStream") {
                                var tmp : [QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream] = []
                                for v in dict["VideoStream"] as! [Any] {
                                    var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.videoStream = tmp
                            }
                        }
                    }
                    public var audioStreamList: QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList?

                    public var subtitleStreamList: QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList?

                    public var videoStreamList: QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.audioStreamList?.validate()
                        try self.subtitleStreamList?.validate()
                        try self.videoStreamList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioStreamList != nil {
                            map["AudioStreamList"] = self.audioStreamList?.toMap()
                        }
                        if self.subtitleStreamList != nil {
                            map["SubtitleStreamList"] = self.subtitleStreamList?.toMap()
                        }
                        if self.videoStreamList != nil {
                            map["VideoStreamList"] = self.videoStreamList?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioStreamList") {
                            var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList()
                            model.fromMap(dict["AudioStreamList"] as! [String: Any])
                            self.audioStreamList = model
                        }
                        if dict.keys.contains("SubtitleStreamList") {
                            var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList()
                            model.fromMap(dict["SubtitleStreamList"] as! [String: Any])
                            self.subtitleStreamList = model
                        }
                        if dict.keys.contains("VideoStreamList") {
                            var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList()
                            model.fromMap(dict["VideoStreamList"] as! [String: Any])
                            self.videoStreamList = model
                        }
                    }
                }
                public var format: QueryMediaListResponseBody.MediaList.Media.MediaInfo.Format?

                public var streams: QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.format?.validate()
                    try self.streams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.format != nil {
                        map["Format"] = self.format?.toMap()
                    }
                    if self.streams != nil {
                        map["Streams"] = self.streams?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Format") {
                        var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo.Format()
                        model.fromMap(dict["Format"] as! [String: Any])
                        self.format = model
                    }
                    if dict.keys.contains("Streams") {
                        var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo.Streams()
                        model.fromMap(dict["Streams"] as! [String: Any])
                        self.streams = model
                    }
                }
            }
            public class PlayList : Tea.TeaModel {
                public class Play : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var state: String?

                        public var URL: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.state != nil {
                                map["State"] = self.state!
                            }
                            if self.URL != nil {
                                map["URL"] = self.URL!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("State") {
                                self.state = dict["State"] as! String
                            }
                            if dict.keys.contains("URL") {
                                self.URL = dict["URL"] as! String
                            }
                        }
                    }
                    public var activityName: String?

                    public var bitrate: String?

                    public var duration: String?

                    public var encryption: String?

                    public var file: QueryMediaListResponseBody.MediaList.Media.PlayList.Play.File?

                    public var format: String?

                    public var fps: String?

                    public var height: String?

                    public var mediaWorkflowId: String?

                    public var mediaWorkflowName: String?

                    public var size: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.activityName != nil {
                            map["ActivityName"] = self.activityName!
                        }
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.encryption != nil {
                            map["Encryption"] = self.encryption!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.mediaWorkflowId != nil {
                            map["MediaWorkflowId"] = self.mediaWorkflowId!
                        }
                        if self.mediaWorkflowName != nil {
                            map["MediaWorkflowName"] = self.mediaWorkflowName!
                        }
                        if self.size != nil {
                            map["Size"] = self.size!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ActivityName") {
                            self.activityName = dict["ActivityName"] as! String
                        }
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Encryption") {
                            self.encryption = dict["Encryption"] as! String
                        }
                        if dict.keys.contains("File") {
                            var model = QueryMediaListResponseBody.MediaList.Media.PlayList.Play.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("MediaWorkflowId") {
                            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                        }
                        if dict.keys.contains("MediaWorkflowName") {
                            self.mediaWorkflowName = dict["MediaWorkflowName"] as! String
                        }
                        if dict.keys.contains("Size") {
                            self.size = dict["Size"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var play: [QueryMediaListResponseBody.MediaList.Media.PlayList.Play]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.play != nil {
                        var tmp : [Any] = []
                        for k in self.play! {
                            tmp.append(k.toMap())
                        }
                        map["Play"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Play") {
                        var tmp : [QueryMediaListResponseBody.MediaList.Media.PlayList.Play] = []
                        for v in dict["Play"] as! [Any] {
                            var model = QueryMediaListResponseBody.MediaList.Media.PlayList.Play()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.play = tmp
                    }
                }
            }
            public class RunIdList : Tea.TeaModel {
                public var runId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.runId != nil {
                        map["RunId"] = self.runId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RunId") {
                        self.runId = dict["RunId"] as! [String]
                    }
                }
            }
            public class SnapshotList : Tea.TeaModel {
                public class Snapshot : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var state: String?

                        public var URL: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.state != nil {
                                map["State"] = self.state!
                            }
                            if self.URL != nil {
                                map["URL"] = self.URL!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("State") {
                                self.state = dict["State"] as! String
                            }
                            if dict.keys.contains("URL") {
                                self.URL = dict["URL"] as! String
                            }
                        }
                    }
                    public var activityName: String?

                    public var count: String?

                    public var file: QueryMediaListResponseBody.MediaList.Media.SnapshotList.Snapshot.File?

                    public var mediaWorkflowId: String?

                    public var mediaWorkflowName: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.activityName != nil {
                            map["ActivityName"] = self.activityName!
                        }
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.mediaWorkflowId != nil {
                            map["MediaWorkflowId"] = self.mediaWorkflowId!
                        }
                        if self.mediaWorkflowName != nil {
                            map["MediaWorkflowName"] = self.mediaWorkflowName!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ActivityName") {
                            self.activityName = dict["ActivityName"] as! String
                        }
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! String
                        }
                        if dict.keys.contains("File") {
                            var model = QueryMediaListResponseBody.MediaList.Media.SnapshotList.Snapshot.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("MediaWorkflowId") {
                            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                        }
                        if dict.keys.contains("MediaWorkflowName") {
                            self.mediaWorkflowName = dict["MediaWorkflowName"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var snapshot: [QueryMediaListResponseBody.MediaList.Media.SnapshotList.Snapshot]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.snapshot != nil {
                        var tmp : [Any] = []
                        for k in self.snapshot! {
                            tmp.append(k.toMap())
                        }
                        map["Snapshot"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Snapshot") {
                        var tmp : [QueryMediaListResponseBody.MediaList.Media.SnapshotList.Snapshot] = []
                        for v in dict["Snapshot"] as! [Any] {
                            var model = QueryMediaListResponseBody.MediaList.Media.SnapshotList.Snapshot()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.snapshot = tmp
                    }
                }
            }
            public class SummaryList : Tea.TeaModel {
                public class Summary : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var state: String?

                        public var URL: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.state != nil {
                                map["State"] = self.state!
                            }
                            if self.URL != nil {
                                map["URL"] = self.URL!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("State") {
                                self.state = dict["State"] as! String
                            }
                            if dict.keys.contains("URL") {
                                self.URL = dict["URL"] as! String
                            }
                        }
                    }
                    public var activityName: String?

                    public var file: QueryMediaListResponseBody.MediaList.Media.SummaryList.Summary.File?

                    public var mediaWorkflowId: String?

                    public var mediaWorkflowName: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.activityName != nil {
                            map["ActivityName"] = self.activityName!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.mediaWorkflowId != nil {
                            map["MediaWorkflowId"] = self.mediaWorkflowId!
                        }
                        if self.mediaWorkflowName != nil {
                            map["MediaWorkflowName"] = self.mediaWorkflowName!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ActivityName") {
                            self.activityName = dict["ActivityName"] as! String
                        }
                        if dict.keys.contains("File") {
                            var model = QueryMediaListResponseBody.MediaList.Media.SummaryList.Summary.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("MediaWorkflowId") {
                            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                        }
                        if dict.keys.contains("MediaWorkflowName") {
                            self.mediaWorkflowName = dict["MediaWorkflowName"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var summary: [QueryMediaListResponseBody.MediaList.Media.SummaryList.Summary]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.summary != nil {
                        var tmp : [Any] = []
                        for k in self.summary! {
                            tmp.append(k.toMap())
                        }
                        map["Summary"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Summary") {
                        var tmp : [QueryMediaListResponseBody.MediaList.Media.SummaryList.Summary] = []
                        for v in dict["Summary"] as! [Any] {
                            var model = QueryMediaListResponseBody.MediaList.Media.SummaryList.Summary()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.summary = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var tag: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        map["Tag"] = self.tag!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        self.tag = dict["Tag"] as! [String]
                    }
                }
            }
            public var bitrate: String?

            public var cateId: Int64?

            public var censorState: String?

            public var coverURL: String?

            public var creationTime: String?

            public var description_: String?

            public var duration: String?

            public var file: QueryMediaListResponseBody.MediaList.Media.File?

            public var format: String?

            public var fps: String?

            public var height: String?

            public var mediaId: String?

            public var mediaInfo: QueryMediaListResponseBody.MediaList.Media.MediaInfo?

            public var playList: QueryMediaListResponseBody.MediaList.Media.PlayList?

            public var publishState: String?

            public var runIdList: QueryMediaListResponseBody.MediaList.Media.RunIdList?

            public var size: String?

            public var snapshotList: QueryMediaListResponseBody.MediaList.Media.SnapshotList?

            public var summaryList: QueryMediaListResponseBody.MediaList.Media.SummaryList?

            public var tags: QueryMediaListResponseBody.MediaList.Media.Tags?

            public var title: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.file?.validate()
                try self.mediaInfo?.validate()
                try self.playList?.validate()
                try self.runIdList?.validate()
                try self.snapshotList?.validate()
                try self.summaryList?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.censorState != nil {
                    map["CensorState"] = self.censorState!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.file != nil {
                    map["File"] = self.file?.toMap()
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaInfo != nil {
                    map["MediaInfo"] = self.mediaInfo?.toMap()
                }
                if self.playList != nil {
                    map["PlayList"] = self.playList?.toMap()
                }
                if self.publishState != nil {
                    map["PublishState"] = self.publishState!
                }
                if self.runIdList != nil {
                    map["RunIdList"] = self.runIdList?.toMap()
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshotList != nil {
                    map["SnapshotList"] = self.snapshotList?.toMap()
                }
                if self.summaryList != nil {
                    map["SummaryList"] = self.summaryList?.toMap()
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CensorState") {
                    self.censorState = dict["CensorState"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("File") {
                    var model = QueryMediaListResponseBody.MediaList.Media.File()
                    model.fromMap(dict["File"] as! [String: Any])
                    self.file = model
                }
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaInfo") {
                    var model = QueryMediaListResponseBody.MediaList.Media.MediaInfo()
                    model.fromMap(dict["MediaInfo"] as! [String: Any])
                    self.mediaInfo = model
                }
                if dict.keys.contains("PlayList") {
                    var model = QueryMediaListResponseBody.MediaList.Media.PlayList()
                    model.fromMap(dict["PlayList"] as! [String: Any])
                    self.playList = model
                }
                if dict.keys.contains("PublishState") {
                    self.publishState = dict["PublishState"] as! String
                }
                if dict.keys.contains("RunIdList") {
                    var model = QueryMediaListResponseBody.MediaList.Media.RunIdList()
                    model.fromMap(dict["RunIdList"] as! [String: Any])
                    self.runIdList = model
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! String
                }
                if dict.keys.contains("SnapshotList") {
                    var model = QueryMediaListResponseBody.MediaList.Media.SnapshotList()
                    model.fromMap(dict["SnapshotList"] as! [String: Any])
                    self.snapshotList = model
                }
                if dict.keys.contains("SummaryList") {
                    var model = QueryMediaListResponseBody.MediaList.Media.SummaryList()
                    model.fromMap(dict["SummaryList"] as! [String: Any])
                    self.summaryList = model
                }
                if dict.keys.contains("Tags") {
                    var model = QueryMediaListResponseBody.MediaList.Media.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var media: [QueryMediaListResponseBody.MediaList.Media]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                var tmp : [Any] = []
                for k in self.media! {
                    tmp.append(k.toMap())
                }
                map["Media"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                var tmp : [QueryMediaListResponseBody.MediaList.Media] = []
                for v in dict["Media"] as! [Any] {
                    var model = QueryMediaListResponseBody.MediaList.Media()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.media = tmp
            }
        }
    }
    public class NonExistMediaIds : Tea.TeaModel {
        public var mediaId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! [String]
            }
        }
    }
    public var mediaList: QueryMediaListResponseBody.MediaList?

    public var nonExistMediaIds: QueryMediaListResponseBody.NonExistMediaIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaList?.validate()
        try self.nonExistMediaIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaList != nil {
            map["MediaList"] = self.mediaList?.toMap()
        }
        if self.nonExistMediaIds != nil {
            map["NonExistMediaIds"] = self.nonExistMediaIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaList") {
            var model = QueryMediaListResponseBody.MediaList()
            model.fromMap(dict["MediaList"] as! [String: Any])
            self.mediaList = model
        }
        if dict.keys.contains("NonExistMediaIds") {
            var model = QueryMediaListResponseBody.NonExistMediaIds()
            model.fromMap(dict["NonExistMediaIds"] as! [String: Any])
            self.nonExistMediaIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMediaListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMediaListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaListByURLRequest : Tea.TeaModel {
    public var fileURLs: String?

    public var includeMediaInfo: Bool?

    public var includePlayList: Bool?

    public var includeSnapshotList: Bool?

    public var includeSummaryList: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileURLs != nil {
            map["FileURLs"] = self.fileURLs!
        }
        if self.includeMediaInfo != nil {
            map["IncludeMediaInfo"] = self.includeMediaInfo!
        }
        if self.includePlayList != nil {
            map["IncludePlayList"] = self.includePlayList!
        }
        if self.includeSnapshotList != nil {
            map["IncludeSnapshotList"] = self.includeSnapshotList!
        }
        if self.includeSummaryList != nil {
            map["IncludeSummaryList"] = self.includeSummaryList!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileURLs") {
            self.fileURLs = dict["FileURLs"] as! String
        }
        if dict.keys.contains("IncludeMediaInfo") {
            self.includeMediaInfo = dict["IncludeMediaInfo"] as! Bool
        }
        if dict.keys.contains("IncludePlayList") {
            self.includePlayList = dict["IncludePlayList"] as! Bool
        }
        if dict.keys.contains("IncludeSnapshotList") {
            self.includeSnapshotList = dict["IncludeSnapshotList"] as! Bool
        }
        if dict.keys.contains("IncludeSummaryList") {
            self.includeSummaryList = dict["IncludeSummaryList"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryMediaListByURLResponseBody : Tea.TeaModel {
    public class MediaList : Tea.TeaModel {
        public class Media : Tea.TeaModel {
            public class File : Tea.TeaModel {
                public var state: String?

                public var URL: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    if self.URL != nil {
                        map["URL"] = self.URL!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! String
                    }
                    if dict.keys.contains("URL") {
                        self.URL = dict["URL"] as! String
                    }
                }
            }
            public class MediaInfo : Tea.TeaModel {
                public class Format : Tea.TeaModel {
                    public var bitrate: String?

                    public var duration: String?

                    public var formatLongName: String?

                    public var formatName: String?

                    public var numPrograms: String?

                    public var numStreams: String?

                    public var size: String?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.formatLongName != nil {
                            map["FormatLongName"] = self.formatLongName!
                        }
                        if self.formatName != nil {
                            map["FormatName"] = self.formatName!
                        }
                        if self.numPrograms != nil {
                            map["NumPrograms"] = self.numPrograms!
                        }
                        if self.numStreams != nil {
                            map["NumStreams"] = self.numStreams!
                        }
                        if self.size != nil {
                            map["Size"] = self.size!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("FormatLongName") {
                            self.formatLongName = dict["FormatLongName"] as! String
                        }
                        if dict.keys.contains("FormatName") {
                            self.formatName = dict["FormatName"] as! String
                        }
                        if dict.keys.contains("NumPrograms") {
                            self.numPrograms = dict["NumPrograms"] as! String
                        }
                        if dict.keys.contains("NumStreams") {
                            self.numStreams = dict["NumStreams"] as! String
                        }
                        if dict.keys.contains("Size") {
                            self.size = dict["Size"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                    }
                }
                public class Streams : Tea.TeaModel {
                    public class AudioStreamList : Tea.TeaModel {
                        public class AudioStream : Tea.TeaModel {
                            public var bitrate: String?

                            public var channelLayout: String?

                            public var channels: String?

                            public var codecLongName: String?

                            public var codecName: String?

                            public var codecTag: String?

                            public var codecTagString: String?

                            public var codecTimeBase: String?

                            public var duration: String?

                            public var index: String?

                            public var lang: String?

                            public var numFrames: String?

                            public var sampleFmt: String?

                            public var samplerate: String?

                            public var startTime: String?

                            public var timebase: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.channelLayout != nil {
                                    map["ChannelLayout"] = self.channelLayout!
                                }
                                if self.channels != nil {
                                    map["Channels"] = self.channels!
                                }
                                if self.codecLongName != nil {
                                    map["CodecLongName"] = self.codecLongName!
                                }
                                if self.codecName != nil {
                                    map["CodecName"] = self.codecName!
                                }
                                if self.codecTag != nil {
                                    map["CodecTag"] = self.codecTag!
                                }
                                if self.codecTagString != nil {
                                    map["CodecTagString"] = self.codecTagString!
                                }
                                if self.codecTimeBase != nil {
                                    map["CodecTimeBase"] = self.codecTimeBase!
                                }
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.index != nil {
                                    map["Index"] = self.index!
                                }
                                if self.lang != nil {
                                    map["Lang"] = self.lang!
                                }
                                if self.numFrames != nil {
                                    map["NumFrames"] = self.numFrames!
                                }
                                if self.sampleFmt != nil {
                                    map["SampleFmt"] = self.sampleFmt!
                                }
                                if self.samplerate != nil {
                                    map["Samplerate"] = self.samplerate!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                if self.timebase != nil {
                                    map["Timebase"] = self.timebase!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("ChannelLayout") {
                                    self.channelLayout = dict["ChannelLayout"] as! String
                                }
                                if dict.keys.contains("Channels") {
                                    self.channels = dict["Channels"] as! String
                                }
                                if dict.keys.contains("CodecLongName") {
                                    self.codecLongName = dict["CodecLongName"] as! String
                                }
                                if dict.keys.contains("CodecName") {
                                    self.codecName = dict["CodecName"] as! String
                                }
                                if dict.keys.contains("CodecTag") {
                                    self.codecTag = dict["CodecTag"] as! String
                                }
                                if dict.keys.contains("CodecTagString") {
                                    self.codecTagString = dict["CodecTagString"] as! String
                                }
                                if dict.keys.contains("CodecTimeBase") {
                                    self.codecTimeBase = dict["CodecTimeBase"] as! String
                                }
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Index") {
                                    self.index = dict["Index"] as! String
                                }
                                if dict.keys.contains("Lang") {
                                    self.lang = dict["Lang"] as! String
                                }
                                if dict.keys.contains("NumFrames") {
                                    self.numFrames = dict["NumFrames"] as! String
                                }
                                if dict.keys.contains("SampleFmt") {
                                    self.sampleFmt = dict["SampleFmt"] as! String
                                }
                                if dict.keys.contains("Samplerate") {
                                    self.samplerate = dict["Samplerate"] as! String
                                }
                                if dict.keys.contains("StartTime") {
                                    self.startTime = dict["StartTime"] as! String
                                }
                                if dict.keys.contains("Timebase") {
                                    self.timebase = dict["Timebase"] as! String
                                }
                            }
                        }
                        public var audioStream: [QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList.AudioStream]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.audioStream != nil {
                                var tmp : [Any] = []
                                for k in self.audioStream! {
                                    tmp.append(k.toMap())
                                }
                                map["AudioStream"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AudioStream") {
                                var tmp : [QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList.AudioStream] = []
                                for v in dict["AudioStream"] as! [Any] {
                                    var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList.AudioStream()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.audioStream = tmp
                            }
                        }
                    }
                    public class SubtitleStreamList : Tea.TeaModel {
                        public class SubtitleStream : Tea.TeaModel {
                            public var index: String?

                            public var lang: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.index != nil {
                                    map["Index"] = self.index!
                                }
                                if self.lang != nil {
                                    map["Lang"] = self.lang!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Index") {
                                    self.index = dict["Index"] as! String
                                }
                                if dict.keys.contains("Lang") {
                                    self.lang = dict["Lang"] as! String
                                }
                            }
                        }
                        public var subtitleStream: [QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList.SubtitleStream]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.subtitleStream != nil {
                                var tmp : [Any] = []
                                for k in self.subtitleStream! {
                                    tmp.append(k.toMap())
                                }
                                map["SubtitleStream"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("SubtitleStream") {
                                var tmp : [QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList.SubtitleStream] = []
                                for v in dict["SubtitleStream"] as! [Any] {
                                    var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList.SubtitleStream()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.subtitleStream = tmp
                            }
                        }
                    }
                    public class VideoStreamList : Tea.TeaModel {
                        public class VideoStream : Tea.TeaModel {
                            public class NetworkCost : Tea.TeaModel {
                                public var avgBitrate: String?

                                public var costBandwidth: String?

                                public var preloadTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.avgBitrate != nil {
                                        map["AvgBitrate"] = self.avgBitrate!
                                    }
                                    if self.costBandwidth != nil {
                                        map["CostBandwidth"] = self.costBandwidth!
                                    }
                                    if self.preloadTime != nil {
                                        map["PreloadTime"] = self.preloadTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("AvgBitrate") {
                                        self.avgBitrate = dict["AvgBitrate"] as! String
                                    }
                                    if dict.keys.contains("CostBandwidth") {
                                        self.costBandwidth = dict["CostBandwidth"] as! String
                                    }
                                    if dict.keys.contains("PreloadTime") {
                                        self.preloadTime = dict["PreloadTime"] as! String
                                    }
                                }
                            }
                            public var avgFPS: String?

                            public var bitrate: String?

                            public var codecLongName: String?

                            public var codecName: String?

                            public var codecTag: String?

                            public var codecTagString: String?

                            public var codecTimeBase: String?

                            public var dar: String?

                            public var duration: String?

                            public var fps: String?

                            public var hasBFrames: String?

                            public var height: String?

                            public var index: String?

                            public var lang: String?

                            public var level: String?

                            public var networkCost: QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream.NetworkCost?

                            public var numFrames: String?

                            public var pixFmt: String?

                            public var profile: String?

                            public var rotate: String?

                            public var sar: String?

                            public var startTime: String?

                            public var timebase: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.networkCost?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.avgFPS != nil {
                                    map["AvgFPS"] = self.avgFPS!
                                }
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.codecLongName != nil {
                                    map["CodecLongName"] = self.codecLongName!
                                }
                                if self.codecName != nil {
                                    map["CodecName"] = self.codecName!
                                }
                                if self.codecTag != nil {
                                    map["CodecTag"] = self.codecTag!
                                }
                                if self.codecTagString != nil {
                                    map["CodecTagString"] = self.codecTagString!
                                }
                                if self.codecTimeBase != nil {
                                    map["CodecTimeBase"] = self.codecTimeBase!
                                }
                                if self.dar != nil {
                                    map["Dar"] = self.dar!
                                }
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.fps != nil {
                                    map["Fps"] = self.fps!
                                }
                                if self.hasBFrames != nil {
                                    map["HasBFrames"] = self.hasBFrames!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.index != nil {
                                    map["Index"] = self.index!
                                }
                                if self.lang != nil {
                                    map["Lang"] = self.lang!
                                }
                                if self.level != nil {
                                    map["Level"] = self.level!
                                }
                                if self.networkCost != nil {
                                    map["NetworkCost"] = self.networkCost?.toMap()
                                }
                                if self.numFrames != nil {
                                    map["NumFrames"] = self.numFrames!
                                }
                                if self.pixFmt != nil {
                                    map["PixFmt"] = self.pixFmt!
                                }
                                if self.profile != nil {
                                    map["Profile"] = self.profile!
                                }
                                if self.rotate != nil {
                                    map["Rotate"] = self.rotate!
                                }
                                if self.sar != nil {
                                    map["Sar"] = self.sar!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                if self.timebase != nil {
                                    map["Timebase"] = self.timebase!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AvgFPS") {
                                    self.avgFPS = dict["AvgFPS"] as! String
                                }
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("CodecLongName") {
                                    self.codecLongName = dict["CodecLongName"] as! String
                                }
                                if dict.keys.contains("CodecName") {
                                    self.codecName = dict["CodecName"] as! String
                                }
                                if dict.keys.contains("CodecTag") {
                                    self.codecTag = dict["CodecTag"] as! String
                                }
                                if dict.keys.contains("CodecTagString") {
                                    self.codecTagString = dict["CodecTagString"] as! String
                                }
                                if dict.keys.contains("CodecTimeBase") {
                                    self.codecTimeBase = dict["CodecTimeBase"] as! String
                                }
                                if dict.keys.contains("Dar") {
                                    self.dar = dict["Dar"] as! String
                                }
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Fps") {
                                    self.fps = dict["Fps"] as! String
                                }
                                if dict.keys.contains("HasBFrames") {
                                    self.hasBFrames = dict["HasBFrames"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("Index") {
                                    self.index = dict["Index"] as! String
                                }
                                if dict.keys.contains("Lang") {
                                    self.lang = dict["Lang"] as! String
                                }
                                if dict.keys.contains("Level") {
                                    self.level = dict["Level"] as! String
                                }
                                if dict.keys.contains("NetworkCost") {
                                    var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream.NetworkCost()
                                    model.fromMap(dict["NetworkCost"] as! [String: Any])
                                    self.networkCost = model
                                }
                                if dict.keys.contains("NumFrames") {
                                    self.numFrames = dict["NumFrames"] as! String
                                }
                                if dict.keys.contains("PixFmt") {
                                    self.pixFmt = dict["PixFmt"] as! String
                                }
                                if dict.keys.contains("Profile") {
                                    self.profile = dict["Profile"] as! String
                                }
                                if dict.keys.contains("Rotate") {
                                    self.rotate = dict["Rotate"] as! String
                                }
                                if dict.keys.contains("Sar") {
                                    self.sar = dict["Sar"] as! String
                                }
                                if dict.keys.contains("StartTime") {
                                    self.startTime = dict["StartTime"] as! String
                                }
                                if dict.keys.contains("Timebase") {
                                    self.timebase = dict["Timebase"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var videoStream: [QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.videoStream != nil {
                                var tmp : [Any] = []
                                for k in self.videoStream! {
                                    tmp.append(k.toMap())
                                }
                                map["VideoStream"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("VideoStream") {
                                var tmp : [QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream] = []
                                for v in dict["VideoStream"] as! [Any] {
                                    var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList.VideoStream()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.videoStream = tmp
                            }
                        }
                    }
                    public var audioStreamList: QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList?

                    public var subtitleStreamList: QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList?

                    public var videoStreamList: QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.audioStreamList?.validate()
                        try self.subtitleStreamList?.validate()
                        try self.videoStreamList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioStreamList != nil {
                            map["AudioStreamList"] = self.audioStreamList?.toMap()
                        }
                        if self.subtitleStreamList != nil {
                            map["SubtitleStreamList"] = self.subtitleStreamList?.toMap()
                        }
                        if self.videoStreamList != nil {
                            map["VideoStreamList"] = self.videoStreamList?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioStreamList") {
                            var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.AudioStreamList()
                            model.fromMap(dict["AudioStreamList"] as! [String: Any])
                            self.audioStreamList = model
                        }
                        if dict.keys.contains("SubtitleStreamList") {
                            var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.SubtitleStreamList()
                            model.fromMap(dict["SubtitleStreamList"] as! [String: Any])
                            self.subtitleStreamList = model
                        }
                        if dict.keys.contains("VideoStreamList") {
                            var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams.VideoStreamList()
                            model.fromMap(dict["VideoStreamList"] as! [String: Any])
                            self.videoStreamList = model
                        }
                    }
                }
                public var format: QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Format?

                public var streams: QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.format?.validate()
                    try self.streams?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.format != nil {
                        map["Format"] = self.format?.toMap()
                    }
                    if self.streams != nil {
                        map["Streams"] = self.streams?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Format") {
                        var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Format()
                        model.fromMap(dict["Format"] as! [String: Any])
                        self.format = model
                    }
                    if dict.keys.contains("Streams") {
                        var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo.Streams()
                        model.fromMap(dict["Streams"] as! [String: Any])
                        self.streams = model
                    }
                }
            }
            public class PlayList : Tea.TeaModel {
                public class Play : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var state: String?

                        public var URL: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.state != nil {
                                map["State"] = self.state!
                            }
                            if self.URL != nil {
                                map["URL"] = self.URL!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("State") {
                                self.state = dict["State"] as! String
                            }
                            if dict.keys.contains("URL") {
                                self.URL = dict["URL"] as! String
                            }
                        }
                    }
                    public var activityName: String?

                    public var bitrate: String?

                    public var duration: String?

                    public var encryption: String?

                    public var file: QueryMediaListByURLResponseBody.MediaList.Media.PlayList.Play.File?

                    public var format: String?

                    public var fps: String?

                    public var height: String?

                    public var mediaWorkflowId: String?

                    public var mediaWorkflowName: String?

                    public var size: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.activityName != nil {
                            map["ActivityName"] = self.activityName!
                        }
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        if self.encryption != nil {
                            map["Encryption"] = self.encryption!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.mediaWorkflowId != nil {
                            map["MediaWorkflowId"] = self.mediaWorkflowId!
                        }
                        if self.mediaWorkflowName != nil {
                            map["MediaWorkflowName"] = self.mediaWorkflowName!
                        }
                        if self.size != nil {
                            map["Size"] = self.size!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ActivityName") {
                            self.activityName = dict["ActivityName"] as! String
                        }
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                        if dict.keys.contains("Encryption") {
                            self.encryption = dict["Encryption"] as! String
                        }
                        if dict.keys.contains("File") {
                            var model = QueryMediaListByURLResponseBody.MediaList.Media.PlayList.Play.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("MediaWorkflowId") {
                            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                        }
                        if dict.keys.contains("MediaWorkflowName") {
                            self.mediaWorkflowName = dict["MediaWorkflowName"] as! String
                        }
                        if dict.keys.contains("Size") {
                            self.size = dict["Size"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var play: [QueryMediaListByURLResponseBody.MediaList.Media.PlayList.Play]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.play != nil {
                        var tmp : [Any] = []
                        for k in self.play! {
                            tmp.append(k.toMap())
                        }
                        map["Play"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Play") {
                        var tmp : [QueryMediaListByURLResponseBody.MediaList.Media.PlayList.Play] = []
                        for v in dict["Play"] as! [Any] {
                            var model = QueryMediaListByURLResponseBody.MediaList.Media.PlayList.Play()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.play = tmp
                    }
                }
            }
            public class RunIdList : Tea.TeaModel {
                public var runId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.runId != nil {
                        map["RunId"] = self.runId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RunId") {
                        self.runId = dict["RunId"] as! [String]
                    }
                }
            }
            public class SnapshotList : Tea.TeaModel {
                public class Snapshot : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var state: String?

                        public var URL: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.state != nil {
                                map["State"] = self.state!
                            }
                            if self.URL != nil {
                                map["URL"] = self.URL!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("State") {
                                self.state = dict["State"] as! String
                            }
                            if dict.keys.contains("URL") {
                                self.URL = dict["URL"] as! String
                            }
                        }
                    }
                    public var activityName: String?

                    public var count: String?

                    public var file: QueryMediaListByURLResponseBody.MediaList.Media.SnapshotList.Snapshot.File?

                    public var mediaWorkflowId: String?

                    public var mediaWorkflowName: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.activityName != nil {
                            map["ActivityName"] = self.activityName!
                        }
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.mediaWorkflowId != nil {
                            map["MediaWorkflowId"] = self.mediaWorkflowId!
                        }
                        if self.mediaWorkflowName != nil {
                            map["MediaWorkflowName"] = self.mediaWorkflowName!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ActivityName") {
                            self.activityName = dict["ActivityName"] as! String
                        }
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! String
                        }
                        if dict.keys.contains("File") {
                            var model = QueryMediaListByURLResponseBody.MediaList.Media.SnapshotList.Snapshot.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("MediaWorkflowId") {
                            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                        }
                        if dict.keys.contains("MediaWorkflowName") {
                            self.mediaWorkflowName = dict["MediaWorkflowName"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var snapshot: [QueryMediaListByURLResponseBody.MediaList.Media.SnapshotList.Snapshot]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.snapshot != nil {
                        var tmp : [Any] = []
                        for k in self.snapshot! {
                            tmp.append(k.toMap())
                        }
                        map["Snapshot"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Snapshot") {
                        var tmp : [QueryMediaListByURLResponseBody.MediaList.Media.SnapshotList.Snapshot] = []
                        for v in dict["Snapshot"] as! [Any] {
                            var model = QueryMediaListByURLResponseBody.MediaList.Media.SnapshotList.Snapshot()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.snapshot = tmp
                    }
                }
            }
            public class SummaryList : Tea.TeaModel {
                public class Summary : Tea.TeaModel {
                    public class File : Tea.TeaModel {
                        public var state: String?

                        public var URL: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.state != nil {
                                map["State"] = self.state!
                            }
                            if self.URL != nil {
                                map["URL"] = self.URL!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("State") {
                                self.state = dict["State"] as! String
                            }
                            if dict.keys.contains("URL") {
                                self.URL = dict["URL"] as! String
                            }
                        }
                    }
                    public var activityName: String?

                    public var file: QueryMediaListByURLResponseBody.MediaList.Media.SummaryList.Summary.File?

                    public var mediaWorkflowId: String?

                    public var mediaWorkflowName: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.file?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.activityName != nil {
                            map["ActivityName"] = self.activityName!
                        }
                        if self.file != nil {
                            map["File"] = self.file?.toMap()
                        }
                        if self.mediaWorkflowId != nil {
                            map["MediaWorkflowId"] = self.mediaWorkflowId!
                        }
                        if self.mediaWorkflowName != nil {
                            map["MediaWorkflowName"] = self.mediaWorkflowName!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ActivityName") {
                            self.activityName = dict["ActivityName"] as! String
                        }
                        if dict.keys.contains("File") {
                            var model = QueryMediaListByURLResponseBody.MediaList.Media.SummaryList.Summary.File()
                            model.fromMap(dict["File"] as! [String: Any])
                            self.file = model
                        }
                        if dict.keys.contains("MediaWorkflowId") {
                            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                        }
                        if dict.keys.contains("MediaWorkflowName") {
                            self.mediaWorkflowName = dict["MediaWorkflowName"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var summary: [QueryMediaListByURLResponseBody.MediaList.Media.SummaryList.Summary]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.summary != nil {
                        var tmp : [Any] = []
                        for k in self.summary! {
                            tmp.append(k.toMap())
                        }
                        map["Summary"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Summary") {
                        var tmp : [QueryMediaListByURLResponseBody.MediaList.Media.SummaryList.Summary] = []
                        for v in dict["Summary"] as! [Any] {
                            var model = QueryMediaListByURLResponseBody.MediaList.Media.SummaryList.Summary()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.summary = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var tag: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        map["Tag"] = self.tag!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        self.tag = dict["Tag"] as! [String]
                    }
                }
            }
            public var bitrate: String?

            public var cateId: Int64?

            public var censorState: String?

            public var coverURL: String?

            public var creationTime: String?

            public var description_: String?

            public var duration: String?

            public var file: QueryMediaListByURLResponseBody.MediaList.Media.File?

            public var format: String?

            public var fps: String?

            public var height: String?

            public var mediaId: String?

            public var mediaInfo: QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo?

            public var playList: QueryMediaListByURLResponseBody.MediaList.Media.PlayList?

            public var publishState: String?

            public var runIdList: QueryMediaListByURLResponseBody.MediaList.Media.RunIdList?

            public var size: String?

            public var snapshotList: QueryMediaListByURLResponseBody.MediaList.Media.SnapshotList?

            public var summaryList: QueryMediaListByURLResponseBody.MediaList.Media.SummaryList?

            public var tags: QueryMediaListByURLResponseBody.MediaList.Media.Tags?

            public var title: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.file?.validate()
                try self.mediaInfo?.validate()
                try self.playList?.validate()
                try self.runIdList?.validate()
                try self.snapshotList?.validate()
                try self.summaryList?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.cateId != nil {
                    map["CateId"] = self.cateId!
                }
                if self.censorState != nil {
                    map["CensorState"] = self.censorState!
                }
                if self.coverURL != nil {
                    map["CoverURL"] = self.coverURL!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.file != nil {
                    map["File"] = self.file?.toMap()
                }
                if self.format != nil {
                    map["Format"] = self.format!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaInfo != nil {
                    map["MediaInfo"] = self.mediaInfo?.toMap()
                }
                if self.playList != nil {
                    map["PlayList"] = self.playList?.toMap()
                }
                if self.publishState != nil {
                    map["PublishState"] = self.publishState!
                }
                if self.runIdList != nil {
                    map["RunIdList"] = self.runIdList?.toMap()
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshotList != nil {
                    map["SnapshotList"] = self.snapshotList?.toMap()
                }
                if self.summaryList != nil {
                    map["SummaryList"] = self.summaryList?.toMap()
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("CateId") {
                    self.cateId = dict["CateId"] as! Int64
                }
                if dict.keys.contains("CensorState") {
                    self.censorState = dict["CensorState"] as! String
                }
                if dict.keys.contains("CoverURL") {
                    self.coverURL = dict["CoverURL"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("File") {
                    var model = QueryMediaListByURLResponseBody.MediaList.Media.File()
                    model.fromMap(dict["File"] as! [String: Any])
                    self.file = model
                }
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaInfo") {
                    var model = QueryMediaListByURLResponseBody.MediaList.Media.MediaInfo()
                    model.fromMap(dict["MediaInfo"] as! [String: Any])
                    self.mediaInfo = model
                }
                if dict.keys.contains("PlayList") {
                    var model = QueryMediaListByURLResponseBody.MediaList.Media.PlayList()
                    model.fromMap(dict["PlayList"] as! [String: Any])
                    self.playList = model
                }
                if dict.keys.contains("PublishState") {
                    self.publishState = dict["PublishState"] as! String
                }
                if dict.keys.contains("RunIdList") {
                    var model = QueryMediaListByURLResponseBody.MediaList.Media.RunIdList()
                    model.fromMap(dict["RunIdList"] as! [String: Any])
                    self.runIdList = model
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! String
                }
                if dict.keys.contains("SnapshotList") {
                    var model = QueryMediaListByURLResponseBody.MediaList.Media.SnapshotList()
                    model.fromMap(dict["SnapshotList"] as! [String: Any])
                    self.snapshotList = model
                }
                if dict.keys.contains("SummaryList") {
                    var model = QueryMediaListByURLResponseBody.MediaList.Media.SummaryList()
                    model.fromMap(dict["SummaryList"] as! [String: Any])
                    self.summaryList = model
                }
                if dict.keys.contains("Tags") {
                    var model = QueryMediaListByURLResponseBody.MediaList.Media.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var media: [QueryMediaListByURLResponseBody.MediaList.Media]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.media != nil {
                var tmp : [Any] = []
                for k in self.media! {
                    tmp.append(k.toMap())
                }
                map["Media"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Media") {
                var tmp : [QueryMediaListByURLResponseBody.MediaList.Media] = []
                for v in dict["Media"] as! [Any] {
                    var model = QueryMediaListByURLResponseBody.MediaList.Media()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.media = tmp
            }
        }
    }
    public class NonExistFileURLs : Tea.TeaModel {
        public var fileURL: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileURL != nil {
                map["FileURL"] = self.fileURL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileURL") {
                self.fileURL = dict["FileURL"] as! [String]
            }
        }
    }
    public var mediaList: QueryMediaListByURLResponseBody.MediaList?

    public var nonExistFileURLs: QueryMediaListByURLResponseBody.NonExistFileURLs?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaList?.validate()
        try self.nonExistFileURLs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaList != nil {
            map["MediaList"] = self.mediaList?.toMap()
        }
        if self.nonExistFileURLs != nil {
            map["NonExistFileURLs"] = self.nonExistFileURLs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaList") {
            var model = QueryMediaListByURLResponseBody.MediaList()
            model.fromMap(dict["MediaList"] as! [String: Any])
            self.mediaList = model
        }
        if dict.keys.contains("NonExistFileURLs") {
            var model = QueryMediaListByURLResponseBody.NonExistFileURLs()
            model.fromMap(dict["NonExistFileURLs"] as! [String: Any])
            self.nonExistFileURLs = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMediaListByURLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaListByURLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMediaListByURLResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaWorkflowExecutionListRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var runIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.runIds != nil {
            map["RunIds"] = self.runIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RunIds") {
            self.runIds = dict["RunIds"] as! String
        }
    }
}

public class QueryMediaWorkflowExecutionListResponseBody : Tea.TeaModel {
    public class MediaWorkflowExecutionList : Tea.TeaModel {
        public class MediaWorkflowExecution : Tea.TeaModel {
            public class ActivityList : Tea.TeaModel {
                public class Activity : Tea.TeaModel {
                    public class MNSMessageResult : Tea.TeaModel {
                        public var errorCode: String?

                        public var errorMessage: String?

                        public var messageId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.errorCode != nil {
                                map["ErrorCode"] = self.errorCode!
                            }
                            if self.errorMessage != nil {
                                map["ErrorMessage"] = self.errorMessage!
                            }
                            if self.messageId != nil {
                                map["MessageId"] = self.messageId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ErrorCode") {
                                self.errorCode = dict["ErrorCode"] as! String
                            }
                            if dict.keys.contains("ErrorMessage") {
                                self.errorMessage = dict["ErrorMessage"] as! String
                            }
                            if dict.keys.contains("MessageId") {
                                self.messageId = dict["MessageId"] as! String
                            }
                        }
                    }
                    public var code: String?

                    public var endTime: String?

                    public var jobId: String?

                    public var MNSMessageResult: QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity.MNSMessageResult?

                    public var message: String?

                    public var name: String?

                    public var startTime: String?

                    public var state: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.MNSMessageResult?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.code != nil {
                            map["Code"] = self.code!
                        }
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.jobId != nil {
                            map["JobId"] = self.jobId!
                        }
                        if self.MNSMessageResult != nil {
                            map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
                        }
                        if self.message != nil {
                            map["Message"] = self.message!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.state != nil {
                            map["State"] = self.state!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Code") {
                            self.code = dict["Code"] as! String
                        }
                        if dict.keys.contains("EndTime") {
                            self.endTime = dict["EndTime"] as! String
                        }
                        if dict.keys.contains("JobId") {
                            self.jobId = dict["JobId"] as! String
                        }
                        if dict.keys.contains("MNSMessageResult") {
                            var model = QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity.MNSMessageResult()
                            model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                            self.MNSMessageResult = model
                        }
                        if dict.keys.contains("Message") {
                            self.message = dict["Message"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                        if dict.keys.contains("State") {
                            self.state = dict["State"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var activity: [QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.activity != nil {
                        var tmp : [Any] = []
                        for k in self.activity! {
                            tmp.append(k.toMap())
                        }
                        map["Activity"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Activity") {
                        var tmp : [QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity] = []
                        for v in dict["Activity"] as! [Any] {
                            var model = QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList.Activity()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.activity = tmp
                    }
                }
            }
            public class Input : Tea.TeaModel {
                public class InputFile : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                    }
                }
                public var inputFile: QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.Input.InputFile?

                public var userData: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.inputFile?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.inputFile != nil {
                        map["InputFile"] = self.inputFile?.toMap()
                    }
                    if self.userData != nil {
                        map["UserData"] = self.userData!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InputFile") {
                        var model = QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.Input.InputFile()
                        model.fromMap(dict["InputFile"] as! [String: Any])
                        self.inputFile = model
                    }
                    if dict.keys.contains("UserData") {
                        self.userData = dict["UserData"] as! String
                    }
                }
            }
            public var activityList: QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList?

            public var creationTime: String?

            public var input: QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.Input?

            public var mediaId: String?

            public var mediaWorkflowId: String?

            public var name: String?

            public var runId: String?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.activityList?.validate()
                try self.input?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activityList != nil {
                    map["ActivityList"] = self.activityList?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                if self.mediaId != nil {
                    map["MediaId"] = self.mediaId!
                }
                if self.mediaWorkflowId != nil {
                    map["MediaWorkflowId"] = self.mediaWorkflowId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.runId != nil {
                    map["RunId"] = self.runId!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActivityList") {
                    var model = QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.ActivityList()
                    model.fromMap(dict["ActivityList"] as! [String: Any])
                    self.activityList = model
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Input") {
                    var model = QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
                if dict.keys.contains("MediaId") {
                    self.mediaId = dict["MediaId"] as! String
                }
                if dict.keys.contains("MediaWorkflowId") {
                    self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RunId") {
                    self.runId = dict["RunId"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
            }
        }
        public var mediaWorkflowExecution: [QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaWorkflowExecution != nil {
                var tmp : [Any] = []
                for k in self.mediaWorkflowExecution! {
                    tmp.append(k.toMap())
                }
                map["MediaWorkflowExecution"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaWorkflowExecution") {
                var tmp : [QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution] = []
                for v in dict["MediaWorkflowExecution"] as! [Any] {
                    var model = QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList.MediaWorkflowExecution()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaWorkflowExecution = tmp
            }
        }
    }
    public class NonExistRunIds : Tea.TeaModel {
        public var runId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.runId != nil {
                map["RunId"] = self.runId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RunId") {
                self.runId = dict["RunId"] as! [String]
            }
        }
    }
    public var mediaWorkflowExecutionList: QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList?

    public var nonExistRunIds: QueryMediaWorkflowExecutionListResponseBody.NonExistRunIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflowExecutionList?.validate()
        try self.nonExistRunIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowExecutionList != nil {
            map["MediaWorkflowExecutionList"] = self.mediaWorkflowExecutionList?.toMap()
        }
        if self.nonExistRunIds != nil {
            map["NonExistRunIds"] = self.nonExistRunIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowExecutionList") {
            var model = QueryMediaWorkflowExecutionListResponseBody.MediaWorkflowExecutionList()
            model.fromMap(dict["MediaWorkflowExecutionList"] as! [String: Any])
            self.mediaWorkflowExecutionList = model
        }
        if dict.keys.contains("NonExistRunIds") {
            var model = QueryMediaWorkflowExecutionListResponseBody.NonExistRunIds()
            model.fromMap(dict["NonExistRunIds"] as! [String: Any])
            self.nonExistRunIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMediaWorkflowExecutionListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaWorkflowExecutionListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMediaWorkflowExecutionListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryMediaWorkflowListRequest : Tea.TeaModel {
    public var mediaWorkflowIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowIds != nil {
            map["MediaWorkflowIds"] = self.mediaWorkflowIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowIds") {
            self.mediaWorkflowIds = dict["MediaWorkflowIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryMediaWorkflowListResponseBody : Tea.TeaModel {
    public class MediaWorkflowList : Tea.TeaModel {
        public class MediaWorkflow : Tea.TeaModel {
            public var creationTime: String?

            public var mediaWorkflowId: String?

            public var name: String?

            public var state: String?

            public var topology: String?

            public var triggerMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.mediaWorkflowId != nil {
                    map["MediaWorkflowId"] = self.mediaWorkflowId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.topology != nil {
                    map["Topology"] = self.topology!
                }
                if self.triggerMode != nil {
                    map["TriggerMode"] = self.triggerMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("MediaWorkflowId") {
                    self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Topology") {
                    self.topology = dict["Topology"] as! String
                }
                if dict.keys.contains("TriggerMode") {
                    self.triggerMode = dict["TriggerMode"] as! String
                }
            }
        }
        public var mediaWorkflow: [QueryMediaWorkflowListResponseBody.MediaWorkflowList.MediaWorkflow]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaWorkflow != nil {
                var tmp : [Any] = []
                for k in self.mediaWorkflow! {
                    tmp.append(k.toMap())
                }
                map["MediaWorkflow"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaWorkflow") {
                var tmp : [QueryMediaWorkflowListResponseBody.MediaWorkflowList.MediaWorkflow] = []
                for v in dict["MediaWorkflow"] as! [Any] {
                    var model = QueryMediaWorkflowListResponseBody.MediaWorkflowList.MediaWorkflow()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaWorkflow = tmp
            }
        }
    }
    public class NonExistMediaWorkflowIds : Tea.TeaModel {
        public var mediaWorkflowId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaWorkflowId != nil {
                map["MediaWorkflowId"] = self.mediaWorkflowId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaWorkflowId") {
                self.mediaWorkflowId = dict["MediaWorkflowId"] as! [String]
            }
        }
    }
    public var mediaWorkflowList: QueryMediaWorkflowListResponseBody.MediaWorkflowList?

    public var nonExistMediaWorkflowIds: QueryMediaWorkflowListResponseBody.NonExistMediaWorkflowIds?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflowList?.validate()
        try self.nonExistMediaWorkflowIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowList != nil {
            map["MediaWorkflowList"] = self.mediaWorkflowList?.toMap()
        }
        if self.nonExistMediaWorkflowIds != nil {
            map["NonExistMediaWorkflowIds"] = self.nonExistMediaWorkflowIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowList") {
            var model = QueryMediaWorkflowListResponseBody.MediaWorkflowList()
            model.fromMap(dict["MediaWorkflowList"] as! [String: Any])
            self.mediaWorkflowList = model
        }
        if dict.keys.contains("NonExistMediaWorkflowIds") {
            var model = QueryMediaWorkflowListResponseBody.NonExistMediaWorkflowIds()
            model.fromMap(dict["NonExistMediaWorkflowIds"] as! [String: Any])
            self.nonExistMediaWorkflowIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryMediaWorkflowListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryMediaWorkflowListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryMediaWorkflowListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryPipelineListRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineIds: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineIds != nil {
            map["PipelineIds"] = self.pipelineIds!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineIds") {
            self.pipelineIds = dict["PipelineIds"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QueryPipelineListResponseBody : Tea.TeaModel {
    public class NonExistPids : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public class PipelineList : Tea.TeaModel {
        public class Pipeline : Tea.TeaModel {
            public class ExtendConfig : Tea.TeaModel {
                public var isBoostNew: Bool?

                public var maxMultiSpeed: Int32?

                public var multiSpeedDowngradePolicy: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.isBoostNew != nil {
                        map["IsBoostNew"] = self.isBoostNew!
                    }
                    if self.maxMultiSpeed != nil {
                        map["MaxMultiSpeed"] = self.maxMultiSpeed!
                    }
                    if self.multiSpeedDowngradePolicy != nil {
                        map["MultiSpeedDowngradePolicy"] = self.multiSpeedDowngradePolicy!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IsBoostNew") {
                        self.isBoostNew = dict["IsBoostNew"] as! Bool
                    }
                    if dict.keys.contains("MaxMultiSpeed") {
                        self.maxMultiSpeed = dict["MaxMultiSpeed"] as! Int32
                    }
                    if dict.keys.contains("MultiSpeedDowngradePolicy") {
                        self.multiSpeedDowngradePolicy = dict["MultiSpeedDowngradePolicy"] as! String
                    }
                }
            }
            public class NotifyConfig : Tea.TeaModel {
                public var mqTag: String?

                public var mqTopic: String?

                public var queueName: String?

                public var topic: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mqTag != nil {
                        map["MqTag"] = self.mqTag!
                    }
                    if self.mqTopic != nil {
                        map["MqTopic"] = self.mqTopic!
                    }
                    if self.queueName != nil {
                        map["QueueName"] = self.queueName!
                    }
                    if self.topic != nil {
                        map["Topic"] = self.topic!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MqTag") {
                        self.mqTag = dict["MqTag"] as! String
                    }
                    if dict.keys.contains("MqTopic") {
                        self.mqTopic = dict["MqTopic"] as! String
                    }
                    if dict.keys.contains("QueueName") {
                        self.queueName = dict["QueueName"] as! String
                    }
                    if dict.keys.contains("Topic") {
                        self.topic = dict["Topic"] as! String
                    }
                }
            }
            public var extendConfig: QueryPipelineListResponseBody.PipelineList.Pipeline.ExtendConfig?

            public var id: String?

            public var name: String?

            public var notifyConfig: QueryPipelineListResponseBody.PipelineList.Pipeline.NotifyConfig?

            public var quotaAllocate: Int64?

            public var role: String?

            public var speed: String?

            public var speedLevel: Int64?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.extendConfig?.validate()
                try self.notifyConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.extendConfig != nil {
                    map["ExtendConfig"] = self.extendConfig?.toMap()
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.notifyConfig != nil {
                    map["NotifyConfig"] = self.notifyConfig?.toMap()
                }
                if self.quotaAllocate != nil {
                    map["QuotaAllocate"] = self.quotaAllocate!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.speed != nil {
                    map["Speed"] = self.speed!
                }
                if self.speedLevel != nil {
                    map["SpeedLevel"] = self.speedLevel!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ExtendConfig") {
                    var model = QueryPipelineListResponseBody.PipelineList.Pipeline.ExtendConfig()
                    model.fromMap(dict["ExtendConfig"] as! [String: Any])
                    self.extendConfig = model
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NotifyConfig") {
                    var model = QueryPipelineListResponseBody.PipelineList.Pipeline.NotifyConfig()
                    model.fromMap(dict["NotifyConfig"] as! [String: Any])
                    self.notifyConfig = model
                }
                if dict.keys.contains("QuotaAllocate") {
                    self.quotaAllocate = dict["QuotaAllocate"] as! Int64
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("Speed") {
                    self.speed = dict["Speed"] as! String
                }
                if dict.keys.contains("SpeedLevel") {
                    self.speedLevel = dict["SpeedLevel"] as! Int64
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
            }
        }
        public var pipeline: [QueryPipelineListResponseBody.PipelineList.Pipeline]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipeline != nil {
                var tmp : [Any] = []
                for k in self.pipeline! {
                    tmp.append(k.toMap())
                }
                map["Pipeline"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Pipeline") {
                var tmp : [QueryPipelineListResponseBody.PipelineList.Pipeline] = []
                for v in dict["Pipeline"] as! [Any] {
                    var model = QueryPipelineListResponseBody.PipelineList.Pipeline()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.pipeline = tmp
            }
        }
    }
    public var nonExistPids: QueryPipelineListResponseBody.NonExistPids?

    public var pipelineList: QueryPipelineListResponseBody.PipelineList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nonExistPids?.validate()
        try self.pipelineList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistPids != nil {
            map["NonExistPids"] = self.nonExistPids?.toMap()
        }
        if self.pipelineList != nil {
            map["PipelineList"] = self.pipelineList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistPids") {
            var model = QueryPipelineListResponseBody.NonExistPids()
            model.fromMap(dict["NonExistPids"] as! [String: Any])
            self.nonExistPids = model
        }
        if dict.keys.contains("PipelineList") {
            var model = QueryPipelineListResponseBody.PipelineList()
            model.fromMap(dict["PipelineList"] as! [String: Any])
            self.pipelineList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryPipelineListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryPipelineListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryPipelineListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySmarttagJobRequest : Tea.TeaModel {
    public var jobId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var params: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class QuerySmarttagJobResponseBody : Tea.TeaModel {
    public class Results : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var data: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var result: [QuerySmarttagJobResponseBody.Results.Result]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Result") {
                var tmp : [QuerySmarttagJobResponseBody.Results.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = QuerySmarttagJobResponseBody.Results.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
        }
    }
    public var jobStatus: String?

    public var message: String?

    public var requestId: String?

    public var results: QuerySmarttagJobResponseBody.Results?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.results?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobStatus != nil {
            map["JobStatus"] = self.jobStatus!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.results != nil {
            map["Results"] = self.results?.toMap()
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobStatus") {
            self.jobStatus = dict["JobStatus"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Results") {
            var model = QuerySmarttagJobResponseBody.Results()
            model.fromMap(dict["Results"] as! [String: Any])
            self.results = model
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class QuerySmarttagJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySmarttagJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QuerySmarttagJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySmarttagTemplateListRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class QuerySmarttagTemplateListResponseBody : Tea.TeaModel {
    public class Templates : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public var analyseTypes: String?

            public var faceCategoryIds: String?

            public var faceCustomParamsConfig: String?

            public var industry: String?

            public var isDefault: Bool?

            public var keywordConfig: String?

            public var knowledgeConfig: String?

            public var labelType: String?

            public var labelVersion: String?

            public var landmarkGroupIds: String?

            public var objectGroupIds: String?

            public var scene: String?

            public var templateId: String?

            public var templateName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.analyseTypes != nil {
                    map["AnalyseTypes"] = self.analyseTypes!
                }
                if self.faceCategoryIds != nil {
                    map["FaceCategoryIds"] = self.faceCategoryIds!
                }
                if self.faceCustomParamsConfig != nil {
                    map["FaceCustomParamsConfig"] = self.faceCustomParamsConfig!
                }
                if self.industry != nil {
                    map["Industry"] = self.industry!
                }
                if self.isDefault != nil {
                    map["IsDefault"] = self.isDefault!
                }
                if self.keywordConfig != nil {
                    map["KeywordConfig"] = self.keywordConfig!
                }
                if self.knowledgeConfig != nil {
                    map["KnowledgeConfig"] = self.knowledgeConfig!
                }
                if self.labelType != nil {
                    map["LabelType"] = self.labelType!
                }
                if self.labelVersion != nil {
                    map["LabelVersion"] = self.labelVersion!
                }
                if self.landmarkGroupIds != nil {
                    map["LandmarkGroupIds"] = self.landmarkGroupIds!
                }
                if self.objectGroupIds != nil {
                    map["ObjectGroupIds"] = self.objectGroupIds!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AnalyseTypes") {
                    self.analyseTypes = dict["AnalyseTypes"] as! String
                }
                if dict.keys.contains("FaceCategoryIds") {
                    self.faceCategoryIds = dict["FaceCategoryIds"] as! String
                }
                if dict.keys.contains("FaceCustomParamsConfig") {
                    self.faceCustomParamsConfig = dict["FaceCustomParamsConfig"] as! String
                }
                if dict.keys.contains("Industry") {
                    self.industry = dict["Industry"] as! String
                }
                if dict.keys.contains("IsDefault") {
                    self.isDefault = dict["IsDefault"] as! Bool
                }
                if dict.keys.contains("KeywordConfig") {
                    self.keywordConfig = dict["KeywordConfig"] as! String
                }
                if dict.keys.contains("KnowledgeConfig") {
                    self.knowledgeConfig = dict["KnowledgeConfig"] as! String
                }
                if dict.keys.contains("LabelType") {
                    self.labelType = dict["LabelType"] as! String
                }
                if dict.keys.contains("LabelVersion") {
                    self.labelVersion = dict["LabelVersion"] as! String
                }
                if dict.keys.contains("LandmarkGroupIds") {
                    self.landmarkGroupIds = dict["LandmarkGroupIds"] as! String
                }
                if dict.keys.contains("ObjectGroupIds") {
                    self.objectGroupIds = dict["ObjectGroupIds"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("TemplateId") {
                    self.templateId = dict["TemplateId"] as! String
                }
                if dict.keys.contains("TemplateName") {
                    self.templateName = dict["TemplateName"] as! String
                }
            }
        }
        public var template: [QuerySmarttagTemplateListResponseBody.Templates.Template]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.template != nil {
                var tmp : [Any] = []
                for k in self.template! {
                    tmp.append(k.toMap())
                }
                map["Template"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Template") {
                var tmp : [QuerySmarttagTemplateListResponseBody.Templates.Template] = []
                for v in dict["Template"] as! [Any] {
                    var model = QuerySmarttagTemplateListResponseBody.Templates.Template()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.template = tmp
            }
        }
    }
    public var requestId: String?

    public var templates: QuerySmarttagTemplateListResponseBody.Templates?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templates?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templates != nil {
            map["Templates"] = self.templates?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Templates") {
            var model = QuerySmarttagTemplateListResponseBody.Templates()
            model.fromMap(dict["Templates"] as! [String: Any])
            self.templates = model
        }
    }
}

public class QuerySmarttagTemplateListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySmarttagTemplateListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QuerySmarttagTemplateListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QuerySnapshotJobListRequest : Tea.TeaModel {
    public var endOfJobCreatedTimeRange: String?

    public var maximumPageSize: Int64?

    public var nextPageToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotJobIds: String?

    public var startOfJobCreatedTimeRange: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endOfJobCreatedTimeRange != nil {
            map["EndOfJobCreatedTimeRange"] = self.endOfJobCreatedTimeRange!
        }
        if self.maximumPageSize != nil {
            map["MaximumPageSize"] = self.maximumPageSize!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotJobIds != nil {
            map["SnapshotJobIds"] = self.snapshotJobIds!
        }
        if self.startOfJobCreatedTimeRange != nil {
            map["StartOfJobCreatedTimeRange"] = self.startOfJobCreatedTimeRange!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndOfJobCreatedTimeRange") {
            self.endOfJobCreatedTimeRange = dict["EndOfJobCreatedTimeRange"] as! String
        }
        if dict.keys.contains("MaximumPageSize") {
            self.maximumPageSize = dict["MaximumPageSize"] as! Int64
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SnapshotJobIds") {
            self.snapshotJobIds = dict["SnapshotJobIds"] as! String
        }
        if dict.keys.contains("StartOfJobCreatedTimeRange") {
            self.startOfJobCreatedTimeRange = dict["StartOfJobCreatedTimeRange"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class QuerySnapshotJobListResponseBody : Tea.TeaModel {
    public class NonExistSnapshotJobIds : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public class SnapshotJobList : Tea.TeaModel {
        public class SnapshotJob : Tea.TeaModel {
            public class Input : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public var roleArn: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    if self.roleArn != nil {
                        map["RoleArn"] = self.roleArn!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                    if dict.keys.contains("RoleArn") {
                        self.roleArn = dict["RoleArn"] as! String
                    }
                }
            }
            public class MNSMessageResult : Tea.TeaModel {
                public var errorCode: String?

                public var errorMessage: String?

                public var messageId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.messageId != nil {
                        map["MessageId"] = self.messageId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("MessageId") {
                        self.messageId = dict["MessageId"] as! String
                    }
                }
            }
            public class SnapshotConfig : Tea.TeaModel {
                public class OutputFile : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public var roleArn: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        if self.roleArn != nil {
                            map["RoleArn"] = self.roleArn!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                        if dict.keys.contains("RoleArn") {
                            self.roleArn = dict["RoleArn"] as! String
                        }
                    }
                }
                public class TileOut : Tea.TeaModel {
                    public var cellHeight: String?

                    public var cellSelStep: String?

                    public var cellWidth: String?

                    public var color: String?

                    public var columns: String?

                    public var isKeepCellPic: String?

                    public var lines: String?

                    public var margin: String?

                    public var padding: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cellHeight != nil {
                            map["CellHeight"] = self.cellHeight!
                        }
                        if self.cellSelStep != nil {
                            map["CellSelStep"] = self.cellSelStep!
                        }
                        if self.cellWidth != nil {
                            map["CellWidth"] = self.cellWidth!
                        }
                        if self.color != nil {
                            map["Color"] = self.color!
                        }
                        if self.columns != nil {
                            map["Columns"] = self.columns!
                        }
                        if self.isKeepCellPic != nil {
                            map["IsKeepCellPic"] = self.isKeepCellPic!
                        }
                        if self.lines != nil {
                            map["Lines"] = self.lines!
                        }
                        if self.margin != nil {
                            map["Margin"] = self.margin!
                        }
                        if self.padding != nil {
                            map["Padding"] = self.padding!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CellHeight") {
                            self.cellHeight = dict["CellHeight"] as! String
                        }
                        if dict.keys.contains("CellSelStep") {
                            self.cellSelStep = dict["CellSelStep"] as! String
                        }
                        if dict.keys.contains("CellWidth") {
                            self.cellWidth = dict["CellWidth"] as! String
                        }
                        if dict.keys.contains("Color") {
                            self.color = dict["Color"] as! String
                        }
                        if dict.keys.contains("Columns") {
                            self.columns = dict["Columns"] as! String
                        }
                        if dict.keys.contains("IsKeepCellPic") {
                            self.isKeepCellPic = dict["IsKeepCellPic"] as! String
                        }
                        if dict.keys.contains("Lines") {
                            self.lines = dict["Lines"] as! String
                        }
                        if dict.keys.contains("Margin") {
                            self.margin = dict["Margin"] as! String
                        }
                        if dict.keys.contains("Padding") {
                            self.padding = dict["Padding"] as! String
                        }
                    }
                }
                public class TileOutputFile : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public var roleArn: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        if self.roleArn != nil {
                            map["RoleArn"] = self.roleArn!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                        if dict.keys.contains("RoleArn") {
                            self.roleArn = dict["RoleArn"] as! String
                        }
                    }
                }
                public class TimeArray : Tea.TeaModel {
                    public var timePointList: [Int64]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.timePointList != nil {
                            map["TimePointList"] = self.timePointList!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TimePointList") {
                            self.timePointList = dict["TimePointList"] as! [Int64]
                        }
                    }
                }
                public var frameType: String?

                public var height: String?

                public var interval: String?

                public var num: String?

                public var outputFile: QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.SnapshotConfig.OutputFile?

                public var tileOut: QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.SnapshotConfig.TileOut?

                public var tileOutputFile: QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.SnapshotConfig.TileOutputFile?

                public var time: String?

                public var timeArray: QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.SnapshotConfig.TimeArray?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.outputFile?.validate()
                    try self.tileOut?.validate()
                    try self.tileOutputFile?.validate()
                    try self.timeArray?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.frameType != nil {
                        map["FrameType"] = self.frameType!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.interval != nil {
                        map["Interval"] = self.interval!
                    }
                    if self.num != nil {
                        map["Num"] = self.num!
                    }
                    if self.outputFile != nil {
                        map["OutputFile"] = self.outputFile?.toMap()
                    }
                    if self.tileOut != nil {
                        map["TileOut"] = self.tileOut?.toMap()
                    }
                    if self.tileOutputFile != nil {
                        map["TileOutputFile"] = self.tileOutputFile?.toMap()
                    }
                    if self.time != nil {
                        map["Time"] = self.time!
                    }
                    if self.timeArray != nil {
                        map["TimeArray"] = self.timeArray?.toMap()
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FrameType") {
                        self.frameType = dict["FrameType"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Interval") {
                        self.interval = dict["Interval"] as! String
                    }
                    if dict.keys.contains("Num") {
                        self.num = dict["Num"] as! String
                    }
                    if dict.keys.contains("OutputFile") {
                        var model = QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.SnapshotConfig.OutputFile()
                        model.fromMap(dict["OutputFile"] as! [String: Any])
                        self.outputFile = model
                    }
                    if dict.keys.contains("TileOut") {
                        var model = QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.SnapshotConfig.TileOut()
                        model.fromMap(dict["TileOut"] as! [String: Any])
                        self.tileOut = model
                    }
                    if dict.keys.contains("TileOutputFile") {
                        var model = QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.SnapshotConfig.TileOutputFile()
                        model.fromMap(dict["TileOutputFile"] as! [String: Any])
                        self.tileOutputFile = model
                    }
                    if dict.keys.contains("Time") {
                        self.time = dict["Time"] as! String
                    }
                    if dict.keys.contains("TimeArray") {
                        var model = QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.SnapshotConfig.TimeArray()
                        model.fromMap(dict["TimeArray"] as! [String: Any])
                        self.timeArray = model
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var code: String?

            public var count: String?

            public var creationTime: String?

            public var id: String?

            public var input: QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.Input?

            public var MNSMessageResult: QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.MNSMessageResult?

            public var message: String?

            public var pipelineId: String?

            public var snapshotConfig: QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.SnapshotConfig?

            public var state: String?

            public var tileCount: String?

            public var userData: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.input?.validate()
                try self.MNSMessageResult?.validate()
                try self.snapshotConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.input != nil {
                    map["Input"] = self.input?.toMap()
                }
                if self.MNSMessageResult != nil {
                    map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.snapshotConfig != nil {
                    map["SnapshotConfig"] = self.snapshotConfig?.toMap()
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.tileCount != nil {
                    map["TileCount"] = self.tileCount!
                }
                if self.userData != nil {
                    map["UserData"] = self.userData!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Input") {
                    var model = QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.Input()
                    model.fromMap(dict["Input"] as! [String: Any])
                    self.input = model
                }
                if dict.keys.contains("MNSMessageResult") {
                    var model = QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.MNSMessageResult()
                    model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                    self.MNSMessageResult = model
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("SnapshotConfig") {
                    var model = QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob.SnapshotConfig()
                    model.fromMap(dict["SnapshotConfig"] as! [String: Any])
                    self.snapshotConfig = model
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("TileCount") {
                    self.tileCount = dict["TileCount"] as! String
                }
                if dict.keys.contains("UserData") {
                    self.userData = dict["UserData"] as! String
                }
            }
        }
        public var snapshotJob: [QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snapshotJob != nil {
                var tmp : [Any] = []
                for k in self.snapshotJob! {
                    tmp.append(k.toMap())
                }
                map["SnapshotJob"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SnapshotJob") {
                var tmp : [QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob] = []
                for v in dict["SnapshotJob"] as! [Any] {
                    var model = QuerySnapshotJobListResponseBody.SnapshotJobList.SnapshotJob()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.snapshotJob = tmp
            }
        }
    }
    public var nextPageToken: String?

    public var nonExistSnapshotJobIds: QuerySnapshotJobListResponseBody.NonExistSnapshotJobIds?

    public var requestId: String?

    public var snapshotJobList: QuerySnapshotJobListResponseBody.SnapshotJobList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nonExistSnapshotJobIds?.validate()
        try self.snapshotJobList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.nonExistSnapshotJobIds != nil {
            map["NonExistSnapshotJobIds"] = self.nonExistSnapshotJobIds?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotJobList != nil {
            map["SnapshotJobList"] = self.snapshotJobList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("NonExistSnapshotJobIds") {
            var model = QuerySnapshotJobListResponseBody.NonExistSnapshotJobIds()
            model.fromMap(dict["NonExistSnapshotJobIds"] as! [String: Any])
            self.nonExistSnapshotJobIds = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotJobList") {
            var model = QuerySnapshotJobListResponseBody.SnapshotJobList()
            model.fromMap(dict["SnapshotJobList"] as! [String: Any])
            self.snapshotJobList = model
        }
    }
}

public class QuerySnapshotJobListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QuerySnapshotJobListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QuerySnapshotJobListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTemplateListRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateIds != nil {
            map["TemplateIds"] = self.templateIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateIds") {
            self.templateIds = dict["TemplateIds"] as! String
        }
    }
}

public class QueryTemplateListResponseBody : Tea.TeaModel {
    public class NonExistTids : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public class TemplateList : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public class Audio : Tea.TeaModel {
                public class Volume : Tea.TeaModel {
                    public var integratedLoudnessTarget: String?

                    public var level: String?

                    public var loudnessRangeTarget: String?

                    public var method: String?

                    public var peakLevel: String?

                    public var truePeak: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.integratedLoudnessTarget != nil {
                            map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                        }
                        if self.level != nil {
                            map["Level"] = self.level!
                        }
                        if self.loudnessRangeTarget != nil {
                            map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                        }
                        if self.method != nil {
                            map["Method"] = self.method!
                        }
                        if self.peakLevel != nil {
                            map["PeakLevel"] = self.peakLevel!
                        }
                        if self.truePeak != nil {
                            map["TruePeak"] = self.truePeak!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IntegratedLoudnessTarget") {
                            self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                        }
                        if dict.keys.contains("Level") {
                            self.level = dict["Level"] as! String
                        }
                        if dict.keys.contains("LoudnessRangeTarget") {
                            self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                        }
                        if dict.keys.contains("Method") {
                            self.method = dict["Method"] as! String
                        }
                        if dict.keys.contains("PeakLevel") {
                            self.peakLevel = dict["PeakLevel"] as! String
                        }
                        if dict.keys.contains("TruePeak") {
                            self.truePeak = dict["TruePeak"] as! String
                        }
                    }
                }
                public var bitrate: String?

                public var channels: String?

                public var codec: String?

                public var profile: String?

                public var qscale: String?

                public var remove: String?

                public var samplerate: String?

                public var volume: QueryTemplateListResponseBody.TemplateList.Template.Audio.Volume?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.volume?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.qscale != nil {
                        map["Qscale"] = self.qscale!
                    }
                    if self.remove != nil {
                        map["Remove"] = self.remove!
                    }
                    if self.samplerate != nil {
                        map["Samplerate"] = self.samplerate!
                    }
                    if self.volume != nil {
                        map["Volume"] = self.volume?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Qscale") {
                        self.qscale = dict["Qscale"] as! String
                    }
                    if dict.keys.contains("Remove") {
                        self.remove = dict["Remove"] as! String
                    }
                    if dict.keys.contains("Samplerate") {
                        self.samplerate = dict["Samplerate"] as! String
                    }
                    if dict.keys.contains("Volume") {
                        var model = QueryTemplateListResponseBody.TemplateList.Template.Audio.Volume()
                        model.fromMap(dict["Volume"] as! [String: Any])
                        self.volume = model
                    }
                }
            }
            public class Container : Tea.TeaModel {
                public var format: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.format != nil {
                        map["Format"] = self.format!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Format") {
                        self.format = dict["Format"] as! String
                    }
                }
            }
            public class MuxConfig : Tea.TeaModel {
                public class Gif : Tea.TeaModel {
                    public var ditherMode: String?

                    public var finalDelay: String?

                    public var isCustomPalette: String?

                    public var loop: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ditherMode != nil {
                            map["DitherMode"] = self.ditherMode!
                        }
                        if self.finalDelay != nil {
                            map["FinalDelay"] = self.finalDelay!
                        }
                        if self.isCustomPalette != nil {
                            map["IsCustomPalette"] = self.isCustomPalette!
                        }
                        if self.loop != nil {
                            map["Loop"] = self.loop!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DitherMode") {
                            self.ditherMode = dict["DitherMode"] as! String
                        }
                        if dict.keys.contains("FinalDelay") {
                            self.finalDelay = dict["FinalDelay"] as! String
                        }
                        if dict.keys.contains("IsCustomPalette") {
                            self.isCustomPalette = dict["IsCustomPalette"] as! String
                        }
                        if dict.keys.contains("Loop") {
                            self.loop = dict["Loop"] as! String
                        }
                    }
                }
                public class Segment : Tea.TeaModel {
                    public var duration: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                    }
                }
                public class Webp : Tea.TeaModel {
                    public var loop: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.loop != nil {
                            map["Loop"] = self.loop!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Loop") {
                            self.loop = dict["Loop"] as! String
                        }
                    }
                }
                public var gif: QueryTemplateListResponseBody.TemplateList.Template.MuxConfig.Gif?

                public var segment: QueryTemplateListResponseBody.TemplateList.Template.MuxConfig.Segment?

                public var webp: QueryTemplateListResponseBody.TemplateList.Template.MuxConfig.Webp?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.gif?.validate()
                    try self.segment?.validate()
                    try self.webp?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gif != nil {
                        map["Gif"] = self.gif?.toMap()
                    }
                    if self.segment != nil {
                        map["Segment"] = self.segment?.toMap()
                    }
                    if self.webp != nil {
                        map["Webp"] = self.webp?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Gif") {
                        var model = QueryTemplateListResponseBody.TemplateList.Template.MuxConfig.Gif()
                        model.fromMap(dict["Gif"] as! [String: Any])
                        self.gif = model
                    }
                    if dict.keys.contains("Segment") {
                        var model = QueryTemplateListResponseBody.TemplateList.Template.MuxConfig.Segment()
                        model.fromMap(dict["Segment"] as! [String: Any])
                        self.segment = model
                    }
                    if dict.keys.contains("Webp") {
                        var model = QueryTemplateListResponseBody.TemplateList.Template.MuxConfig.Webp()
                        model.fromMap(dict["Webp"] as! [String: Any])
                        self.webp = model
                    }
                }
            }
            public class TransConfig : Tea.TeaModel {
                public var adjDarMethod: String?

                public var isCheckAudioBitrate: String?

                public var isCheckAudioBitrateFail: String?

                public var isCheckReso: String?

                public var isCheckResoFail: String?

                public var isCheckVideoBitrate: String?

                public var isCheckVideoBitrateFail: String?

                public var transMode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adjDarMethod != nil {
                        map["AdjDarMethod"] = self.adjDarMethod!
                    }
                    if self.isCheckAudioBitrate != nil {
                        map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                    }
                    if self.isCheckAudioBitrateFail != nil {
                        map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                    }
                    if self.isCheckReso != nil {
                        map["IsCheckReso"] = self.isCheckReso!
                    }
                    if self.isCheckResoFail != nil {
                        map["IsCheckResoFail"] = self.isCheckResoFail!
                    }
                    if self.isCheckVideoBitrate != nil {
                        map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                    }
                    if self.isCheckVideoBitrateFail != nil {
                        map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                    }
                    if self.transMode != nil {
                        map["TransMode"] = self.transMode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdjDarMethod") {
                        self.adjDarMethod = dict["AdjDarMethod"] as! String
                    }
                    if dict.keys.contains("IsCheckAudioBitrate") {
                        self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                    }
                    if dict.keys.contains("IsCheckAudioBitrateFail") {
                        self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                    }
                    if dict.keys.contains("IsCheckReso") {
                        self.isCheckReso = dict["IsCheckReso"] as! String
                    }
                    if dict.keys.contains("IsCheckResoFail") {
                        self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                    }
                    if dict.keys.contains("IsCheckVideoBitrate") {
                        self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                    }
                    if dict.keys.contains("IsCheckVideoBitrateFail") {
                        self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                    }
                    if dict.keys.contains("TransMode") {
                        self.transMode = dict["TransMode"] as! String
                    }
                }
            }
            public class Video : Tea.TeaModel {
                public class BitrateBnd : Tea.TeaModel {
                    public var max: String?

                    public var min: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.max != nil {
                            map["Max"] = self.max!
                        }
                        if self.min != nil {
                            map["Min"] = self.min!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Max") {
                            self.max = dict["Max"] as! String
                        }
                        if dict.keys.contains("Min") {
                            self.min = dict["Min"] as! String
                        }
                    }
                }
                public class NarrowBand : Tea.TeaModel {
                    public var abrmax: Double?

                    public var maxAbrRatio: Double?

                    public var version: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.abrmax != nil {
                            map["Abrmax"] = self.abrmax!
                        }
                        if self.maxAbrRatio != nil {
                            map["MaxAbrRatio"] = self.maxAbrRatio!
                        }
                        if self.version != nil {
                            map["Version"] = self.version!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Abrmax") {
                            self.abrmax = dict["Abrmax"] as! Double
                        }
                        if dict.keys.contains("MaxAbrRatio") {
                            self.maxAbrRatio = dict["MaxAbrRatio"] as! Double
                        }
                        if dict.keys.contains("Version") {
                            self.version = dict["Version"] as! String
                        }
                    }
                }
                public var bitrate: String?

                public var bitrateBnd: QueryTemplateListResponseBody.TemplateList.Template.Video.BitrateBnd?

                public var bufsize: String?

                public var codec: String?

                public var crf: String?

                public var crop: String?

                public var degrain: String?

                public var fps: String?

                public var gop: String?

                public var hdr2sdr: String?

                public var height: String?

                public var longShortMode: String?

                public var maxFps: String?

                public var maxrate: String?

                public var narrowBand: QueryTemplateListResponseBody.TemplateList.Template.Video.NarrowBand?

                public var pad: String?

                public var pixFmt: String?

                public var preset: String?

                public var profile: String?

                public var qscale: String?

                public var remove: String?

                public var resoPriority: String?

                public var scanMode: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.bitrateBnd?.validate()
                    try self.narrowBand?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.bitrateBnd != nil {
                        map["BitrateBnd"] = self.bitrateBnd?.toMap()
                    }
                    if self.bufsize != nil {
                        map["Bufsize"] = self.bufsize!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.crf != nil {
                        map["Crf"] = self.crf!
                    }
                    if self.crop != nil {
                        map["Crop"] = self.crop!
                    }
                    if self.degrain != nil {
                        map["Degrain"] = self.degrain!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.gop != nil {
                        map["Gop"] = self.gop!
                    }
                    if self.hdr2sdr != nil {
                        map["Hdr2sdr"] = self.hdr2sdr!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.longShortMode != nil {
                        map["LongShortMode"] = self.longShortMode!
                    }
                    if self.maxFps != nil {
                        map["MaxFps"] = self.maxFps!
                    }
                    if self.maxrate != nil {
                        map["Maxrate"] = self.maxrate!
                    }
                    if self.narrowBand != nil {
                        map["NarrowBand"] = self.narrowBand?.toMap()
                    }
                    if self.pad != nil {
                        map["Pad"] = self.pad!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.preset != nil {
                        map["Preset"] = self.preset!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.qscale != nil {
                        map["Qscale"] = self.qscale!
                    }
                    if self.remove != nil {
                        map["Remove"] = self.remove!
                    }
                    if self.resoPriority != nil {
                        map["ResoPriority"] = self.resoPriority!
                    }
                    if self.scanMode != nil {
                        map["ScanMode"] = self.scanMode!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("BitrateBnd") {
                        var model = QueryTemplateListResponseBody.TemplateList.Template.Video.BitrateBnd()
                        model.fromMap(dict["BitrateBnd"] as! [String: Any])
                        self.bitrateBnd = model
                    }
                    if dict.keys.contains("Bufsize") {
                        self.bufsize = dict["Bufsize"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Crf") {
                        self.crf = dict["Crf"] as! String
                    }
                    if dict.keys.contains("Crop") {
                        self.crop = dict["Crop"] as! String
                    }
                    if dict.keys.contains("Degrain") {
                        self.degrain = dict["Degrain"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Gop") {
                        self.gop = dict["Gop"] as! String
                    }
                    if dict.keys.contains("Hdr2sdr") {
                        self.hdr2sdr = dict["Hdr2sdr"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("LongShortMode") {
                        self.longShortMode = dict["LongShortMode"] as! String
                    }
                    if dict.keys.contains("MaxFps") {
                        self.maxFps = dict["MaxFps"] as! String
                    }
                    if dict.keys.contains("Maxrate") {
                        self.maxrate = dict["Maxrate"] as! String
                    }
                    if dict.keys.contains("NarrowBand") {
                        var model = QueryTemplateListResponseBody.TemplateList.Template.Video.NarrowBand()
                        model.fromMap(dict["NarrowBand"] as! [String: Any])
                        self.narrowBand = model
                    }
                    if dict.keys.contains("Pad") {
                        self.pad = dict["Pad"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Preset") {
                        self.preset = dict["Preset"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Qscale") {
                        self.qscale = dict["Qscale"] as! String
                    }
                    if dict.keys.contains("Remove") {
                        self.remove = dict["Remove"] as! String
                    }
                    if dict.keys.contains("ResoPriority") {
                        self.resoPriority = dict["ResoPriority"] as! String
                    }
                    if dict.keys.contains("ScanMode") {
                        self.scanMode = dict["ScanMode"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audio: QueryTemplateListResponseBody.TemplateList.Template.Audio?

            public var container: QueryTemplateListResponseBody.TemplateList.Template.Container?

            public var creationTime: String?

            public var id: String?

            public var muxConfig: QueryTemplateListResponseBody.TemplateList.Template.MuxConfig?

            public var name: String?

            public var state: String?

            public var transConfig: QueryTemplateListResponseBody.TemplateList.Template.TransConfig?

            public var video: QueryTemplateListResponseBody.TemplateList.Template.Video?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audio?.validate()
                try self.container?.validate()
                try self.muxConfig?.validate()
                try self.transConfig?.validate()
                try self.video?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audio != nil {
                    map["Audio"] = self.audio?.toMap()
                }
                if self.container != nil {
                    map["Container"] = self.container?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.muxConfig != nil {
                    map["MuxConfig"] = self.muxConfig?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.transConfig != nil {
                    map["TransConfig"] = self.transConfig?.toMap()
                }
                if self.video != nil {
                    map["Video"] = self.video?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Audio") {
                    var model = QueryTemplateListResponseBody.TemplateList.Template.Audio()
                    model.fromMap(dict["Audio"] as! [String: Any])
                    self.audio = model
                }
                if dict.keys.contains("Container") {
                    var model = QueryTemplateListResponseBody.TemplateList.Template.Container()
                    model.fromMap(dict["Container"] as! [String: Any])
                    self.container = model
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("MuxConfig") {
                    var model = QueryTemplateListResponseBody.TemplateList.Template.MuxConfig()
                    model.fromMap(dict["MuxConfig"] as! [String: Any])
                    self.muxConfig = model
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("TransConfig") {
                    var model = QueryTemplateListResponseBody.TemplateList.Template.TransConfig()
                    model.fromMap(dict["TransConfig"] as! [String: Any])
                    self.transConfig = model
                }
                if dict.keys.contains("Video") {
                    var model = QueryTemplateListResponseBody.TemplateList.Template.Video()
                    model.fromMap(dict["Video"] as! [String: Any])
                    self.video = model
                }
            }
        }
        public var template: [QueryTemplateListResponseBody.TemplateList.Template]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.template != nil {
                var tmp : [Any] = []
                for k in self.template! {
                    tmp.append(k.toMap())
                }
                map["Template"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Template") {
                var tmp : [QueryTemplateListResponseBody.TemplateList.Template] = []
                for v in dict["Template"] as! [Any] {
                    var model = QueryTemplateListResponseBody.TemplateList.Template()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.template = tmp
            }
        }
    }
    public var nonExistTids: QueryTemplateListResponseBody.NonExistTids?

    public var requestId: String?

    public var templateList: QueryTemplateListResponseBody.TemplateList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nonExistTids?.validate()
        try self.templateList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistTids != nil {
            map["NonExistTids"] = self.nonExistTids?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateList != nil {
            map["TemplateList"] = self.templateList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistTids") {
            var model = QueryTemplateListResponseBody.NonExistTids()
            model.fromMap(dict["NonExistTids"] as! [String: Any])
            self.nonExistTids = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateList") {
            var model = QueryTemplateListResponseBody.TemplateList()
            model.fromMap(dict["TemplateList"] as! [String: Any])
            self.templateList = model
        }
    }
}

public class QueryTemplateListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTemplateListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryTemplateListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTraceAbJobRequest : Tea.TeaModel {
    public var jobId: String?

    public var mediaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
    }
}

public class QueryTraceAbJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var callback: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var input: String?

        public var jobId: String?

        public var level: Int64?

        public var mediaId: String?

        public var output: String?

        public var result: String?

        public var status: String?

        public var userData: String?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callback != nil {
                map["Callback"] = self.callback!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.input != nil {
                map["Input"] = self.input!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.level != nil {
                map["Level"] = self.level!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.output != nil {
                map["Output"] = self.output!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Callback") {
                self.callback = dict["Callback"] as! String
            }
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! Int64
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! Int64
            }
            if dict.keys.contains("Input") {
                self.input = dict["Input"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Level") {
                self.level = dict["Level"] as! Int64
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("Output") {
                self.output = dict["Output"] as! String
            }
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! Int64
            }
        }
    }
    public var data: [QueryTraceAbJobResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var statusCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [QueryTraceAbJobResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryTraceAbJobResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! Int64
        }
    }
}

public class QueryTraceAbJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTraceAbJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryTraceAbJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTraceExtractJobRequest : Tea.TeaModel {
    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class QueryTraceExtractJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var trace: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.trace != nil {
                map["Trace"] = self.trace!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Trace") {
                self.trace = dict["Trace"] as! String
            }
        }
    }
    public var data: QueryTraceExtractJobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var statusCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = QueryTraceExtractJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! Int64
        }
    }
}

public class QueryTraceExtractJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTraceExtractJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryTraceExtractJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryTraceM3u8JobRequest : Tea.TeaModel {
    public var createTimeEnd: Int64?

    public var createTimeStart: Int64?

    public var jobId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTimeEnd != nil {
            map["CreateTimeEnd"] = self.createTimeEnd!
        }
        if self.createTimeStart != nil {
            map["CreateTimeStart"] = self.createTimeStart!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTimeEnd") {
            self.createTimeEnd = dict["CreateTimeEnd"] as! Int64
        }
        if dict.keys.contains("CreateTimeStart") {
            self.createTimeStart = dict["CreateTimeStart"] as! Int64
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class QueryTraceM3u8JobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var jobId: String?

        public var mediaId: String?

        public var output: String?

        public var status: String?

        public var trace: String?

        public var userData: String?

        public var userId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.output != nil {
                map["Output"] = self.output!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.trace != nil {
                map["Trace"] = self.trace!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GmtCreate") {
                self.gmtCreate = dict["GmtCreate"] as! Int64
            }
            if dict.keys.contains("GmtModified") {
                self.gmtModified = dict["GmtModified"] as! Int64
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("Output") {
                self.output = dict["Output"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Trace") {
                self.trace = dict["Trace"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! Int64
            }
        }
    }
    public var data: [QueryTraceM3u8JobResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var statusCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var tmp : [QueryTraceM3u8JobResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = QueryTraceM3u8JobResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! Int64
        }
    }
}

public class QueryTraceM3u8JobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryTraceM3u8JobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryTraceM3u8JobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryWaterMarkTemplateListRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var waterMarkTemplateIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.waterMarkTemplateIds != nil {
            map["WaterMarkTemplateIds"] = self.waterMarkTemplateIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("WaterMarkTemplateIds") {
            self.waterMarkTemplateIds = dict["WaterMarkTemplateIds"] as! String
        }
    }
}

public class QueryWaterMarkTemplateListResponseBody : Tea.TeaModel {
    public class NonExistWids : Tea.TeaModel {
        public var string: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.string != nil {
                map["String"] = self.string!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("String") {
                self.string = dict["String"] as! [String]
            }
        }
    }
    public class WaterMarkTemplateList : Tea.TeaModel {
        public class WaterMarkTemplate : Tea.TeaModel {
            public class RatioRefer : Tea.TeaModel {
                public var dx: String?

                public var dy: String?

                public var height: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dx != nil {
                        map["Dx"] = self.dx!
                    }
                    if self.dy != nil {
                        map["Dy"] = self.dy!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Dx") {
                        self.dx = dict["Dx"] as! String
                    }
                    if dict.keys.contains("Dy") {
                        self.dy = dict["Dy"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class Timeline : Tea.TeaModel {
                public var duration: String?

                public var start: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.start != nil {
                        map["Start"] = self.start!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Start") {
                        self.start = dict["Start"] as! String
                    }
                }
            }
            public var dx: String?

            public var dy: String?

            public var height: String?

            public var id: String?

            public var name: String?

            public var ratioRefer: QueryWaterMarkTemplateListResponseBody.WaterMarkTemplateList.WaterMarkTemplate.RatioRefer?

            public var referPos: String?

            public var state: String?

            public var timeline: QueryWaterMarkTemplateListResponseBody.WaterMarkTemplateList.WaterMarkTemplate.Timeline?

            public var type: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ratioRefer?.validate()
                try self.timeline?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dx != nil {
                    map["Dx"] = self.dx!
                }
                if self.dy != nil {
                    map["Dy"] = self.dy!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ratioRefer != nil {
                    map["RatioRefer"] = self.ratioRefer?.toMap()
                }
                if self.referPos != nil {
                    map["ReferPos"] = self.referPos!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.timeline != nil {
                    map["Timeline"] = self.timeline?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Dx") {
                    self.dx = dict["Dx"] as! String
                }
                if dict.keys.contains("Dy") {
                    self.dy = dict["Dy"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RatioRefer") {
                    var model = QueryWaterMarkTemplateListResponseBody.WaterMarkTemplateList.WaterMarkTemplate.RatioRefer()
                    model.fromMap(dict["RatioRefer"] as! [String: Any])
                    self.ratioRefer = model
                }
                if dict.keys.contains("ReferPos") {
                    self.referPos = dict["ReferPos"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Timeline") {
                    var model = QueryWaterMarkTemplateListResponseBody.WaterMarkTemplateList.WaterMarkTemplate.Timeline()
                    model.fromMap(dict["Timeline"] as! [String: Any])
                    self.timeline = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var waterMarkTemplate: [QueryWaterMarkTemplateListResponseBody.WaterMarkTemplateList.WaterMarkTemplate]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.waterMarkTemplate != nil {
                var tmp : [Any] = []
                for k in self.waterMarkTemplate! {
                    tmp.append(k.toMap())
                }
                map["WaterMarkTemplate"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WaterMarkTemplate") {
                var tmp : [QueryWaterMarkTemplateListResponseBody.WaterMarkTemplateList.WaterMarkTemplate] = []
                for v in dict["WaterMarkTemplate"] as! [Any] {
                    var model = QueryWaterMarkTemplateListResponseBody.WaterMarkTemplateList.WaterMarkTemplate()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.waterMarkTemplate = tmp
            }
        }
    }
    public var nonExistWids: QueryWaterMarkTemplateListResponseBody.NonExistWids?

    public var requestId: String?

    public var waterMarkTemplateList: QueryWaterMarkTemplateListResponseBody.WaterMarkTemplateList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nonExistWids?.validate()
        try self.waterMarkTemplateList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nonExistWids != nil {
            map["NonExistWids"] = self.nonExistWids?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.waterMarkTemplateList != nil {
            map["WaterMarkTemplateList"] = self.waterMarkTemplateList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NonExistWids") {
            var model = QueryWaterMarkTemplateListResponseBody.NonExistWids()
            model.fromMap(dict["NonExistWids"] as! [String: Any])
            self.nonExistWids = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WaterMarkTemplateList") {
            var model = QueryWaterMarkTemplateListResponseBody.WaterMarkTemplateList()
            model.fromMap(dict["WaterMarkTemplateList"] as! [String: Any])
            self.waterMarkTemplateList = model
        }
    }
}

public class QueryWaterMarkTemplateListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryWaterMarkTemplateListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryWaterMarkTemplateListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterCustomFaceRequest : Tea.TeaModel {
    public var categoryId: String?

    public var imageUrl: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var personId: String?

    public var personName: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.personId != nil {
            map["PersonId"] = self.personId!
        }
        if self.personName != nil {
            map["PersonName"] = self.personName!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CategoryId") {
            self.categoryId = dict["CategoryId"] as! String
        }
        if dict.keys.contains("ImageUrl") {
            self.imageUrl = dict["ImageUrl"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PersonId") {
            self.personId = dict["PersonId"] as! String
        }
        if dict.keys.contains("PersonName") {
            self.personName = dict["PersonName"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class RegisterCustomFaceResponseBody : Tea.TeaModel {
    public var faceId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.faceId != nil {
            map["FaceId"] = self.faceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FaceId") {
            self.faceId = dict["FaceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RegisterCustomFaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterCustomFaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RegisterCustomFaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterCustomViewRequest : Tea.TeaModel {
    public var algorithm: String?

    public var customEntityId: String?

    public var customGroupId: String?

    public var imageUrl: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.algorithm != nil {
            map["Algorithm"] = self.algorithm!
        }
        if self.customEntityId != nil {
            map["CustomEntityId"] = self.customEntityId!
        }
        if self.customGroupId != nil {
            map["CustomGroupId"] = self.customGroupId!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Algorithm") {
            self.algorithm = dict["Algorithm"] as! String
        }
        if dict.keys.contains("CustomEntityId") {
            self.customEntityId = dict["CustomEntityId"] as! String
        }
        if dict.keys.contains("CustomGroupId") {
            self.customGroupId = dict["CustomGroupId"] as! String
        }
        if dict.keys.contains("ImageUrl") {
            self.imageUrl = dict["ImageUrl"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class RegisterCustomViewResponseBody : Tea.TeaModel {
    public var customViewId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customViewId != nil {
            map["CustomViewId"] = self.customViewId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomViewId") {
            self.customViewId = dict["CustomViewId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RegisterCustomViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterCustomViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RegisterCustomViewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchMediaWorkflowRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var stateList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.stateList != nil {
            map["StateList"] = self.stateList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StateList") {
            self.stateList = dict["StateList"] as! String
        }
    }
}

public class SearchMediaWorkflowResponseBody : Tea.TeaModel {
    public class MediaWorkflowList : Tea.TeaModel {
        public class MediaWorkflow : Tea.TeaModel {
            public var creationTime: String?

            public var mediaWorkflowId: String?

            public var name: String?

            public var state: String?

            public var topology: String?

            public var triggerMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.mediaWorkflowId != nil {
                    map["MediaWorkflowId"] = self.mediaWorkflowId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.topology != nil {
                    map["Topology"] = self.topology!
                }
                if self.triggerMode != nil {
                    map["TriggerMode"] = self.triggerMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("MediaWorkflowId") {
                    self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Topology") {
                    self.topology = dict["Topology"] as! String
                }
                if dict.keys.contains("TriggerMode") {
                    self.triggerMode = dict["TriggerMode"] as! String
                }
            }
        }
        public var mediaWorkflow: [SearchMediaWorkflowResponseBody.MediaWorkflowList.MediaWorkflow]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mediaWorkflow != nil {
                var tmp : [Any] = []
                for k in self.mediaWorkflow! {
                    tmp.append(k.toMap())
                }
                map["MediaWorkflow"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MediaWorkflow") {
                var tmp : [SearchMediaWorkflowResponseBody.MediaWorkflowList.MediaWorkflow] = []
                for v in dict["MediaWorkflow"] as! [Any] {
                    var model = SearchMediaWorkflowResponseBody.MediaWorkflowList.MediaWorkflow()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mediaWorkflow = tmp
            }
        }
    }
    public var mediaWorkflowList: SearchMediaWorkflowResponseBody.MediaWorkflowList?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflowList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowList != nil {
            map["MediaWorkflowList"] = self.mediaWorkflowList?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowList") {
            var model = SearchMediaWorkflowResponseBody.MediaWorkflowList()
            model.fromMap(dict["MediaWorkflowList"] as! [String: Any])
            self.mediaWorkflowList = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class SearchMediaWorkflowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchMediaWorkflowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchMediaWorkflowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchPipelineRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class SearchPipelineResponseBody : Tea.TeaModel {
    public class PipelineList : Tea.TeaModel {
        public class Pipeline : Tea.TeaModel {
            public class NotifyConfig : Tea.TeaModel {
                public var mqTag: String?

                public var mqTopic: String?

                public var queueName: String?

                public var topic: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mqTag != nil {
                        map["MqTag"] = self.mqTag!
                    }
                    if self.mqTopic != nil {
                        map["MqTopic"] = self.mqTopic!
                    }
                    if self.queueName != nil {
                        map["QueueName"] = self.queueName!
                    }
                    if self.topic != nil {
                        map["Topic"] = self.topic!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MqTag") {
                        self.mqTag = dict["MqTag"] as! String
                    }
                    if dict.keys.contains("MqTopic") {
                        self.mqTopic = dict["MqTopic"] as! String
                    }
                    if dict.keys.contains("QueueName") {
                        self.queueName = dict["QueueName"] as! String
                    }
                    if dict.keys.contains("Topic") {
                        self.topic = dict["Topic"] as! String
                    }
                }
            }
            public var creationTime: String?

            public var id: String?

            public var name: String?

            public var notifyConfig: SearchPipelineResponseBody.PipelineList.Pipeline.NotifyConfig?

            public var quotaAllocate: Int64?

            public var role: String?

            public var speed: String?

            public var speedLevel: Int64?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.notifyConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.notifyConfig != nil {
                    map["NotifyConfig"] = self.notifyConfig?.toMap()
                }
                if self.quotaAllocate != nil {
                    map["QuotaAllocate"] = self.quotaAllocate!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.speed != nil {
                    map["Speed"] = self.speed!
                }
                if self.speedLevel != nil {
                    map["SpeedLevel"] = self.speedLevel!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NotifyConfig") {
                    var model = SearchPipelineResponseBody.PipelineList.Pipeline.NotifyConfig()
                    model.fromMap(dict["NotifyConfig"] as! [String: Any])
                    self.notifyConfig = model
                }
                if dict.keys.contains("QuotaAllocate") {
                    self.quotaAllocate = dict["QuotaAllocate"] as! Int64
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("Speed") {
                    self.speed = dict["Speed"] as! String
                }
                if dict.keys.contains("SpeedLevel") {
                    self.speedLevel = dict["SpeedLevel"] as! Int64
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
            }
        }
        public var pipeline: [SearchPipelineResponseBody.PipelineList.Pipeline]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipeline != nil {
                var tmp : [Any] = []
                for k in self.pipeline! {
                    tmp.append(k.toMap())
                }
                map["Pipeline"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Pipeline") {
                var tmp : [SearchPipelineResponseBody.PipelineList.Pipeline] = []
                for v in dict["Pipeline"] as! [Any] {
                    var model = SearchPipelineResponseBody.PipelineList.Pipeline()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.pipeline = tmp
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var pipelineList: SearchPipelineResponseBody.PipelineList?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipelineList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pipelineList != nil {
            map["PipelineList"] = self.pipelineList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PipelineList") {
            var model = SearchPipelineResponseBody.PipelineList()
            model.fromMap(dict["PipelineList"] as! [String: Any])
            self.pipelineList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class SearchPipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchPipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchPipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchTemplateRequest : Tea.TeaModel {
    public var namePrefix: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namePrefix != nil {
            map["NamePrefix"] = self.namePrefix!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NamePrefix") {
            self.namePrefix = dict["NamePrefix"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class SearchTemplateResponseBody : Tea.TeaModel {
    public class TemplateList : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public class Audio : Tea.TeaModel {
                public var bitrate: String?

                public var channels: String?

                public var codec: String?

                public var profile: String?

                public var qscale: String?

                public var remove: String?

                public var samplerate: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.channels != nil {
                        map["Channels"] = self.channels!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.qscale != nil {
                        map["Qscale"] = self.qscale!
                    }
                    if self.remove != nil {
                        map["Remove"] = self.remove!
                    }
                    if self.samplerate != nil {
                        map["Samplerate"] = self.samplerate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Channels") {
                        self.channels = dict["Channels"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Qscale") {
                        self.qscale = dict["Qscale"] as! String
                    }
                    if dict.keys.contains("Remove") {
                        self.remove = dict["Remove"] as! String
                    }
                    if dict.keys.contains("Samplerate") {
                        self.samplerate = dict["Samplerate"] as! String
                    }
                }
            }
            public class Container : Tea.TeaModel {
                public var format: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.format != nil {
                        map["Format"] = self.format!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Format") {
                        self.format = dict["Format"] as! String
                    }
                }
            }
            public class MuxConfig : Tea.TeaModel {
                public class Gif : Tea.TeaModel {
                    public var ditherMode: String?

                    public var finalDelay: String?

                    public var isCustomPalette: String?

                    public var loop: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ditherMode != nil {
                            map["DitherMode"] = self.ditherMode!
                        }
                        if self.finalDelay != nil {
                            map["FinalDelay"] = self.finalDelay!
                        }
                        if self.isCustomPalette != nil {
                            map["IsCustomPalette"] = self.isCustomPalette!
                        }
                        if self.loop != nil {
                            map["Loop"] = self.loop!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DitherMode") {
                            self.ditherMode = dict["DitherMode"] as! String
                        }
                        if dict.keys.contains("FinalDelay") {
                            self.finalDelay = dict["FinalDelay"] as! String
                        }
                        if dict.keys.contains("IsCustomPalette") {
                            self.isCustomPalette = dict["IsCustomPalette"] as! String
                        }
                        if dict.keys.contains("Loop") {
                            self.loop = dict["Loop"] as! String
                        }
                    }
                }
                public class Segment : Tea.TeaModel {
                    public var duration: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! String
                        }
                    }
                }
                public var gif: SearchTemplateResponseBody.TemplateList.Template.MuxConfig.Gif?

                public var segment: SearchTemplateResponseBody.TemplateList.Template.MuxConfig.Segment?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.gif?.validate()
                    try self.segment?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.gif != nil {
                        map["Gif"] = self.gif?.toMap()
                    }
                    if self.segment != nil {
                        map["Segment"] = self.segment?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Gif") {
                        var model = SearchTemplateResponseBody.TemplateList.Template.MuxConfig.Gif()
                        model.fromMap(dict["Gif"] as! [String: Any])
                        self.gif = model
                    }
                    if dict.keys.contains("Segment") {
                        var model = SearchTemplateResponseBody.TemplateList.Template.MuxConfig.Segment()
                        model.fromMap(dict["Segment"] as! [String: Any])
                        self.segment = model
                    }
                }
            }
            public class TransConfig : Tea.TeaModel {
                public var adjDarMethod: String?

                public var isCheckAudioBitrate: String?

                public var isCheckAudioBitrateFail: String?

                public var isCheckReso: String?

                public var isCheckResoFail: String?

                public var isCheckVideoBitrate: String?

                public var isCheckVideoBitrateFail: String?

                public var transMode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.adjDarMethod != nil {
                        map["AdjDarMethod"] = self.adjDarMethod!
                    }
                    if self.isCheckAudioBitrate != nil {
                        map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                    }
                    if self.isCheckAudioBitrateFail != nil {
                        map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                    }
                    if self.isCheckReso != nil {
                        map["IsCheckReso"] = self.isCheckReso!
                    }
                    if self.isCheckResoFail != nil {
                        map["IsCheckResoFail"] = self.isCheckResoFail!
                    }
                    if self.isCheckVideoBitrate != nil {
                        map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                    }
                    if self.isCheckVideoBitrateFail != nil {
                        map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                    }
                    if self.transMode != nil {
                        map["TransMode"] = self.transMode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AdjDarMethod") {
                        self.adjDarMethod = dict["AdjDarMethod"] as! String
                    }
                    if dict.keys.contains("IsCheckAudioBitrate") {
                        self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                    }
                    if dict.keys.contains("IsCheckAudioBitrateFail") {
                        self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                    }
                    if dict.keys.contains("IsCheckReso") {
                        self.isCheckReso = dict["IsCheckReso"] as! String
                    }
                    if dict.keys.contains("IsCheckResoFail") {
                        self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                    }
                    if dict.keys.contains("IsCheckVideoBitrate") {
                        self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                    }
                    if dict.keys.contains("IsCheckVideoBitrateFail") {
                        self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                    }
                    if dict.keys.contains("TransMode") {
                        self.transMode = dict["TransMode"] as! String
                    }
                }
            }
            public class Video : Tea.TeaModel {
                public class BitrateBnd : Tea.TeaModel {
                    public var max: String?

                    public var min: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.max != nil {
                            map["Max"] = self.max!
                        }
                        if self.min != nil {
                            map["Min"] = self.min!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Max") {
                            self.max = dict["Max"] as! String
                        }
                        if dict.keys.contains("Min") {
                            self.min = dict["Min"] as! String
                        }
                    }
                }
                public class NarrowBand : Tea.TeaModel {
                    public var abrmax: Double?

                    public var maxAbrRatio: Double?

                    public var version: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.abrmax != nil {
                            map["Abrmax"] = self.abrmax!
                        }
                        if self.maxAbrRatio != nil {
                            map["MaxAbrRatio"] = self.maxAbrRatio!
                        }
                        if self.version != nil {
                            map["Version"] = self.version!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Abrmax") {
                            self.abrmax = dict["Abrmax"] as! Double
                        }
                        if dict.keys.contains("MaxAbrRatio") {
                            self.maxAbrRatio = dict["MaxAbrRatio"] as! Double
                        }
                        if dict.keys.contains("Version") {
                            self.version = dict["Version"] as! String
                        }
                    }
                }
                public var bitrate: String?

                public var bitrateBnd: SearchTemplateResponseBody.TemplateList.Template.Video.BitrateBnd?

                public var bufsize: String?

                public var codec: String?

                public var crf: String?

                public var crop: String?

                public var degrain: String?

                public var fps: String?

                public var gop: String?

                public var hdr2sdr: String?

                public var height: String?

                public var longShortMode: String?

                public var maxFps: String?

                public var maxrate: String?

                public var narrowBand: SearchTemplateResponseBody.TemplateList.Template.Video.NarrowBand?

                public var pad: String?

                public var pixFmt: String?

                public var preset: String?

                public var profile: String?

                public var qscale: String?

                public var remove: String?

                public var resoPriority: String?

                public var scanMode: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.bitrateBnd?.validate()
                    try self.narrowBand?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.bitrateBnd != nil {
                        map["BitrateBnd"] = self.bitrateBnd?.toMap()
                    }
                    if self.bufsize != nil {
                        map["Bufsize"] = self.bufsize!
                    }
                    if self.codec != nil {
                        map["Codec"] = self.codec!
                    }
                    if self.crf != nil {
                        map["Crf"] = self.crf!
                    }
                    if self.crop != nil {
                        map["Crop"] = self.crop!
                    }
                    if self.degrain != nil {
                        map["Degrain"] = self.degrain!
                    }
                    if self.fps != nil {
                        map["Fps"] = self.fps!
                    }
                    if self.gop != nil {
                        map["Gop"] = self.gop!
                    }
                    if self.hdr2sdr != nil {
                        map["Hdr2sdr"] = self.hdr2sdr!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.longShortMode != nil {
                        map["LongShortMode"] = self.longShortMode!
                    }
                    if self.maxFps != nil {
                        map["MaxFps"] = self.maxFps!
                    }
                    if self.maxrate != nil {
                        map["Maxrate"] = self.maxrate!
                    }
                    if self.narrowBand != nil {
                        map["NarrowBand"] = self.narrowBand?.toMap()
                    }
                    if self.pad != nil {
                        map["Pad"] = self.pad!
                    }
                    if self.pixFmt != nil {
                        map["PixFmt"] = self.pixFmt!
                    }
                    if self.preset != nil {
                        map["Preset"] = self.preset!
                    }
                    if self.profile != nil {
                        map["Profile"] = self.profile!
                    }
                    if self.qscale != nil {
                        map["Qscale"] = self.qscale!
                    }
                    if self.remove != nil {
                        map["Remove"] = self.remove!
                    }
                    if self.resoPriority != nil {
                        map["ResoPriority"] = self.resoPriority!
                    }
                    if self.scanMode != nil {
                        map["ScanMode"] = self.scanMode!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("BitrateBnd") {
                        var model = SearchTemplateResponseBody.TemplateList.Template.Video.BitrateBnd()
                        model.fromMap(dict["BitrateBnd"] as! [String: Any])
                        self.bitrateBnd = model
                    }
                    if dict.keys.contains("Bufsize") {
                        self.bufsize = dict["Bufsize"] as! String
                    }
                    if dict.keys.contains("Codec") {
                        self.codec = dict["Codec"] as! String
                    }
                    if dict.keys.contains("Crf") {
                        self.crf = dict["Crf"] as! String
                    }
                    if dict.keys.contains("Crop") {
                        self.crop = dict["Crop"] as! String
                    }
                    if dict.keys.contains("Degrain") {
                        self.degrain = dict["Degrain"] as! String
                    }
                    if dict.keys.contains("Fps") {
                        self.fps = dict["Fps"] as! String
                    }
                    if dict.keys.contains("Gop") {
                        self.gop = dict["Gop"] as! String
                    }
                    if dict.keys.contains("Hdr2sdr") {
                        self.hdr2sdr = dict["Hdr2sdr"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("LongShortMode") {
                        self.longShortMode = dict["LongShortMode"] as! String
                    }
                    if dict.keys.contains("MaxFps") {
                        self.maxFps = dict["MaxFps"] as! String
                    }
                    if dict.keys.contains("Maxrate") {
                        self.maxrate = dict["Maxrate"] as! String
                    }
                    if dict.keys.contains("NarrowBand") {
                        var model = SearchTemplateResponseBody.TemplateList.Template.Video.NarrowBand()
                        model.fromMap(dict["NarrowBand"] as! [String: Any])
                        self.narrowBand = model
                    }
                    if dict.keys.contains("Pad") {
                        self.pad = dict["Pad"] as! String
                    }
                    if dict.keys.contains("PixFmt") {
                        self.pixFmt = dict["PixFmt"] as! String
                    }
                    if dict.keys.contains("Preset") {
                        self.preset = dict["Preset"] as! String
                    }
                    if dict.keys.contains("Profile") {
                        self.profile = dict["Profile"] as! String
                    }
                    if dict.keys.contains("Qscale") {
                        self.qscale = dict["Qscale"] as! String
                    }
                    if dict.keys.contains("Remove") {
                        self.remove = dict["Remove"] as! String
                    }
                    if dict.keys.contains("ResoPriority") {
                        self.resoPriority = dict["ResoPriority"] as! String
                    }
                    if dict.keys.contains("ScanMode") {
                        self.scanMode = dict["ScanMode"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public var audio: SearchTemplateResponseBody.TemplateList.Template.Audio?

            public var container: SearchTemplateResponseBody.TemplateList.Template.Container?

            public var creationTime: String?

            public var id: String?

            public var muxConfig: SearchTemplateResponseBody.TemplateList.Template.MuxConfig?

            public var name: String?

            public var state: String?

            public var transConfig: SearchTemplateResponseBody.TemplateList.Template.TransConfig?

            public var video: SearchTemplateResponseBody.TemplateList.Template.Video?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.audio?.validate()
                try self.container?.validate()
                try self.muxConfig?.validate()
                try self.transConfig?.validate()
                try self.video?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audio != nil {
                    map["Audio"] = self.audio?.toMap()
                }
                if self.container != nil {
                    map["Container"] = self.container?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.muxConfig != nil {
                    map["MuxConfig"] = self.muxConfig?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.transConfig != nil {
                    map["TransConfig"] = self.transConfig?.toMap()
                }
                if self.video != nil {
                    map["Video"] = self.video?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Audio") {
                    var model = SearchTemplateResponseBody.TemplateList.Template.Audio()
                    model.fromMap(dict["Audio"] as! [String: Any])
                    self.audio = model
                }
                if dict.keys.contains("Container") {
                    var model = SearchTemplateResponseBody.TemplateList.Template.Container()
                    model.fromMap(dict["Container"] as! [String: Any])
                    self.container = model
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("MuxConfig") {
                    var model = SearchTemplateResponseBody.TemplateList.Template.MuxConfig()
                    model.fromMap(dict["MuxConfig"] as! [String: Any])
                    self.muxConfig = model
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("TransConfig") {
                    var model = SearchTemplateResponseBody.TemplateList.Template.TransConfig()
                    model.fromMap(dict["TransConfig"] as! [String: Any])
                    self.transConfig = model
                }
                if dict.keys.contains("Video") {
                    var model = SearchTemplateResponseBody.TemplateList.Template.Video()
                    model.fromMap(dict["Video"] as! [String: Any])
                    self.video = model
                }
            }
        }
        public var template: [SearchTemplateResponseBody.TemplateList.Template]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.template != nil {
                var tmp : [Any] = []
                for k in self.template! {
                    tmp.append(k.toMap())
                }
                map["Template"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Template") {
                var tmp : [SearchTemplateResponseBody.TemplateList.Template] = []
                for v in dict["Template"] as! [Any] {
                    var model = SearchTemplateResponseBody.TemplateList.Template()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.template = tmp
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var templateList: SearchTemplateResponseBody.TemplateList?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateList != nil {
            map["TemplateList"] = self.templateList?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateList") {
            var model = SearchTemplateResponseBody.TemplateList()
            model.fromMap(dict["TemplateList"] as! [String: Any])
            self.templateList = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class SearchTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SearchWaterMarkTemplateRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class SearchWaterMarkTemplateResponseBody : Tea.TeaModel {
    public class WaterMarkTemplateList : Tea.TeaModel {
        public class WaterMarkTemplate : Tea.TeaModel {
            public class RatioRefer : Tea.TeaModel {
                public var dx: String?

                public var dy: String?

                public var height: String?

                public var width: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dx != nil {
                        map["Dx"] = self.dx!
                    }
                    if self.dy != nil {
                        map["Dy"] = self.dy!
                    }
                    if self.height != nil {
                        map["Height"] = self.height!
                    }
                    if self.width != nil {
                        map["Width"] = self.width!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Dx") {
                        self.dx = dict["Dx"] as! String
                    }
                    if dict.keys.contains("Dy") {
                        self.dy = dict["Dy"] as! String
                    }
                    if dict.keys.contains("Height") {
                        self.height = dict["Height"] as! String
                    }
                    if dict.keys.contains("Width") {
                        self.width = dict["Width"] as! String
                    }
                }
            }
            public class Timeline : Tea.TeaModel {
                public var duration: String?

                public var start: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.start != nil {
                        map["Start"] = self.start!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("Start") {
                        self.start = dict["Start"] as! String
                    }
                }
            }
            public var dx: String?

            public var dy: String?

            public var height: String?

            public var id: String?

            public var name: String?

            public var ratioRefer: SearchWaterMarkTemplateResponseBody.WaterMarkTemplateList.WaterMarkTemplate.RatioRefer?

            public var referPos: String?

            public var state: String?

            public var timeline: SearchWaterMarkTemplateResponseBody.WaterMarkTemplateList.WaterMarkTemplate.Timeline?

            public var type: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ratioRefer?.validate()
                try self.timeline?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dx != nil {
                    map["Dx"] = self.dx!
                }
                if self.dy != nil {
                    map["Dy"] = self.dy!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ratioRefer != nil {
                    map["RatioRefer"] = self.ratioRefer?.toMap()
                }
                if self.referPos != nil {
                    map["ReferPos"] = self.referPos!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.timeline != nil {
                    map["Timeline"] = self.timeline?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Dx") {
                    self.dx = dict["Dx"] as! String
                }
                if dict.keys.contains("Dy") {
                    self.dy = dict["Dy"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RatioRefer") {
                    var model = SearchWaterMarkTemplateResponseBody.WaterMarkTemplateList.WaterMarkTemplate.RatioRefer()
                    model.fromMap(dict["RatioRefer"] as! [String: Any])
                    self.ratioRefer = model
                }
                if dict.keys.contains("ReferPos") {
                    self.referPos = dict["ReferPos"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Timeline") {
                    var model = SearchWaterMarkTemplateResponseBody.WaterMarkTemplateList.WaterMarkTemplate.Timeline()
                    model.fromMap(dict["Timeline"] as! [String: Any])
                    self.timeline = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var waterMarkTemplate: [SearchWaterMarkTemplateResponseBody.WaterMarkTemplateList.WaterMarkTemplate]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.waterMarkTemplate != nil {
                var tmp : [Any] = []
                for k in self.waterMarkTemplate! {
                    tmp.append(k.toMap())
                }
                map["WaterMarkTemplate"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("WaterMarkTemplate") {
                var tmp : [SearchWaterMarkTemplateResponseBody.WaterMarkTemplateList.WaterMarkTemplate] = []
                for v in dict["WaterMarkTemplate"] as! [Any] {
                    var model = SearchWaterMarkTemplateResponseBody.WaterMarkTemplateList.WaterMarkTemplate()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.waterMarkTemplate = tmp
            }
        }
    }
    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public var waterMarkTemplateList: SearchWaterMarkTemplateResponseBody.WaterMarkTemplateList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.waterMarkTemplateList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.waterMarkTemplateList != nil {
            map["WaterMarkTemplateList"] = self.waterMarkTemplateList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
        if dict.keys.contains("WaterMarkTemplateList") {
            var model = SearchWaterMarkTemplateResponseBody.WaterMarkTemplateList()
            model.fromMap(dict["WaterMarkTemplateList"] as! [String: Any])
            self.waterMarkTemplateList = model
        }
    }
}

public class SearchWaterMarkTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SearchWaterMarkTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SearchWaterMarkTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitAnalysisJobRequest : Tea.TeaModel {
    public var analysisConfig: String?

    public var input: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var priority: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.analysisConfig != nil {
            map["AnalysisConfig"] = self.analysisConfig!
        }
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AnalysisConfig") {
            self.analysisConfig = dict["AnalysisConfig"] as! String
        }
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitAnalysisJobResponseBody : Tea.TeaModel {
    public class AnalysisJob : Tea.TeaModel {
        public class AnalysisConfig : Tea.TeaModel {
            public class PropertiesControl : Tea.TeaModel {
                public class Crop : Tea.TeaModel {
                    public var height: String?

                    public var left_: String?

                    public var mode: String?

                    public var top: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.left_ != nil {
                            map["Left"] = self.left_!
                        }
                        if self.mode != nil {
                            map["Mode"] = self.mode!
                        }
                        if self.top != nil {
                            map["Top"] = self.top!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("Left") {
                            self.left_ = dict["Left"] as! String
                        }
                        if dict.keys.contains("Mode") {
                            self.mode = dict["Mode"] as! String
                        }
                        if dict.keys.contains("Top") {
                            self.top = dict["Top"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var crop: SubmitAnalysisJobResponseBody.AnalysisJob.AnalysisConfig.PropertiesControl.Crop?

                public var deinterlace: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.crop?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.crop != nil {
                        map["Crop"] = self.crop?.toMap()
                    }
                    if self.deinterlace != nil {
                        map["Deinterlace"] = self.deinterlace!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Crop") {
                        var model = SubmitAnalysisJobResponseBody.AnalysisJob.AnalysisConfig.PropertiesControl.Crop()
                        model.fromMap(dict["Crop"] as! [String: Any])
                        self.crop = model
                    }
                    if dict.keys.contains("Deinterlace") {
                        self.deinterlace = dict["Deinterlace"] as! String
                    }
                }
            }
            public class QualityControl : Tea.TeaModel {
                public var methodStreaming: String?

                public var rateQuality: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.methodStreaming != nil {
                        map["MethodStreaming"] = self.methodStreaming!
                    }
                    if self.rateQuality != nil {
                        map["RateQuality"] = self.rateQuality!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MethodStreaming") {
                        self.methodStreaming = dict["MethodStreaming"] as! String
                    }
                    if dict.keys.contains("RateQuality") {
                        self.rateQuality = dict["RateQuality"] as! String
                    }
                }
            }
            public var propertiesControl: SubmitAnalysisJobResponseBody.AnalysisJob.AnalysisConfig.PropertiesControl?

            public var qualityControl: SubmitAnalysisJobResponseBody.AnalysisJob.AnalysisConfig.QualityControl?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.propertiesControl?.validate()
                try self.qualityControl?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.propertiesControl != nil {
                    map["PropertiesControl"] = self.propertiesControl?.toMap()
                }
                if self.qualityControl != nil {
                    map["QualityControl"] = self.qualityControl?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PropertiesControl") {
                    var model = SubmitAnalysisJobResponseBody.AnalysisJob.AnalysisConfig.PropertiesControl()
                    model.fromMap(dict["PropertiesControl"] as! [String: Any])
                    self.propertiesControl = model
                }
                if dict.keys.contains("QualityControl") {
                    var model = SubmitAnalysisJobResponseBody.AnalysisJob.AnalysisConfig.QualityControl()
                    model.fromMap(dict["QualityControl"] as! [String: Any])
                    self.qualityControl = model
                }
            }
        }
        public class InputFile : Tea.TeaModel {
            public var bucket: String?

            public var location: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("Object") {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public class MNSMessageResult : Tea.TeaModel {
            public var errorCode: String?

            public var errorMessage: String?

            public var messageId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.messageId != nil {
                    map["MessageId"] = self.messageId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("MessageId") {
                    self.messageId = dict["MessageId"] as! String
                }
            }
        }
        public class TemplateList : Tea.TeaModel {
            public class Template : Tea.TeaModel {
                public class Audio : Tea.TeaModel {
                    public var bitrate: String?

                    public var channels: String?

                    public var codec: String?

                    public var profile: String?

                    public var qscale: String?

                    public var samplerate: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.channels != nil {
                            map["Channels"] = self.channels!
                        }
                        if self.codec != nil {
                            map["Codec"] = self.codec!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.qscale != nil {
                            map["Qscale"] = self.qscale!
                        }
                        if self.samplerate != nil {
                            map["Samplerate"] = self.samplerate!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("Channels") {
                            self.channels = dict["Channels"] as! String
                        }
                        if dict.keys.contains("Codec") {
                            self.codec = dict["Codec"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Qscale") {
                            self.qscale = dict["Qscale"] as! String
                        }
                        if dict.keys.contains("Samplerate") {
                            self.samplerate = dict["Samplerate"] as! String
                        }
                    }
                }
                public class Container : Tea.TeaModel {
                    public var format: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                    }
                }
                public class MuxConfig : Tea.TeaModel {
                    public class Gif : Tea.TeaModel {
                        public var finalDelay: String?

                        public var loop: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.finalDelay != nil {
                                map["FinalDelay"] = self.finalDelay!
                            }
                            if self.loop != nil {
                                map["Loop"] = self.loop!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("FinalDelay") {
                                self.finalDelay = dict["FinalDelay"] as! String
                            }
                            if dict.keys.contains("Loop") {
                                self.loop = dict["Loop"] as! String
                            }
                        }
                    }
                    public class Segment : Tea.TeaModel {
                        public var duration: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                        }
                    }
                    public var gif: SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.MuxConfig.Gif?

                    public var segment: SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.MuxConfig.Segment?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.gif?.validate()
                        try self.segment?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.gif != nil {
                            map["Gif"] = self.gif?.toMap()
                        }
                        if self.segment != nil {
                            map["Segment"] = self.segment?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Gif") {
                            var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.MuxConfig.Gif()
                            model.fromMap(dict["Gif"] as! [String: Any])
                            self.gif = model
                        }
                        if dict.keys.contains("Segment") {
                            var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.MuxConfig.Segment()
                            model.fromMap(dict["Segment"] as! [String: Any])
                            self.segment = model
                        }
                    }
                }
                public class TransConfig : Tea.TeaModel {
                    public var transMode: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.transMode != nil {
                            map["TransMode"] = self.transMode!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TransMode") {
                            self.transMode = dict["TransMode"] as! String
                        }
                    }
                }
                public class Video : Tea.TeaModel {
                    public class BitrateBnd : Tea.TeaModel {
                        public var max: String?

                        public var min: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.max != nil {
                                map["Max"] = self.max!
                            }
                            if self.min != nil {
                                map["Min"] = self.min!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Max") {
                                self.max = dict["Max"] as! String
                            }
                            if dict.keys.contains("Min") {
                                self.min = dict["Min"] as! String
                            }
                        }
                    }
                    public var bitrate: String?

                    public var bitrateBnd: SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.Video.BitrateBnd?

                    public var bufsize: String?

                    public var codec: String?

                    public var crf: String?

                    public var degrain: String?

                    public var fps: String?

                    public var gop: String?

                    public var height: String?

                    public var maxrate: String?

                    public var pixFmt: String?

                    public var preset: String?

                    public var profile: String?

                    public var qscale: String?

                    public var scanMode: String?

                    public var width: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.bitrateBnd?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bitrate != nil {
                            map["Bitrate"] = self.bitrate!
                        }
                        if self.bitrateBnd != nil {
                            map["BitrateBnd"] = self.bitrateBnd?.toMap()
                        }
                        if self.bufsize != nil {
                            map["Bufsize"] = self.bufsize!
                        }
                        if self.codec != nil {
                            map["Codec"] = self.codec!
                        }
                        if self.crf != nil {
                            map["Crf"] = self.crf!
                        }
                        if self.degrain != nil {
                            map["Degrain"] = self.degrain!
                        }
                        if self.fps != nil {
                            map["Fps"] = self.fps!
                        }
                        if self.gop != nil {
                            map["Gop"] = self.gop!
                        }
                        if self.height != nil {
                            map["Height"] = self.height!
                        }
                        if self.maxrate != nil {
                            map["Maxrate"] = self.maxrate!
                        }
                        if self.pixFmt != nil {
                            map["PixFmt"] = self.pixFmt!
                        }
                        if self.preset != nil {
                            map["Preset"] = self.preset!
                        }
                        if self.profile != nil {
                            map["Profile"] = self.profile!
                        }
                        if self.qscale != nil {
                            map["Qscale"] = self.qscale!
                        }
                        if self.scanMode != nil {
                            map["ScanMode"] = self.scanMode!
                        }
                        if self.width != nil {
                            map["Width"] = self.width!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bitrate") {
                            self.bitrate = dict["Bitrate"] as! String
                        }
                        if dict.keys.contains("BitrateBnd") {
                            var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.Video.BitrateBnd()
                            model.fromMap(dict["BitrateBnd"] as! [String: Any])
                            self.bitrateBnd = model
                        }
                        if dict.keys.contains("Bufsize") {
                            self.bufsize = dict["Bufsize"] as! String
                        }
                        if dict.keys.contains("Codec") {
                            self.codec = dict["Codec"] as! String
                        }
                        if dict.keys.contains("Crf") {
                            self.crf = dict["Crf"] as! String
                        }
                        if dict.keys.contains("Degrain") {
                            self.degrain = dict["Degrain"] as! String
                        }
                        if dict.keys.contains("Fps") {
                            self.fps = dict["Fps"] as! String
                        }
                        if dict.keys.contains("Gop") {
                            self.gop = dict["Gop"] as! String
                        }
                        if dict.keys.contains("Height") {
                            self.height = dict["Height"] as! String
                        }
                        if dict.keys.contains("Maxrate") {
                            self.maxrate = dict["Maxrate"] as! String
                        }
                        if dict.keys.contains("PixFmt") {
                            self.pixFmt = dict["PixFmt"] as! String
                        }
                        if dict.keys.contains("Preset") {
                            self.preset = dict["Preset"] as! String
                        }
                        if dict.keys.contains("Profile") {
                            self.profile = dict["Profile"] as! String
                        }
                        if dict.keys.contains("Qscale") {
                            self.qscale = dict["Qscale"] as! String
                        }
                        if dict.keys.contains("ScanMode") {
                            self.scanMode = dict["ScanMode"] as! String
                        }
                        if dict.keys.contains("Width") {
                            self.width = dict["Width"] as! String
                        }
                    }
                }
                public var audio: SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.Audio?

                public var container: SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.Container?

                public var id: String?

                public var muxConfig: SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.MuxConfig?

                public var name: String?

                public var state: String?

                public var transConfig: SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.TransConfig?

                public var video: SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.Video?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.audio?.validate()
                    try self.container?.validate()
                    try self.muxConfig?.validate()
                    try self.transConfig?.validate()
                    try self.video?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audio != nil {
                        map["Audio"] = self.audio?.toMap()
                    }
                    if self.container != nil {
                        map["Container"] = self.container?.toMap()
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.muxConfig != nil {
                        map["MuxConfig"] = self.muxConfig?.toMap()
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    if self.transConfig != nil {
                        map["TransConfig"] = self.transConfig?.toMap()
                    }
                    if self.video != nil {
                        map["Video"] = self.video?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Audio") {
                        var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.Audio()
                        model.fromMap(dict["Audio"] as! [String: Any])
                        self.audio = model
                    }
                    if dict.keys.contains("Container") {
                        var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.Container()
                        model.fromMap(dict["Container"] as! [String: Any])
                        self.container = model
                    }
                    if dict.keys.contains("Id") {
                        self.id = dict["Id"] as! String
                    }
                    if dict.keys.contains("MuxConfig") {
                        var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.MuxConfig()
                        model.fromMap(dict["MuxConfig"] as! [String: Any])
                        self.muxConfig = model
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! String
                    }
                    if dict.keys.contains("TransConfig") {
                        var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.TransConfig()
                        model.fromMap(dict["TransConfig"] as! [String: Any])
                        self.transConfig = model
                    }
                    if dict.keys.contains("Video") {
                        var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template.Video()
                        model.fromMap(dict["Video"] as! [String: Any])
                        self.video = model
                    }
                }
            }
            public var template: [SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.template != nil {
                    var tmp : [Any] = []
                    for k in self.template! {
                        tmp.append(k.toMap())
                    }
                    map["Template"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Template") {
                    var tmp : [SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template] = []
                    for v in dict["Template"] as! [Any] {
                        var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList.Template()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.template = tmp
                }
            }
        }
        public var analysisConfig: SubmitAnalysisJobResponseBody.AnalysisJob.AnalysisConfig?

        public var code: String?

        public var creationTime: String?

        public var id: String?

        public var inputFile: SubmitAnalysisJobResponseBody.AnalysisJob.InputFile?

        public var MNSMessageResult: SubmitAnalysisJobResponseBody.AnalysisJob.MNSMessageResult?

        public var message: String?

        public var percent: Int64?

        public var pipelineId: String?

        public var priority: String?

        public var state: String?

        public var templateList: SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.analysisConfig?.validate()
            try self.inputFile?.validate()
            try self.MNSMessageResult?.validate()
            try self.templateList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.analysisConfig != nil {
                map["AnalysisConfig"] = self.analysisConfig?.toMap()
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.inputFile != nil {
                map["InputFile"] = self.inputFile?.toMap()
            }
            if self.MNSMessageResult != nil {
                map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.percent != nil {
                map["Percent"] = self.percent!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.templateList != nil {
                map["TemplateList"] = self.templateList?.toMap()
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AnalysisConfig") {
                var model = SubmitAnalysisJobResponseBody.AnalysisJob.AnalysisConfig()
                model.fromMap(dict["AnalysisConfig"] as! [String: Any])
                self.analysisConfig = model
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("InputFile") {
                var model = SubmitAnalysisJobResponseBody.AnalysisJob.InputFile()
                model.fromMap(dict["InputFile"] as! [String: Any])
                self.inputFile = model
            }
            if dict.keys.contains("MNSMessageResult") {
                var model = SubmitAnalysisJobResponseBody.AnalysisJob.MNSMessageResult()
                model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                self.MNSMessageResult = model
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Percent") {
                self.percent = dict["Percent"] as! Int64
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("TemplateList") {
                var model = SubmitAnalysisJobResponseBody.AnalysisJob.TemplateList()
                model.fromMap(dict["TemplateList"] as! [String: Any])
                self.templateList = model
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var analysisJob: SubmitAnalysisJobResponseBody.AnalysisJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.analysisJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.analysisJob != nil {
            map["AnalysisJob"] = self.analysisJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AnalysisJob") {
            var model = SubmitAnalysisJobResponseBody.AnalysisJob()
            model.fromMap(dict["AnalysisJob"] as! [String: Any])
            self.analysisJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitAnalysisJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitAnalysisJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitAnalysisJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitCopyrightExtractJobRequest : Tea.TeaModel {
    public var callBack: String?

    public var input: String?

    public var params: String?

    public var url: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callBack != nil {
            map["CallBack"] = self.callBack!
        }
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallBack") {
            self.callBack = dict["CallBack"] as! String
        }
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitCopyrightExtractJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: SubmitCopyrightExtractJobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var statusCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SubmitCopyrightExtractJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! Int64
        }
    }
}

public class SubmitCopyrightExtractJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitCopyrightExtractJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitCopyrightExtractJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitCopyrightJobRequest : Tea.TeaModel {
    public var callBack: String?

    public var description_: String?

    public var input: String?

    public var level: Int64?

    public var message: String?

    public var output: String?

    public var params: String?

    public var startTime: String?

    public var totalTime: String?

    public var url: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callBack != nil {
            map["CallBack"] = self.callBack!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.totalTime != nil {
            map["TotalTime"] = self.totalTime!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallBack") {
            self.callBack = dict["CallBack"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("Level") {
            self.level = dict["Level"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Output") {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TotalTime") {
            self.totalTime = dict["TotalTime"] as! String
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitCopyrightJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: SubmitCopyrightJobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var statusCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SubmitCopyrightJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! Int64
        }
    }
}

public class SubmitCopyrightJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitCopyrightJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitCopyrightJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitFpDBDeleteJobRequest : Tea.TeaModel {
    public var delType: String?

    public var fpDBId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.delType != nil {
            map["DelType"] = self.delType!
        }
        if self.fpDBId != nil {
            map["FpDBId"] = self.fpDBId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DelType") {
            self.delType = dict["DelType"] as! String
        }
        if dict.keys.contains("FpDBId") {
            self.fpDBId = dict["FpDBId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitFpDBDeleteJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitFpDBDeleteJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitFpDBDeleteJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitFpDBDeleteJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitFpFileDeleteJobRequest : Tea.TeaModel {
    public var fileIds: String?

    public var fpDBId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var primaryKeys: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileIds != nil {
            map["FileIds"] = self.fileIds!
        }
        if self.fpDBId != nil {
            map["FpDBId"] = self.fpDBId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.primaryKeys != nil {
            map["PrimaryKeys"] = self.primaryKeys!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileIds") {
            self.fileIds = dict["FileIds"] as! String
        }
        if dict.keys.contains("FpDBId") {
            self.fpDBId = dict["FpDBId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("PrimaryKeys") {
            self.primaryKeys = dict["PrimaryKeys"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitFpFileDeleteJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitFpFileDeleteJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitFpFileDeleteJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitFpFileDeleteJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitFpShotJobRequest : Tea.TeaModel {
    public var fpShotConfig: String?

    public var input: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fpShotConfig != nil {
            map["FpShotConfig"] = self.fpShotConfig!
        }
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FpShotConfig") {
            self.fpShotConfig = dict["FpShotConfig"] as! String
        }
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitFpShotJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitFpShotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitFpShotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitFpShotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitIProductionJobRequest : Tea.TeaModel {
    public var functionName: String?

    public var input: String?

    public var jobParams: String?

    public var modelId: String?

    public var notifyUrl: String?

    public var output: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scheduleParams: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.functionName != nil {
            map["FunctionName"] = self.functionName!
        }
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.jobParams != nil {
            map["JobParams"] = self.jobParams!
        }
        if self.modelId != nil {
            map["ModelId"] = self.modelId!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scheduleParams != nil {
            map["ScheduleParams"] = self.scheduleParams!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FunctionName") {
            self.functionName = dict["FunctionName"] as! String
        }
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("JobParams") {
            self.jobParams = dict["JobParams"] as! String
        }
        if dict.keys.contains("ModelId") {
            self.modelId = dict["ModelId"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("Output") {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScheduleParams") {
            self.scheduleParams = dict["ScheduleParams"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitIProductionJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class SubmitIProductionJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitIProductionJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitIProductionJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitImageCopyrightRequest : Tea.TeaModel {
    public var message: String?

    public var output: String?

    public var params: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Output") {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
    }
}

public class SubmitImageCopyrightResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: SubmitImageCopyrightResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var statusCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SubmitImageCopyrightResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! Int64
        }
    }
}

public class SubmitImageCopyrightResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitImageCopyrightResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitImageCopyrightResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitJobsRequest : Tea.TeaModel {
    public var input: String?

    public var outputBucket: String?

    public var outputLocation: String?

    public var outputs: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.outputBucket != nil {
            map["OutputBucket"] = self.outputBucket!
        }
        if self.outputLocation != nil {
            map["OutputLocation"] = self.outputLocation!
        }
        if self.outputs != nil {
            map["Outputs"] = self.outputs!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("OutputBucket") {
            self.outputBucket = dict["OutputBucket"] as! String
        }
        if dict.keys.contains("OutputLocation") {
            self.outputLocation = dict["OutputLocation"] as! String
        }
        if dict.keys.contains("Outputs") {
            self.outputs = dict["Outputs"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class SubmitJobsResponseBody : Tea.TeaModel {
    public class JobResultList : Tea.TeaModel {
        public class JobResult : Tea.TeaModel {
            public class Job : Tea.TeaModel {
                public class Input : Tea.TeaModel {
                    public var bucket: String?

                    public var location: String?

                    public var object: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.bucket != nil {
                            map["Bucket"] = self.bucket!
                        }
                        if self.location != nil {
                            map["Location"] = self.location!
                        }
                        if self.object != nil {
                            map["Object"] = self.object!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Bucket") {
                            self.bucket = dict["Bucket"] as! String
                        }
                        if dict.keys.contains("Location") {
                            self.location = dict["Location"] as! String
                        }
                        if dict.keys.contains("Object") {
                            self.object = dict["Object"] as! String
                        }
                    }
                }
                public class MNSMessageResult : Tea.TeaModel {
                    public var errorCode: String?

                    public var errorMessage: String?

                    public var messageId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.errorCode != nil {
                            map["ErrorCode"] = self.errorCode!
                        }
                        if self.errorMessage != nil {
                            map["ErrorMessage"] = self.errorMessage!
                        }
                        if self.messageId != nil {
                            map["MessageId"] = self.messageId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ErrorCode") {
                            self.errorCode = dict["ErrorCode"] as! String
                        }
                        if dict.keys.contains("ErrorMessage") {
                            self.errorMessage = dict["ErrorMessage"] as! String
                        }
                        if dict.keys.contains("MessageId") {
                            self.messageId = dict["MessageId"] as! String
                        }
                    }
                }
                public class Output : Tea.TeaModel {
                    public class AmixList : Tea.TeaModel {
                        public class Amix : Tea.TeaModel {
                            public var amixURL: String?

                            public var duration: String?

                            public var map: String?

                            public var mixDurMode: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.amixURL != nil {
                                    map["AmixURL"] = self.amixURL!
                                }
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.map != nil {
                                    map["Map"] = self.map!
                                }
                                if self.mixDurMode != nil {
                                    map["MixDurMode"] = self.mixDurMode!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AmixURL") {
                                    self.amixURL = dict["AmixURL"] as! String
                                }
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Map") {
                                    self.map = dict["Map"] as! String
                                }
                                if dict.keys.contains("MixDurMode") {
                                    self.mixDurMode = dict["MixDurMode"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var amix: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.AmixList.Amix]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.amix != nil {
                                var tmp : [Any] = []
                                for k in self.amix! {
                                    tmp.append(k.toMap())
                                }
                                map["Amix"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Amix") {
                                var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.AmixList.Amix] = []
                                for v in dict["Amix"] as! [Any] {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.AmixList.Amix()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.amix = tmp
                            }
                        }
                    }
                    public class Audio : Tea.TeaModel {
                        public class Volume : Tea.TeaModel {
                            public var level: String?

                            public var method: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.level != nil {
                                    map["Level"] = self.level!
                                }
                                if self.method != nil {
                                    map["Method"] = self.method!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Level") {
                                    self.level = dict["Level"] as! String
                                }
                                if dict.keys.contains("Method") {
                                    self.method = dict["Method"] as! String
                                }
                            }
                        }
                        public var bitrate: String?

                        public var channels: String?

                        public var codec: String?

                        public var profile: String?

                        public var qscale: String?

                        public var samplerate: String?

                        public var volume: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Audio.Volume?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.volume?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.channels != nil {
                                map["Channels"] = self.channels!
                            }
                            if self.codec != nil {
                                map["Codec"] = self.codec!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.qscale != nil {
                                map["Qscale"] = self.qscale!
                            }
                            if self.samplerate != nil {
                                map["Samplerate"] = self.samplerate!
                            }
                            if self.volume != nil {
                                map["Volume"] = self.volume?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Channels") {
                                self.channels = dict["Channels"] as! String
                            }
                            if dict.keys.contains("Codec") {
                                self.codec = dict["Codec"] as! String
                            }
                            if dict.keys.contains("Profile") {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Qscale") {
                                self.qscale = dict["Qscale"] as! String
                            }
                            if dict.keys.contains("Samplerate") {
                                self.samplerate = dict["Samplerate"] as! String
                            }
                            if dict.keys.contains("Volume") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Audio.Volume()
                                model.fromMap(dict["Volume"] as! [String: Any])
                                self.volume = model
                            }
                        }
                    }
                    public class Clip : Tea.TeaModel {
                        public class TimeSpan : Tea.TeaModel {
                            public var duration: String?

                            public var seek: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.seek != nil {
                                    map["Seek"] = self.seek!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("Seek") {
                                    self.seek = dict["Seek"] as! String
                                }
                            }
                        }
                        public var timeSpan: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Clip.TimeSpan?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.timeSpan?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.timeSpan != nil {
                                map["TimeSpan"] = self.timeSpan?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("TimeSpan") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Clip.TimeSpan()
                                model.fromMap(dict["TimeSpan"] as! [String: Any])
                                self.timeSpan = model
                            }
                        }
                    }
                    public class Container : Tea.TeaModel {
                        public var format: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.format != nil {
                                map["Format"] = self.format!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Format") {
                                self.format = dict["Format"] as! String
                            }
                        }
                    }
                    public class DigiWaterMark : Tea.TeaModel {
                        public class InputFile : Tea.TeaModel {
                            public var bucket: String?

                            public var location: String?

                            public var object: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bucket != nil {
                                    map["Bucket"] = self.bucket!
                                }
                                if self.location != nil {
                                    map["Location"] = self.location!
                                }
                                if self.object != nil {
                                    map["Object"] = self.object!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bucket") {
                                    self.bucket = dict["Bucket"] as! String
                                }
                                if dict.keys.contains("Location") {
                                    self.location = dict["Location"] as! String
                                }
                                if dict.keys.contains("Object") {
                                    self.object = dict["Object"] as! String
                                }
                            }
                        }
                        public var alpha: String?

                        public var inputFile: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.DigiWaterMark.InputFile?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.inputFile?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.alpha != nil {
                                map["Alpha"] = self.alpha!
                            }
                            if self.inputFile != nil {
                                map["InputFile"] = self.inputFile?.toMap()
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Alpha") {
                                self.alpha = dict["Alpha"] as! String
                            }
                            if dict.keys.contains("InputFile") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.DigiWaterMark.InputFile()
                                model.fromMap(dict["InputFile"] as! [String: Any])
                                self.inputFile = model
                            }
                            if dict.keys.contains("Type") {
                                self.type = dict["Type"] as! String
                            }
                        }
                    }
                    public class Encryption : Tea.TeaModel {
                        public var id: String?

                        public var key: String?

                        public var keyType: String?

                        public var keyUri: String?

                        public var skipCnt: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.id != nil {
                                map["Id"] = self.id!
                            }
                            if self.key != nil {
                                map["Key"] = self.key!
                            }
                            if self.keyType != nil {
                                map["KeyType"] = self.keyType!
                            }
                            if self.keyUri != nil {
                                map["KeyUri"] = self.keyUri!
                            }
                            if self.skipCnt != nil {
                                map["SkipCnt"] = self.skipCnt!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Id") {
                                self.id = dict["Id"] as! String
                            }
                            if dict.keys.contains("Key") {
                                self.key = dict["Key"] as! String
                            }
                            if dict.keys.contains("KeyType") {
                                self.keyType = dict["KeyType"] as! String
                            }
                            if dict.keys.contains("KeyUri") {
                                self.keyUri = dict["KeyUri"] as! String
                            }
                            if dict.keys.contains("SkipCnt") {
                                self.skipCnt = dict["SkipCnt"] as! String
                            }
                            if dict.keys.contains("Type") {
                                self.type = dict["Type"] as! String
                            }
                        }
                    }
                    public class M3U8NonStandardSupport : Tea.TeaModel {
                        public class TS : Tea.TeaModel {
                            public var md5Support: Bool?

                            public var sizeSupport: Bool?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.md5Support != nil {
                                    map["Md5Support"] = self.md5Support!
                                }
                                if self.sizeSupport != nil {
                                    map["SizeSupport"] = self.sizeSupport!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Md5Support") {
                                    self.md5Support = dict["Md5Support"] as! Bool
                                }
                                if dict.keys.contains("SizeSupport") {
                                    self.sizeSupport = dict["SizeSupport"] as! Bool
                                }
                            }
                        }
                        public var TS: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.M3U8NonStandardSupport.TS?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.TS?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.TS != nil {
                                map["TS"] = self.TS?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("TS") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.M3U8NonStandardSupport.TS()
                                model.fromMap(dict["TS"] as! [String: Any])
                                self.TS = model
                            }
                        }
                    }
                    public class MergeList : Tea.TeaModel {
                        public class Merge : Tea.TeaModel {
                            public var duration: String?

                            public var mergeURL: String?

                            public var roleArn: String?

                            public var start: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.mergeURL != nil {
                                    map["MergeURL"] = self.mergeURL!
                                }
                                if self.roleArn != nil {
                                    map["RoleArn"] = self.roleArn!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("MergeURL") {
                                    self.mergeURL = dict["MergeURL"] as! String
                                }
                                if dict.keys.contains("RoleArn") {
                                    self.roleArn = dict["RoleArn"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                            }
                        }
                        public var merge: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MergeList.Merge]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.merge != nil {
                                var tmp : [Any] = []
                                for k in self.merge! {
                                    tmp.append(k.toMap())
                                }
                                map["Merge"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Merge") {
                                var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MergeList.Merge] = []
                                for v in dict["Merge"] as! [Any] {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MergeList.Merge()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.merge = tmp
                            }
                        }
                    }
                    public class MuxConfig : Tea.TeaModel {
                        public class Gif : Tea.TeaModel {
                            public var ditherMode: String?

                            public var finalDelay: String?

                            public var isCustomPalette: String?

                            public var loop: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.ditherMode != nil {
                                    map["DitherMode"] = self.ditherMode!
                                }
                                if self.finalDelay != nil {
                                    map["FinalDelay"] = self.finalDelay!
                                }
                                if self.isCustomPalette != nil {
                                    map["IsCustomPalette"] = self.isCustomPalette!
                                }
                                if self.loop != nil {
                                    map["Loop"] = self.loop!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("DitherMode") {
                                    self.ditherMode = dict["DitherMode"] as! String
                                }
                                if dict.keys.contains("FinalDelay") {
                                    self.finalDelay = dict["FinalDelay"] as! String
                                }
                                if dict.keys.contains("IsCustomPalette") {
                                    self.isCustomPalette = dict["IsCustomPalette"] as! String
                                }
                                if dict.keys.contains("Loop") {
                                    self.loop = dict["Loop"] as! String
                                }
                            }
                        }
                        public class Segment : Tea.TeaModel {
                            public var duration: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                            }
                        }
                        public class Webp : Tea.TeaModel {
                            public var loop: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.loop != nil {
                                    map["Loop"] = self.loop!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Loop") {
                                    self.loop = dict["Loop"] as! String
                                }
                            }
                        }
                        public var gif: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MuxConfig.Gif?

                        public var segment: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MuxConfig.Segment?

                        public var webp: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MuxConfig.Webp?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.gif?.validate()
                            try self.segment?.validate()
                            try self.webp?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.gif != nil {
                                map["Gif"] = self.gif?.toMap()
                            }
                            if self.segment != nil {
                                map["Segment"] = self.segment?.toMap()
                            }
                            if self.webp != nil {
                                map["Webp"] = self.webp?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Gif") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MuxConfig.Gif()
                                model.fromMap(dict["Gif"] as! [String: Any])
                                self.gif = model
                            }
                            if dict.keys.contains("Segment") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MuxConfig.Segment()
                                model.fromMap(dict["Segment"] as! [String: Any])
                                self.segment = model
                            }
                            if dict.keys.contains("Webp") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MuxConfig.Webp()
                                model.fromMap(dict["Webp"] as! [String: Any])
                                self.webp = model
                            }
                        }
                    }
                    public class OpeningList : Tea.TeaModel {
                        public class Opening : Tea.TeaModel {
                            public var height: String?

                            public var start: String?

                            public var width: String?

                            public var openUrl: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                if self.openUrl != nil {
                                    map["openUrl"] = self.openUrl!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                                if dict.keys.contains("openUrl") {
                                    self.openUrl = dict["openUrl"] as! String
                                }
                            }
                        }
                        public var opening: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OpeningList.Opening]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.opening != nil {
                                var tmp : [Any] = []
                                for k in self.opening! {
                                    tmp.append(k.toMap())
                                }
                                map["Opening"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Opening") {
                                var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OpeningList.Opening] = []
                                for v in dict["Opening"] as! [Any] {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OpeningList.Opening()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.opening = tmp
                            }
                        }
                    }
                    public class OutSubtitleList : Tea.TeaModel {
                        public class OutSubtitle : Tea.TeaModel {
                            public class OutSubtitleFile : Tea.TeaModel {
                                public var bucket: String?

                                public var location: String?

                                public var object: String?

                                public var roleArn: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.bucket != nil {
                                        map["Bucket"] = self.bucket!
                                    }
                                    if self.location != nil {
                                        map["Location"] = self.location!
                                    }
                                    if self.object != nil {
                                        map["Object"] = self.object!
                                    }
                                    if self.roleArn != nil {
                                        map["RoleArn"] = self.roleArn!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Bucket") {
                                        self.bucket = dict["Bucket"] as! String
                                    }
                                    if dict.keys.contains("Location") {
                                        self.location = dict["Location"] as! String
                                    }
                                    if dict.keys.contains("Object") {
                                        self.object = dict["Object"] as! String
                                    }
                                    if dict.keys.contains("RoleArn") {
                                        self.roleArn = dict["RoleArn"] as! String
                                    }
                                }
                            }
                            public var map: String?

                            public var message: String?

                            public var outSubtitleFile: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OutSubtitleList.OutSubtitle.OutSubtitleFile?

                            public var success: Bool?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.outSubtitleFile?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.map != nil {
                                    map["Map"] = self.map!
                                }
                                if self.message != nil {
                                    map["Message"] = self.message!
                                }
                                if self.outSubtitleFile != nil {
                                    map["OutSubtitleFile"] = self.outSubtitleFile?.toMap()
                                }
                                if self.success != nil {
                                    map["Success"] = self.success!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Map") {
                                    self.map = dict["Map"] as! String
                                }
                                if dict.keys.contains("Message") {
                                    self.message = dict["Message"] as! String
                                }
                                if dict.keys.contains("OutSubtitleFile") {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OutSubtitleList.OutSubtitle.OutSubtitleFile()
                                    model.fromMap(dict["OutSubtitleFile"] as! [String: Any])
                                    self.outSubtitleFile = model
                                }
                                if dict.keys.contains("Success") {
                                    self.success = dict["Success"] as! Bool
                                }
                            }
                        }
                        public var outSubtitle: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OutSubtitleList.OutSubtitle]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.outSubtitle != nil {
                                var tmp : [Any] = []
                                for k in self.outSubtitle! {
                                    tmp.append(k.toMap())
                                }
                                map["OutSubtitle"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("OutSubtitle") {
                                var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OutSubtitleList.OutSubtitle] = []
                                for v in dict["OutSubtitle"] as! [Any] {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OutSubtitleList.OutSubtitle()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.outSubtitle = tmp
                            }
                        }
                    }
                    public class OutputFile : Tea.TeaModel {
                        public var bucket: String?

                        public var location: String?

                        public var object: String?

                        public var roleArn: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bucket != nil {
                                map["Bucket"] = self.bucket!
                            }
                            if self.location != nil {
                                map["Location"] = self.location!
                            }
                            if self.object != nil {
                                map["Object"] = self.object!
                            }
                            if self.roleArn != nil {
                                map["RoleArn"] = self.roleArn!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bucket") {
                                self.bucket = dict["Bucket"] as! String
                            }
                            if dict.keys.contains("Location") {
                                self.location = dict["Location"] as! String
                            }
                            if dict.keys.contains("Object") {
                                self.object = dict["Object"] as! String
                            }
                            if dict.keys.contains("RoleArn") {
                                self.roleArn = dict["RoleArn"] as! String
                            }
                        }
                    }
                    public class Properties : Tea.TeaModel {
                        public class Format : Tea.TeaModel {
                            public var bitrate: String?

                            public var duration: String?

                            public var formatLongName: String?

                            public var formatName: String?

                            public var numPrograms: String?

                            public var numStreams: String?

                            public var size: String?

                            public var startTime: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bitrate != nil {
                                    map["Bitrate"] = self.bitrate!
                                }
                                if self.duration != nil {
                                    map["Duration"] = self.duration!
                                }
                                if self.formatLongName != nil {
                                    map["FormatLongName"] = self.formatLongName!
                                }
                                if self.formatName != nil {
                                    map["FormatName"] = self.formatName!
                                }
                                if self.numPrograms != nil {
                                    map["NumPrograms"] = self.numPrograms!
                                }
                                if self.numStreams != nil {
                                    map["NumStreams"] = self.numStreams!
                                }
                                if self.size != nil {
                                    map["Size"] = self.size!
                                }
                                if self.startTime != nil {
                                    map["StartTime"] = self.startTime!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Bitrate") {
                                    self.bitrate = dict["Bitrate"] as! String
                                }
                                if dict.keys.contains("Duration") {
                                    self.duration = dict["Duration"] as! String
                                }
                                if dict.keys.contains("FormatLongName") {
                                    self.formatLongName = dict["FormatLongName"] as! String
                                }
                                if dict.keys.contains("FormatName") {
                                    self.formatName = dict["FormatName"] as! String
                                }
                                if dict.keys.contains("NumPrograms") {
                                    self.numPrograms = dict["NumPrograms"] as! String
                                }
                                if dict.keys.contains("NumStreams") {
                                    self.numStreams = dict["NumStreams"] as! String
                                }
                                if dict.keys.contains("Size") {
                                    self.size = dict["Size"] as! String
                                }
                                if dict.keys.contains("StartTime") {
                                    self.startTime = dict["StartTime"] as! String
                                }
                            }
                        }
                        public class Streams : Tea.TeaModel {
                            public class AudioStreamList : Tea.TeaModel {
                                public class AudioStream : Tea.TeaModel {
                                    public var bitrate: String?

                                    public var channelLayout: String?

                                    public var channels: String?

                                    public var codecLongName: String?

                                    public var codecName: String?

                                    public var codecTag: String?

                                    public var codecTagString: String?

                                    public var codecTimeBase: String?

                                    public var duration: String?

                                    public var index: String?

                                    public var lang: String?

                                    public var numFrames: String?

                                    public var sampleFmt: String?

                                    public var samplerate: String?

                                    public var startTime: String?

                                    public var timebase: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.bitrate != nil {
                                            map["Bitrate"] = self.bitrate!
                                        }
                                        if self.channelLayout != nil {
                                            map["ChannelLayout"] = self.channelLayout!
                                        }
                                        if self.channels != nil {
                                            map["Channels"] = self.channels!
                                        }
                                        if self.codecLongName != nil {
                                            map["CodecLongName"] = self.codecLongName!
                                        }
                                        if self.codecName != nil {
                                            map["CodecName"] = self.codecName!
                                        }
                                        if self.codecTag != nil {
                                            map["CodecTag"] = self.codecTag!
                                        }
                                        if self.codecTagString != nil {
                                            map["CodecTagString"] = self.codecTagString!
                                        }
                                        if self.codecTimeBase != nil {
                                            map["CodecTimeBase"] = self.codecTimeBase!
                                        }
                                        if self.duration != nil {
                                            map["Duration"] = self.duration!
                                        }
                                        if self.index != nil {
                                            map["Index"] = self.index!
                                        }
                                        if self.lang != nil {
                                            map["Lang"] = self.lang!
                                        }
                                        if self.numFrames != nil {
                                            map["NumFrames"] = self.numFrames!
                                        }
                                        if self.sampleFmt != nil {
                                            map["SampleFmt"] = self.sampleFmt!
                                        }
                                        if self.samplerate != nil {
                                            map["Samplerate"] = self.samplerate!
                                        }
                                        if self.startTime != nil {
                                            map["StartTime"] = self.startTime!
                                        }
                                        if self.timebase != nil {
                                            map["Timebase"] = self.timebase!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Bitrate") {
                                            self.bitrate = dict["Bitrate"] as! String
                                        }
                                        if dict.keys.contains("ChannelLayout") {
                                            self.channelLayout = dict["ChannelLayout"] as! String
                                        }
                                        if dict.keys.contains("Channels") {
                                            self.channels = dict["Channels"] as! String
                                        }
                                        if dict.keys.contains("CodecLongName") {
                                            self.codecLongName = dict["CodecLongName"] as! String
                                        }
                                        if dict.keys.contains("CodecName") {
                                            self.codecName = dict["CodecName"] as! String
                                        }
                                        if dict.keys.contains("CodecTag") {
                                            self.codecTag = dict["CodecTag"] as! String
                                        }
                                        if dict.keys.contains("CodecTagString") {
                                            self.codecTagString = dict["CodecTagString"] as! String
                                        }
                                        if dict.keys.contains("CodecTimeBase") {
                                            self.codecTimeBase = dict["CodecTimeBase"] as! String
                                        }
                                        if dict.keys.contains("Duration") {
                                            self.duration = dict["Duration"] as! String
                                        }
                                        if dict.keys.contains("Index") {
                                            self.index = dict["Index"] as! String
                                        }
                                        if dict.keys.contains("Lang") {
                                            self.lang = dict["Lang"] as! String
                                        }
                                        if dict.keys.contains("NumFrames") {
                                            self.numFrames = dict["NumFrames"] as! String
                                        }
                                        if dict.keys.contains("SampleFmt") {
                                            self.sampleFmt = dict["SampleFmt"] as! String
                                        }
                                        if dict.keys.contains("Samplerate") {
                                            self.samplerate = dict["Samplerate"] as! String
                                        }
                                        if dict.keys.contains("StartTime") {
                                            self.startTime = dict["StartTime"] as! String
                                        }
                                        if dict.keys.contains("Timebase") {
                                            self.timebase = dict["Timebase"] as! String
                                        }
                                    }
                                }
                                public var audioStream: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.AudioStreamList.AudioStream]?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.audioStream != nil {
                                        var tmp : [Any] = []
                                        for k in self.audioStream! {
                                            tmp.append(k.toMap())
                                        }
                                        map["AudioStream"] = tmp
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("AudioStream") {
                                        var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.AudioStreamList.AudioStream] = []
                                        for v in dict["AudioStream"] as! [Any] {
                                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.AudioStreamList.AudioStream()
                                            if v != nil {
                                                model.fromMap(v as! [String: Any])
                                            }
                                            tmp.append(model)
                                        }
                                        self.audioStream = tmp
                                    }
                                }
                            }
                            public class SubtitleStreamList : Tea.TeaModel {
                                public class SubtitleStream : Tea.TeaModel {
                                    public var index: String?

                                    public var lang: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.index != nil {
                                            map["Index"] = self.index!
                                        }
                                        if self.lang != nil {
                                            map["Lang"] = self.lang!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Index") {
                                            self.index = dict["Index"] as! String
                                        }
                                        if dict.keys.contains("Lang") {
                                            self.lang = dict["Lang"] as! String
                                        }
                                    }
                                }
                                public var subtitleStream: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.SubtitleStreamList.SubtitleStream]?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.subtitleStream != nil {
                                        var tmp : [Any] = []
                                        for k in self.subtitleStream! {
                                            tmp.append(k.toMap())
                                        }
                                        map["SubtitleStream"] = tmp
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("SubtitleStream") {
                                        var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.SubtitleStreamList.SubtitleStream] = []
                                        for v in dict["SubtitleStream"] as! [Any] {
                                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.SubtitleStreamList.SubtitleStream()
                                            if v != nil {
                                                model.fromMap(v as! [String: Any])
                                            }
                                            tmp.append(model)
                                        }
                                        self.subtitleStream = tmp
                                    }
                                }
                            }
                            public class VideoStreamList : Tea.TeaModel {
                                public class VideoStream : Tea.TeaModel {
                                    public class NetworkCost : Tea.TeaModel {
                                        public var avgBitrate: String?

                                        public var costBandwidth: String?

                                        public var preloadTime: String?

                                        public override init() {
                                            super.init()
                                        }

                                        public init(_ dict: [String: Any]) {
                                            super.init()
                                            self.fromMap(dict)
                                        }

                                        public override func validate() throws -> Void {
                                        }

                                        public override func toMap() -> [String : Any] {
                                            var map = super.toMap()
                                            if self.avgBitrate != nil {
                                                map["AvgBitrate"] = self.avgBitrate!
                                            }
                                            if self.costBandwidth != nil {
                                                map["CostBandwidth"] = self.costBandwidth!
                                            }
                                            if self.preloadTime != nil {
                                                map["PreloadTime"] = self.preloadTime!
                                            }
                                            return map
                                        }

                                        public override func fromMap(_ dict: [String: Any]) -> Void {
                                            if dict.keys.contains("AvgBitrate") {
                                                self.avgBitrate = dict["AvgBitrate"] as! String
                                            }
                                            if dict.keys.contains("CostBandwidth") {
                                                self.costBandwidth = dict["CostBandwidth"] as! String
                                            }
                                            if dict.keys.contains("PreloadTime") {
                                                self.preloadTime = dict["PreloadTime"] as! String
                                            }
                                        }
                                    }
                                    public var avgFPS: String?

                                    public var bitrate: String?

                                    public var codecLongName: String?

                                    public var codecName: String?

                                    public var codecTag: String?

                                    public var codecTagString: String?

                                    public var codecTimeBase: String?

                                    public var dar: String?

                                    public var duration: String?

                                    public var fps: String?

                                    public var hasBFrames: String?

                                    public var height: String?

                                    public var index: String?

                                    public var lang: String?

                                    public var level: String?

                                    public var networkCost: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.VideoStreamList.VideoStream.NetworkCost?

                                    public var numFrames: String?

                                    public var pixFmt: String?

                                    public var profile: String?

                                    public var sar: String?

                                    public var startTime: String?

                                    public var timebase: String?

                                    public var width: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                        try self.networkCost?.validate()
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.avgFPS != nil {
                                            map["AvgFPS"] = self.avgFPS!
                                        }
                                        if self.bitrate != nil {
                                            map["Bitrate"] = self.bitrate!
                                        }
                                        if self.codecLongName != nil {
                                            map["CodecLongName"] = self.codecLongName!
                                        }
                                        if self.codecName != nil {
                                            map["CodecName"] = self.codecName!
                                        }
                                        if self.codecTag != nil {
                                            map["CodecTag"] = self.codecTag!
                                        }
                                        if self.codecTagString != nil {
                                            map["CodecTagString"] = self.codecTagString!
                                        }
                                        if self.codecTimeBase != nil {
                                            map["CodecTimeBase"] = self.codecTimeBase!
                                        }
                                        if self.dar != nil {
                                            map["Dar"] = self.dar!
                                        }
                                        if self.duration != nil {
                                            map["Duration"] = self.duration!
                                        }
                                        if self.fps != nil {
                                            map["Fps"] = self.fps!
                                        }
                                        if self.hasBFrames != nil {
                                            map["HasBFrames"] = self.hasBFrames!
                                        }
                                        if self.height != nil {
                                            map["Height"] = self.height!
                                        }
                                        if self.index != nil {
                                            map["Index"] = self.index!
                                        }
                                        if self.lang != nil {
                                            map["Lang"] = self.lang!
                                        }
                                        if self.level != nil {
                                            map["Level"] = self.level!
                                        }
                                        if self.networkCost != nil {
                                            map["NetworkCost"] = self.networkCost?.toMap()
                                        }
                                        if self.numFrames != nil {
                                            map["NumFrames"] = self.numFrames!
                                        }
                                        if self.pixFmt != nil {
                                            map["PixFmt"] = self.pixFmt!
                                        }
                                        if self.profile != nil {
                                            map["Profile"] = self.profile!
                                        }
                                        if self.sar != nil {
                                            map["Sar"] = self.sar!
                                        }
                                        if self.startTime != nil {
                                            map["StartTime"] = self.startTime!
                                        }
                                        if self.timebase != nil {
                                            map["Timebase"] = self.timebase!
                                        }
                                        if self.width != nil {
                                            map["Width"] = self.width!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("AvgFPS") {
                                            self.avgFPS = dict["AvgFPS"] as! String
                                        }
                                        if dict.keys.contains("Bitrate") {
                                            self.bitrate = dict["Bitrate"] as! String
                                        }
                                        if dict.keys.contains("CodecLongName") {
                                            self.codecLongName = dict["CodecLongName"] as! String
                                        }
                                        if dict.keys.contains("CodecName") {
                                            self.codecName = dict["CodecName"] as! String
                                        }
                                        if dict.keys.contains("CodecTag") {
                                            self.codecTag = dict["CodecTag"] as! String
                                        }
                                        if dict.keys.contains("CodecTagString") {
                                            self.codecTagString = dict["CodecTagString"] as! String
                                        }
                                        if dict.keys.contains("CodecTimeBase") {
                                            self.codecTimeBase = dict["CodecTimeBase"] as! String
                                        }
                                        if dict.keys.contains("Dar") {
                                            self.dar = dict["Dar"] as! String
                                        }
                                        if dict.keys.contains("Duration") {
                                            self.duration = dict["Duration"] as! String
                                        }
                                        if dict.keys.contains("Fps") {
                                            self.fps = dict["Fps"] as! String
                                        }
                                        if dict.keys.contains("HasBFrames") {
                                            self.hasBFrames = dict["HasBFrames"] as! String
                                        }
                                        if dict.keys.contains("Height") {
                                            self.height = dict["Height"] as! String
                                        }
                                        if dict.keys.contains("Index") {
                                            self.index = dict["Index"] as! String
                                        }
                                        if dict.keys.contains("Lang") {
                                            self.lang = dict["Lang"] as! String
                                        }
                                        if dict.keys.contains("Level") {
                                            self.level = dict["Level"] as! String
                                        }
                                        if dict.keys.contains("NetworkCost") {
                                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.VideoStreamList.VideoStream.NetworkCost()
                                            model.fromMap(dict["NetworkCost"] as! [String: Any])
                                            self.networkCost = model
                                        }
                                        if dict.keys.contains("NumFrames") {
                                            self.numFrames = dict["NumFrames"] as! String
                                        }
                                        if dict.keys.contains("PixFmt") {
                                            self.pixFmt = dict["PixFmt"] as! String
                                        }
                                        if dict.keys.contains("Profile") {
                                            self.profile = dict["Profile"] as! String
                                        }
                                        if dict.keys.contains("Sar") {
                                            self.sar = dict["Sar"] as! String
                                        }
                                        if dict.keys.contains("StartTime") {
                                            self.startTime = dict["StartTime"] as! String
                                        }
                                        if dict.keys.contains("Timebase") {
                                            self.timebase = dict["Timebase"] as! String
                                        }
                                        if dict.keys.contains("Width") {
                                            self.width = dict["Width"] as! String
                                        }
                                    }
                                }
                                public var videoStream: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.VideoStreamList.VideoStream]?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.videoStream != nil {
                                        var tmp : [Any] = []
                                        for k in self.videoStream! {
                                            tmp.append(k.toMap())
                                        }
                                        map["VideoStream"] = tmp
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("VideoStream") {
                                        var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.VideoStreamList.VideoStream] = []
                                        for v in dict["VideoStream"] as! [Any] {
                                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.VideoStreamList.VideoStream()
                                            if v != nil {
                                                model.fromMap(v as! [String: Any])
                                            }
                                            tmp.append(model)
                                        }
                                        self.videoStream = tmp
                                    }
                                }
                            }
                            public var audioStreamList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.AudioStreamList?

                            public var subtitleStreamList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.SubtitleStreamList?

                            public var videoStreamList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.VideoStreamList?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.audioStreamList?.validate()
                                try self.subtitleStreamList?.validate()
                                try self.videoStreamList?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.audioStreamList != nil {
                                    map["AudioStreamList"] = self.audioStreamList?.toMap()
                                }
                                if self.subtitleStreamList != nil {
                                    map["SubtitleStreamList"] = self.subtitleStreamList?.toMap()
                                }
                                if self.videoStreamList != nil {
                                    map["VideoStreamList"] = self.videoStreamList?.toMap()
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AudioStreamList") {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.AudioStreamList()
                                    model.fromMap(dict["AudioStreamList"] as! [String: Any])
                                    self.audioStreamList = model
                                }
                                if dict.keys.contains("SubtitleStreamList") {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.SubtitleStreamList()
                                    model.fromMap(dict["SubtitleStreamList"] as! [String: Any])
                                    self.subtitleStreamList = model
                                }
                                if dict.keys.contains("VideoStreamList") {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams.VideoStreamList()
                                    model.fromMap(dict["VideoStreamList"] as! [String: Any])
                                    self.videoStreamList = model
                                }
                            }
                        }
                        public var bitrate: String?

                        public var duration: String?

                        public var fileFormat: String?

                        public var fileSize: String?

                        public var format: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Format?

                        public var fps: String?

                        public var height: String?

                        public var streams: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.format?.validate()
                            try self.streams?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.fileFormat != nil {
                                map["FileFormat"] = self.fileFormat!
                            }
                            if self.fileSize != nil {
                                map["FileSize"] = self.fileSize!
                            }
                            if self.format != nil {
                                map["Format"] = self.format?.toMap()
                            }
                            if self.fps != nil {
                                map["Fps"] = self.fps!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.streams != nil {
                                map["Streams"] = self.streams?.toMap()
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("FileFormat") {
                                self.fileFormat = dict["FileFormat"] as! String
                            }
                            if dict.keys.contains("FileSize") {
                                self.fileSize = dict["FileSize"] as! String
                            }
                            if dict.keys.contains("Format") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Format()
                                model.fromMap(dict["Format"] as! [String: Any])
                                self.format = model
                            }
                            if dict.keys.contains("Fps") {
                                self.fps = dict["Fps"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("Streams") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties.Streams()
                                model.fromMap(dict["Streams"] as! [String: Any])
                                self.streams = model
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public class SubtitleConfig : Tea.TeaModel {
                        public class ExtSubtitleList : Tea.TeaModel {
                            public class ExtSubtitle : Tea.TeaModel {
                                public class Input : Tea.TeaModel {
                                    public var bucket: String?

                                    public var location: String?

                                    public var object: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.bucket != nil {
                                            map["Bucket"] = self.bucket!
                                        }
                                        if self.location != nil {
                                            map["Location"] = self.location!
                                        }
                                        if self.object != nil {
                                            map["Object"] = self.object!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Bucket") {
                                            self.bucket = dict["Bucket"] as! String
                                        }
                                        if dict.keys.contains("Location") {
                                            self.location = dict["Location"] as! String
                                        }
                                        if dict.keys.contains("Object") {
                                            self.object = dict["Object"] as! String
                                        }
                                    }
                                }
                                public var charEnc: String?

                                public var fontName: String?

                                public var input: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle.Input?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                    try self.input?.validate()
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.charEnc != nil {
                                        map["CharEnc"] = self.charEnc!
                                    }
                                    if self.fontName != nil {
                                        map["FontName"] = self.fontName!
                                    }
                                    if self.input != nil {
                                        map["Input"] = self.input?.toMap()
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("CharEnc") {
                                        self.charEnc = dict["CharEnc"] as! String
                                    }
                                    if dict.keys.contains("FontName") {
                                        self.fontName = dict["FontName"] as! String
                                    }
                                    if dict.keys.contains("Input") {
                                        var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle.Input()
                                        model.fromMap(dict["Input"] as! [String: Any])
                                        self.input = model
                                    }
                                }
                            }
                            public var extSubtitle: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.extSubtitle != nil {
                                    var tmp : [Any] = []
                                    for k in self.extSubtitle! {
                                        tmp.append(k.toMap())
                                    }
                                    map["ExtSubtitle"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("ExtSubtitle") {
                                    var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle] = []
                                    for v in dict["ExtSubtitle"] as! [Any] {
                                        var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.ExtSubtitleList.ExtSubtitle()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.extSubtitle = tmp
                                }
                            }
                        }
                        public class SubtitleList : Tea.TeaModel {
                            public class Subtitle : Tea.TeaModel {
                                public var map: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.map != nil {
                                        map["Map"] = self.map!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Map") {
                                        self.map = dict["Map"] as! String
                                    }
                                }
                            }
                            public var subtitle: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.SubtitleList.Subtitle]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.subtitle != nil {
                                    var tmp : [Any] = []
                                    for k in self.subtitle! {
                                        tmp.append(k.toMap())
                                    }
                                    map["Subtitle"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Subtitle") {
                                    var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.SubtitleList.Subtitle] = []
                                    for v in dict["Subtitle"] as! [Any] {
                                        var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.SubtitleList.Subtitle()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.subtitle = tmp
                                }
                            }
                        }
                        public var extSubtitleList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.ExtSubtitleList?

                        public var subtitleList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.SubtitleList?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.extSubtitleList?.validate()
                            try self.subtitleList?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.extSubtitleList != nil {
                                map["ExtSubtitleList"] = self.extSubtitleList?.toMap()
                            }
                            if self.subtitleList != nil {
                                map["SubtitleList"] = self.subtitleList?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ExtSubtitleList") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.ExtSubtitleList()
                                model.fromMap(dict["ExtSubtitleList"] as! [String: Any])
                                self.extSubtitleList = model
                            }
                            if dict.keys.contains("SubtitleList") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig.SubtitleList()
                                model.fromMap(dict["SubtitleList"] as! [String: Any])
                                self.subtitleList = model
                            }
                        }
                    }
                    public class SuperReso : Tea.TeaModel {
                        public var isHalfSample: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.isHalfSample != nil {
                                map["IsHalfSample"] = self.isHalfSample!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("IsHalfSample") {
                                self.isHalfSample = dict["IsHalfSample"] as! String
                            }
                        }
                    }
                    public class TailSlateList : Tea.TeaModel {
                        public class TailSlate : Tea.TeaModel {
                            public var bgColor: String?

                            public var blendDuration: String?

                            public var height: String?

                            public var isMergeAudio: Bool?

                            public var start: String?

                            public var tailUrl: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.bgColor != nil {
                                    map["BgColor"] = self.bgColor!
                                }
                                if self.blendDuration != nil {
                                    map["BlendDuration"] = self.blendDuration!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.isMergeAudio != nil {
                                    map["IsMergeAudio"] = self.isMergeAudio!
                                }
                                if self.start != nil {
                                    map["Start"] = self.start!
                                }
                                if self.tailUrl != nil {
                                    map["TailUrl"] = self.tailUrl!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("BgColor") {
                                    self.bgColor = dict["BgColor"] as! String
                                }
                                if dict.keys.contains("BlendDuration") {
                                    self.blendDuration = dict["BlendDuration"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("IsMergeAudio") {
                                    self.isMergeAudio = dict["IsMergeAudio"] as! Bool
                                }
                                if dict.keys.contains("Start") {
                                    self.start = dict["Start"] as! String
                                }
                                if dict.keys.contains("TailUrl") {
                                    self.tailUrl = dict["TailUrl"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var tailSlate: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.TailSlateList.TailSlate]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.tailSlate != nil {
                                var tmp : [Any] = []
                                for k in self.tailSlate! {
                                    tmp.append(k.toMap())
                                }
                                map["TailSlate"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("TailSlate") {
                                var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.TailSlateList.TailSlate] = []
                                for v in dict["TailSlate"] as! [Any] {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.TailSlateList.TailSlate()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.tailSlate = tmp
                            }
                        }
                    }
                    public class TransConfig : Tea.TeaModel {
                        public var adjDarMethod: String?

                        public var isCheckAudioBitrate: String?

                        public var isCheckAudioBitrateFail: String?

                        public var isCheckReso: String?

                        public var isCheckResoFail: String?

                        public var isCheckVideoBitrate: String?

                        public var isCheckVideoBitrateFail: String?

                        public var transMode: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.adjDarMethod != nil {
                                map["AdjDarMethod"] = self.adjDarMethod!
                            }
                            if self.isCheckAudioBitrate != nil {
                                map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                            }
                            if self.isCheckAudioBitrateFail != nil {
                                map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                            }
                            if self.isCheckReso != nil {
                                map["IsCheckReso"] = self.isCheckReso!
                            }
                            if self.isCheckResoFail != nil {
                                map["IsCheckResoFail"] = self.isCheckResoFail!
                            }
                            if self.isCheckVideoBitrate != nil {
                                map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                            }
                            if self.isCheckVideoBitrateFail != nil {
                                map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                            }
                            if self.transMode != nil {
                                map["TransMode"] = self.transMode!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AdjDarMethod") {
                                self.adjDarMethod = dict["AdjDarMethod"] as! String
                            }
                            if dict.keys.contains("IsCheckAudioBitrate") {
                                self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                            }
                            if dict.keys.contains("IsCheckAudioBitrateFail") {
                                self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                            }
                            if dict.keys.contains("IsCheckReso") {
                                self.isCheckReso = dict["IsCheckReso"] as! String
                            }
                            if dict.keys.contains("IsCheckResoFail") {
                                self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                            }
                            if dict.keys.contains("IsCheckVideoBitrate") {
                                self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                            }
                            if dict.keys.contains("IsCheckVideoBitrateFail") {
                                self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                            }
                            if dict.keys.contains("TransMode") {
                                self.transMode = dict["TransMode"] as! String
                            }
                        }
                    }
                    public class Video : Tea.TeaModel {
                        public class BitrateBnd : Tea.TeaModel {
                            public var max: String?

                            public var min: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.max != nil {
                                    map["Max"] = self.max!
                                }
                                if self.min != nil {
                                    map["Min"] = self.min!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Max") {
                                    self.max = dict["Max"] as! String
                                }
                                if dict.keys.contains("Min") {
                                    self.min = dict["Min"] as! String
                                }
                            }
                        }
                        public var bitrate: String?

                        public var bitrateBnd: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Video.BitrateBnd?

                        public var bufsize: String?

                        public var codec: String?

                        public var crf: String?

                        public var crop: String?

                        public var degrain: String?

                        public var fps: String?

                        public var gop: String?

                        public var height: String?

                        public var maxFps: String?

                        public var maxrate: String?

                        public var pad: String?

                        public var pixFmt: String?

                        public var preset: String?

                        public var profile: String?

                        public var qscale: String?

                        public var resoPriority: String?

                        public var scanMode: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.bitrateBnd?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.bitrateBnd != nil {
                                map["BitrateBnd"] = self.bitrateBnd?.toMap()
                            }
                            if self.bufsize != nil {
                                map["Bufsize"] = self.bufsize!
                            }
                            if self.codec != nil {
                                map["Codec"] = self.codec!
                            }
                            if self.crf != nil {
                                map["Crf"] = self.crf!
                            }
                            if self.crop != nil {
                                map["Crop"] = self.crop!
                            }
                            if self.degrain != nil {
                                map["Degrain"] = self.degrain!
                            }
                            if self.fps != nil {
                                map["Fps"] = self.fps!
                            }
                            if self.gop != nil {
                                map["Gop"] = self.gop!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.maxFps != nil {
                                map["MaxFps"] = self.maxFps!
                            }
                            if self.maxrate != nil {
                                map["Maxrate"] = self.maxrate!
                            }
                            if self.pad != nil {
                                map["Pad"] = self.pad!
                            }
                            if self.pixFmt != nil {
                                map["PixFmt"] = self.pixFmt!
                            }
                            if self.preset != nil {
                                map["Preset"] = self.preset!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.qscale != nil {
                                map["Qscale"] = self.qscale!
                            }
                            if self.resoPriority != nil {
                                map["ResoPriority"] = self.resoPriority!
                            }
                            if self.scanMode != nil {
                                map["ScanMode"] = self.scanMode!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("BitrateBnd") {
                                var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Video.BitrateBnd()
                                model.fromMap(dict["BitrateBnd"] as! [String: Any])
                                self.bitrateBnd = model
                            }
                            if dict.keys.contains("Bufsize") {
                                self.bufsize = dict["Bufsize"] as! String
                            }
                            if dict.keys.contains("Codec") {
                                self.codec = dict["Codec"] as! String
                            }
                            if dict.keys.contains("Crf") {
                                self.crf = dict["Crf"] as! String
                            }
                            if dict.keys.contains("Crop") {
                                self.crop = dict["Crop"] as! String
                            }
                            if dict.keys.contains("Degrain") {
                                self.degrain = dict["Degrain"] as! String
                            }
                            if dict.keys.contains("Fps") {
                                self.fps = dict["Fps"] as! String
                            }
                            if dict.keys.contains("Gop") {
                                self.gop = dict["Gop"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("MaxFps") {
                                self.maxFps = dict["MaxFps"] as! String
                            }
                            if dict.keys.contains("Maxrate") {
                                self.maxrate = dict["Maxrate"] as! String
                            }
                            if dict.keys.contains("Pad") {
                                self.pad = dict["Pad"] as! String
                            }
                            if dict.keys.contains("PixFmt") {
                                self.pixFmt = dict["PixFmt"] as! String
                            }
                            if dict.keys.contains("Preset") {
                                self.preset = dict["Preset"] as! String
                            }
                            if dict.keys.contains("Profile") {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Qscale") {
                                self.qscale = dict["Qscale"] as! String
                            }
                            if dict.keys.contains("ResoPriority") {
                                self.resoPriority = dict["ResoPriority"] as! String
                            }
                            if dict.keys.contains("ScanMode") {
                                self.scanMode = dict["ScanMode"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public class WaterMarkList : Tea.TeaModel {
                        public class WaterMark : Tea.TeaModel {
                            public class InputFile : Tea.TeaModel {
                                public var bucket: String?

                                public var location: String?

                                public var object: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.bucket != nil {
                                        map["Bucket"] = self.bucket!
                                    }
                                    if self.location != nil {
                                        map["Location"] = self.location!
                                    }
                                    if self.object != nil {
                                        map["Object"] = self.object!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Bucket") {
                                        self.bucket = dict["Bucket"] as! String
                                    }
                                    if dict.keys.contains("Location") {
                                        self.location = dict["Location"] as! String
                                    }
                                    if dict.keys.contains("Object") {
                                        self.object = dict["Object"] as! String
                                    }
                                }
                            }
                            public var dx: String?

                            public var dy: String?

                            public var height: String?

                            public var inputFile: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.WaterMarkList.WaterMark.InputFile?

                            public var referPos: String?

                            public var type: String?

                            public var waterMarkTemplateId: String?

                            public var width: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.inputFile?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.dx != nil {
                                    map["Dx"] = self.dx!
                                }
                                if self.dy != nil {
                                    map["Dy"] = self.dy!
                                }
                                if self.height != nil {
                                    map["Height"] = self.height!
                                }
                                if self.inputFile != nil {
                                    map["InputFile"] = self.inputFile?.toMap()
                                }
                                if self.referPos != nil {
                                    map["ReferPos"] = self.referPos!
                                }
                                if self.type != nil {
                                    map["Type"] = self.type!
                                }
                                if self.waterMarkTemplateId != nil {
                                    map["WaterMarkTemplateId"] = self.waterMarkTemplateId!
                                }
                                if self.width != nil {
                                    map["Width"] = self.width!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Dx") {
                                    self.dx = dict["Dx"] as! String
                                }
                                if dict.keys.contains("Dy") {
                                    self.dy = dict["Dy"] as! String
                                }
                                if dict.keys.contains("Height") {
                                    self.height = dict["Height"] as! String
                                }
                                if dict.keys.contains("InputFile") {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.WaterMarkList.WaterMark.InputFile()
                                    model.fromMap(dict["InputFile"] as! [String: Any])
                                    self.inputFile = model
                                }
                                if dict.keys.contains("ReferPos") {
                                    self.referPos = dict["ReferPos"] as! String
                                }
                                if dict.keys.contains("Type") {
                                    self.type = dict["Type"] as! String
                                }
                                if dict.keys.contains("WaterMarkTemplateId") {
                                    self.waterMarkTemplateId = dict["WaterMarkTemplateId"] as! String
                                }
                                if dict.keys.contains("Width") {
                                    self.width = dict["Width"] as! String
                                }
                            }
                        }
                        public var waterMark: [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.WaterMarkList.WaterMark]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.waterMark != nil {
                                var tmp : [Any] = []
                                for k in self.waterMark! {
                                    tmp.append(k.toMap())
                                }
                                map["WaterMark"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("WaterMark") {
                                var tmp : [SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.WaterMarkList.WaterMark] = []
                                for v in dict["WaterMark"] as! [Any] {
                                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.WaterMarkList.WaterMark()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.waterMark = tmp
                            }
                        }
                    }
                    public var amixList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.AmixList?

                    public var audio: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Audio?

                    public var audioStreamMap: String?

                    public var clip: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Clip?

                    public var container: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Container?

                    public var deWatermark: String?

                    public var digiWaterMark: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.DigiWaterMark?

                    public var encryption: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Encryption?

                    public var m3U8NonStandardSupport: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.M3U8NonStandardSupport?

                    public var mergeConfigUrl: String?

                    public var mergeList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MergeList?

                    public var muxConfig: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MuxConfig?

                    public var openingList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OpeningList?

                    public var outSubtitleList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OutSubtitleList?

                    public var outputFile: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OutputFile?

                    public var priority: String?

                    public var properties: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties?

                    public var rotate: String?

                    public var subtitleConfig: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig?

                    public var superReso: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SuperReso?

                    public var tailSlateList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.TailSlateList?

                    public var templateId: String?

                    public var transConfig: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.TransConfig?

                    public var userData: String?

                    public var video: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Video?

                    public var videoStreamMap: String?

                    public var waterMarkConfigUrl: String?

                    public var waterMarkList: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.WaterMarkList?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.amixList?.validate()
                        try self.audio?.validate()
                        try self.clip?.validate()
                        try self.container?.validate()
                        try self.digiWaterMark?.validate()
                        try self.encryption?.validate()
                        try self.m3U8NonStandardSupport?.validate()
                        try self.mergeList?.validate()
                        try self.muxConfig?.validate()
                        try self.openingList?.validate()
                        try self.outSubtitleList?.validate()
                        try self.outputFile?.validate()
                        try self.properties?.validate()
                        try self.subtitleConfig?.validate()
                        try self.superReso?.validate()
                        try self.tailSlateList?.validate()
                        try self.transConfig?.validate()
                        try self.video?.validate()
                        try self.waterMarkList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.amixList != nil {
                            map["AmixList"] = self.amixList?.toMap()
                        }
                        if self.audio != nil {
                            map["Audio"] = self.audio?.toMap()
                        }
                        if self.audioStreamMap != nil {
                            map["AudioStreamMap"] = self.audioStreamMap!
                        }
                        if self.clip != nil {
                            map["Clip"] = self.clip?.toMap()
                        }
                        if self.container != nil {
                            map["Container"] = self.container?.toMap()
                        }
                        if self.deWatermark != nil {
                            map["DeWatermark"] = self.deWatermark!
                        }
                        if self.digiWaterMark != nil {
                            map["DigiWaterMark"] = self.digiWaterMark?.toMap()
                        }
                        if self.encryption != nil {
                            map["Encryption"] = self.encryption?.toMap()
                        }
                        if self.m3U8NonStandardSupport != nil {
                            map["M3U8NonStandardSupport"] = self.m3U8NonStandardSupport?.toMap()
                        }
                        if self.mergeConfigUrl != nil {
                            map["MergeConfigUrl"] = self.mergeConfigUrl!
                        }
                        if self.mergeList != nil {
                            map["MergeList"] = self.mergeList?.toMap()
                        }
                        if self.muxConfig != nil {
                            map["MuxConfig"] = self.muxConfig?.toMap()
                        }
                        if self.openingList != nil {
                            map["OpeningList"] = self.openingList?.toMap()
                        }
                        if self.outSubtitleList != nil {
                            map["OutSubtitleList"] = self.outSubtitleList?.toMap()
                        }
                        if self.outputFile != nil {
                            map["OutputFile"] = self.outputFile?.toMap()
                        }
                        if self.priority != nil {
                            map["Priority"] = self.priority!
                        }
                        if self.properties != nil {
                            map["Properties"] = self.properties?.toMap()
                        }
                        if self.rotate != nil {
                            map["Rotate"] = self.rotate!
                        }
                        if self.subtitleConfig != nil {
                            map["SubtitleConfig"] = self.subtitleConfig?.toMap()
                        }
                        if self.superReso != nil {
                            map["SuperReso"] = self.superReso?.toMap()
                        }
                        if self.tailSlateList != nil {
                            map["TailSlateList"] = self.tailSlateList?.toMap()
                        }
                        if self.templateId != nil {
                            map["TemplateId"] = self.templateId!
                        }
                        if self.transConfig != nil {
                            map["TransConfig"] = self.transConfig?.toMap()
                        }
                        if self.userData != nil {
                            map["UserData"] = self.userData!
                        }
                        if self.video != nil {
                            map["Video"] = self.video?.toMap()
                        }
                        if self.videoStreamMap != nil {
                            map["VideoStreamMap"] = self.videoStreamMap!
                        }
                        if self.waterMarkConfigUrl != nil {
                            map["WaterMarkConfigUrl"] = self.waterMarkConfigUrl!
                        }
                        if self.waterMarkList != nil {
                            map["WaterMarkList"] = self.waterMarkList?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AmixList") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.AmixList()
                            model.fromMap(dict["AmixList"] as! [String: Any])
                            self.amixList = model
                        }
                        if dict.keys.contains("Audio") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Audio()
                            model.fromMap(dict["Audio"] as! [String: Any])
                            self.audio = model
                        }
                        if dict.keys.contains("AudioStreamMap") {
                            self.audioStreamMap = dict["AudioStreamMap"] as! String
                        }
                        if dict.keys.contains("Clip") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Clip()
                            model.fromMap(dict["Clip"] as! [String: Any])
                            self.clip = model
                        }
                        if dict.keys.contains("Container") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Container()
                            model.fromMap(dict["Container"] as! [String: Any])
                            self.container = model
                        }
                        if dict.keys.contains("DeWatermark") {
                            self.deWatermark = dict["DeWatermark"] as! String
                        }
                        if dict.keys.contains("DigiWaterMark") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.DigiWaterMark()
                            model.fromMap(dict["DigiWaterMark"] as! [String: Any])
                            self.digiWaterMark = model
                        }
                        if dict.keys.contains("Encryption") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Encryption()
                            model.fromMap(dict["Encryption"] as! [String: Any])
                            self.encryption = model
                        }
                        if dict.keys.contains("M3U8NonStandardSupport") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.M3U8NonStandardSupport()
                            model.fromMap(dict["M3U8NonStandardSupport"] as! [String: Any])
                            self.m3U8NonStandardSupport = model
                        }
                        if dict.keys.contains("MergeConfigUrl") {
                            self.mergeConfigUrl = dict["MergeConfigUrl"] as! String
                        }
                        if dict.keys.contains("MergeList") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MergeList()
                            model.fromMap(dict["MergeList"] as! [String: Any])
                            self.mergeList = model
                        }
                        if dict.keys.contains("MuxConfig") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.MuxConfig()
                            model.fromMap(dict["MuxConfig"] as! [String: Any])
                            self.muxConfig = model
                        }
                        if dict.keys.contains("OpeningList") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OpeningList()
                            model.fromMap(dict["OpeningList"] as! [String: Any])
                            self.openingList = model
                        }
                        if dict.keys.contains("OutSubtitleList") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OutSubtitleList()
                            model.fromMap(dict["OutSubtitleList"] as! [String: Any])
                            self.outSubtitleList = model
                        }
                        if dict.keys.contains("OutputFile") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.OutputFile()
                            model.fromMap(dict["OutputFile"] as! [String: Any])
                            self.outputFile = model
                        }
                        if dict.keys.contains("Priority") {
                            self.priority = dict["Priority"] as! String
                        }
                        if dict.keys.contains("Properties") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Properties()
                            model.fromMap(dict["Properties"] as! [String: Any])
                            self.properties = model
                        }
                        if dict.keys.contains("Rotate") {
                            self.rotate = dict["Rotate"] as! String
                        }
                        if dict.keys.contains("SubtitleConfig") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SubtitleConfig()
                            model.fromMap(dict["SubtitleConfig"] as! [String: Any])
                            self.subtitleConfig = model
                        }
                        if dict.keys.contains("SuperReso") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.SuperReso()
                            model.fromMap(dict["SuperReso"] as! [String: Any])
                            self.superReso = model
                        }
                        if dict.keys.contains("TailSlateList") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.TailSlateList()
                            model.fromMap(dict["TailSlateList"] as! [String: Any])
                            self.tailSlateList = model
                        }
                        if dict.keys.contains("TemplateId") {
                            self.templateId = dict["TemplateId"] as! String
                        }
                        if dict.keys.contains("TransConfig") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.TransConfig()
                            model.fromMap(dict["TransConfig"] as! [String: Any])
                            self.transConfig = model
                        }
                        if dict.keys.contains("UserData") {
                            self.userData = dict["UserData"] as! String
                        }
                        if dict.keys.contains("Video") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.Video()
                            model.fromMap(dict["Video"] as! [String: Any])
                            self.video = model
                        }
                        if dict.keys.contains("VideoStreamMap") {
                            self.videoStreamMap = dict["VideoStreamMap"] as! String
                        }
                        if dict.keys.contains("WaterMarkConfigUrl") {
                            self.waterMarkConfigUrl = dict["WaterMarkConfigUrl"] as! String
                        }
                        if dict.keys.contains("WaterMarkList") {
                            var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output.WaterMarkList()
                            model.fromMap(dict["WaterMarkList"] as! [String: Any])
                            self.waterMarkList = model
                        }
                    }
                }
                public var code: String?

                public var creationTime: String?

                public var finishTime: String?

                public var input: SubmitJobsResponseBody.JobResultList.JobResult.Job.Input?

                public var jobId: String?

                public var MNSMessageResult: SubmitJobsResponseBody.JobResultList.JobResult.Job.MNSMessageResult?

                public var message: String?

                public var output: SubmitJobsResponseBody.JobResultList.JobResult.Job.Output?

                public var percent: Int64?

                public var pipelineId: String?

                public var state: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.input?.validate()
                    try self.MNSMessageResult?.validate()
                    try self.output?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.creationTime != nil {
                        map["CreationTime"] = self.creationTime!
                    }
                    if self.finishTime != nil {
                        map["FinishTime"] = self.finishTime!
                    }
                    if self.input != nil {
                        map["Input"] = self.input?.toMap()
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.MNSMessageResult != nil {
                        map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.output != nil {
                        map["Output"] = self.output?.toMap()
                    }
                    if self.percent != nil {
                        map["Percent"] = self.percent!
                    }
                    if self.pipelineId != nil {
                        map["PipelineId"] = self.pipelineId!
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! String
                    }
                    if dict.keys.contains("CreationTime") {
                        self.creationTime = dict["CreationTime"] as! String
                    }
                    if dict.keys.contains("FinishTime") {
                        self.finishTime = dict["FinishTime"] as! String
                    }
                    if dict.keys.contains("Input") {
                        var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Input()
                        model.fromMap(dict["Input"] as! [String: Any])
                        self.input = model
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("MNSMessageResult") {
                        var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.MNSMessageResult()
                        model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                        self.MNSMessageResult = model
                    }
                    if dict.keys.contains("Message") {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("Output") {
                        var model = SubmitJobsResponseBody.JobResultList.JobResult.Job.Output()
                        model.fromMap(dict["Output"] as! [String: Any])
                        self.output = model
                    }
                    if dict.keys.contains("Percent") {
                        self.percent = dict["Percent"] as! Int64
                    }
                    if dict.keys.contains("PipelineId") {
                        self.pipelineId = dict["PipelineId"] as! String
                    }
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! String
                    }
                }
            }
            public var code: String?

            public var job: SubmitJobsResponseBody.JobResultList.JobResult.Job?

            public var message: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.job?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.job != nil {
                    map["Job"] = self.job?.toMap()
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Job") {
                    var model = SubmitJobsResponseBody.JobResultList.JobResult.Job()
                    model.fromMap(dict["Job"] as! [String: Any])
                    self.job = model
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Success") {
                    self.success = dict["Success"] as! Bool
                }
            }
        }
        public var jobResult: [SubmitJobsResponseBody.JobResultList.JobResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobResult != nil {
                var tmp : [Any] = []
                for k in self.jobResult! {
                    tmp.append(k.toMap())
                }
                map["JobResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobResult") {
                var tmp : [SubmitJobsResponseBody.JobResultList.JobResult] = []
                for v in dict["JobResult"] as! [Any] {
                    var model = SubmitJobsResponseBody.JobResultList.JobResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.jobResult = tmp
            }
        }
    }
    public var jobResultList: SubmitJobsResponseBody.JobResultList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobResultList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobResultList != nil {
            map["JobResultList"] = self.jobResultList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobResultList") {
            var model = SubmitJobsResponseBody.JobResultList()
            model.fromMap(dict["JobResultList"] as! [String: Any])
            self.jobResultList = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitMediaCensorJobRequest : Tea.TeaModel {
    public var barrages: String?

    public var coverImages: String?

    public var description_: String?

    public var externalUrl: String?

    public var input: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var title: String?

    public var userData: String?

    public var videoCensorConfig: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.barrages != nil {
            map["Barrages"] = self.barrages!
        }
        if self.coverImages != nil {
            map["CoverImages"] = self.coverImages!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.externalUrl != nil {
            map["ExternalUrl"] = self.externalUrl!
        }
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.videoCensorConfig != nil {
            map["VideoCensorConfig"] = self.videoCensorConfig!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Barrages") {
            self.barrages = dict["Barrages"] as! String
        }
        if dict.keys.contains("CoverImages") {
            self.coverImages = dict["CoverImages"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ExternalUrl") {
            self.externalUrl = dict["ExternalUrl"] as! String
        }
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VideoCensorConfig") {
            self.videoCensorConfig = dict["VideoCensorConfig"] as! String
        }
    }
}

public class SubmitMediaCensorJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitMediaCensorJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitMediaCensorJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitMediaCensorJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitMediaInfoJobRequest : Tea.TeaModel {
    public var async: Bool?

    public var input: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.async != nil {
            map["Async"] = self.async!
        }
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Async") {
            self.async = dict["Async"] as! Bool
        }
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitMediaInfoJobResponseBody : Tea.TeaModel {
    public class MediaInfoJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var bucket: String?

            public var location: String?

            public var object: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("Object") {
                    self.object = dict["Object"] as! String
                }
            }
        }
        public class MNSMessageResult : Tea.TeaModel {
            public var errorCode: String?

            public var errorMessage: String?

            public var messageId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.messageId != nil {
                    map["MessageId"] = self.messageId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("MessageId") {
                    self.messageId = dict["MessageId"] as! String
                }
            }
        }
        public class Properties : Tea.TeaModel {
            public class Format : Tea.TeaModel {
                public var bitrate: String?

                public var duration: String?

                public var formatLongName: String?

                public var formatName: String?

                public var numPrograms: String?

                public var numStreams: String?

                public var size: String?

                public var startTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bitrate != nil {
                        map["Bitrate"] = self.bitrate!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.formatLongName != nil {
                        map["FormatLongName"] = self.formatLongName!
                    }
                    if self.formatName != nil {
                        map["FormatName"] = self.formatName!
                    }
                    if self.numPrograms != nil {
                        map["NumPrograms"] = self.numPrograms!
                    }
                    if self.numStreams != nil {
                        map["NumStreams"] = self.numStreams!
                    }
                    if self.size != nil {
                        map["Size"] = self.size!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bitrate") {
                        self.bitrate = dict["Bitrate"] as! String
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                    if dict.keys.contains("FormatLongName") {
                        self.formatLongName = dict["FormatLongName"] as! String
                    }
                    if dict.keys.contains("FormatName") {
                        self.formatName = dict["FormatName"] as! String
                    }
                    if dict.keys.contains("NumPrograms") {
                        self.numPrograms = dict["NumPrograms"] as! String
                    }
                    if dict.keys.contains("NumStreams") {
                        self.numStreams = dict["NumStreams"] as! String
                    }
                    if dict.keys.contains("Size") {
                        self.size = dict["Size"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                }
            }
            public class Streams : Tea.TeaModel {
                public class AudioStreamList : Tea.TeaModel {
                    public class AudioStream : Tea.TeaModel {
                        public var bitrate: String?

                        public var channelLayout: String?

                        public var channels: String?

                        public var codecLongName: String?

                        public var codecName: String?

                        public var codecTag: String?

                        public var codecTagString: String?

                        public var codecTimeBase: String?

                        public var duration: String?

                        public var index: String?

                        public var lang: String?

                        public var numFrames: String?

                        public var sampleFmt: String?

                        public var samplerate: String?

                        public var startTime: String?

                        public var timebase: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.channelLayout != nil {
                                map["ChannelLayout"] = self.channelLayout!
                            }
                            if self.channels != nil {
                                map["Channels"] = self.channels!
                            }
                            if self.codecLongName != nil {
                                map["CodecLongName"] = self.codecLongName!
                            }
                            if self.codecName != nil {
                                map["CodecName"] = self.codecName!
                            }
                            if self.codecTag != nil {
                                map["CodecTag"] = self.codecTag!
                            }
                            if self.codecTagString != nil {
                                map["CodecTagString"] = self.codecTagString!
                            }
                            if self.codecTimeBase != nil {
                                map["CodecTimeBase"] = self.codecTimeBase!
                            }
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.index != nil {
                                map["Index"] = self.index!
                            }
                            if self.lang != nil {
                                map["Lang"] = self.lang!
                            }
                            if self.numFrames != nil {
                                map["NumFrames"] = self.numFrames!
                            }
                            if self.sampleFmt != nil {
                                map["SampleFmt"] = self.sampleFmt!
                            }
                            if self.samplerate != nil {
                                map["Samplerate"] = self.samplerate!
                            }
                            if self.startTime != nil {
                                map["StartTime"] = self.startTime!
                            }
                            if self.timebase != nil {
                                map["Timebase"] = self.timebase!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("ChannelLayout") {
                                self.channelLayout = dict["ChannelLayout"] as! String
                            }
                            if dict.keys.contains("Channels") {
                                self.channels = dict["Channels"] as! String
                            }
                            if dict.keys.contains("CodecLongName") {
                                self.codecLongName = dict["CodecLongName"] as! String
                            }
                            if dict.keys.contains("CodecName") {
                                self.codecName = dict["CodecName"] as! String
                            }
                            if dict.keys.contains("CodecTag") {
                                self.codecTag = dict["CodecTag"] as! String
                            }
                            if dict.keys.contains("CodecTagString") {
                                self.codecTagString = dict["CodecTagString"] as! String
                            }
                            if dict.keys.contains("CodecTimeBase") {
                                self.codecTimeBase = dict["CodecTimeBase"] as! String
                            }
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("Index") {
                                self.index = dict["Index"] as! String
                            }
                            if dict.keys.contains("Lang") {
                                self.lang = dict["Lang"] as! String
                            }
                            if dict.keys.contains("NumFrames") {
                                self.numFrames = dict["NumFrames"] as! String
                            }
                            if dict.keys.contains("SampleFmt") {
                                self.sampleFmt = dict["SampleFmt"] as! String
                            }
                            if dict.keys.contains("Samplerate") {
                                self.samplerate = dict["Samplerate"] as! String
                            }
                            if dict.keys.contains("StartTime") {
                                self.startTime = dict["StartTime"] as! String
                            }
                            if dict.keys.contains("Timebase") {
                                self.timebase = dict["Timebase"] as! String
                            }
                        }
                    }
                    public var audioStream: [SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.AudioStreamList.AudioStream]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.audioStream != nil {
                            var tmp : [Any] = []
                            for k in self.audioStream! {
                                tmp.append(k.toMap())
                            }
                            map["AudioStream"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AudioStream") {
                            var tmp : [SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.AudioStreamList.AudioStream] = []
                            for v in dict["AudioStream"] as! [Any] {
                                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.AudioStreamList.AudioStream()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.audioStream = tmp
                        }
                    }
                }
                public class SubtitleStreamList : Tea.TeaModel {
                    public class SubtitleStream : Tea.TeaModel {
                        public var codecLongName: String?

                        public var codecName: String?

                        public var codecTag: String?

                        public var codecTagString: String?

                        public var codecTimeBase: String?

                        public var duration: String?

                        public var index: String?

                        public var lang: String?

                        public var startTime: String?

                        public var timebase: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.codecLongName != nil {
                                map["CodecLongName"] = self.codecLongName!
                            }
                            if self.codecName != nil {
                                map["CodecName"] = self.codecName!
                            }
                            if self.codecTag != nil {
                                map["CodecTag"] = self.codecTag!
                            }
                            if self.codecTagString != nil {
                                map["CodecTagString"] = self.codecTagString!
                            }
                            if self.codecTimeBase != nil {
                                map["CodecTimeBase"] = self.codecTimeBase!
                            }
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.index != nil {
                                map["Index"] = self.index!
                            }
                            if self.lang != nil {
                                map["Lang"] = self.lang!
                            }
                            if self.startTime != nil {
                                map["StartTime"] = self.startTime!
                            }
                            if self.timebase != nil {
                                map["Timebase"] = self.timebase!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CodecLongName") {
                                self.codecLongName = dict["CodecLongName"] as! String
                            }
                            if dict.keys.contains("CodecName") {
                                self.codecName = dict["CodecName"] as! String
                            }
                            if dict.keys.contains("CodecTag") {
                                self.codecTag = dict["CodecTag"] as! String
                            }
                            if dict.keys.contains("CodecTagString") {
                                self.codecTagString = dict["CodecTagString"] as! String
                            }
                            if dict.keys.contains("CodecTimeBase") {
                                self.codecTimeBase = dict["CodecTimeBase"] as! String
                            }
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("Index") {
                                self.index = dict["Index"] as! String
                            }
                            if dict.keys.contains("Lang") {
                                self.lang = dict["Lang"] as! String
                            }
                            if dict.keys.contains("StartTime") {
                                self.startTime = dict["StartTime"] as! String
                            }
                            if dict.keys.contains("Timebase") {
                                self.timebase = dict["Timebase"] as! String
                            }
                        }
                    }
                    public var subtitleStream: [SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.SubtitleStreamList.SubtitleStream]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.subtitleStream != nil {
                            var tmp : [Any] = []
                            for k in self.subtitleStream! {
                                tmp.append(k.toMap())
                            }
                            map["SubtitleStream"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("SubtitleStream") {
                            var tmp : [SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.SubtitleStreamList.SubtitleStream] = []
                            for v in dict["SubtitleStream"] as! [Any] {
                                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.SubtitleStreamList.SubtitleStream()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.subtitleStream = tmp
                        }
                    }
                }
                public class VideoStreamList : Tea.TeaModel {
                    public class VideoStream : Tea.TeaModel {
                        public class NetworkCost : Tea.TeaModel {
                            public var avgBitrate: String?

                            public var costBandwidth: String?

                            public var preloadTime: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.avgBitrate != nil {
                                    map["AvgBitrate"] = self.avgBitrate!
                                }
                                if self.costBandwidth != nil {
                                    map["CostBandwidth"] = self.costBandwidth!
                                }
                                if self.preloadTime != nil {
                                    map["PreloadTime"] = self.preloadTime!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AvgBitrate") {
                                    self.avgBitrate = dict["AvgBitrate"] as! String
                                }
                                if dict.keys.contains("CostBandwidth") {
                                    self.costBandwidth = dict["CostBandwidth"] as! String
                                }
                                if dict.keys.contains("PreloadTime") {
                                    self.preloadTime = dict["PreloadTime"] as! String
                                }
                            }
                        }
                        public var avgFPS: String?

                        public var bitrate: String?

                        public var codecLongName: String?

                        public var codecName: String?

                        public var codecTag: String?

                        public var codecTagString: String?

                        public var codecTimeBase: String?

                        public var colorPrimaries: String?

                        public var colorRange: String?

                        public var colorTransfer: String?

                        public var dar: String?

                        public var duration: String?

                        public var fps: String?

                        public var hasBFrames: String?

                        public var height: String?

                        public var index: String?

                        public var lang: String?

                        public var level: String?

                        public var networkCost: SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream.NetworkCost?

                        public var numFrames: String?

                        public var pixFmt: String?

                        public var profile: String?

                        public var rotate: String?

                        public var sar: String?

                        public var startTime: String?

                        public var timebase: String?

                        public var width: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.networkCost?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.avgFPS != nil {
                                map["AvgFPS"] = self.avgFPS!
                            }
                            if self.bitrate != nil {
                                map["Bitrate"] = self.bitrate!
                            }
                            if self.codecLongName != nil {
                                map["CodecLongName"] = self.codecLongName!
                            }
                            if self.codecName != nil {
                                map["CodecName"] = self.codecName!
                            }
                            if self.codecTag != nil {
                                map["CodecTag"] = self.codecTag!
                            }
                            if self.codecTagString != nil {
                                map["CodecTagString"] = self.codecTagString!
                            }
                            if self.codecTimeBase != nil {
                                map["CodecTimeBase"] = self.codecTimeBase!
                            }
                            if self.colorPrimaries != nil {
                                map["ColorPrimaries"] = self.colorPrimaries!
                            }
                            if self.colorRange != nil {
                                map["ColorRange"] = self.colorRange!
                            }
                            if self.colorTransfer != nil {
                                map["ColorTransfer"] = self.colorTransfer!
                            }
                            if self.dar != nil {
                                map["Dar"] = self.dar!
                            }
                            if self.duration != nil {
                                map["Duration"] = self.duration!
                            }
                            if self.fps != nil {
                                map["Fps"] = self.fps!
                            }
                            if self.hasBFrames != nil {
                                map["HasBFrames"] = self.hasBFrames!
                            }
                            if self.height != nil {
                                map["Height"] = self.height!
                            }
                            if self.index != nil {
                                map["Index"] = self.index!
                            }
                            if self.lang != nil {
                                map["Lang"] = self.lang!
                            }
                            if self.level != nil {
                                map["Level"] = self.level!
                            }
                            if self.networkCost != nil {
                                map["NetworkCost"] = self.networkCost?.toMap()
                            }
                            if self.numFrames != nil {
                                map["NumFrames"] = self.numFrames!
                            }
                            if self.pixFmt != nil {
                                map["PixFmt"] = self.pixFmt!
                            }
                            if self.profile != nil {
                                map["Profile"] = self.profile!
                            }
                            if self.rotate != nil {
                                map["Rotate"] = self.rotate!
                            }
                            if self.sar != nil {
                                map["Sar"] = self.sar!
                            }
                            if self.startTime != nil {
                                map["StartTime"] = self.startTime!
                            }
                            if self.timebase != nil {
                                map["Timebase"] = self.timebase!
                            }
                            if self.width != nil {
                                map["Width"] = self.width!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AvgFPS") {
                                self.avgFPS = dict["AvgFPS"] as! String
                            }
                            if dict.keys.contains("Bitrate") {
                                self.bitrate = dict["Bitrate"] as! String
                            }
                            if dict.keys.contains("CodecLongName") {
                                self.codecLongName = dict["CodecLongName"] as! String
                            }
                            if dict.keys.contains("CodecName") {
                                self.codecName = dict["CodecName"] as! String
                            }
                            if dict.keys.contains("CodecTag") {
                                self.codecTag = dict["CodecTag"] as! String
                            }
                            if dict.keys.contains("CodecTagString") {
                                self.codecTagString = dict["CodecTagString"] as! String
                            }
                            if dict.keys.contains("CodecTimeBase") {
                                self.codecTimeBase = dict["CodecTimeBase"] as! String
                            }
                            if dict.keys.contains("ColorPrimaries") {
                                self.colorPrimaries = dict["ColorPrimaries"] as! String
                            }
                            if dict.keys.contains("ColorRange") {
                                self.colorRange = dict["ColorRange"] as! String
                            }
                            if dict.keys.contains("ColorTransfer") {
                                self.colorTransfer = dict["ColorTransfer"] as! String
                            }
                            if dict.keys.contains("Dar") {
                                self.dar = dict["Dar"] as! String
                            }
                            if dict.keys.contains("Duration") {
                                self.duration = dict["Duration"] as! String
                            }
                            if dict.keys.contains("Fps") {
                                self.fps = dict["Fps"] as! String
                            }
                            if dict.keys.contains("HasBFrames") {
                                self.hasBFrames = dict["HasBFrames"] as! String
                            }
                            if dict.keys.contains("Height") {
                                self.height = dict["Height"] as! String
                            }
                            if dict.keys.contains("Index") {
                                self.index = dict["Index"] as! String
                            }
                            if dict.keys.contains("Lang") {
                                self.lang = dict["Lang"] as! String
                            }
                            if dict.keys.contains("Level") {
                                self.level = dict["Level"] as! String
                            }
                            if dict.keys.contains("NetworkCost") {
                                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream.NetworkCost()
                                model.fromMap(dict["NetworkCost"] as! [String: Any])
                                self.networkCost = model
                            }
                            if dict.keys.contains("NumFrames") {
                                self.numFrames = dict["NumFrames"] as! String
                            }
                            if dict.keys.contains("PixFmt") {
                                self.pixFmt = dict["PixFmt"] as! String
                            }
                            if dict.keys.contains("Profile") {
                                self.profile = dict["Profile"] as! String
                            }
                            if dict.keys.contains("Rotate") {
                                self.rotate = dict["Rotate"] as! String
                            }
                            if dict.keys.contains("Sar") {
                                self.sar = dict["Sar"] as! String
                            }
                            if dict.keys.contains("StartTime") {
                                self.startTime = dict["StartTime"] as! String
                            }
                            if dict.keys.contains("Timebase") {
                                self.timebase = dict["Timebase"] as! String
                            }
                            if dict.keys.contains("Width") {
                                self.width = dict["Width"] as! String
                            }
                        }
                    }
                    public var videoStream: [SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.videoStream != nil {
                            var tmp : [Any] = []
                            for k in self.videoStream! {
                                tmp.append(k.toMap())
                            }
                            map["VideoStream"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("VideoStream") {
                            var tmp : [SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream] = []
                            for v in dict["VideoStream"] as! [Any] {
                                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.VideoStreamList.VideoStream()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.videoStream = tmp
                        }
                    }
                }
                public var audioStreamList: SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.AudioStreamList?

                public var subtitleStreamList: SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.SubtitleStreamList?

                public var videoStreamList: SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.VideoStreamList?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.audioStreamList?.validate()
                    try self.subtitleStreamList?.validate()
                    try self.videoStreamList?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.audioStreamList != nil {
                        map["AudioStreamList"] = self.audioStreamList?.toMap()
                    }
                    if self.subtitleStreamList != nil {
                        map["SubtitleStreamList"] = self.subtitleStreamList?.toMap()
                    }
                    if self.videoStreamList != nil {
                        map["VideoStreamList"] = self.videoStreamList?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AudioStreamList") {
                        var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.AudioStreamList()
                        model.fromMap(dict["AudioStreamList"] as! [String: Any])
                        self.audioStreamList = model
                    }
                    if dict.keys.contains("SubtitleStreamList") {
                        var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.SubtitleStreamList()
                        model.fromMap(dict["SubtitleStreamList"] as! [String: Any])
                        self.subtitleStreamList = model
                    }
                    if dict.keys.contains("VideoStreamList") {
                        var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams.VideoStreamList()
                        model.fromMap(dict["VideoStreamList"] as! [String: Any])
                        self.videoStreamList = model
                    }
                }
            }
            public var bitrate: String?

            public var duration: String?

            public var fileFormat: String?

            public var fileSize: String?

            public var format: SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Format?

            public var fps: String?

            public var height: String?

            public var streams: SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.format?.validate()
                try self.streams?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.fileFormat != nil {
                    map["FileFormat"] = self.fileFormat!
                }
                if self.fileSize != nil {
                    map["FileSize"] = self.fileSize!
                }
                if self.format != nil {
                    map["Format"] = self.format?.toMap()
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.streams != nil {
                    map["Streams"] = self.streams?.toMap()
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("FileFormat") {
                    self.fileFormat = dict["FileFormat"] as! String
                }
                if dict.keys.contains("FileSize") {
                    self.fileSize = dict["FileSize"] as! String
                }
                if dict.keys.contains("Format") {
                    var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Format()
                    model.fromMap(dict["Format"] as! [String: Any])
                    self.format = model
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Streams") {
                    var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties.Streams()
                    model.fromMap(dict["Streams"] as! [String: Any])
                    self.streams = model
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var async: Bool?

        public var code: String?

        public var creationTime: String?

        public var input: SubmitMediaInfoJobResponseBody.MediaInfoJob.Input?

        public var jobId: String?

        public var MNSMessageResult: SubmitMediaInfoJobResponseBody.MediaInfoJob.MNSMessageResult?

        public var message: String?

        public var pipelineId: String?

        public var properties: SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties?

        public var state: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.MNSMessageResult?.validate()
            try self.properties?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.async != nil {
                map["Async"] = self.async!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.MNSMessageResult != nil {
                map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.properties != nil {
                map["Properties"] = self.properties?.toMap()
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Async") {
                self.async = dict["Async"] as! Bool
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Input") {
                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MNSMessageResult") {
                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.MNSMessageResult()
                model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                self.MNSMessageResult = model
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("Properties") {
                var model = SubmitMediaInfoJobResponseBody.MediaInfoJob.Properties()
                model.fromMap(dict["Properties"] as! [String: Any])
                self.properties = model
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var mediaInfoJob: SubmitMediaInfoJobResponseBody.MediaInfoJob?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaInfoJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaInfoJob != nil {
            map["MediaInfoJob"] = self.mediaInfoJob?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaInfoJob") {
            var model = SubmitMediaInfoJobResponseBody.MediaInfoJob()
            model.fromMap(dict["MediaInfoJob"] as! [String: Any])
            self.mediaInfoJob = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitMediaInfoJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitMediaInfoJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitMediaInfoJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSmarttagJobRequest : Tea.TeaModel {
    public var content: String?

    public var contentAddr: String?

    public var contentType: String?

    public var input: String?

    public var notifyUrl: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var params: String?

    public var pipelineId: String?

    public var priority: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateId: String?

    public var title: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.contentAddr != nil {
            map["ContentAddr"] = self.contentAddr!
        }
        if self.contentType != nil {
            map["ContentType"] = self.contentType!
        }
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.notifyUrl != nil {
            map["NotifyUrl"] = self.notifyUrl!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("ContentAddr") {
            self.contentAddr = dict["ContentAddr"] as! String
        }
        if dict.keys.contains("ContentType") {
            self.contentType = dict["ContentType"] as! String
        }
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("NotifyUrl") {
            self.notifyUrl = dict["NotifyUrl"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSmarttagJobResponseBody : Tea.TeaModel {
    public var jobId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitSmarttagJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSmarttagJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitSmarttagJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitSnapshotJobRequest : Tea.TeaModel {
    public var input: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotConfig: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotConfig != nil {
            map["SnapshotConfig"] = self.snapshotConfig!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SnapshotConfig") {
            self.snapshotConfig = dict["SnapshotConfig"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitSnapshotJobResponseBody : Tea.TeaModel {
    public class SnapshotJob : Tea.TeaModel {
        public class Input : Tea.TeaModel {
            public var bucket: String?

            public var location: String?

            public var object: String?

            public var roleArn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucket != nil {
                    map["Bucket"] = self.bucket!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.object != nil {
                    map["Object"] = self.object!
                }
                if self.roleArn != nil {
                    map["RoleArn"] = self.roleArn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bucket") {
                    self.bucket = dict["Bucket"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("Object") {
                    self.object = dict["Object"] as! String
                }
                if dict.keys.contains("RoleArn") {
                    self.roleArn = dict["RoleArn"] as! String
                }
            }
        }
        public class MNSMessageResult : Tea.TeaModel {
            public var errorCode: String?

            public var errorMessage: String?

            public var messageId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.messageId != nil {
                    map["MessageId"] = self.messageId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("MessageId") {
                    self.messageId = dict["MessageId"] as! String
                }
            }
        }
        public class SnapshotConfig : Tea.TeaModel {
            public class OutputFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public var roleArn: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    if self.roleArn != nil {
                        map["RoleArn"] = self.roleArn!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                    if dict.keys.contains("RoleArn") {
                        self.roleArn = dict["RoleArn"] as! String
                    }
                }
            }
            public class TileOut : Tea.TeaModel {
                public var cellHeight: String?

                public var cellSelStep: String?

                public var cellWidth: String?

                public var color: String?

                public var columns: String?

                public var isKeepCellPic: String?

                public var lines: String?

                public var margin: String?

                public var padding: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cellHeight != nil {
                        map["CellHeight"] = self.cellHeight!
                    }
                    if self.cellSelStep != nil {
                        map["CellSelStep"] = self.cellSelStep!
                    }
                    if self.cellWidth != nil {
                        map["CellWidth"] = self.cellWidth!
                    }
                    if self.color != nil {
                        map["Color"] = self.color!
                    }
                    if self.columns != nil {
                        map["Columns"] = self.columns!
                    }
                    if self.isKeepCellPic != nil {
                        map["IsKeepCellPic"] = self.isKeepCellPic!
                    }
                    if self.lines != nil {
                        map["Lines"] = self.lines!
                    }
                    if self.margin != nil {
                        map["Margin"] = self.margin!
                    }
                    if self.padding != nil {
                        map["Padding"] = self.padding!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CellHeight") {
                        self.cellHeight = dict["CellHeight"] as! String
                    }
                    if dict.keys.contains("CellSelStep") {
                        self.cellSelStep = dict["CellSelStep"] as! String
                    }
                    if dict.keys.contains("CellWidth") {
                        self.cellWidth = dict["CellWidth"] as! String
                    }
                    if dict.keys.contains("Color") {
                        self.color = dict["Color"] as! String
                    }
                    if dict.keys.contains("Columns") {
                        self.columns = dict["Columns"] as! String
                    }
                    if dict.keys.contains("IsKeepCellPic") {
                        self.isKeepCellPic = dict["IsKeepCellPic"] as! String
                    }
                    if dict.keys.contains("Lines") {
                        self.lines = dict["Lines"] as! String
                    }
                    if dict.keys.contains("Margin") {
                        self.margin = dict["Margin"] as! String
                    }
                    if dict.keys.contains("Padding") {
                        self.padding = dict["Padding"] as! String
                    }
                }
            }
            public class TileOutputFile : Tea.TeaModel {
                public var bucket: String?

                public var location: String?

                public var object: String?

                public var roleArn: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bucket != nil {
                        map["Bucket"] = self.bucket!
                    }
                    if self.location != nil {
                        map["Location"] = self.location!
                    }
                    if self.object != nil {
                        map["Object"] = self.object!
                    }
                    if self.roleArn != nil {
                        map["RoleArn"] = self.roleArn!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bucket") {
                        self.bucket = dict["Bucket"] as! String
                    }
                    if dict.keys.contains("Location") {
                        self.location = dict["Location"] as! String
                    }
                    if dict.keys.contains("Object") {
                        self.object = dict["Object"] as! String
                    }
                    if dict.keys.contains("RoleArn") {
                        self.roleArn = dict["RoleArn"] as! String
                    }
                }
            }
            public class TimeArray : Tea.TeaModel {
                public var timePointList: [Int64]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.timePointList != nil {
                        map["TimePointList"] = self.timePointList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TimePointList") {
                        self.timePointList = dict["TimePointList"] as! [Int64]
                    }
                }
            }
            public var frameType: String?

            public var height: String?

            public var interval: String?

            public var num: String?

            public var outputFile: SubmitSnapshotJobResponseBody.SnapshotJob.SnapshotConfig.OutputFile?

            public var tileOut: SubmitSnapshotJobResponseBody.SnapshotJob.SnapshotConfig.TileOut?

            public var tileOutputFile: SubmitSnapshotJobResponseBody.SnapshotJob.SnapshotConfig.TileOutputFile?

            public var time: String?

            public var timeArray: SubmitSnapshotJobResponseBody.SnapshotJob.SnapshotConfig.TimeArray?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.outputFile?.validate()
                try self.tileOut?.validate()
                try self.tileOutputFile?.validate()
                try self.timeArray?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.frameType != nil {
                    map["FrameType"] = self.frameType!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.interval != nil {
                    map["Interval"] = self.interval!
                }
                if self.num != nil {
                    map["Num"] = self.num!
                }
                if self.outputFile != nil {
                    map["OutputFile"] = self.outputFile?.toMap()
                }
                if self.tileOut != nil {
                    map["TileOut"] = self.tileOut?.toMap()
                }
                if self.tileOutputFile != nil {
                    map["TileOutputFile"] = self.tileOutputFile?.toMap()
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                if self.timeArray != nil {
                    map["TimeArray"] = self.timeArray?.toMap()
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FrameType") {
                    self.frameType = dict["FrameType"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Interval") {
                    self.interval = dict["Interval"] as! String
                }
                if dict.keys.contains("Num") {
                    self.num = dict["Num"] as! String
                }
                if dict.keys.contains("OutputFile") {
                    var model = SubmitSnapshotJobResponseBody.SnapshotJob.SnapshotConfig.OutputFile()
                    model.fromMap(dict["OutputFile"] as! [String: Any])
                    self.outputFile = model
                }
                if dict.keys.contains("TileOut") {
                    var model = SubmitSnapshotJobResponseBody.SnapshotJob.SnapshotConfig.TileOut()
                    model.fromMap(dict["TileOut"] as! [String: Any])
                    self.tileOut = model
                }
                if dict.keys.contains("TileOutputFile") {
                    var model = SubmitSnapshotJobResponseBody.SnapshotJob.SnapshotConfig.TileOutputFile()
                    model.fromMap(dict["TileOutputFile"] as! [String: Any])
                    self.tileOutputFile = model
                }
                if dict.keys.contains("Time") {
                    self.time = dict["Time"] as! String
                }
                if dict.keys.contains("TimeArray") {
                    var model = SubmitSnapshotJobResponseBody.SnapshotJob.SnapshotConfig.TimeArray()
                    model.fromMap(dict["TimeArray"] as! [String: Any])
                    self.timeArray = model
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var code: String?

        public var count: String?

        public var creationTime: String?

        public var id: String?

        public var input: SubmitSnapshotJobResponseBody.SnapshotJob.Input?

        public var MNSMessageResult: SubmitSnapshotJobResponseBody.SnapshotJob.MNSMessageResult?

        public var message: String?

        public var pipelineId: String?

        public var snapshotConfig: SubmitSnapshotJobResponseBody.SnapshotJob.SnapshotConfig?

        public var state: String?

        public var tileCount: String?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.input?.validate()
            try self.MNSMessageResult?.validate()
            try self.snapshotConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.input != nil {
                map["Input"] = self.input?.toMap()
            }
            if self.MNSMessageResult != nil {
                map["MNSMessageResult"] = self.MNSMessageResult?.toMap()
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.snapshotConfig != nil {
                map["SnapshotConfig"] = self.snapshotConfig?.toMap()
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.tileCount != nil {
                map["TileCount"] = self.tileCount!
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Input") {
                var model = SubmitSnapshotJobResponseBody.SnapshotJob.Input()
                model.fromMap(dict["Input"] as! [String: Any])
                self.input = model
            }
            if dict.keys.contains("MNSMessageResult") {
                var model = SubmitSnapshotJobResponseBody.SnapshotJob.MNSMessageResult()
                model.fromMap(dict["MNSMessageResult"] as! [String: Any])
                self.MNSMessageResult = model
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("SnapshotConfig") {
                var model = SubmitSnapshotJobResponseBody.SnapshotJob.SnapshotConfig()
                model.fromMap(dict["SnapshotConfig"] as! [String: Any])
                self.snapshotConfig = model
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("TileCount") {
                self.tileCount = dict["TileCount"] as! String
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public var requestId: String?

    public var snapshotJob: SubmitSnapshotJobResponseBody.SnapshotJob?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotJob != nil {
            map["SnapshotJob"] = self.snapshotJob?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotJob") {
            var model = SubmitSnapshotJobResponseBody.SnapshotJob()
            model.fromMap(dict["SnapshotJob"] as! [String: Any])
            self.snapshotJob = model
        }
    }
}

public class SubmitSnapshotJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSnapshotJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitSnapshotJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitTraceAbJobRequest : Tea.TeaModel {
    public var callBack: String?

    public var cipherBase64ed: String?

    public var input: String?

    public var level: Int64?

    public var output: String?

    public var startTime: String?

    public var totalTime: String?

    public var url: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callBack != nil {
            map["CallBack"] = self.callBack!
        }
        if self.cipherBase64ed != nil {
            map["CipherBase64ed"] = self.cipherBase64ed!
        }
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.totalTime != nil {
            map["TotalTime"] = self.totalTime!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallBack") {
            self.callBack = dict["CallBack"] as! String
        }
        if dict.keys.contains("CipherBase64ed") {
            self.cipherBase64ed = dict["CipherBase64ed"] as! String
        }
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("Level") {
            self.level = dict["Level"] as! Int64
        }
        if dict.keys.contains("Output") {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TotalTime") {
            self.totalTime = dict["TotalTime"] as! String
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitTraceAbJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public var mediaId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
        }
    }
    public var data: SubmitTraceAbJobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var statusCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SubmitTraceAbJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! Int64
        }
    }
}

public class SubmitTraceAbJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitTraceAbJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitTraceAbJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitTraceExtractJobRequest : Tea.TeaModel {
    public var callBack: String?

    public var input: String?

    public var params: String?

    public var url: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callBack != nil {
            map["CallBack"] = self.callBack!
        }
        if self.input != nil {
            map["Input"] = self.input!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallBack") {
            self.callBack = dict["CallBack"] as! String
        }
        if dict.keys.contains("Input") {
            self.input = dict["Input"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("Url") {
            self.url = dict["Url"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class SubmitTraceExtractJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: SubmitTraceExtractJobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var statusCode: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusCode != nil {
            map["StatusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SubmitTraceExtractJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusCode") {
            self.statusCode = dict["StatusCode"] as! Int64
        }
    }
}

public class SubmitTraceExtractJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitTraceExtractJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitTraceExtractJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitTraceM3u8JobRequest : Tea.TeaModel {
    public var keyUri: String?

    public var mediaId: String?

    public var output: String?

    public var params: String?

    public var trace: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyUri != nil {
            map["KeyUri"] = self.keyUri!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.trace != nil {
            map["Trace"] = self.trace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyUri") {
            self.keyUri = dict["KeyUri"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("Output") {
            self.output = dict["Output"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("Trace") {
            self.trace = dict["Trace"] as! String
        }
    }
}

public class SubmitTraceM3u8JobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var data: SubmitTraceM3u8JobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = SubmitTraceM3u8JobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitTraceM3u8JobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitTraceM3u8JobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitTraceM3u8JobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagCustomPersonRequest : Tea.TeaModel {
    public var categoryDescription: String?

    public var categoryId: String?

    public var categoryName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var personDescription: String?

    public var personId: String?

    public var personName: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryDescription != nil {
            map["CategoryDescription"] = self.categoryDescription!
        }
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.categoryName != nil {
            map["CategoryName"] = self.categoryName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.personDescription != nil {
            map["PersonDescription"] = self.personDescription!
        }
        if self.personId != nil {
            map["PersonId"] = self.personId!
        }
        if self.personName != nil {
            map["PersonName"] = self.personName!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CategoryDescription") {
            self.categoryDescription = dict["CategoryDescription"] as! String
        }
        if dict.keys.contains("CategoryId") {
            self.categoryId = dict["CategoryId"] as! String
        }
        if dict.keys.contains("CategoryName") {
            self.categoryName = dict["CategoryName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PersonDescription") {
            self.personDescription = dict["PersonDescription"] as! String
        }
        if dict.keys.contains("PersonId") {
            self.personId = dict["PersonId"] as! String
        }
        if dict.keys.contains("PersonName") {
            self.personName = dict["PersonName"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class TagCustomPersonResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TagCustomPersonResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagCustomPersonResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagCustomPersonResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnbindInputBucketRequest : Tea.TeaModel {
    public var bucket: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var roleArn: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucket != nil {
            map["Bucket"] = self.bucket!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.roleArn != nil {
            map["RoleArn"] = self.roleArn!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bucket") {
            self.bucket = dict["Bucket"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RoleArn") {
            self.roleArn = dict["RoleArn"] as! String
        }
    }
}

public class UnbindInputBucketResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnbindInputBucketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindInputBucketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnbindInputBucketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnbindOutputBucketRequest : Tea.TeaModel {
    public var bucket: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucket != nil {
            map["Bucket"] = self.bucket!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bucket") {
            self.bucket = dict["Bucket"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UnbindOutputBucketResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnbindOutputBucketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindOutputBucketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnbindOutputBucketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnregisterCustomFaceRequest : Tea.TeaModel {
    public var categoryId: String?

    public var faceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var personId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.faceId != nil {
            map["FaceId"] = self.faceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.personId != nil {
            map["PersonId"] = self.personId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CategoryId") {
            self.categoryId = dict["CategoryId"] as! String
        }
        if dict.keys.contains("FaceId") {
            self.faceId = dict["FaceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PersonId") {
            self.personId = dict["PersonId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UnregisterCustomFaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnregisterCustomFaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnregisterCustomFaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnregisterCustomFaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var coverURL: String?

    public var description_: String?

    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tags: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateMediaResponseBody : Tea.TeaModel {
    public class Media : Tea.TeaModel {
        public class File : Tea.TeaModel {
            public var state: String?

            public var URL: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.URL != nil {
                    map["URL"] = self.URL!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("URL") {
                    self.URL = dict["URL"] as! String
                }
            }
        }
        public class RunIdList : Tea.TeaModel {
            public var runId: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.runId != nil {
                    map["RunId"] = self.runId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RunId") {
                    self.runId = dict["RunId"] as! [String]
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var tag: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Tag") {
                    self.tag = dict["Tag"] as! [String]
                }
            }
        }
        public var bitrate: String?

        public var cateId: Int64?

        public var censorState: String?

        public var coverURL: String?

        public var creationTime: String?

        public var description_: String?

        public var duration: String?

        public var file: UpdateMediaResponseBody.Media.File?

        public var format: String?

        public var fps: String?

        public var height: String?

        public var mediaId: String?

        public var publishState: String?

        public var runIdList: UpdateMediaResponseBody.Media.RunIdList?

        public var size: String?

        public var tags: UpdateMediaResponseBody.Media.Tags?

        public var title: String?

        public var width: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.file?.validate()
            try self.runIdList?.validate()
            try self.tags?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bitrate != nil {
                map["Bitrate"] = self.bitrate!
            }
            if self.cateId != nil {
                map["CateId"] = self.cateId!
            }
            if self.censorState != nil {
                map["CensorState"] = self.censorState!
            }
            if self.coverURL != nil {
                map["CoverURL"] = self.coverURL!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.file != nil {
                map["File"] = self.file?.toMap()
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.fps != nil {
                map["Fps"] = self.fps!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.mediaId != nil {
                map["MediaId"] = self.mediaId!
            }
            if self.publishState != nil {
                map["PublishState"] = self.publishState!
            }
            if self.runIdList != nil {
                map["RunIdList"] = self.runIdList?.toMap()
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.tags != nil {
                map["Tags"] = self.tags?.toMap()
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bitrate") {
                self.bitrate = dict["Bitrate"] as! String
            }
            if dict.keys.contains("CateId") {
                self.cateId = dict["CateId"] as! Int64
            }
            if dict.keys.contains("CensorState") {
                self.censorState = dict["CensorState"] as! String
            }
            if dict.keys.contains("CoverURL") {
                self.coverURL = dict["CoverURL"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("File") {
                var model = UpdateMediaResponseBody.Media.File()
                model.fromMap(dict["File"] as! [String: Any])
                self.file = model
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("Fps") {
                self.fps = dict["Fps"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! String
            }
            if dict.keys.contains("MediaId") {
                self.mediaId = dict["MediaId"] as! String
            }
            if dict.keys.contains("PublishState") {
                self.publishState = dict["PublishState"] as! String
            }
            if dict.keys.contains("RunIdList") {
                var model = UpdateMediaResponseBody.Media.RunIdList()
                model.fromMap(dict["RunIdList"] as! [String: Any])
                self.runIdList = model
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! String
            }
            if dict.keys.contains("Tags") {
                var model = UpdateMediaResponseBody.Media.Tags()
                model.fromMap(dict["Tags"] as! [String: Any])
                self.tags = model
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! String
            }
        }
    }
    public var media: UpdateMediaResponseBody.Media?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.media?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.media != nil {
            map["Media"] = self.media?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Media") {
            var model = UpdateMediaResponseBody.Media()
            model.fromMap(dict["Media"] as! [String: Any])
            self.media = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaCategoryRequest : Tea.TeaModel {
    public var cateId: Int64?

    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cateId != nil {
            map["CateId"] = self.cateId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CateId") {
            self.cateId = dict["CateId"] as! Int64
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UpdateMediaCategoryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaCoverRequest : Tea.TeaModel {
    public var coverURL: String?

    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coverURL != nil {
            map["CoverURL"] = self.coverURL!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoverURL") {
            self.coverURL = dict["CoverURL"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UpdateMediaCoverResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaCoverResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaCoverResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaCoverResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaPublishStateRequest : Tea.TeaModel {
    public var mediaId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var publish: Bool?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publish != nil {
            map["Publish"] = self.publish!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Publish") {
            self.publish = dict["Publish"] as! Bool
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UpdateMediaPublishStateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaPublishStateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaPublishStateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaPublishStateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaWorkflowRequest : Tea.TeaModel {
    public var mediaWorkflowId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var topology: String?

    public var triggerMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowId != nil {
            map["MediaWorkflowId"] = self.mediaWorkflowId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.topology != nil {
            map["Topology"] = self.topology!
        }
        if self.triggerMode != nil {
            map["TriggerMode"] = self.triggerMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowId") {
            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Topology") {
            self.topology = dict["Topology"] as! String
        }
        if dict.keys.contains("TriggerMode") {
            self.triggerMode = dict["TriggerMode"] as! String
        }
    }
}

public class UpdateMediaWorkflowResponseBody : Tea.TeaModel {
    public class MediaWorkflow : Tea.TeaModel {
        public var creationTime: String?

        public var mediaWorkflowId: String?

        public var name: String?

        public var state: String?

        public var topology: String?

        public var triggerMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.mediaWorkflowId != nil {
                map["MediaWorkflowId"] = self.mediaWorkflowId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.topology != nil {
                map["Topology"] = self.topology!
            }
            if self.triggerMode != nil {
                map["TriggerMode"] = self.triggerMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("MediaWorkflowId") {
                self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Topology") {
                self.topology = dict["Topology"] as! String
            }
            if dict.keys.contains("TriggerMode") {
                self.triggerMode = dict["TriggerMode"] as! String
            }
        }
    }
    public var mediaWorkflow: UpdateMediaWorkflowResponseBody.MediaWorkflow?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflow?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflow != nil {
            map["MediaWorkflow"] = self.mediaWorkflow?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflow") {
            var model = UpdateMediaWorkflowResponseBody.MediaWorkflow()
            model.fromMap(dict["MediaWorkflow"] as! [String: Any])
            self.mediaWorkflow = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaWorkflowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaWorkflowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaWorkflowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateMediaWorkflowTriggerModeRequest : Tea.TeaModel {
    public var mediaWorkflowId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var triggerMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflowId != nil {
            map["MediaWorkflowId"] = self.mediaWorkflowId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.triggerMode != nil {
            map["TriggerMode"] = self.triggerMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflowId") {
            self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TriggerMode") {
            self.triggerMode = dict["TriggerMode"] as! String
        }
    }
}

public class UpdateMediaWorkflowTriggerModeResponseBody : Tea.TeaModel {
    public class MediaWorkflow : Tea.TeaModel {
        public var creationTime: String?

        public var mediaWorkflowId: String?

        public var name: String?

        public var state: String?

        public var topology: String?

        public var triggerMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.mediaWorkflowId != nil {
                map["MediaWorkflowId"] = self.mediaWorkflowId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.topology != nil {
                map["Topology"] = self.topology!
            }
            if self.triggerMode != nil {
                map["TriggerMode"] = self.triggerMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("MediaWorkflowId") {
                self.mediaWorkflowId = dict["MediaWorkflowId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Topology") {
                self.topology = dict["Topology"] as! String
            }
            if dict.keys.contains("TriggerMode") {
                self.triggerMode = dict["TriggerMode"] as! String
            }
        }
    }
    public var mediaWorkflow: UpdateMediaWorkflowTriggerModeResponseBody.MediaWorkflow?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mediaWorkflow?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mediaWorkflow != nil {
            map["MediaWorkflow"] = self.mediaWorkflow?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MediaWorkflow") {
            var model = UpdateMediaWorkflowTriggerModeResponseBody.MediaWorkflow()
            model.fromMap(dict["MediaWorkflow"] as! [String: Any])
            self.mediaWorkflow = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateMediaWorkflowTriggerModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateMediaWorkflowTriggerModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateMediaWorkflowTriggerModeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePipelineRequest : Tea.TeaModel {
    public var extendConfig: String?

    public var name: String?

    public var notifyConfig: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pipelineId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var role: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extendConfig != nil {
            map["ExtendConfig"] = self.extendConfig!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.notifyConfig != nil {
            map["NotifyConfig"] = self.notifyConfig!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExtendConfig") {
            self.extendConfig = dict["ExtendConfig"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NotifyConfig") {
            self.notifyConfig = dict["NotifyConfig"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class UpdatePipelineResponseBody : Tea.TeaModel {
    public class Pipeline : Tea.TeaModel {
        public class NotifyConfig : Tea.TeaModel {
            public var mqTag: String?

            public var mqTopic: String?

            public var queueName: String?

            public var topic: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mqTag != nil {
                    map["MqTag"] = self.mqTag!
                }
                if self.mqTopic != nil {
                    map["MqTopic"] = self.mqTopic!
                }
                if self.queueName != nil {
                    map["QueueName"] = self.queueName!
                }
                if self.topic != nil {
                    map["Topic"] = self.topic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MqTag") {
                    self.mqTag = dict["MqTag"] as! String
                }
                if dict.keys.contains("MqTopic") {
                    self.mqTopic = dict["MqTopic"] as! String
                }
                if dict.keys.contains("QueueName") {
                    self.queueName = dict["QueueName"] as! String
                }
                if dict.keys.contains("Topic") {
                    self.topic = dict["Topic"] as! String
                }
            }
        }
        public var id: String?

        public var name: String?

        public var notifyConfig: UpdatePipelineResponseBody.Pipeline.NotifyConfig?

        public var quotaAllocate: Int64?

        public var role: String?

        public var speed: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.notifyConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.notifyConfig != nil {
                map["NotifyConfig"] = self.notifyConfig?.toMap()
            }
            if self.quotaAllocate != nil {
                map["QuotaAllocate"] = self.quotaAllocate!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.speed != nil {
                map["Speed"] = self.speed!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NotifyConfig") {
                var model = UpdatePipelineResponseBody.Pipeline.NotifyConfig()
                model.fromMap(dict["NotifyConfig"] as! [String: Any])
                self.notifyConfig = model
            }
            if dict.keys.contains("QuotaAllocate") {
                self.quotaAllocate = dict["QuotaAllocate"] as! Int64
            }
            if dict.keys.contains("Role") {
                self.role = dict["Role"] as! String
            }
            if dict.keys.contains("Speed") {
                self.speed = dict["Speed"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
        }
    }
    public var pipeline: UpdatePipelineResponseBody.Pipeline?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pipeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipeline != nil {
            map["Pipeline"] = self.pipeline?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Pipeline") {
            var model = UpdatePipelineResponseBody.Pipeline()
            model.fromMap(dict["Pipeline"] as! [String: Any])
            self.pipeline = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdatePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSmarttagTemplateRequest : Tea.TeaModel {
    public var analyseTypes: String?

    public var faceCategoryIds: String?

    public var faceCustomParamsConfig: String?

    public var industry: String?

    public var isDefault: Bool?

    public var keywordConfig: String?

    public var knowledgeConfig: String?

    public var labelType: String?

    public var labelVersion: String?

    public var landmarkGroupIds: String?

    public var objectGroupIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scene: String?

    public var templateId: String?

    public var templateName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.analyseTypes != nil {
            map["AnalyseTypes"] = self.analyseTypes!
        }
        if self.faceCategoryIds != nil {
            map["FaceCategoryIds"] = self.faceCategoryIds!
        }
        if self.faceCustomParamsConfig != nil {
            map["FaceCustomParamsConfig"] = self.faceCustomParamsConfig!
        }
        if self.industry != nil {
            map["Industry"] = self.industry!
        }
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.keywordConfig != nil {
            map["KeywordConfig"] = self.keywordConfig!
        }
        if self.knowledgeConfig != nil {
            map["KnowledgeConfig"] = self.knowledgeConfig!
        }
        if self.labelType != nil {
            map["LabelType"] = self.labelType!
        }
        if self.labelVersion != nil {
            map["LabelVersion"] = self.labelVersion!
        }
        if self.landmarkGroupIds != nil {
            map["LandmarkGroupIds"] = self.landmarkGroupIds!
        }
        if self.objectGroupIds != nil {
            map["ObjectGroupIds"] = self.objectGroupIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scene != nil {
            map["Scene"] = self.scene!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AnalyseTypes") {
            self.analyseTypes = dict["AnalyseTypes"] as! String
        }
        if dict.keys.contains("FaceCategoryIds") {
            self.faceCategoryIds = dict["FaceCategoryIds"] as! String
        }
        if dict.keys.contains("FaceCustomParamsConfig") {
            self.faceCustomParamsConfig = dict["FaceCustomParamsConfig"] as! String
        }
        if dict.keys.contains("Industry") {
            self.industry = dict["Industry"] as! String
        }
        if dict.keys.contains("IsDefault") {
            self.isDefault = dict["IsDefault"] as! Bool
        }
        if dict.keys.contains("KeywordConfig") {
            self.keywordConfig = dict["KeywordConfig"] as! String
        }
        if dict.keys.contains("KnowledgeConfig") {
            self.knowledgeConfig = dict["KnowledgeConfig"] as! String
        }
        if dict.keys.contains("LabelType") {
            self.labelType = dict["LabelType"] as! String
        }
        if dict.keys.contains("LabelVersion") {
            self.labelVersion = dict["LabelVersion"] as! String
        }
        if dict.keys.contains("LandmarkGroupIds") {
            self.landmarkGroupIds = dict["LandmarkGroupIds"] as! String
        }
        if dict.keys.contains("ObjectGroupIds") {
            self.objectGroupIds = dict["ObjectGroupIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Scene") {
            self.scene = dict["Scene"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateName") {
            self.templateName = dict["TemplateName"] as! String
        }
    }
}

public class UpdateSmarttagTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateSmarttagTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSmarttagTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateSmarttagTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTemplateRequest : Tea.TeaModel {
    public var audio: String?

    public var container: String?

    public var muxConfig: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateId: String?

    public var transConfig: String?

    public var video: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audio != nil {
            map["Audio"] = self.audio!
        }
        if self.container != nil {
            map["Container"] = self.container!
        }
        if self.muxConfig != nil {
            map["MuxConfig"] = self.muxConfig!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.transConfig != nil {
            map["TransConfig"] = self.transConfig!
        }
        if self.video != nil {
            map["Video"] = self.video!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Audio") {
            self.audio = dict["Audio"] as! String
        }
        if dict.keys.contains("Container") {
            self.container = dict["Container"] as! String
        }
        if dict.keys.contains("MuxConfig") {
            self.muxConfig = dict["MuxConfig"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TransConfig") {
            self.transConfig = dict["TransConfig"] as! String
        }
        if dict.keys.contains("Video") {
            self.video = dict["Video"] as! String
        }
    }
}

public class UpdateTemplateResponseBody : Tea.TeaModel {
    public class Template : Tea.TeaModel {
        public class Audio : Tea.TeaModel {
            public class Volume : Tea.TeaModel {
                public var integratedLoudnessTarget: String?

                public var level: String?

                public var loudnessRangeTarget: String?

                public var method: String?

                public var peakLevel: String?

                public var truePeak: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.integratedLoudnessTarget != nil {
                        map["IntegratedLoudnessTarget"] = self.integratedLoudnessTarget!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.loudnessRangeTarget != nil {
                        map["LoudnessRangeTarget"] = self.loudnessRangeTarget!
                    }
                    if self.method != nil {
                        map["Method"] = self.method!
                    }
                    if self.peakLevel != nil {
                        map["PeakLevel"] = self.peakLevel!
                    }
                    if self.truePeak != nil {
                        map["TruePeak"] = self.truePeak!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IntegratedLoudnessTarget") {
                        self.integratedLoudnessTarget = dict["IntegratedLoudnessTarget"] as! String
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! String
                    }
                    if dict.keys.contains("LoudnessRangeTarget") {
                        self.loudnessRangeTarget = dict["LoudnessRangeTarget"] as! String
                    }
                    if dict.keys.contains("Method") {
                        self.method = dict["Method"] as! String
                    }
                    if dict.keys.contains("PeakLevel") {
                        self.peakLevel = dict["PeakLevel"] as! String
                    }
                    if dict.keys.contains("TruePeak") {
                        self.truePeak = dict["TruePeak"] as! String
                    }
                }
            }
            public var bitrate: String?

            public var channels: String?

            public var codec: String?

            public var profile: String?

            public var qscale: String?

            public var remove: String?

            public var samplerate: String?

            public var volume: UpdateTemplateResponseBody.Template.Audio.Volume?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.volume?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.channels != nil {
                    map["Channels"] = self.channels!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.qscale != nil {
                    map["Qscale"] = self.qscale!
                }
                if self.remove != nil {
                    map["Remove"] = self.remove!
                }
                if self.samplerate != nil {
                    map["Samplerate"] = self.samplerate!
                }
                if self.volume != nil {
                    map["Volume"] = self.volume?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("Channels") {
                    self.channels = dict["Channels"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Qscale") {
                    self.qscale = dict["Qscale"] as! String
                }
                if dict.keys.contains("Remove") {
                    self.remove = dict["Remove"] as! String
                }
                if dict.keys.contains("Samplerate") {
                    self.samplerate = dict["Samplerate"] as! String
                }
                if dict.keys.contains("Volume") {
                    var model = UpdateTemplateResponseBody.Template.Audio.Volume()
                    model.fromMap(dict["Volume"] as! [String: Any])
                    self.volume = model
                }
            }
        }
        public class Container : Tea.TeaModel {
            public var format: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.format != nil {
                    map["Format"] = self.format!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Format") {
                    self.format = dict["Format"] as! String
                }
            }
        }
        public class MuxConfig : Tea.TeaModel {
            public class Gif : Tea.TeaModel {
                public var ditherMode: String?

                public var finalDelay: String?

                public var isCustomPalette: String?

                public var loop: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ditherMode != nil {
                        map["DitherMode"] = self.ditherMode!
                    }
                    if self.finalDelay != nil {
                        map["FinalDelay"] = self.finalDelay!
                    }
                    if self.isCustomPalette != nil {
                        map["IsCustomPalette"] = self.isCustomPalette!
                    }
                    if self.loop != nil {
                        map["Loop"] = self.loop!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DitherMode") {
                        self.ditherMode = dict["DitherMode"] as! String
                    }
                    if dict.keys.contains("FinalDelay") {
                        self.finalDelay = dict["FinalDelay"] as! String
                    }
                    if dict.keys.contains("IsCustomPalette") {
                        self.isCustomPalette = dict["IsCustomPalette"] as! String
                    }
                    if dict.keys.contains("Loop") {
                        self.loop = dict["Loop"] as! String
                    }
                }
            }
            public class Segment : Tea.TeaModel {
                public var duration: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! String
                    }
                }
            }
            public class Webp : Tea.TeaModel {
                public var loop: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.loop != nil {
                        map["Loop"] = self.loop!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Loop") {
                        self.loop = dict["Loop"] as! String
                    }
                }
            }
            public var gif: UpdateTemplateResponseBody.Template.MuxConfig.Gif?

            public var segment: UpdateTemplateResponseBody.Template.MuxConfig.Segment?

            public var webp: UpdateTemplateResponseBody.Template.MuxConfig.Webp?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.gif?.validate()
                try self.segment?.validate()
                try self.webp?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gif != nil {
                    map["Gif"] = self.gif?.toMap()
                }
                if self.segment != nil {
                    map["Segment"] = self.segment?.toMap()
                }
                if self.webp != nil {
                    map["Webp"] = self.webp?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Gif") {
                    var model = UpdateTemplateResponseBody.Template.MuxConfig.Gif()
                    model.fromMap(dict["Gif"] as! [String: Any])
                    self.gif = model
                }
                if dict.keys.contains("Segment") {
                    var model = UpdateTemplateResponseBody.Template.MuxConfig.Segment()
                    model.fromMap(dict["Segment"] as! [String: Any])
                    self.segment = model
                }
                if dict.keys.contains("Webp") {
                    var model = UpdateTemplateResponseBody.Template.MuxConfig.Webp()
                    model.fromMap(dict["Webp"] as! [String: Any])
                    self.webp = model
                }
            }
        }
        public class TransConfig : Tea.TeaModel {
            public var adjDarMethod: String?

            public var isCheckAudioBitrate: String?

            public var isCheckAudioBitrateFail: String?

            public var isCheckReso: String?

            public var isCheckResoFail: String?

            public var isCheckVideoBitrate: String?

            public var isCheckVideoBitrateFail: String?

            public var transMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adjDarMethod != nil {
                    map["AdjDarMethod"] = self.adjDarMethod!
                }
                if self.isCheckAudioBitrate != nil {
                    map["IsCheckAudioBitrate"] = self.isCheckAudioBitrate!
                }
                if self.isCheckAudioBitrateFail != nil {
                    map["IsCheckAudioBitrateFail"] = self.isCheckAudioBitrateFail!
                }
                if self.isCheckReso != nil {
                    map["IsCheckReso"] = self.isCheckReso!
                }
                if self.isCheckResoFail != nil {
                    map["IsCheckResoFail"] = self.isCheckResoFail!
                }
                if self.isCheckVideoBitrate != nil {
                    map["IsCheckVideoBitrate"] = self.isCheckVideoBitrate!
                }
                if self.isCheckVideoBitrateFail != nil {
                    map["IsCheckVideoBitrateFail"] = self.isCheckVideoBitrateFail!
                }
                if self.transMode != nil {
                    map["TransMode"] = self.transMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdjDarMethod") {
                    self.adjDarMethod = dict["AdjDarMethod"] as! String
                }
                if dict.keys.contains("IsCheckAudioBitrate") {
                    self.isCheckAudioBitrate = dict["IsCheckAudioBitrate"] as! String
                }
                if dict.keys.contains("IsCheckAudioBitrateFail") {
                    self.isCheckAudioBitrateFail = dict["IsCheckAudioBitrateFail"] as! String
                }
                if dict.keys.contains("IsCheckReso") {
                    self.isCheckReso = dict["IsCheckReso"] as! String
                }
                if dict.keys.contains("IsCheckResoFail") {
                    self.isCheckResoFail = dict["IsCheckResoFail"] as! String
                }
                if dict.keys.contains("IsCheckVideoBitrate") {
                    self.isCheckVideoBitrate = dict["IsCheckVideoBitrate"] as! String
                }
                if dict.keys.contains("IsCheckVideoBitrateFail") {
                    self.isCheckVideoBitrateFail = dict["IsCheckVideoBitrateFail"] as! String
                }
                if dict.keys.contains("TransMode") {
                    self.transMode = dict["TransMode"] as! String
                }
            }
        }
        public class Video : Tea.TeaModel {
            public class BitrateBnd : Tea.TeaModel {
                public var max: String?

                public var min: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.max != nil {
                        map["Max"] = self.max!
                    }
                    if self.min != nil {
                        map["Min"] = self.min!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Max") {
                        self.max = dict["Max"] as! String
                    }
                    if dict.keys.contains("Min") {
                        self.min = dict["Min"] as! String
                    }
                }
            }
            public class NarrowBand : Tea.TeaModel {
                public var abrmax: Double?

                public var maxAbrRatio: Double?

                public var version: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.abrmax != nil {
                        map["Abrmax"] = self.abrmax!
                    }
                    if self.maxAbrRatio != nil {
                        map["MaxAbrRatio"] = self.maxAbrRatio!
                    }
                    if self.version != nil {
                        map["Version"] = self.version!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Abrmax") {
                        self.abrmax = dict["Abrmax"] as! Double
                    }
                    if dict.keys.contains("MaxAbrRatio") {
                        self.maxAbrRatio = dict["MaxAbrRatio"] as! Double
                    }
                    if dict.keys.contains("Version") {
                        self.version = dict["Version"] as! String
                    }
                }
            }
            public var bitrate: String?

            public var bitrateBnd: UpdateTemplateResponseBody.Template.Video.BitrateBnd?

            public var bufsize: String?

            public var codec: String?

            public var crf: String?

            public var crop: String?

            public var degrain: String?

            public var fps: String?

            public var gop: String?

            public var hdr2sdr: String?

            public var height: String?

            public var longShortMode: String?

            public var maxFps: String?

            public var maxrate: String?

            public var narrowBand: UpdateTemplateResponseBody.Template.Video.NarrowBand?

            public var pad: String?

            public var pixFmt: String?

            public var preset: String?

            public var profile: String?

            public var qscale: String?

            public var remove: String?

            public var resoPriority: String?

            public var scanMode: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.bitrateBnd?.validate()
                try self.narrowBand?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bitrate != nil {
                    map["Bitrate"] = self.bitrate!
                }
                if self.bitrateBnd != nil {
                    map["BitrateBnd"] = self.bitrateBnd?.toMap()
                }
                if self.bufsize != nil {
                    map["Bufsize"] = self.bufsize!
                }
                if self.codec != nil {
                    map["Codec"] = self.codec!
                }
                if self.crf != nil {
                    map["Crf"] = self.crf!
                }
                if self.crop != nil {
                    map["Crop"] = self.crop!
                }
                if self.degrain != nil {
                    map["Degrain"] = self.degrain!
                }
                if self.fps != nil {
                    map["Fps"] = self.fps!
                }
                if self.gop != nil {
                    map["Gop"] = self.gop!
                }
                if self.hdr2sdr != nil {
                    map["Hdr2sdr"] = self.hdr2sdr!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.longShortMode != nil {
                    map["LongShortMode"] = self.longShortMode!
                }
                if self.maxFps != nil {
                    map["MaxFps"] = self.maxFps!
                }
                if self.maxrate != nil {
                    map["Maxrate"] = self.maxrate!
                }
                if self.narrowBand != nil {
                    map["NarrowBand"] = self.narrowBand?.toMap()
                }
                if self.pad != nil {
                    map["Pad"] = self.pad!
                }
                if self.pixFmt != nil {
                    map["PixFmt"] = self.pixFmt!
                }
                if self.preset != nil {
                    map["Preset"] = self.preset!
                }
                if self.profile != nil {
                    map["Profile"] = self.profile!
                }
                if self.qscale != nil {
                    map["Qscale"] = self.qscale!
                }
                if self.remove != nil {
                    map["Remove"] = self.remove!
                }
                if self.resoPriority != nil {
                    map["ResoPriority"] = self.resoPriority!
                }
                if self.scanMode != nil {
                    map["ScanMode"] = self.scanMode!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bitrate") {
                    self.bitrate = dict["Bitrate"] as! String
                }
                if dict.keys.contains("BitrateBnd") {
                    var model = UpdateTemplateResponseBody.Template.Video.BitrateBnd()
                    model.fromMap(dict["BitrateBnd"] as! [String: Any])
                    self.bitrateBnd = model
                }
                if dict.keys.contains("Bufsize") {
                    self.bufsize = dict["Bufsize"] as! String
                }
                if dict.keys.contains("Codec") {
                    self.codec = dict["Codec"] as! String
                }
                if dict.keys.contains("Crf") {
                    self.crf = dict["Crf"] as! String
                }
                if dict.keys.contains("Crop") {
                    self.crop = dict["Crop"] as! String
                }
                if dict.keys.contains("Degrain") {
                    self.degrain = dict["Degrain"] as! String
                }
                if dict.keys.contains("Fps") {
                    self.fps = dict["Fps"] as! String
                }
                if dict.keys.contains("Gop") {
                    self.gop = dict["Gop"] as! String
                }
                if dict.keys.contains("Hdr2sdr") {
                    self.hdr2sdr = dict["Hdr2sdr"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("LongShortMode") {
                    self.longShortMode = dict["LongShortMode"] as! String
                }
                if dict.keys.contains("MaxFps") {
                    self.maxFps = dict["MaxFps"] as! String
                }
                if dict.keys.contains("Maxrate") {
                    self.maxrate = dict["Maxrate"] as! String
                }
                if dict.keys.contains("NarrowBand") {
                    var model = UpdateTemplateResponseBody.Template.Video.NarrowBand()
                    model.fromMap(dict["NarrowBand"] as! [String: Any])
                    self.narrowBand = model
                }
                if dict.keys.contains("Pad") {
                    self.pad = dict["Pad"] as! String
                }
                if dict.keys.contains("PixFmt") {
                    self.pixFmt = dict["PixFmt"] as! String
                }
                if dict.keys.contains("Preset") {
                    self.preset = dict["Preset"] as! String
                }
                if dict.keys.contains("Profile") {
                    self.profile = dict["Profile"] as! String
                }
                if dict.keys.contains("Qscale") {
                    self.qscale = dict["Qscale"] as! String
                }
                if dict.keys.contains("Remove") {
                    self.remove = dict["Remove"] as! String
                }
                if dict.keys.contains("ResoPriority") {
                    self.resoPriority = dict["ResoPriority"] as! String
                }
                if dict.keys.contains("ScanMode") {
                    self.scanMode = dict["ScanMode"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public var audio: UpdateTemplateResponseBody.Template.Audio?

        public var container: UpdateTemplateResponseBody.Template.Container?

        public var id: String?

        public var muxConfig: UpdateTemplateResponseBody.Template.MuxConfig?

        public var name: String?

        public var state: String?

        public var transConfig: UpdateTemplateResponseBody.Template.TransConfig?

        public var video: UpdateTemplateResponseBody.Template.Video?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.audio?.validate()
            try self.container?.validate()
            try self.muxConfig?.validate()
            try self.transConfig?.validate()
            try self.video?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audio != nil {
                map["Audio"] = self.audio?.toMap()
            }
            if self.container != nil {
                map["Container"] = self.container?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.muxConfig != nil {
                map["MuxConfig"] = self.muxConfig?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.transConfig != nil {
                map["TransConfig"] = self.transConfig?.toMap()
            }
            if self.video != nil {
                map["Video"] = self.video?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Audio") {
                var model = UpdateTemplateResponseBody.Template.Audio()
                model.fromMap(dict["Audio"] as! [String: Any])
                self.audio = model
            }
            if dict.keys.contains("Container") {
                var model = UpdateTemplateResponseBody.Template.Container()
                model.fromMap(dict["Container"] as! [String: Any])
                self.container = model
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MuxConfig") {
                var model = UpdateTemplateResponseBody.Template.MuxConfig()
                model.fromMap(dict["MuxConfig"] as! [String: Any])
                self.muxConfig = model
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("TransConfig") {
                var model = UpdateTemplateResponseBody.Template.TransConfig()
                model.fromMap(dict["TransConfig"] as! [String: Any])
                self.transConfig = model
            }
            if dict.keys.contains("Video") {
                var model = UpdateTemplateResponseBody.Template.Video()
                model.fromMap(dict["Video"] as! [String: Any])
                self.video = model
            }
        }
    }
    public var requestId: String?

    public var template: UpdateTemplateResponseBody.Template?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.template != nil {
            map["Template"] = self.template?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Template") {
            var model = UpdateTemplateResponseBody.Template()
            model.fromMap(dict["Template"] as! [String: Any])
            self.template = model
        }
    }
}

public class UpdateTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWaterMarkTemplateRequest : Tea.TeaModel {
    public var config: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var waterMarkTemplateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.waterMarkTemplateId != nil {
            map["WaterMarkTemplateId"] = self.waterMarkTemplateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") {
            self.config = dict["Config"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("WaterMarkTemplateId") {
            self.waterMarkTemplateId = dict["WaterMarkTemplateId"] as! String
        }
    }
}

public class UpdateWaterMarkTemplateResponseBody : Tea.TeaModel {
    public class WaterMarkTemplate : Tea.TeaModel {
        public class RatioRefer : Tea.TeaModel {
            public var dx: String?

            public var dy: String?

            public var height: String?

            public var width: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dx != nil {
                    map["Dx"] = self.dx!
                }
                if self.dy != nil {
                    map["Dy"] = self.dy!
                }
                if self.height != nil {
                    map["Height"] = self.height!
                }
                if self.width != nil {
                    map["Width"] = self.width!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Dx") {
                    self.dx = dict["Dx"] as! String
                }
                if dict.keys.contains("Dy") {
                    self.dy = dict["Dy"] as! String
                }
                if dict.keys.contains("Height") {
                    self.height = dict["Height"] as! String
                }
                if dict.keys.contains("Width") {
                    self.width = dict["Width"] as! String
                }
            }
        }
        public class Timeline : Tea.TeaModel {
            public var duration: String?

            public var start: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.start != nil {
                    map["Start"] = self.start!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("Start") {
                    self.start = dict["Start"] as! String
                }
            }
        }
        public var dx: String?

        public var dy: String?

        public var height: String?

        public var id: String?

        public var name: String?

        public var ratioRefer: UpdateWaterMarkTemplateResponseBody.WaterMarkTemplate.RatioRefer?

        public var referPos: String?

        public var state: String?

        public var timeline: UpdateWaterMarkTemplateResponseBody.WaterMarkTemplate.Timeline?

        public var type: String?

        public var width: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ratioRefer?.validate()
            try self.timeline?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dx != nil {
                map["Dx"] = self.dx!
            }
            if self.dy != nil {
                map["Dy"] = self.dy!
            }
            if self.height != nil {
                map["Height"] = self.height!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ratioRefer != nil {
                map["RatioRefer"] = self.ratioRefer?.toMap()
            }
            if self.referPos != nil {
                map["ReferPos"] = self.referPos!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.timeline != nil {
                map["Timeline"] = self.timeline?.toMap()
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.width != nil {
                map["Width"] = self.width!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Dx") {
                self.dx = dict["Dx"] as! String
            }
            if dict.keys.contains("Dy") {
                self.dy = dict["Dy"] as! String
            }
            if dict.keys.contains("Height") {
                self.height = dict["Height"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RatioRefer") {
                var model = UpdateWaterMarkTemplateResponseBody.WaterMarkTemplate.RatioRefer()
                model.fromMap(dict["RatioRefer"] as! [String: Any])
                self.ratioRefer = model
            }
            if dict.keys.contains("ReferPos") {
                self.referPos = dict["ReferPos"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Timeline") {
                var model = UpdateWaterMarkTemplateResponseBody.WaterMarkTemplate.Timeline()
                model.fromMap(dict["Timeline"] as! [String: Any])
                self.timeline = model
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Width") {
                self.width = dict["Width"] as! String
            }
        }
    }
    public var requestId: String?

    public var waterMarkTemplate: UpdateWaterMarkTemplateResponseBody.WaterMarkTemplate?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.waterMarkTemplate?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.waterMarkTemplate != nil {
            map["WaterMarkTemplate"] = self.waterMarkTemplate?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WaterMarkTemplate") {
            var model = UpdateWaterMarkTemplateResponseBody.WaterMarkTemplate()
            model.fromMap(dict["WaterMarkTemplate"] as! [String: Any])
            self.waterMarkTemplate = model
        }
    }
}

public class UpdateWaterMarkTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWaterMarkTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateWaterMarkTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
