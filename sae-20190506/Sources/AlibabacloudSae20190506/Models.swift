import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AclConfig : Tea.TeaModel {
    public var aclEntries: [AclEntryConfig]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntries != nil {
            var tmp : [Any] = []
            for k in self.aclEntries! {
                tmp.append(k.toMap())
            }
            map["aclEntries"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("aclEntries") {
            var tmp : [AclEntryConfig] = []
            for v in dict["aclEntries"] as! [Any] {
                var model = AclEntryConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.aclEntries = tmp
        }
    }
}

public class AclEntryConfig : Tea.TeaModel {
    public var entry: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entry != nil {
            map["entry"] = self.entry!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("entry") {
            self.entry = dict["entry"] as! String
        }
    }
}

public class AppStackInstance : Tea.TeaModel {
    public class Endpoints : Tea.TeaModel {
        public var address: String?

        public var name: String?

        public var protocol_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Protocol") {
                self.protocol_ = dict["Protocol"] as! String
            }
        }
    }
    public class Parameters : Tea.TeaModel {
        public var name: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var createTime: Int64?

    public var endpoints: [AppStackInstance.Endpoints]?

    public var instanceId: String?

    public var instanceName: String?

    public var parameters: [AppStackInstance.Parameters]?

    public var stackId: String?

    public var status: String?

    public var updateTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.endpoints != nil {
            var tmp : [Any] = []
            for k in self.endpoints! {
                tmp.append(k.toMap())
            }
            map["Endpoints"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.parameters != nil {
            var tmp : [Any] = []
            for k in self.parameters! {
                tmp.append(k.toMap())
            }
            map["Parameters"] = tmp
        }
        if self.stackId != nil {
            map["StackId"] = self.stackId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("Endpoints") {
            var tmp : [AppStackInstance.Endpoints] = []
            for v in dict["Endpoints"] as! [Any] {
                var model = AppStackInstance.Endpoints()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endpoints = tmp
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("Parameters") {
            var tmp : [AppStackInstance.Parameters] = []
            for v in dict["Parameters"] as! [Any] {
                var model = AppStackInstance.Parameters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.parameters = tmp
        }
        if dict.keys.contains("StackId") {
            self.stackId = dict["StackId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("UpdateTime") {
            self.updateTime = dict["UpdateTime"] as! Int64
        }
    }
}

public class AppStackResource : Tea.TeaModel {
    public var createTime: Int64?

    public var instanceId: String?

    public var productCode: String?

    public var resourceId: String?

    public var resourceName: String?

    public var resourceType: String?

    public var stackId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.productCode != nil {
            map["ProductCode"] = self.productCode!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceName != nil {
            map["ResourceName"] = self.resourceName!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.stackId != nil {
            map["StackId"] = self.stackId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ProductCode") {
            self.productCode = dict["ProductCode"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceName") {
            self.resourceName = dict["ResourceName"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("StackId") {
            self.stackId = dict["StackId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class AppStackTask : Tea.TeaModel {
    public class Steps : Tea.TeaModel {
        public var code: String?

        public var duration: Int64?

        public var endTime: Int64?

        public var id: String?

        public var message: String?

        public var name: String?

        public var startTime: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var createTime: Int64?

    public var endTime: Int64?

    public var instanceId: String?

    public var stackId: String?

    public var startTime: Int64?

    public var status: String?

    public var steps: [AppStackTask.Steps]?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.stackId != nil {
            map["StackId"] = self.stackId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.steps != nil {
            var tmp : [Any] = []
            for k in self.steps! {
                tmp.append(k.toMap())
            }
            map["Steps"] = tmp
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("StackId") {
            self.stackId = dict["StackId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Steps") {
            var tmp : [AppStackTask.Steps] = []
            for v in dict["Steps"] as! [Any] {
                var model = AppStackTask.Steps()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.steps = tmp
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class Application : Tea.TeaModel {
    public var requestId: String?

    public var applicationID: String?

    public var applicationId: String?

    public var applicationName: String?

    public var args: String?

    public var caPort: Int32?

    public var codeChecksum: String?

    public var codeSize: Int64?

    public var command: String?

    public var cpu: Double?

    public var createdTime: String?

    public var customDNS: CustomDNS?

    public var customDomainName: String?

    public var customHealthCheckConfig: CustomHealthCheckConfig?

    public var customRuntimeConfig: CustomRuntimeConfig?

    public var description_: String?

    public var diskSize: Int32?

    public var enableAppMetric: Bool?

    public var enableArmsAdvanced: Bool?

    public var environmentVariables: [String: String]?

    public var gpuMemorySize: Int32?

    public var handler: String?

    public var httpTriggerConfig: HTTPTriggerConfig?

    public var imageConfig: ImageConfig?

    public var initializationTimeout: Int32?

    public var initializer: String?

    public var instanceConcurrency: Int32?

    public var instanceLifecycleConfig: InstanceLifecycleConfig?

    public var instanceSoftConcurrency: Int32?

    public var instanceType: String?

    public var internetAccess: Bool?

    public var lastModifiedTime: String?

    public var layers: [String]?

    public var layersArnV2: [String]?

    public var livenessProbe: Probe?

    public var logConfig: LogConfig?

    public var memorySize: Int32?

    public var namespace: String?

    public var namespaceID: String?

    public var namespaceName: String?

    public var nasConfig: NASConfig?

    public var ossMountConfig: OSSMountConfig?

    public var runtime: String?

    public var scaleConfig: ScaleConfig?

    public var slsConfig: SLSConfig?

    public var startupProbe: Probe?

    public var timeout: Int32?

    public var tracingConfig: TracingConfig?

    public var urlInternet: String?

    public var urlIntranet: String?

    public var version: Version?

    public var vpcConfig: VPCConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.customDNS?.validate()
        try self.customHealthCheckConfig?.validate()
        try self.customRuntimeConfig?.validate()
        try self.httpTriggerConfig?.validate()
        try self.imageConfig?.validate()
        try self.instanceLifecycleConfig?.validate()
        try self.livenessProbe?.validate()
        try self.logConfig?.validate()
        try self.nasConfig?.validate()
        try self.ossMountConfig?.validate()
        try self.scaleConfig?.validate()
        try self.slsConfig?.validate()
        try self.startupProbe?.validate()
        try self.tracingConfig?.validate()
        try self.version?.validate()
        try self.vpcConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.applicationID != nil {
            map["applicationID"] = self.applicationID!
        }
        if self.applicationId != nil {
            map["applicationId"] = self.applicationId!
        }
        if self.applicationName != nil {
            map["applicationName"] = self.applicationName!
        }
        if self.args != nil {
            map["args"] = self.args!
        }
        if self.caPort != nil {
            map["caPort"] = self.caPort!
        }
        if self.codeChecksum != nil {
            map["codeChecksum"] = self.codeChecksum!
        }
        if self.codeSize != nil {
            map["codeSize"] = self.codeSize!
        }
        if self.command != nil {
            map["command"] = self.command!
        }
        if self.cpu != nil {
            map["cpu"] = self.cpu!
        }
        if self.createdTime != nil {
            map["createdTime"] = self.createdTime!
        }
        if self.customDNS != nil {
            map["customDNS"] = self.customDNS?.toMap()
        }
        if self.customDomainName != nil {
            map["customDomainName"] = self.customDomainName!
        }
        if self.customHealthCheckConfig != nil {
            map["customHealthCheckConfig"] = self.customHealthCheckConfig?.toMap()
        }
        if self.customRuntimeConfig != nil {
            map["customRuntimeConfig"] = self.customRuntimeConfig?.toMap()
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.diskSize != nil {
            map["diskSize"] = self.diskSize!
        }
        if self.enableAppMetric != nil {
            map["enableAppMetric"] = self.enableAppMetric!
        }
        if self.enableArmsAdvanced != nil {
            map["enableArmsAdvanced"] = self.enableArmsAdvanced!
        }
        if self.environmentVariables != nil {
            map["environmentVariables"] = self.environmentVariables!
        }
        if self.gpuMemorySize != nil {
            map["gpuMemorySize"] = self.gpuMemorySize!
        }
        if self.handler != nil {
            map["handler"] = self.handler!
        }
        if self.httpTriggerConfig != nil {
            map["httpTriggerConfig"] = self.httpTriggerConfig?.toMap()
        }
        if self.imageConfig != nil {
            map["imageConfig"] = self.imageConfig?.toMap()
        }
        if self.initializationTimeout != nil {
            map["initializationTimeout"] = self.initializationTimeout!
        }
        if self.initializer != nil {
            map["initializer"] = self.initializer!
        }
        if self.instanceConcurrency != nil {
            map["instanceConcurrency"] = self.instanceConcurrency!
        }
        if self.instanceLifecycleConfig != nil {
            map["instanceLifecycleConfig"] = self.instanceLifecycleConfig?.toMap()
        }
        if self.instanceSoftConcurrency != nil {
            map["instanceSoftConcurrency"] = self.instanceSoftConcurrency!
        }
        if self.instanceType != nil {
            map["instanceType"] = self.instanceType!
        }
        if self.internetAccess != nil {
            map["internetAccess"] = self.internetAccess!
        }
        if self.lastModifiedTime != nil {
            map["lastModifiedTime"] = self.lastModifiedTime!
        }
        if self.layers != nil {
            map["layers"] = self.layers!
        }
        if self.layersArnV2 != nil {
            map["layersArnV2"] = self.layersArnV2!
        }
        if self.livenessProbe != nil {
            map["livenessProbe"] = self.livenessProbe?.toMap()
        }
        if self.logConfig != nil {
            map["logConfig"] = self.logConfig?.toMap()
        }
        if self.memorySize != nil {
            map["memorySize"] = self.memorySize!
        }
        if self.namespace != nil {
            map["namespace"] = self.namespace!
        }
        if self.namespaceID != nil {
            map["namespaceID"] = self.namespaceID!
        }
        if self.namespaceName != nil {
            map["namespaceName"] = self.namespaceName!
        }
        if self.nasConfig != nil {
            map["nasConfig"] = self.nasConfig?.toMap()
        }
        if self.ossMountConfig != nil {
            map["ossMountConfig"] = self.ossMountConfig?.toMap()
        }
        if self.runtime != nil {
            map["runtime"] = self.runtime!
        }
        if self.scaleConfig != nil {
            map["scaleConfig"] = self.scaleConfig?.toMap()
        }
        if self.slsConfig != nil {
            map["slsConfig"] = self.slsConfig?.toMap()
        }
        if self.startupProbe != nil {
            map["startupProbe"] = self.startupProbe?.toMap()
        }
        if self.timeout != nil {
            map["timeout"] = self.timeout!
        }
        if self.tracingConfig != nil {
            map["tracingConfig"] = self.tracingConfig?.toMap()
        }
        if self.urlInternet != nil {
            map["urlInternet"] = self.urlInternet!
        }
        if self.urlIntranet != nil {
            map["urlIntranet"] = self.urlIntranet!
        }
        if self.version != nil {
            map["version"] = self.version?.toMap()
        }
        if self.vpcConfig != nil {
            map["vpcConfig"] = self.vpcConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("applicationID") {
            self.applicationID = dict["applicationID"] as! String
        }
        if dict.keys.contains("applicationId") {
            self.applicationId = dict["applicationId"] as! String
        }
        if dict.keys.contains("applicationName") {
            self.applicationName = dict["applicationName"] as! String
        }
        if dict.keys.contains("args") {
            self.args = dict["args"] as! String
        }
        if dict.keys.contains("caPort") {
            self.caPort = dict["caPort"] as! Int32
        }
        if dict.keys.contains("codeChecksum") {
            self.codeChecksum = dict["codeChecksum"] as! String
        }
        if dict.keys.contains("codeSize") {
            self.codeSize = dict["codeSize"] as! Int64
        }
        if dict.keys.contains("command") {
            self.command = dict["command"] as! String
        }
        if dict.keys.contains("cpu") {
            self.cpu = dict["cpu"] as! Double
        }
        if dict.keys.contains("createdTime") {
            self.createdTime = dict["createdTime"] as! String
        }
        if dict.keys.contains("customDNS") {
            var model = CustomDNS()
            model.fromMap(dict["customDNS"] as! [String: Any])
            self.customDNS = model
        }
        if dict.keys.contains("customDomainName") {
            self.customDomainName = dict["customDomainName"] as! String
        }
        if dict.keys.contains("customHealthCheckConfig") {
            var model = CustomHealthCheckConfig()
            model.fromMap(dict["customHealthCheckConfig"] as! [String: Any])
            self.customHealthCheckConfig = model
        }
        if dict.keys.contains("customRuntimeConfig") {
            var model = CustomRuntimeConfig()
            model.fromMap(dict["customRuntimeConfig"] as! [String: Any])
            self.customRuntimeConfig = model
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("diskSize") {
            self.diskSize = dict["diskSize"] as! Int32
        }
        if dict.keys.contains("enableAppMetric") {
            self.enableAppMetric = dict["enableAppMetric"] as! Bool
        }
        if dict.keys.contains("enableArmsAdvanced") {
            self.enableArmsAdvanced = dict["enableArmsAdvanced"] as! Bool
        }
        if dict.keys.contains("environmentVariables") {
            self.environmentVariables = dict["environmentVariables"] as! [String: String]
        }
        if dict.keys.contains("gpuMemorySize") {
            self.gpuMemorySize = dict["gpuMemorySize"] as! Int32
        }
        if dict.keys.contains("handler") {
            self.handler = dict["handler"] as! String
        }
        if dict.keys.contains("httpTriggerConfig") {
            var model = HTTPTriggerConfig()
            model.fromMap(dict["httpTriggerConfig"] as! [String: Any])
            self.httpTriggerConfig = model
        }
        if dict.keys.contains("imageConfig") {
            var model = ImageConfig()
            model.fromMap(dict["imageConfig"] as! [String: Any])
            self.imageConfig = model
        }
        if dict.keys.contains("initializationTimeout") {
            self.initializationTimeout = dict["initializationTimeout"] as! Int32
        }
        if dict.keys.contains("initializer") {
            self.initializer = dict["initializer"] as! String
        }
        if dict.keys.contains("instanceConcurrency") {
            self.instanceConcurrency = dict["instanceConcurrency"] as! Int32
        }
        if dict.keys.contains("instanceLifecycleConfig") {
            var model = InstanceLifecycleConfig()
            model.fromMap(dict["instanceLifecycleConfig"] as! [String: Any])
            self.instanceLifecycleConfig = model
        }
        if dict.keys.contains("instanceSoftConcurrency") {
            self.instanceSoftConcurrency = dict["instanceSoftConcurrency"] as! Int32
        }
        if dict.keys.contains("instanceType") {
            self.instanceType = dict["instanceType"] as! String
        }
        if dict.keys.contains("internetAccess") {
            self.internetAccess = dict["internetAccess"] as! Bool
        }
        if dict.keys.contains("lastModifiedTime") {
            self.lastModifiedTime = dict["lastModifiedTime"] as! String
        }
        if dict.keys.contains("layers") {
            self.layers = dict["layers"] as! [String]
        }
        if dict.keys.contains("layersArnV2") {
            self.layersArnV2 = dict["layersArnV2"] as! [String]
        }
        if dict.keys.contains("livenessProbe") {
            var model = Probe()
            model.fromMap(dict["livenessProbe"] as! [String: Any])
            self.livenessProbe = model
        }
        if dict.keys.contains("logConfig") {
            var model = LogConfig()
            model.fromMap(dict["logConfig"] as! [String: Any])
            self.logConfig = model
        }
        if dict.keys.contains("memorySize") {
            self.memorySize = dict["memorySize"] as! Int32
        }
        if dict.keys.contains("namespace") {
            self.namespace = dict["namespace"] as! String
        }
        if dict.keys.contains("namespaceID") {
            self.namespaceID = dict["namespaceID"] as! String
        }
        if dict.keys.contains("namespaceName") {
            self.namespaceName = dict["namespaceName"] as! String
        }
        if dict.keys.contains("nasConfig") {
            var model = NASConfig()
            model.fromMap(dict["nasConfig"] as! [String: Any])
            self.nasConfig = model
        }
        if dict.keys.contains("ossMountConfig") {
            var model = OSSMountConfig()
            model.fromMap(dict["ossMountConfig"] as! [String: Any])
            self.ossMountConfig = model
        }
        if dict.keys.contains("runtime") {
            self.runtime = dict["runtime"] as! String
        }
        if dict.keys.contains("scaleConfig") {
            var model = ScaleConfig()
            model.fromMap(dict["scaleConfig"] as! [String: Any])
            self.scaleConfig = model
        }
        if dict.keys.contains("slsConfig") {
            var model = SLSConfig()
            model.fromMap(dict["slsConfig"] as! [String: Any])
            self.slsConfig = model
        }
        if dict.keys.contains("startupProbe") {
            var model = Probe()
            model.fromMap(dict["startupProbe"] as! [String: Any])
            self.startupProbe = model
        }
        if dict.keys.contains("timeout") {
            self.timeout = dict["timeout"] as! Int32
        }
        if dict.keys.contains("tracingConfig") {
            var model = TracingConfig()
            model.fromMap(dict["tracingConfig"] as! [String: Any])
            self.tracingConfig = model
        }
        if dict.keys.contains("urlInternet") {
            self.urlInternet = dict["urlInternet"] as! String
        }
        if dict.keys.contains("urlIntranet") {
            self.urlIntranet = dict["urlIntranet"] as! String
        }
        if dict.keys.contains("version") {
            var model = Version()
            model.fromMap(dict["version"] as! [String: Any])
            self.version = model
        }
        if dict.keys.contains("vpcConfig") {
            var model = VPCConfig()
            model.fromMap(dict["vpcConfig"] as! [String: Any])
            self.vpcConfig = model
        }
    }
}

public class ApplicationStatus : Tea.TeaModel {
    public var instanceCount: Int64?

    public var scaleConfig: ScaleConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scaleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceCount != nil {
            map["instanceCount"] = self.instanceCount!
        }
        if self.scaleConfig != nil {
            map["scaleConfig"] = self.scaleConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("instanceCount") {
            self.instanceCount = dict["instanceCount"] as! Int64
        }
        if dict.keys.contains("scaleConfig") {
            var model = ScaleConfig()
            model.fromMap(dict["scaleConfig"] as! [String: Any])
            self.scaleConfig = model
        }
    }
}

public class ApplicationWithStatus : Tea.TeaModel {
    public var application: Application?

    public var status: ApplicationStatus?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.application?.validate()
        try self.status?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.application != nil {
            map["application"] = self.application?.toMap()
        }
        if self.status != nil {
            map["status"] = self.status?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("application") {
            var model = Application()
            model.fromMap(dict["application"] as! [String: Any])
            self.application = model
        }
        if dict.keys.contains("status") {
            var model = ApplicationStatus()
            model.fromMap(dict["status"] as! [String: Any])
            self.status = model
        }
    }
}

public class ArmsConfig : Tea.TeaModel {
    public var agentVersion: String?

    public var appId: String?

    public var licenseKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentVersion != nil {
            map["agentVersion"] = self.agentVersion!
        }
        if self.appId != nil {
            map["appId"] = self.appId!
        }
        if self.licenseKey != nil {
            map["licenseKey"] = self.licenseKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("agentVersion") {
            self.agentVersion = dict["agentVersion"] as! String
        }
        if dict.keys.contains("appId") {
            self.appId = dict["appId"] as! String
        }
        if dict.keys.contains("licenseKey") {
            self.licenseKey = dict["licenseKey"] as! String
        }
    }
}

public class BuildPipeline : Tea.TeaModel {
    public class BuildConfig : Tea.TeaModel {
        public var beforeBuildCommand: String?

        public var buildType: String?

        public var dockerfilePath: String?

        public var runCommand: String?

        public var runtimeType: String?

        public var runtimeVersion: String?

        public var tomcatConfig: TomcatConfig?

        public var workingDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.tomcatConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.beforeBuildCommand != nil {
                map["BeforeBuildCommand"] = self.beforeBuildCommand!
            }
            if self.buildType != nil {
                map["BuildType"] = self.buildType!
            }
            if self.dockerfilePath != nil {
                map["DockerfilePath"] = self.dockerfilePath!
            }
            if self.runCommand != nil {
                map["RunCommand"] = self.runCommand!
            }
            if self.runtimeType != nil {
                map["RuntimeType"] = self.runtimeType!
            }
            if self.runtimeVersion != nil {
                map["RuntimeVersion"] = self.runtimeVersion!
            }
            if self.tomcatConfig != nil {
                map["TomcatConfig"] = self.tomcatConfig?.toMap()
            }
            if self.workingDir != nil {
                map["WorkingDir"] = self.workingDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BeforeBuildCommand") {
                self.beforeBuildCommand = dict["BeforeBuildCommand"] as! String
            }
            if dict.keys.contains("BuildType") {
                self.buildType = dict["BuildType"] as! String
            }
            if dict.keys.contains("DockerfilePath") {
                self.dockerfilePath = dict["DockerfilePath"] as! String
            }
            if dict.keys.contains("RunCommand") {
                self.runCommand = dict["RunCommand"] as! String
            }
            if dict.keys.contains("RuntimeType") {
                self.runtimeType = dict["RuntimeType"] as! String
            }
            if dict.keys.contains("RuntimeVersion") {
                self.runtimeVersion = dict["RuntimeVersion"] as! String
            }
            if dict.keys.contains("TomcatConfig") {
                var model = TomcatConfig()
                model.fromMap(dict["TomcatConfig"] as! [String: Any])
                self.tomcatConfig = model
            }
            if dict.keys.contains("WorkingDir") {
                self.workingDir = dict["WorkingDir"] as! String
            }
        }
    }
    public class CodeConfig : Tea.TeaModel {
        public var accountId: String?

        public var branchName: String?

        public var commitId: String?

        public var commitUrl: String?

        public var organizationId: String?

        public var provider: String?

        public var repoFullName: String?

        public var repoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.branchName != nil {
                map["BranchName"] = self.branchName!
            }
            if self.commitId != nil {
                map["CommitId"] = self.commitId!
            }
            if self.commitUrl != nil {
                map["CommitUrl"] = self.commitUrl!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.provider != nil {
                map["Provider"] = self.provider!
            }
            if self.repoFullName != nil {
                map["RepoFullName"] = self.repoFullName!
            }
            if self.repoId != nil {
                map["RepoId"] = self.repoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountId") {
                self.accountId = dict["AccountId"] as! String
            }
            if dict.keys.contains("BranchName") {
                self.branchName = dict["BranchName"] as! String
            }
            if dict.keys.contains("CommitId") {
                self.commitId = dict["CommitId"] as! String
            }
            if dict.keys.contains("CommitUrl") {
                self.commitUrl = dict["CommitUrl"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
            if dict.keys.contains("Provider") {
                self.provider = dict["Provider"] as! String
            }
            if dict.keys.contains("RepoFullName") {
                self.repoFullName = dict["RepoFullName"] as! String
            }
            if dict.keys.contains("RepoId") {
                self.repoId = dict["RepoId"] as! String
            }
        }
    }
    public class DeployConfig : Tea.TeaModel {
        public var alwaysAllocateCPU: Bool?

        public var maximumInstanceCount: Int32?

        public var minimumInstanceCount: Int32?

        public var updateApplicationInput: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alwaysAllocateCPU != nil {
                map["AlwaysAllocateCPU"] = self.alwaysAllocateCPU!
            }
            if self.maximumInstanceCount != nil {
                map["MaximumInstanceCount"] = self.maximumInstanceCount!
            }
            if self.minimumInstanceCount != nil {
                map["MinimumInstanceCount"] = self.minimumInstanceCount!
            }
            if self.updateApplicationInput != nil {
                map["UpdateApplicationInput"] = self.updateApplicationInput!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlwaysAllocateCPU") {
                self.alwaysAllocateCPU = dict["AlwaysAllocateCPU"] as! Bool
            }
            if dict.keys.contains("MaximumInstanceCount") {
                self.maximumInstanceCount = dict["MaximumInstanceCount"] as! Int32
            }
            if dict.keys.contains("MinimumInstanceCount") {
                self.minimumInstanceCount = dict["MinimumInstanceCount"] as! Int32
            }
            if dict.keys.contains("UpdateApplicationInput") {
                self.updateApplicationInput = dict["UpdateApplicationInput"] as! String
            }
        }
    }
    public class ImageConfig : Tea.TeaModel {
        public var instanceType: String?

        public var namespace: String?

        public var repository: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.repository != nil {
                map["Repository"] = self.repository!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Repository") {
                self.repository = dict["Repository"] as! String
            }
        }
    }
    public class PackageConfig : Tea.TeaModel {
        public var packageName: String?

        public var packageType: String?

        public var packageUrl: String?

        public var packageVersion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.packageName != nil {
                map["PackageName"] = self.packageName!
            }
            if self.packageType != nil {
                map["PackageType"] = self.packageType!
            }
            if self.packageUrl != nil {
                map["PackageUrl"] = self.packageUrl!
            }
            if self.packageVersion != nil {
                map["PackageVersion"] = self.packageVersion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PackageName") {
                self.packageName = dict["PackageName"] as! String
            }
            if dict.keys.contains("PackageType") {
                self.packageType = dict["PackageType"] as! String
            }
            if dict.keys.contains("PackageUrl") {
                self.packageUrl = dict["PackageUrl"] as! String
            }
            if dict.keys.contains("PackageVersion") {
                self.packageVersion = dict["PackageVersion"] as! String
            }
        }
    }
    public class TriggerConfig : Tea.TeaModel {
        public var branchName: String?

        public var tagName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.branchName != nil {
                map["BranchName"] = self.branchName!
            }
            if self.tagName != nil {
                map["TagName"] = self.tagName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BranchName") {
                self.branchName = dict["BranchName"] as! String
            }
            if dict.keys.contains("TagName") {
                self.tagName = dict["TagName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var applicationId: String?

    public var applicationName: String?

    public var buildConfig: BuildPipeline.BuildConfig?

    public var codeConfig: BuildPipeline.CodeConfig?

    public var deployConfig: BuildPipeline.DeployConfig?

    public var enabled: Bool?

    public var imageConfig: BuildPipeline.ImageConfig?

    public var packageConfig: BuildPipeline.PackageConfig?

    public var triggerConfig: BuildPipeline.TriggerConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.buildConfig?.validate()
        try self.codeConfig?.validate()
        try self.deployConfig?.validate()
        try self.imageConfig?.validate()
        try self.packageConfig?.validate()
        try self.triggerConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.applicationName != nil {
            map["ApplicationName"] = self.applicationName!
        }
        if self.buildConfig != nil {
            map["BuildConfig"] = self.buildConfig?.toMap()
        }
        if self.codeConfig != nil {
            map["CodeConfig"] = self.codeConfig?.toMap()
        }
        if self.deployConfig != nil {
            map["DeployConfig"] = self.deployConfig?.toMap()
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.imageConfig != nil {
            map["ImageConfig"] = self.imageConfig?.toMap()
        }
        if self.packageConfig != nil {
            map["PackageConfig"] = self.packageConfig?.toMap()
        }
        if self.triggerConfig != nil {
            map["TriggerConfig"] = self.triggerConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationId") {
            self.applicationId = dict["ApplicationId"] as! String
        }
        if dict.keys.contains("ApplicationName") {
            self.applicationName = dict["ApplicationName"] as! String
        }
        if dict.keys.contains("BuildConfig") {
            var model = BuildPipeline.BuildConfig()
            model.fromMap(dict["BuildConfig"] as! [String: Any])
            self.buildConfig = model
        }
        if dict.keys.contains("CodeConfig") {
            var model = BuildPipeline.CodeConfig()
            model.fromMap(dict["CodeConfig"] as! [String: Any])
            self.codeConfig = model
        }
        if dict.keys.contains("DeployConfig") {
            var model = BuildPipeline.DeployConfig()
            model.fromMap(dict["DeployConfig"] as! [String: Any])
            self.deployConfig = model
        }
        if dict.keys.contains("Enabled") {
            self.enabled = dict["Enabled"] as! Bool
        }
        if dict.keys.contains("ImageConfig") {
            var model = BuildPipeline.ImageConfig()
            model.fromMap(dict["ImageConfig"] as! [String: Any])
            self.imageConfig = model
        }
        if dict.keys.contains("PackageConfig") {
            var model = BuildPipeline.PackageConfig()
            model.fromMap(dict["PackageConfig"] as! [String: Any])
            self.packageConfig = model
        }
        if dict.keys.contains("TriggerConfig") {
            var model = BuildPipeline.TriggerConfig()
            model.fromMap(dict["TriggerConfig"] as! [String: Any])
            self.triggerConfig = model
        }
    }
}

public class BuildPipelineRun : Tea.TeaModel {
    public class BuildConfig : Tea.TeaModel {
        public class Trigger : Tea.TeaModel {
            public var branchName: String?

            public var tagName: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.branchName != nil {
                    map["BranchName"] = self.branchName!
                }
                if self.tagName != nil {
                    map["TagName"] = self.tagName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BranchName") {
                    self.branchName = dict["BranchName"] as! String
                }
                if dict.keys.contains("TagName") {
                    self.tagName = dict["TagName"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var beforeBuildCommand: String?

        public var buildType: String?

        public var dockerfilePath: String?

        public var runCommand: String?

        public var runtimeType: String?

        public var runtimeVersion: String?

        public var tomcatConfig: TomcatConfig?

        public var trigger: BuildPipelineRun.BuildConfig.Trigger?

        public var workingDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.tomcatConfig?.validate()
            try self.trigger?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.beforeBuildCommand != nil {
                map["BeforeBuildCommand"] = self.beforeBuildCommand!
            }
            if self.buildType != nil {
                map["BuildType"] = self.buildType!
            }
            if self.dockerfilePath != nil {
                map["DockerfilePath"] = self.dockerfilePath!
            }
            if self.runCommand != nil {
                map["RunCommand"] = self.runCommand!
            }
            if self.runtimeType != nil {
                map["RuntimeType"] = self.runtimeType!
            }
            if self.runtimeVersion != nil {
                map["RuntimeVersion"] = self.runtimeVersion!
            }
            if self.tomcatConfig != nil {
                map["TomcatConfig"] = self.tomcatConfig?.toMap()
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger?.toMap()
            }
            if self.workingDir != nil {
                map["WorkingDir"] = self.workingDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BeforeBuildCommand") {
                self.beforeBuildCommand = dict["BeforeBuildCommand"] as! String
            }
            if dict.keys.contains("BuildType") {
                self.buildType = dict["BuildType"] as! String
            }
            if dict.keys.contains("DockerfilePath") {
                self.dockerfilePath = dict["DockerfilePath"] as! String
            }
            if dict.keys.contains("RunCommand") {
                self.runCommand = dict["RunCommand"] as! String
            }
            if dict.keys.contains("RuntimeType") {
                self.runtimeType = dict["RuntimeType"] as! String
            }
            if dict.keys.contains("RuntimeVersion") {
                self.runtimeVersion = dict["RuntimeVersion"] as! String
            }
            if dict.keys.contains("TomcatConfig") {
                var model = TomcatConfig()
                model.fromMap(dict["TomcatConfig"] as! [String: Any])
                self.tomcatConfig = model
            }
            if dict.keys.contains("Trigger") {
                var model = BuildPipelineRun.BuildConfig.Trigger()
                model.fromMap(dict["Trigger"] as! [String: Any])
                self.trigger = model
            }
            if dict.keys.contains("WorkingDir") {
                self.workingDir = dict["WorkingDir"] as! String
            }
        }
    }
    public class CodeConfig : Tea.TeaModel {
        public var accountId: String?

        public var branchName: String?

        public var commitId: String?

        public var commitUrl: String?

        public var organizationId: String?

        public var provider: String?

        public var repoFullName: String?

        public var repoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.branchName != nil {
                map["BranchName"] = self.branchName!
            }
            if self.commitId != nil {
                map["CommitId"] = self.commitId!
            }
            if self.commitUrl != nil {
                map["CommitUrl"] = self.commitUrl!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.provider != nil {
                map["Provider"] = self.provider!
            }
            if self.repoFullName != nil {
                map["RepoFullName"] = self.repoFullName!
            }
            if self.repoId != nil {
                map["RepoId"] = self.repoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountId") {
                self.accountId = dict["AccountId"] as! String
            }
            if dict.keys.contains("BranchName") {
                self.branchName = dict["BranchName"] as! String
            }
            if dict.keys.contains("CommitId") {
                self.commitId = dict["CommitId"] as! String
            }
            if dict.keys.contains("CommitUrl") {
                self.commitUrl = dict["CommitUrl"] as! String
            }
            if dict.keys.contains("OrganizationId") {
                self.organizationId = dict["OrganizationId"] as! String
            }
            if dict.keys.contains("Provider") {
                self.provider = dict["Provider"] as! String
            }
            if dict.keys.contains("RepoFullName") {
                self.repoFullName = dict["RepoFullName"] as! String
            }
            if dict.keys.contains("RepoId") {
                self.repoId = dict["RepoId"] as! String
            }
        }
    }
    public class DeployConfig : Tea.TeaModel {
        public var alwaysAllocateCPU: Bool?

        public var maximumInstanceCount: Int32?

        public var minimumInstanceCount: Int32?

        public var updateApplicationInput: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alwaysAllocateCPU != nil {
                map["AlwaysAllocateCPU"] = self.alwaysAllocateCPU!
            }
            if self.maximumInstanceCount != nil {
                map["MaximumInstanceCount"] = self.maximumInstanceCount!
            }
            if self.minimumInstanceCount != nil {
                map["MinimumInstanceCount"] = self.minimumInstanceCount!
            }
            if self.updateApplicationInput != nil {
                map["UpdateApplicationInput"] = self.updateApplicationInput!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlwaysAllocateCPU") {
                self.alwaysAllocateCPU = dict["AlwaysAllocateCPU"] as! Bool
            }
            if dict.keys.contains("MaximumInstanceCount") {
                self.maximumInstanceCount = dict["MaximumInstanceCount"] as! Int32
            }
            if dict.keys.contains("MinimumInstanceCount") {
                self.minimumInstanceCount = dict["MinimumInstanceCount"] as! Int32
            }
            if dict.keys.contains("UpdateApplicationInput") {
                self.updateApplicationInput = dict["UpdateApplicationInput"] as! String
            }
        }
    }
    public class ImageConfig : Tea.TeaModel {
        public var instanceType: String?

        public var namespace: String?

        public var repository: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.repository != nil {
                map["Repository"] = self.repository!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("Namespace") {
                self.namespace = dict["Namespace"] as! String
            }
            if dict.keys.contains("Repository") {
                self.repository = dict["Repository"] as! String
            }
        }
    }
    public class PackageConfig : Tea.TeaModel {
        public var packageName: String?

        public var packageType: String?

        public var packageUrl: String?

        public var packageVersion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.packageName != nil {
                map["PackageName"] = self.packageName!
            }
            if self.packageType != nil {
                map["PackageType"] = self.packageType!
            }
            if self.packageUrl != nil {
                map["PackageUrl"] = self.packageUrl!
            }
            if self.packageVersion != nil {
                map["PackageVersion"] = self.packageVersion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PackageName") {
                self.packageName = dict["PackageName"] as! String
            }
            if dict.keys.contains("PackageType") {
                self.packageType = dict["PackageType"] as! String
            }
            if dict.keys.contains("PackageUrl") {
                self.packageUrl = dict["PackageUrl"] as! String
            }
            if dict.keys.contains("PackageVersion") {
                self.packageVersion = dict["PackageVersion"] as! String
            }
        }
    }
    public class Steps : Tea.TeaModel {
        public var description_: String?

        public var duration: Int64?

        public var endTime: Int64?

        public var id: String?

        public var name: String?

        public var result: String?

        public var startTime: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class TriggerConfig : Tea.TeaModel {
        public var branchName: String?

        public var tagName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.branchName != nil {
                map["BranchName"] = self.branchName!
            }
            if self.tagName != nil {
                map["TagName"] = self.tagName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BranchName") {
                self.branchName = dict["BranchName"] as! String
            }
            if dict.keys.contains("TagName") {
                self.tagName = dict["TagName"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var buildConfig: BuildPipelineRun.BuildConfig?

    public var buildDuration: Int64?

    public var codeConfig: BuildPipelineRun.CodeConfig?

    public var createTime: Int64?

    public var deployConfig: BuildPipelineRun.DeployConfig?

    public var deployDuration: Int64?

    public var endTime: Int64?

    public var imageConfig: BuildPipelineRun.ImageConfig?

    public var packageConfig: BuildPipelineRun.PackageConfig?

    public var pipelineId: String?

    public var pipelineRunId: String?

    public var startTime: Int64?

    public var status: String?

    public var steps: [BuildPipelineRun.Steps]?

    public var triggerConfig: BuildPipelineRun.TriggerConfig?

    public var versionId: String?

    public var waitDuration: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.buildConfig?.validate()
        try self.codeConfig?.validate()
        try self.deployConfig?.validate()
        try self.imageConfig?.validate()
        try self.packageConfig?.validate()
        try self.triggerConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.buildConfig != nil {
            map["BuildConfig"] = self.buildConfig?.toMap()
        }
        if self.buildDuration != nil {
            map["BuildDuration"] = self.buildDuration!
        }
        if self.codeConfig != nil {
            map["CodeConfig"] = self.codeConfig?.toMap()
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.deployConfig != nil {
            map["DeployConfig"] = self.deployConfig?.toMap()
        }
        if self.deployDuration != nil {
            map["DeployDuration"] = self.deployDuration!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.imageConfig != nil {
            map["ImageConfig"] = self.imageConfig?.toMap()
        }
        if self.packageConfig != nil {
            map["PackageConfig"] = self.packageConfig?.toMap()
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.pipelineRunId != nil {
            map["PipelineRunId"] = self.pipelineRunId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.steps != nil {
            var tmp : [Any] = []
            for k in self.steps! {
                tmp.append(k.toMap())
            }
            map["Steps"] = tmp
        }
        if self.triggerConfig != nil {
            map["TriggerConfig"] = self.triggerConfig?.toMap()
        }
        if self.versionId != nil {
            map["VersionId"] = self.versionId!
        }
        if self.waitDuration != nil {
            map["WaitDuration"] = self.waitDuration!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BuildConfig") {
            var model = BuildPipelineRun.BuildConfig()
            model.fromMap(dict["BuildConfig"] as! [String: Any])
            self.buildConfig = model
        }
        if dict.keys.contains("BuildDuration") {
            self.buildDuration = dict["BuildDuration"] as! Int64
        }
        if dict.keys.contains("CodeConfig") {
            var model = BuildPipelineRun.CodeConfig()
            model.fromMap(dict["CodeConfig"] as! [String: Any])
            self.codeConfig = model
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("DeployConfig") {
            var model = BuildPipelineRun.DeployConfig()
            model.fromMap(dict["DeployConfig"] as! [String: Any])
            self.deployConfig = model
        }
        if dict.keys.contains("DeployDuration") {
            self.deployDuration = dict["DeployDuration"] as! Int64
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("ImageConfig") {
            var model = BuildPipelineRun.ImageConfig()
            model.fromMap(dict["ImageConfig"] as! [String: Any])
            self.imageConfig = model
        }
        if dict.keys.contains("PackageConfig") {
            var model = BuildPipelineRun.PackageConfig()
            model.fromMap(dict["PackageConfig"] as! [String: Any])
            self.packageConfig = model
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
        if dict.keys.contains("PipelineRunId") {
            self.pipelineRunId = dict["PipelineRunId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Steps") {
            var tmp : [BuildPipelineRun.Steps] = []
            for v in dict["Steps"] as! [Any] {
                var model = BuildPipelineRun.Steps()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.steps = tmp
        }
        if dict.keys.contains("TriggerConfig") {
            var model = BuildPipelineRun.TriggerConfig()
            model.fromMap(dict["TriggerConfig"] as! [String: Any])
            self.triggerConfig = model
        }
        if dict.keys.contains("VersionId") {
            self.versionId = dict["VersionId"] as! String
        }
        if dict.keys.contains("WaitDuration") {
            self.waitDuration = dict["WaitDuration"] as! Int64
        }
    }
}

public class BuildPipelineRunLogLine : Tea.TeaModel {
    public var content: String?

    public var offset: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Offset") {
            self.offset = dict["Offset"] as! Int64
        }
    }
}

public class CertConfig : Tea.TeaModel {
    public var certName: String?

    public var certificate: String?

    public var privateKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certName != nil {
            map["certName"] = self.certName!
        }
        if self.certificate != nil {
            map["certificate"] = self.certificate!
        }
        if self.privateKey != nil {
            map["privateKey"] = self.privateKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("certName") {
            self.certName = dict["certName"] as! String
        }
        if dict.keys.contains("certificate") {
            self.certificate = dict["certificate"] as! String
        }
        if dict.keys.contains("privateKey") {
            self.privateKey = dict["privateKey"] as! String
        }
    }
}

public class CreateApplicationInput : Tea.TeaModel {
    public var applicationName: String?

    public var args: String?

    public var caPort: Int32?

    public var code: InputCodeLocation?

    public var command: String?

    public var cpu: Double?

    public var customDNS: CustomDNS?

    public var customHealthCheckConfig: CustomHealthCheckConfig?

    public var customRuntimeConfig: CustomRuntimeConfig?

    public var description_: String?

    public var diskSize: Int32?

    public var environmentVariables: [String: String]?

    public var gpuMemorySize: Int32?

    public var handler: String?

    public var httpTriggerConfig: HTTPTriggerConfig?

    public var imageConfig: ImageConfig?

    public var initializationTimeout: Int32?

    public var initializer: String?

    public var instanceConcurrency: Int32?

    public var instanceLifecycleConfig: InstanceLifecycleConfig?

    public var instanceSoftConcurrency: Int32?

    public var instanceType: String?

    public var internetAccess: Bool?

    public var layers: [String]?

    public var livenessProbe: Probe?

    public var logConfig: LogConfig?

    public var memorySize: Int32?

    public var namespaceID: String?

    public var nasConfig: NASConfig?

    public var ossMountConfig: OSSMountConfig?

    public var runtime: String?

    public var scaleConfig: ScaleConfig?

    public var slsConfig: SLSConfig?

    public var startupProbe: Probe?

    public var timeout: Int32?

    public var tracingConfig: TracingConfig?

    public var vpcConfig: VPCConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.code?.validate()
        try self.customDNS?.validate()
        try self.customHealthCheckConfig?.validate()
        try self.customRuntimeConfig?.validate()
        try self.httpTriggerConfig?.validate()
        try self.imageConfig?.validate()
        try self.instanceLifecycleConfig?.validate()
        try self.livenessProbe?.validate()
        try self.logConfig?.validate()
        try self.nasConfig?.validate()
        try self.ossMountConfig?.validate()
        try self.scaleConfig?.validate()
        try self.slsConfig?.validate()
        try self.startupProbe?.validate()
        try self.tracingConfig?.validate()
        try self.vpcConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationName != nil {
            map["applicationName"] = self.applicationName!
        }
        if self.args != nil {
            map["args"] = self.args!
        }
        if self.caPort != nil {
            map["caPort"] = self.caPort!
        }
        if self.code != nil {
            map["code"] = self.code?.toMap()
        }
        if self.command != nil {
            map["command"] = self.command!
        }
        if self.cpu != nil {
            map["cpu"] = self.cpu!
        }
        if self.customDNS != nil {
            map["customDNS"] = self.customDNS?.toMap()
        }
        if self.customHealthCheckConfig != nil {
            map["customHealthCheckConfig"] = self.customHealthCheckConfig?.toMap()
        }
        if self.customRuntimeConfig != nil {
            map["customRuntimeConfig"] = self.customRuntimeConfig?.toMap()
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.diskSize != nil {
            map["diskSize"] = self.diskSize!
        }
        if self.environmentVariables != nil {
            map["environmentVariables"] = self.environmentVariables!
        }
        if self.gpuMemorySize != nil {
            map["gpuMemorySize"] = self.gpuMemorySize!
        }
        if self.handler != nil {
            map["handler"] = self.handler!
        }
        if self.httpTriggerConfig != nil {
            map["httpTriggerConfig"] = self.httpTriggerConfig?.toMap()
        }
        if self.imageConfig != nil {
            map["imageConfig"] = self.imageConfig?.toMap()
        }
        if self.initializationTimeout != nil {
            map["initializationTimeout"] = self.initializationTimeout!
        }
        if self.initializer != nil {
            map["initializer"] = self.initializer!
        }
        if self.instanceConcurrency != nil {
            map["instanceConcurrency"] = self.instanceConcurrency!
        }
        if self.instanceLifecycleConfig != nil {
            map["instanceLifecycleConfig"] = self.instanceLifecycleConfig?.toMap()
        }
        if self.instanceSoftConcurrency != nil {
            map["instanceSoftConcurrency"] = self.instanceSoftConcurrency!
        }
        if self.instanceType != nil {
            map["instanceType"] = self.instanceType!
        }
        if self.internetAccess != nil {
            map["internetAccess"] = self.internetAccess!
        }
        if self.layers != nil {
            map["layers"] = self.layers!
        }
        if self.livenessProbe != nil {
            map["livenessProbe"] = self.livenessProbe?.toMap()
        }
        if self.logConfig != nil {
            map["logConfig"] = self.logConfig?.toMap()
        }
        if self.memorySize != nil {
            map["memorySize"] = self.memorySize!
        }
        if self.namespaceID != nil {
            map["namespaceID"] = self.namespaceID!
        }
        if self.nasConfig != nil {
            map["nasConfig"] = self.nasConfig?.toMap()
        }
        if self.ossMountConfig != nil {
            map["ossMountConfig"] = self.ossMountConfig?.toMap()
        }
        if self.runtime != nil {
            map["runtime"] = self.runtime!
        }
        if self.scaleConfig != nil {
            map["scaleConfig"] = self.scaleConfig?.toMap()
        }
        if self.slsConfig != nil {
            map["slsConfig"] = self.slsConfig?.toMap()
        }
        if self.startupProbe != nil {
            map["startupProbe"] = self.startupProbe?.toMap()
        }
        if self.timeout != nil {
            map["timeout"] = self.timeout!
        }
        if self.tracingConfig != nil {
            map["tracingConfig"] = self.tracingConfig?.toMap()
        }
        if self.vpcConfig != nil {
            map["vpcConfig"] = self.vpcConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("applicationName") {
            self.applicationName = dict["applicationName"] as! String
        }
        if dict.keys.contains("args") {
            self.args = dict["args"] as! String
        }
        if dict.keys.contains("caPort") {
            self.caPort = dict["caPort"] as! Int32
        }
        if dict.keys.contains("code") {
            var model = InputCodeLocation()
            model.fromMap(dict["code"] as! [String: Any])
            self.code = model
        }
        if dict.keys.contains("command") {
            self.command = dict["command"] as! String
        }
        if dict.keys.contains("cpu") {
            self.cpu = dict["cpu"] as! Double
        }
        if dict.keys.contains("customDNS") {
            var model = CustomDNS()
            model.fromMap(dict["customDNS"] as! [String: Any])
            self.customDNS = model
        }
        if dict.keys.contains("customHealthCheckConfig") {
            var model = CustomHealthCheckConfig()
            model.fromMap(dict["customHealthCheckConfig"] as! [String: Any])
            self.customHealthCheckConfig = model
        }
        if dict.keys.contains("customRuntimeConfig") {
            var model = CustomRuntimeConfig()
            model.fromMap(dict["customRuntimeConfig"] as! [String: Any])
            self.customRuntimeConfig = model
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("diskSize") {
            self.diskSize = dict["diskSize"] as! Int32
        }
        if dict.keys.contains("environmentVariables") {
            self.environmentVariables = dict["environmentVariables"] as! [String: String]
        }
        if dict.keys.contains("gpuMemorySize") {
            self.gpuMemorySize = dict["gpuMemorySize"] as! Int32
        }
        if dict.keys.contains("handler") {
            self.handler = dict["handler"] as! String
        }
        if dict.keys.contains("httpTriggerConfig") {
            var model = HTTPTriggerConfig()
            model.fromMap(dict["httpTriggerConfig"] as! [String: Any])
            self.httpTriggerConfig = model
        }
        if dict.keys.contains("imageConfig") {
            var model = ImageConfig()
            model.fromMap(dict["imageConfig"] as! [String: Any])
            self.imageConfig = model
        }
        if dict.keys.contains("initializationTimeout") {
            self.initializationTimeout = dict["initializationTimeout"] as! Int32
        }
        if dict.keys.contains("initializer") {
            self.initializer = dict["initializer"] as! String
        }
        if dict.keys.contains("instanceConcurrency") {
            self.instanceConcurrency = dict["instanceConcurrency"] as! Int32
        }
        if dict.keys.contains("instanceLifecycleConfig") {
            var model = InstanceLifecycleConfig()
            model.fromMap(dict["instanceLifecycleConfig"] as! [String: Any])
            self.instanceLifecycleConfig = model
        }
        if dict.keys.contains("instanceSoftConcurrency") {
            self.instanceSoftConcurrency = dict["instanceSoftConcurrency"] as! Int32
        }
        if dict.keys.contains("instanceType") {
            self.instanceType = dict["instanceType"] as! String
        }
        if dict.keys.contains("internetAccess") {
            self.internetAccess = dict["internetAccess"] as! Bool
        }
        if dict.keys.contains("layers") {
            self.layers = dict["layers"] as! [String]
        }
        if dict.keys.contains("livenessProbe") {
            var model = Probe()
            model.fromMap(dict["livenessProbe"] as! [String: Any])
            self.livenessProbe = model
        }
        if dict.keys.contains("logConfig") {
            var model = LogConfig()
            model.fromMap(dict["logConfig"] as! [String: Any])
            self.logConfig = model
        }
        if dict.keys.contains("memorySize") {
            self.memorySize = dict["memorySize"] as! Int32
        }
        if dict.keys.contains("namespaceID") {
            self.namespaceID = dict["namespaceID"] as! String
        }
        if dict.keys.contains("nasConfig") {
            var model = NASConfig()
            model.fromMap(dict["nasConfig"] as! [String: Any])
            self.nasConfig = model
        }
        if dict.keys.contains("ossMountConfig") {
            var model = OSSMountConfig()
            model.fromMap(dict["ossMountConfig"] as! [String: Any])
            self.ossMountConfig = model
        }
        if dict.keys.contains("runtime") {
            self.runtime = dict["runtime"] as! String
        }
        if dict.keys.contains("scaleConfig") {
            var model = ScaleConfig()
            model.fromMap(dict["scaleConfig"] as! [String: Any])
            self.scaleConfig = model
        }
        if dict.keys.contains("slsConfig") {
            var model = SLSConfig()
            model.fromMap(dict["slsConfig"] as! [String: Any])
            self.slsConfig = model
        }
        if dict.keys.contains("startupProbe") {
            var model = Probe()
            model.fromMap(dict["startupProbe"] as! [String: Any])
            self.startupProbe = model
        }
        if dict.keys.contains("timeout") {
            self.timeout = dict["timeout"] as! Int32
        }
        if dict.keys.contains("tracingConfig") {
            var model = TracingConfig()
            model.fromMap(dict["tracingConfig"] as! [String: Any])
            self.tracingConfig = model
        }
        if dict.keys.contains("vpcConfig") {
            var model = VPCConfig()
            model.fromMap(dict["vpcConfig"] as! [String: Any])
            self.vpcConfig = model
        }
    }
}

public class CreateCustomDomainInput : Tea.TeaModel {
    public var applicationName: String?

    public var certConfig: CertConfig?

    public var domainName: String?

    public var keepFullPath: Bool?

    public var namespaceID: String?

    public var protocol_: String?

    public var tlsConfig: TLSConfig?

    public var wafConfig: WAFConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.certConfig?.validate()
        try self.tlsConfig?.validate()
        try self.wafConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationName != nil {
            map["applicationName"] = self.applicationName!
        }
        if self.certConfig != nil {
            map["certConfig"] = self.certConfig?.toMap()
        }
        if self.domainName != nil {
            map["domainName"] = self.domainName!
        }
        if self.keepFullPath != nil {
            map["keepFullPath"] = self.keepFullPath!
        }
        if self.namespaceID != nil {
            map["namespaceID"] = self.namespaceID!
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.tlsConfig != nil {
            map["tlsConfig"] = self.tlsConfig?.toMap()
        }
        if self.wafConfig != nil {
            map["wafConfig"] = self.wafConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("applicationName") {
            self.applicationName = dict["applicationName"] as! String
        }
        if dict.keys.contains("certConfig") {
            var model = CertConfig()
            model.fromMap(dict["certConfig"] as! [String: Any])
            self.certConfig = model
        }
        if dict.keys.contains("domainName") {
            self.domainName = dict["domainName"] as! String
        }
        if dict.keys.contains("keepFullPath") {
            self.keepFullPath = dict["keepFullPath"] as! Bool
        }
        if dict.keys.contains("namespaceID") {
            self.namespaceID = dict["namespaceID"] as! String
        }
        if dict.keys.contains("protocol") {
            self.protocol_ = dict["protocol"] as! String
        }
        if dict.keys.contains("tlsConfig") {
            var model = TLSConfig()
            model.fromMap(dict["tlsConfig"] as! [String: Any])
            self.tlsConfig = model
        }
        if dict.keys.contains("wafConfig") {
            var model = WAFConfig()
            model.fromMap(dict["wafConfig"] as! [String: Any])
            self.wafConfig = model
        }
    }
}

public class CreateSlsIndexRequest : Tea.TeaModel {
    public var logstore: String?

    public var project: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logstore != nil {
            map["logstore"] = self.logstore!
        }
        if self.project != nil {
            map["project"] = self.project!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("logstore") {
            self.logstore = dict["logstore"] as! String
        }
        if dict.keys.contains("project") {
            self.project = dict["project"] as! String
        }
    }
}

public class CreateSlsIndexResponse : Tea.TeaModel {
    public var requestId: String?

    public var logStore: String?

    public var project: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.logStore != nil {
            map["logStore"] = self.logStore!
        }
        if self.project != nil {
            map["project"] = self.project!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("logStore") {
            self.logStore = dict["logStore"] as! String
        }
        if dict.keys.contains("project") {
            self.project = dict["project"] as! String
        }
    }
}

public class CreateSlsResourceResponse : Tea.TeaModel {
    public var logStore: String?

    public var project: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logStore != nil {
            map["logStore"] = self.logStore!
        }
        if self.project != nil {
            map["project"] = self.project!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("logStore") {
            self.logStore = dict["logStore"] as! String
        }
        if dict.keys.contains("project") {
            self.project = dict["project"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class CustomDNS : Tea.TeaModel {
    public var dnsOptions: [DNSOption]?

    public var nameServers: [String]?

    public var searches: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dnsOptions != nil {
            var tmp : [Any] = []
            for k in self.dnsOptions! {
                tmp.append(k.toMap())
            }
            map["dnsOptions"] = tmp
        }
        if self.nameServers != nil {
            map["nameServers"] = self.nameServers!
        }
        if self.searches != nil {
            map["searches"] = self.searches!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("dnsOptions") {
            var tmp : [DNSOption] = []
            for v in dict["dnsOptions"] as! [Any] {
                var model = DNSOption()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dnsOptions = tmp
        }
        if dict.keys.contains("nameServers") {
            self.nameServers = dict["nameServers"] as! [String]
        }
        if dict.keys.contains("searches") {
            self.searches = dict["searches"] as! [String]
        }
    }
}

public class CustomDomain : Tea.TeaModel {
    public var accountId: String?

    public var apiVersion: String?

    public var certConfig: CertConfig?

    public var createdTime: String?

    public var domainName: String?

    public var keepFullPath: Bool?

    public var lastModifiedTime: String?

    public var namespaceID: String?

    public var protocol_: String?

    public var requestId: String?

    public var routeConfig: RouteConfig?

    public var subdomainCount: String?

    public var tlsConfig: TLSConfig?

    public var wafConfig: WAFConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.certConfig?.validate()
        try self.routeConfig?.validate()
        try self.tlsConfig?.validate()
        try self.wafConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["accountId"] = self.accountId!
        }
        if self.apiVersion != nil {
            map["apiVersion"] = self.apiVersion!
        }
        if self.certConfig != nil {
            map["certConfig"] = self.certConfig?.toMap()
        }
        if self.createdTime != nil {
            map["createdTime"] = self.createdTime!
        }
        if self.domainName != nil {
            map["domainName"] = self.domainName!
        }
        if self.keepFullPath != nil {
            map["keepFullPath"] = self.keepFullPath!
        }
        if self.lastModifiedTime != nil {
            map["lastModifiedTime"] = self.lastModifiedTime!
        }
        if self.namespaceID != nil {
            map["namespaceID"] = self.namespaceID!
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.routeConfig != nil {
            map["routeConfig"] = self.routeConfig?.toMap()
        }
        if self.subdomainCount != nil {
            map["subdomainCount"] = self.subdomainCount!
        }
        if self.tlsConfig != nil {
            map["tlsConfig"] = self.tlsConfig?.toMap()
        }
        if self.wafConfig != nil {
            map["wafConfig"] = self.wafConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accountId") {
            self.accountId = dict["accountId"] as! String
        }
        if dict.keys.contains("apiVersion") {
            self.apiVersion = dict["apiVersion"] as! String
        }
        if dict.keys.contains("certConfig") {
            var model = CertConfig()
            model.fromMap(dict["certConfig"] as! [String: Any])
            self.certConfig = model
        }
        if dict.keys.contains("createdTime") {
            self.createdTime = dict["createdTime"] as! String
        }
        if dict.keys.contains("domainName") {
            self.domainName = dict["domainName"] as! String
        }
        if dict.keys.contains("keepFullPath") {
            self.keepFullPath = dict["keepFullPath"] as! Bool
        }
        if dict.keys.contains("lastModifiedTime") {
            self.lastModifiedTime = dict["lastModifiedTime"] as! String
        }
        if dict.keys.contains("namespaceID") {
            self.namespaceID = dict["namespaceID"] as! String
        }
        if dict.keys.contains("protocol") {
            self.protocol_ = dict["protocol"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("routeConfig") {
            var model = RouteConfig()
            model.fromMap(dict["routeConfig"] as! [String: Any])
            self.routeConfig = model
        }
        if dict.keys.contains("subdomainCount") {
            self.subdomainCount = dict["subdomainCount"] as! String
        }
        if dict.keys.contains("tlsConfig") {
            var model = TLSConfig()
            model.fromMap(dict["tlsConfig"] as! [String: Any])
            self.tlsConfig = model
        }
        if dict.keys.contains("wafConfig") {
            var model = WAFConfig()
            model.fromMap(dict["wafConfig"] as! [String: Any])
            self.wafConfig = model
        }
    }
}

public class CustomHealthCheckConfig : Tea.TeaModel {
    public var failureThreshold: Int32?

    public var httpGetUrl: String?

    public var initialDelaySeconds: Int32?

    public var periodSeconds: Int32?

    public var successThreshold: Int32?

    public var timeoutSeconds: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failureThreshold != nil {
            map["failureThreshold"] = self.failureThreshold!
        }
        if self.httpGetUrl != nil {
            map["httpGetUrl"] = self.httpGetUrl!
        }
        if self.initialDelaySeconds != nil {
            map["initialDelaySeconds"] = self.initialDelaySeconds!
        }
        if self.periodSeconds != nil {
            map["periodSeconds"] = self.periodSeconds!
        }
        if self.successThreshold != nil {
            map["successThreshold"] = self.successThreshold!
        }
        if self.timeoutSeconds != nil {
            map["timeoutSeconds"] = self.timeoutSeconds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("failureThreshold") {
            self.failureThreshold = dict["failureThreshold"] as! Int32
        }
        if dict.keys.contains("httpGetUrl") {
            self.httpGetUrl = dict["httpGetUrl"] as! String
        }
        if dict.keys.contains("initialDelaySeconds") {
            self.initialDelaySeconds = dict["initialDelaySeconds"] as! Int32
        }
        if dict.keys.contains("periodSeconds") {
            self.periodSeconds = dict["periodSeconds"] as! Int32
        }
        if dict.keys.contains("successThreshold") {
            self.successThreshold = dict["successThreshold"] as! Int32
        }
        if dict.keys.contains("timeoutSeconds") {
            self.timeoutSeconds = dict["timeoutSeconds"] as! Int32
        }
    }
}

public class CustomRuntimeConfig : Tea.TeaModel {
    public var args: [String]?

    public var command: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.args != nil {
            map["args"] = self.args!
        }
        if self.command != nil {
            map["command"] = self.command!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("args") {
            self.args = dict["args"] as! [String]
        }
        if dict.keys.contains("command") {
            self.command = dict["command"] as! [String]
        }
    }
}

public class DNSOption : Tea.TeaModel {
    public var name: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.value != nil {
            map["value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("value") {
            self.value = dict["value"] as! String
        }
    }
}

public class GetApplicationLogsInput : Tea.TeaModel {
    public var backwardLine: Int64?

    public var endTime: Int64?

    public var forwardLine: Int64?

    public var instanceID: String?

    public var isTail: Bool?

    public var match: String?

    public var message: String?

    public var offset: Int64?

    public var packID: String?

    public var packMeta: String?

    public var startTime: Int64?

    public var timestamp: String?

    public var versionID: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backwardLine != nil {
            map["backwardLine"] = self.backwardLine!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.forwardLine != nil {
            map["forwardLine"] = self.forwardLine!
        }
        if self.instanceID != nil {
            map["instanceID"] = self.instanceID!
        }
        if self.isTail != nil {
            map["isTail"] = self.isTail!
        }
        if self.match != nil {
            map["match"] = self.match!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.offset != nil {
            map["offset"] = self.offset!
        }
        if self.packID != nil {
            map["packID"] = self.packID!
        }
        if self.packMeta != nil {
            map["packMeta"] = self.packMeta!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        if self.versionID != nil {
            map["versionID"] = self.versionID!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("backwardLine") {
            self.backwardLine = dict["backwardLine"] as! Int64
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("forwardLine") {
            self.forwardLine = dict["forwardLine"] as! Int64
        }
        if dict.keys.contains("instanceID") {
            self.instanceID = dict["instanceID"] as! String
        }
        if dict.keys.contains("isTail") {
            self.isTail = dict["isTail"] as! Bool
        }
        if dict.keys.contains("match") {
            self.match = dict["match"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("offset") {
            self.offset = dict["offset"] as! Int64
        }
        if dict.keys.contains("packID") {
            self.packID = dict["packID"] as! String
        }
        if dict.keys.contains("packMeta") {
            self.packMeta = dict["packMeta"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("timestamp") {
            self.timestamp = dict["timestamp"] as! String
        }
        if dict.keys.contains("versionID") {
            self.versionID = dict["versionID"] as! String
        }
    }
}

public class GetApplicationLogsOutput : Tea.TeaModel {
    public var logEntrys: [LogEntry]?

    public var nextOffset: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logEntrys != nil {
            var tmp : [Any] = []
            for k in self.logEntrys! {
                tmp.append(k.toMap())
            }
            map["logEntrys"] = tmp
        }
        if self.nextOffset != nil {
            map["nextOffset"] = self.nextOffset!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("logEntrys") {
            var tmp : [LogEntry] = []
            for v in dict["logEntrys"] as! [Any] {
                var model = LogEntry()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.logEntrys = tmp
        }
        if dict.keys.contains("nextOffset") {
            self.nextOffset = dict["nextOffset"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetInstanceLogsInput : Tea.TeaModel {
    public var backwardLine: Int64?

    public var endTime: Int64?

    public var forwardLine: Int64?

    public var isTail: Bool?

    public var match: String?

    public var message: String?

    public var offset: Int64?

    public var packID: String?

    public var packMeta: String?

    public var startTime: Int64?

    public var timestamp: String?

    public var versionID: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backwardLine != nil {
            map["backwardLine"] = self.backwardLine!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.forwardLine != nil {
            map["forwardLine"] = self.forwardLine!
        }
        if self.isTail != nil {
            map["isTail"] = self.isTail!
        }
        if self.match != nil {
            map["match"] = self.match!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.offset != nil {
            map["offset"] = self.offset!
        }
        if self.packID != nil {
            map["packID"] = self.packID!
        }
        if self.packMeta != nil {
            map["packMeta"] = self.packMeta!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        if self.versionID != nil {
            map["versionID"] = self.versionID!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("backwardLine") {
            self.backwardLine = dict["backwardLine"] as! Int64
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("forwardLine") {
            self.forwardLine = dict["forwardLine"] as! Int64
        }
        if dict.keys.contains("isTail") {
            self.isTail = dict["isTail"] as! Bool
        }
        if dict.keys.contains("match") {
            self.match = dict["match"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("offset") {
            self.offset = dict["offset"] as! Int64
        }
        if dict.keys.contains("packID") {
            self.packID = dict["packID"] as! String
        }
        if dict.keys.contains("packMeta") {
            self.packMeta = dict["packMeta"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("timestamp") {
            self.timestamp = dict["timestamp"] as! String
        }
        if dict.keys.contains("versionID") {
            self.versionID = dict["versionID"] as! String
        }
    }
}

public class GetInstanceLogsOutput : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") {
            self.data = dict["data"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetPerRequestLogsInput : Tea.TeaModel {
    public var endTime: Int64?

    public var errorType: String?

    public var forwardLine: Int64?

    public var instanceID: String?

    public var isColdStart: Bool?

    public var requestID: String?

    public var startTime: Int64?

    public var timestamp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.errorType != nil {
            map["errorType"] = self.errorType!
        }
        if self.forwardLine != nil {
            map["forwardLine"] = self.forwardLine!
        }
        if self.instanceID != nil {
            map["instanceID"] = self.instanceID!
        }
        if self.isColdStart != nil {
            map["isColdStart"] = self.isColdStart!
        }
        if self.requestID != nil {
            map["requestID"] = self.requestID!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("errorType") {
            self.errorType = dict["errorType"] as! String
        }
        if dict.keys.contains("forwardLine") {
            self.forwardLine = dict["forwardLine"] as! Int64
        }
        if dict.keys.contains("instanceID") {
            self.instanceID = dict["instanceID"] as! String
        }
        if dict.keys.contains("isColdStart") {
            self.isColdStart = dict["isColdStart"] as! Bool
        }
        if dict.keys.contains("requestID") {
            self.requestID = dict["requestID"] as! String
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("timestamp") {
            self.timestamp = dict["timestamp"] as! String
        }
    }
}

public class GetPerRequestLogsOutput : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("data") {
            self.data = dict["data"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class GetQuotaOutput : Tea.TeaModel {
    public var requestId: String?

    public var instanceLimit: Int64?

    public var instanceUsed: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.instanceLimit != nil {
            map["instanceLimit"] = self.instanceLimit!
        }
        if self.instanceUsed != nil {
            map["instanceUsed"] = self.instanceUsed!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("instanceLimit") {
            self.instanceLimit = dict["instanceLimit"] as! Int64
        }
        if dict.keys.contains("instanceUsed") {
            self.instanceUsed = dict["instanceUsed"] as! Int64
        }
    }
}

public class HTTPTriggerConfig : Tea.TeaModel {
    public var aclConfig: AclConfig?

    public var authConfig: Any?

    public var authType: String?

    public var disableURLInternet: Bool?

    public var safeMode: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.aclConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclConfig != nil {
            map["aclConfig"] = self.aclConfig?.toMap()
        }
        if self.authConfig != nil {
            map["authConfig"] = self.authConfig!
        }
        if self.authType != nil {
            map["authType"] = self.authType!
        }
        if self.disableURLInternet != nil {
            map["disableURLInternet"] = self.disableURLInternet!
        }
        if self.safeMode != nil {
            map["safeMode"] = self.safeMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("aclConfig") {
            var model = AclConfig()
            model.fromMap(dict["aclConfig"] as! [String: Any])
            self.aclConfig = model
        }
        if dict.keys.contains("authConfig") {
            self.authConfig = dict["authConfig"] as! Any
        }
        if dict.keys.contains("authType") {
            self.authType = dict["authType"] as! String
        }
        if dict.keys.contains("disableURLInternet") {
            self.disableURLInternet = dict["disableURLInternet"] as! Bool
        }
        if dict.keys.contains("safeMode") {
            self.safeMode = dict["safeMode"] as! Bool
        }
    }
}

public class ImageConfig : Tea.TeaModel {
    public var accelerationType: String?

    public var image: String?

    public var instanceID: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerationType != nil {
            map["accelerationType"] = self.accelerationType!
        }
        if self.image != nil {
            map["image"] = self.image!
        }
        if self.instanceID != nil {
            map["instanceID"] = self.instanceID!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accelerationType") {
            self.accelerationType = dict["accelerationType"] as! String
        }
        if dict.keys.contains("image") {
            self.image = dict["image"] as! String
        }
        if dict.keys.contains("instanceID") {
            self.instanceID = dict["instanceID"] as! String
        }
    }
}

public class InputCodeLocation : Tea.TeaModel {
    public var ossBucketName: String?

    public var ossObjectName: String?

    public var zipFile: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ossBucketName != nil {
            map["ossBucketName"] = self.ossBucketName!
        }
        if self.ossObjectName != nil {
            map["ossObjectName"] = self.ossObjectName!
        }
        if self.zipFile != nil {
            map["zipFile"] = self.zipFile!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ossBucketName") {
            self.ossBucketName = dict["ossBucketName"] as! String
        }
        if dict.keys.contains("ossObjectName") {
            self.ossObjectName = dict["ossObjectName"] as! String
        }
        if dict.keys.contains("zipFile") {
            self.zipFile = dict["zipFile"] as! String
        }
    }
}

public class InstanceExecAuthorizationInput : Tea.TeaModel {
    public var options: InstanceExecAuthorizationInputOptions?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.options?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.options != nil {
            map["options"] = self.options?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("options") {
            var model = InstanceExecAuthorizationInputOptions()
            model.fromMap(dict["options"] as! [String: Any])
            self.options = model
        }
    }
}

public class InstanceExecAuthorizationInputOptions : Tea.TeaModel {
    public var command: [String]?

    public var stderr: Bool?

    public var stdin: Bool?

    public var stdout: Bool?

    public var tty: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.command != nil {
            map["command"] = self.command!
        }
        if self.stderr != nil {
            map["stderr"] = self.stderr!
        }
        if self.stdin != nil {
            map["stdin"] = self.stdin!
        }
        if self.stdout != nil {
            map["stdout"] = self.stdout!
        }
        if self.tty != nil {
            map["tty"] = self.tty!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("command") {
            self.command = dict["command"] as! [String]
        }
        if dict.keys.contains("stderr") {
            self.stderr = dict["stderr"] as! Bool
        }
        if dict.keys.contains("stdin") {
            self.stdin = dict["stdin"] as! Bool
        }
        if dict.keys.contains("stdout") {
            self.stdout = dict["stdout"] as! Bool
        }
        if dict.keys.contains("tty") {
            self.tty = dict["tty"] as! Bool
        }
    }
}

public class InstanceExecAuthorizationOutput : Tea.TeaModel {
    public var accessKeyId: String?

    public var accountId: String?

    public var authorization: String?

    public var date: String?

    public var endpoint: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessKeyId != nil {
            map["accessKeyId"] = self.accessKeyId!
        }
        if self.accountId != nil {
            map["accountId"] = self.accountId!
        }
        if self.authorization != nil {
            map["authorization"] = self.authorization!
        }
        if self.date != nil {
            map["date"] = self.date!
        }
        if self.endpoint != nil {
            map["endpoint"] = self.endpoint!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("accessKeyId") {
            self.accessKeyId = dict["accessKeyId"] as! String
        }
        if dict.keys.contains("accountId") {
            self.accountId = dict["accountId"] as! String
        }
        if dict.keys.contains("authorization") {
            self.authorization = dict["authorization"] as! String
        }
        if dict.keys.contains("date") {
            self.date = dict["date"] as! String
        }
        if dict.keys.contains("endpoint") {
            self.endpoint = dict["endpoint"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class InstanceInfo : Tea.TeaModel {
    public var imageUrl: String?

    public var instanceId: String?

    public var status: String?

    public var versionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageUrl != nil {
            map["imageUrl"] = self.imageUrl!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.versionId != nil {
            map["versionId"] = self.versionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("imageUrl") {
            self.imageUrl = dict["imageUrl"] as! String
        }
        if dict.keys.contains("instanceId") {
            self.instanceId = dict["instanceId"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("versionId") {
            self.versionId = dict["versionId"] as! String
        }
    }
}

public class InstanceLifecycleConfig : Tea.TeaModel {
    public var preFreeze: LifecycleHook?

    public var preStop: LifecycleHook?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.preFreeze?.validate()
        try self.preStop?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.preFreeze != nil {
            map["preFreeze"] = self.preFreeze?.toMap()
        }
        if self.preStop != nil {
            map["preStop"] = self.preStop?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("preFreeze") {
            var model = LifecycleHook()
            model.fromMap(dict["preFreeze"] as! [String: Any])
            self.preFreeze = model
        }
        if dict.keys.contains("preStop") {
            var model = LifecycleHook()
            model.fromMap(dict["preStop"] as! [String: Any])
            self.preStop = model
        }
    }
}

public class InstanceMetricInfo : Tea.TeaModel {
    public var applicationID: String?

    public var cpuPercent: Double?

    public var cpuQuotaPercent: Double?

    public var instanceID: String?

    public var memoryLimitMB: Double?

    public var memoryUsageMB: Double?

    public var timestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationID != nil {
            map["applicationID"] = self.applicationID!
        }
        if self.cpuPercent != nil {
            map["cpuPercent"] = self.cpuPercent!
        }
        if self.cpuQuotaPercent != nil {
            map["cpuQuotaPercent"] = self.cpuQuotaPercent!
        }
        if self.instanceID != nil {
            map["instanceID"] = self.instanceID!
        }
        if self.memoryLimitMB != nil {
            map["memoryLimitMB"] = self.memoryLimitMB!
        }
        if self.memoryUsageMB != nil {
            map["memoryUsageMB"] = self.memoryUsageMB!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("applicationID") {
            self.applicationID = dict["applicationID"] as! String
        }
        if dict.keys.contains("cpuPercent") {
            self.cpuPercent = dict["cpuPercent"] as! Double
        }
        if dict.keys.contains("cpuQuotaPercent") {
            self.cpuQuotaPercent = dict["cpuQuotaPercent"] as! Double
        }
        if dict.keys.contains("instanceID") {
            self.instanceID = dict["instanceID"] as! String
        }
        if dict.keys.contains("memoryLimitMB") {
            self.memoryLimitMB = dict["memoryLimitMB"] as! Double
        }
        if dict.keys.contains("memoryUsageMB") {
            self.memoryUsageMB = dict["memoryUsageMB"] as! Double
        }
        if dict.keys.contains("timestamp") {
            self.timestamp = dict["timestamp"] as! Int64
        }
    }
}

public class JaegerConfig : Tea.TeaModel {
    public var endpoint: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpoint != nil {
            map["endpoint"] = self.endpoint!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endpoint") {
            self.endpoint = dict["endpoint"] as! String
        }
    }
}

public class LifecycleHook : Tea.TeaModel {
    public var handler: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.handler != nil {
            map["handler"] = self.handler!
        }
        if self.timeout != nil {
            map["timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("handler") {
            self.handler = dict["handler"] as! String
        }
        if dict.keys.contains("timeout") {
            self.timeout = dict["timeout"] as! Int32
        }
    }
}

public class ListApplicationVersionsOutput : Tea.TeaModel {
    public var direction: String?

    public var nextToken: String?

    public var requestId: String?

    public var versions: [Version]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["direction"] = self.direction!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.versions != nil {
            var tmp : [Any] = []
            for k in self.versions! {
                tmp.append(k.toMap())
            }
            map["versions"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("direction") {
            self.direction = dict["direction"] as! String
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("versions") {
            var tmp : [Version] = []
            for v in dict["versions"] as! [Any] {
                var model = Version()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.versions = tmp
        }
    }
}

public class ListApplicationsOutput : Tea.TeaModel {
    public var applications: [Application]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applications != nil {
            var tmp : [Any] = []
            for k in self.applications! {
                tmp.append(k.toMap())
            }
            map["applications"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("applications") {
            var tmp : [Application] = []
            for v in dict["applications"] as! [Any] {
                var model = Application()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.applications = tmp
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListApplicationsWithStatusOutput : Tea.TeaModel {
    public var applications: [ApplicationWithStatus]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applications != nil {
            var tmp : [Any] = []
            for k in self.applications! {
                tmp.append(k.toMap())
            }
            map["applications"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("applications") {
            var tmp : [ApplicationWithStatus] = []
            for v in dict["applications"] as! [Any] {
                var model = ApplicationWithStatus()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.applications = tmp
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListCustomDomainOutput : Tea.TeaModel {
    public var customDomains: [CustomDomain]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customDomains != nil {
            var tmp : [Any] = []
            for k in self.customDomains! {
                tmp.append(k.toMap())
            }
            map["customDomains"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("customDomains") {
            var tmp : [CustomDomain] = []
            for v in dict["customDomains"] as! [Any] {
                var model = CustomDomain()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.customDomains = tmp
        }
        if dict.keys.contains("nextToken") {
            self.nextToken = dict["nextToken"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class ListInstancesMetricsOutput : Tea.TeaModel {
    public var requestId: String?

    public var metricsList: [InstanceMetricInfo]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.metricsList != nil {
            var tmp : [Any] = []
            for k in self.metricsList! {
                tmp.append(k.toMap())
            }
            map["metricsList"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("metricsList") {
            var tmp : [InstanceMetricInfo] = []
            for v in dict["metricsList"] as! [Any] {
                var model = InstanceMetricInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.metricsList = tmp
        }
        if dict.keys.contains("pageNumber") {
            self.pageNumber = dict["pageNumber"] as! Int32
        }
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("totalCount") {
            self.totalCount = dict["totalCount"] as! Int32
        }
    }
}

public class ListInstancesOutput : Tea.TeaModel {
    public var currentError: String?

    public var instances: [InstanceInfo]?

    public var requestId: String?

    public var versionStatus: [String: VersionStatus]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentError != nil {
            map["currentError"] = self.currentError!
        }
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["instances"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.versionStatus != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.versionStatus! {
                tmp[k] = v.toMap()
            }
            map["versionStatus"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("currentError") {
            self.currentError = dict["currentError"] as! String
        }
        if dict.keys.contains("instances") {
            var tmp : [InstanceInfo] = []
            for v in dict["instances"] as! [Any] {
                var model = InstanceInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instances = tmp
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("versionStatus") {
            var tmp : [String: VersionStatus] = [:]
            for (k, v) in dict["versionStatus"] as! [String: Any] {
                if v != nil {
                    var model = VersionStatus()
                    model.fromMap(v as! [String: Any])
                    tmp[k] = model
                }
            }
            self.versionStatus = tmp
        }
    }
}

public class ListMetricsOutput : Tea.TeaModel {
    public var requestId: String?

    public var metrics: [String: [MetricInfo]]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.metrics != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.metrics! {
                var l1 : [Any] = []
                for k1 in v {
                    l1.append(k1.toMap())
                }
                tmp[k] = l1
            }
            map["metrics"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("metrics") {
            var tmp : [String: [MetricInfo]] = [:]
            for (k, v) in dict["metrics"] as! [String: Any] {
                var l1 : [MetricInfo] = []
                for v1 in v as! [Any] {
                    var model = MetricInfo()
                    if v1 != nil {
                        model.fromMap(v1 as! [String: Any])
                    }
                    l1.append(model)
                }
                tmp[k] = l1
            }
            self.metrics = tmp
        }
    }
}

public class ListStaticsQueryResponse : Tea.TeaModel {
    public var length: Int64?

    public var sort: String?

    public var statics: [StaticsInfo]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.length != nil {
            map["length"] = self.length!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        if self.statics != nil {
            var tmp : [Any] = []
            for k in self.statics! {
                tmp.append(k.toMap())
            }
            map["statics"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("length") {
            self.length = dict["length"] as! Int64
        }
        if dict.keys.contains("sort") {
            self.sort = dict["sort"] as! String
        }
        if dict.keys.contains("statics") {
            var tmp : [StaticsInfo] = []
            for v in dict["statics"] as! [Any] {
                var model = StaticsInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.statics = tmp
        }
    }
}

public class LogConfig : Tea.TeaModel {
    public var enableInstanceMetrics: Bool?

    public var enableRequestMetrics: Bool?

    public var logBeginRule: String?

    public var logstore: String?

    public var project: String?

    public var pushToUserSLS: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableInstanceMetrics != nil {
            map["enableInstanceMetrics"] = self.enableInstanceMetrics!
        }
        if self.enableRequestMetrics != nil {
            map["enableRequestMetrics"] = self.enableRequestMetrics!
        }
        if self.logBeginRule != nil {
            map["logBeginRule"] = self.logBeginRule!
        }
        if self.logstore != nil {
            map["logstore"] = self.logstore!
        }
        if self.project != nil {
            map["project"] = self.project!
        }
        if self.pushToUserSLS != nil {
            map["pushToUserSLS"] = self.pushToUserSLS!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("enableInstanceMetrics") {
            self.enableInstanceMetrics = dict["enableInstanceMetrics"] as! Bool
        }
        if dict.keys.contains("enableRequestMetrics") {
            self.enableRequestMetrics = dict["enableRequestMetrics"] as! Bool
        }
        if dict.keys.contains("logBeginRule") {
            self.logBeginRule = dict["logBeginRule"] as! String
        }
        if dict.keys.contains("logstore") {
            self.logstore = dict["logstore"] as! String
        }
        if dict.keys.contains("project") {
            self.project = dict["project"] as! String
        }
        if dict.keys.contains("pushToUserSLS") {
            self.pushToUserSLS = dict["pushToUserSLS"] as! Bool
        }
    }
}

public class LogEntry : Tea.TeaModel {
    public var instanceID: String?

    public var message: String?

    public var offset: Int64?

    public var packID: String?

    public var packMeta: String?

    public var qualifier: String?

    public var timestamp: Int32?

    public var versionID: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceID != nil {
            map["instanceID"] = self.instanceID!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.offset != nil {
            map["offset"] = self.offset!
        }
        if self.packID != nil {
            map["packID"] = self.packID!
        }
        if self.packMeta != nil {
            map["packMeta"] = self.packMeta!
        }
        if self.qualifier != nil {
            map["qualifier"] = self.qualifier!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        if self.versionID != nil {
            map["versionID"] = self.versionID!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("instanceID") {
            self.instanceID = dict["instanceID"] as! String
        }
        if dict.keys.contains("message") {
            self.message = dict["message"] as! String
        }
        if dict.keys.contains("offset") {
            self.offset = dict["offset"] as! Int64
        }
        if dict.keys.contains("packID") {
            self.packID = dict["packID"] as! String
        }
        if dict.keys.contains("packMeta") {
            self.packMeta = dict["packMeta"] as! String
        }
        if dict.keys.contains("qualifier") {
            self.qualifier = dict["qualifier"] as! String
        }
        if dict.keys.contains("timestamp") {
            self.timestamp = dict["timestamp"] as! Int32
        }
        if dict.keys.contains("versionID") {
            self.versionID = dict["versionID"] as! String
        }
    }
}

public class MetricInfo : Tea.TeaModel {
    public var average: Double?

    public var count: Double?

    public var maximum: Double?

    public var minimum: Double?

    public var sum: Double?

    public var timestamp: Int64?

    public var value: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.average != nil {
            map["Average"] = self.average!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.maximum != nil {
            map["Maximum"] = self.maximum!
        }
        if self.minimum != nil {
            map["Minimum"] = self.minimum!
        }
        if self.sum != nil {
            map["Sum"] = self.sum!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        if self.value != nil {
            map["value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Average") {
            self.average = dict["Average"] as! Double
        }
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Double
        }
        if dict.keys.contains("Maximum") {
            self.maximum = dict["Maximum"] as! Double
        }
        if dict.keys.contains("Minimum") {
            self.minimum = dict["Minimum"] as! Double
        }
        if dict.keys.contains("Sum") {
            self.sum = dict["Sum"] as! Double
        }
        if dict.keys.contains("timestamp") {
            self.timestamp = dict["timestamp"] as! Int64
        }
        if dict.keys.contains("value") {
            self.value = dict["value"] as! Double
        }
    }
}

public class NASConfig : Tea.TeaModel {
    public var mountPoints: [NASMountConfig]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mountPoints != nil {
            var tmp : [Any] = []
            for k in self.mountPoints! {
                tmp.append(k.toMap())
            }
            map["mountPoints"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("mountPoints") {
            var tmp : [NASMountConfig] = []
            for v in dict["mountPoints"] as! [Any] {
                var model = NASMountConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mountPoints = tmp
        }
    }
}

public class NASMountConfig : Tea.TeaModel {
    public var enableTLS: Bool?

    public var mountDir: String?

    public var serverAddr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableTLS != nil {
            map["enableTLS"] = self.enableTLS!
        }
        if self.mountDir != nil {
            map["mountDir"] = self.mountDir!
        }
        if self.serverAddr != nil {
            map["serverAddr"] = self.serverAddr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("enableTLS") {
            self.enableTLS = dict["enableTLS"] as! Bool
        }
        if dict.keys.contains("mountDir") {
            self.mountDir = dict["mountDir"] as! String
        }
        if dict.keys.contains("serverAddr") {
            self.serverAddr = dict["serverAddr"] as! String
        }
    }
}

public class OSSMountConfig : Tea.TeaModel {
    public var mountPoints: [OSSMountPoint]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mountPoints != nil {
            var tmp : [Any] = []
            for k in self.mountPoints! {
                tmp.append(k.toMap())
            }
            map["mountPoints"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("mountPoints") {
            var tmp : [OSSMountPoint] = []
            for v in dict["mountPoints"] as! [Any] {
                var model = OSSMountPoint()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.mountPoints = tmp
        }
    }
}

public class OSSMountPoint : Tea.TeaModel {
    public var bucketName: String?

    public var bucketPath: String?

    public var endpoint: String?

    public var mountDir: String?

    public var readOnly: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketName != nil {
            map["bucketName"] = self.bucketName!
        }
        if self.bucketPath != nil {
            map["bucketPath"] = self.bucketPath!
        }
        if self.endpoint != nil {
            map["endpoint"] = self.endpoint!
        }
        if self.mountDir != nil {
            map["mountDir"] = self.mountDir!
        }
        if self.readOnly != nil {
            map["readOnly"] = self.readOnly!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("bucketName") {
            self.bucketName = dict["bucketName"] as! String
        }
        if dict.keys.contains("bucketPath") {
            self.bucketPath = dict["bucketPath"] as! String
        }
        if dict.keys.contains("endpoint") {
            self.endpoint = dict["endpoint"] as! String
        }
        if dict.keys.contains("mountDir") {
            self.mountDir = dict["mountDir"] as! String
        }
        if dict.keys.contains("readOnly") {
            self.readOnly = dict["readOnly"] as! Bool
        }
    }
}

public class PathConfig : Tea.TeaModel {
    public var applicationName: String?

    public var path: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationName != nil {
            map["applicationName"] = self.applicationName!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("applicationName") {
            self.applicationName = dict["applicationName"] as! String
        }
        if dict.keys.contains("path") {
            self.path = dict["path"] as! String
        }
    }
}

public class PermissionAssistantApi : Tea.TeaModel {
    public var createTime: String?

    public var id: Int64?

    public var name: String?

    public var resourceType: String?

    public var updateTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["createTime"] = self.createTime!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.resourceType != nil {
            map["resourceType"] = self.resourceType!
        }
        if self.updateTime != nil {
            map["updateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("createTime") {
            self.createTime = dict["createTime"] as! String
        }
        if dict.keys.contains("id") {
            self.id = dict["id"] as! Int64
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("resourceType") {
            self.resourceType = dict["resourceType"] as! String
        }
        if dict.keys.contains("updateTime") {
            self.updateTime = dict["updateTime"] as! String
        }
    }
}

public class PolicyItem : Tea.TeaModel {
    public var key: String?

    public var operator_: String?

    public var type: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.key != nil {
            map["key"] = self.key!
        }
        if self.operator_ != nil {
            map["operator"] = self.operator_!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        if self.value != nil {
            map["value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("key") {
            self.key = dict["key"] as! String
        }
        if dict.keys.contains("operator") {
            self.operator_ = dict["operator"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
        if dict.keys.contains("value") {
            self.value = dict["value"] as! String
        }
    }
}

public class PriceEstimateFeature : Tea.TeaModel {
    public var appType: String?

    public var cpuCore: Double?

    public var cpuStrategy: String?

    public var envType: String?

    public var highLoadInstanceCount: Int64?

    public var highLoadQps: Double?

    public var highLoadSeconds: Int64?

    public var instanceQps: Double?

    public var internetOutboundGiB: Double?

    public var lowLoadInstanceCount: Int64?

    public var lowLoadQps: Double?

    public var lowLoadSeconds: Int64?

    public var maxInstanceCount: Int64?

    public var memoryGiB: Double?

    public var minInstanceCount: Int64?

    public var noneLoadInstanceCount: Int64?

    public var noneLoadSeconds: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.cpuCore != nil {
            map["CpuCore"] = self.cpuCore!
        }
        if self.cpuStrategy != nil {
            map["CpuStrategy"] = self.cpuStrategy!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.highLoadInstanceCount != nil {
            map["HighLoadInstanceCount"] = self.highLoadInstanceCount!
        }
        if self.highLoadQps != nil {
            map["HighLoadQps"] = self.highLoadQps!
        }
        if self.highLoadSeconds != nil {
            map["HighLoadSeconds"] = self.highLoadSeconds!
        }
        if self.instanceQps != nil {
            map["InstanceQps"] = self.instanceQps!
        }
        if self.internetOutboundGiB != nil {
            map["InternetOutboundGiB"] = self.internetOutboundGiB!
        }
        if self.lowLoadInstanceCount != nil {
            map["LowLoadInstanceCount"] = self.lowLoadInstanceCount!
        }
        if self.lowLoadQps != nil {
            map["LowLoadQps"] = self.lowLoadQps!
        }
        if self.lowLoadSeconds != nil {
            map["LowLoadSeconds"] = self.lowLoadSeconds!
        }
        if self.maxInstanceCount != nil {
            map["MaxInstanceCount"] = self.maxInstanceCount!
        }
        if self.memoryGiB != nil {
            map["MemoryGiB"] = self.memoryGiB!
        }
        if self.minInstanceCount != nil {
            map["MinInstanceCount"] = self.minInstanceCount!
        }
        if self.noneLoadInstanceCount != nil {
            map["NoneLoadInstanceCount"] = self.noneLoadInstanceCount!
        }
        if self.noneLoadSeconds != nil {
            map["NoneLoadSeconds"] = self.noneLoadSeconds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppType") {
            self.appType = dict["AppType"] as! String
        }
        if dict.keys.contains("CpuCore") {
            self.cpuCore = dict["CpuCore"] as! Double
        }
        if dict.keys.contains("CpuStrategy") {
            self.cpuStrategy = dict["CpuStrategy"] as! String
        }
        if dict.keys.contains("EnvType") {
            self.envType = dict["EnvType"] as! String
        }
        if dict.keys.contains("HighLoadInstanceCount") {
            self.highLoadInstanceCount = dict["HighLoadInstanceCount"] as! Int64
        }
        if dict.keys.contains("HighLoadQps") {
            self.highLoadQps = dict["HighLoadQps"] as! Double
        }
        if dict.keys.contains("HighLoadSeconds") {
            self.highLoadSeconds = dict["HighLoadSeconds"] as! Int64
        }
        if dict.keys.contains("InstanceQps") {
            self.instanceQps = dict["InstanceQps"] as! Double
        }
        if dict.keys.contains("InternetOutboundGiB") {
            self.internetOutboundGiB = dict["InternetOutboundGiB"] as! Double
        }
        if dict.keys.contains("LowLoadInstanceCount") {
            self.lowLoadInstanceCount = dict["LowLoadInstanceCount"] as! Int64
        }
        if dict.keys.contains("LowLoadQps") {
            self.lowLoadQps = dict["LowLoadQps"] as! Double
        }
        if dict.keys.contains("LowLoadSeconds") {
            self.lowLoadSeconds = dict["LowLoadSeconds"] as! Int64
        }
        if dict.keys.contains("MaxInstanceCount") {
            self.maxInstanceCount = dict["MaxInstanceCount"] as! Int64
        }
        if dict.keys.contains("MemoryGiB") {
            self.memoryGiB = dict["MemoryGiB"] as! Double
        }
        if dict.keys.contains("MinInstanceCount") {
            self.minInstanceCount = dict["MinInstanceCount"] as! Int64
        }
        if dict.keys.contains("NoneLoadInstanceCount") {
            self.noneLoadInstanceCount = dict["NoneLoadInstanceCount"] as! Int64
        }
        if dict.keys.contains("NoneLoadSeconds") {
            self.noneLoadSeconds = dict["NoneLoadSeconds"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class PriceEstimateOutput : Tea.TeaModel {
    public class Apps : Tea.TeaModel {
        public class Usages : Tea.TeaModel {
            public var amount: Double?

            public var id: String?

            public var unit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["Amount"] = self.amount!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.unit != nil {
                    map["Unit"] = self.unit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Amount") {
                    self.amount = dict["Amount"] as! Double
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Unit") {
                    self.unit = dict["Unit"] as! String
                }
            }
        }
        public var feature: PriceEstimateFeature?

        public var id: Int64?

        public var usages: [PriceEstimateOutput.Apps.Usages]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.feature?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.feature != nil {
                map["Feature"] = self.feature?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.usages != nil {
                var tmp : [Any] = []
                for k in self.usages! {
                    tmp.append(k.toMap())
                }
                map["Usages"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Feature") {
                var model = PriceEstimateFeature()
                model.fromMap(dict["Feature"] as! [String: Any])
                self.feature = model
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Usages") {
                var tmp : [PriceEstimateOutput.Apps.Usages] = []
                for v in dict["Usages"] as! [Any] {
                    var model = PriceEstimateOutput.Apps.Usages()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.usages = tmp
            }
        }
    }
    public class Items : Tea.TeaModel {
        public class Steps : Tea.TeaModel {
            public var begin: Int64?

            public var end: Int64?

            public var price: Double?

            public var regionIds: [String]?

            public var unit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.begin != nil {
                    map["Begin"] = self.begin!
                }
                if self.end != nil {
                    map["End"] = self.end!
                }
                if self.price != nil {
                    map["Price"] = self.price!
                }
                if self.regionIds != nil {
                    map["RegionIds"] = self.regionIds!
                }
                if self.unit != nil {
                    map["Unit"] = self.unit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Begin") {
                    self.begin = dict["Begin"] as! Int64
                }
                if dict.keys.contains("End") {
                    self.end = dict["End"] as! Int64
                }
                if dict.keys.contains("Price") {
                    self.price = dict["Price"] as! Double
                }
                if dict.keys.contains("RegionIds") {
                    self.regionIds = dict["RegionIds"] as! [String]
                }
                if dict.keys.contains("Unit") {
                    self.unit = dict["Unit"] as! String
                }
            }
        }
        public var amount: Double?

        public var count: Int64?

        public var id: String?

        public var price: Double?

        public var steps: [PriceEstimateOutput.Items.Steps]?

        public var type: String?

        public var unit: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.amount != nil {
                map["Amount"] = self.amount!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.price != nil {
                map["Price"] = self.price!
            }
            if self.steps != nil {
                var tmp : [Any] = []
                for k in self.steps! {
                    tmp.append(k.toMap())
                }
                map["Steps"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.unit != nil {
                map["Unit"] = self.unit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Amount") {
                self.amount = dict["Amount"] as! Double
            }
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int64
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Price") {
                self.price = dict["Price"] as! Double
            }
            if dict.keys.contains("Steps") {
                var tmp : [PriceEstimateOutput.Items.Steps] = []
                for v in dict["Steps"] as! [Any] {
                    var model = PriceEstimateOutput.Items.Steps()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.steps = tmp
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Unit") {
                self.unit = dict["Unit"] as! String
            }
        }
    }
    public var apps: [PriceEstimateOutput.Apps]?

    public var items: [PriceEstimateOutput.Items]?

    public var totalPrice: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apps != nil {
            var tmp : [Any] = []
            for k in self.apps! {
                tmp.append(k.toMap())
            }
            map["Apps"] = tmp
        }
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.totalPrice != nil {
            map["TotalPrice"] = self.totalPrice!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Apps") {
            var tmp : [PriceEstimateOutput.Apps] = []
            for v in dict["Apps"] as! [Any] {
                var model = PriceEstimateOutput.Apps()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.apps = tmp
        }
        if dict.keys.contains("Items") {
            var tmp : [PriceEstimateOutput.Items] = []
            for v in dict["Items"] as! [Any] {
                var model = PriceEstimateOutput.Items()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.items = tmp
        }
        if dict.keys.contains("TotalPrice") {
            self.totalPrice = dict["TotalPrice"] as! Double
        }
    }
}

public class Probe : Tea.TeaModel {
    public class ProbeHandler : Tea.TeaModel {
        public class HttpGet : Tea.TeaModel {
            public class HttpHeaders : Tea.TeaModel {
                public var name: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("value") {
                        self.value = dict["value"] as! String
                    }
                }
            }
            public var httpHeaders: [Probe.ProbeHandler.HttpGet.HttpHeaders]?

            public var path: String?

            public var port: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.httpHeaders != nil {
                    var tmp : [Any] = []
                    for k in self.httpHeaders! {
                        tmp.append(k.toMap())
                    }
                    map["httpHeaders"] = tmp
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.port != nil {
                    map["port"] = self.port!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("httpHeaders") {
                    var tmp : [Probe.ProbeHandler.HttpGet.HttpHeaders] = []
                    for v in dict["httpHeaders"] as! [Any] {
                        var model = Probe.ProbeHandler.HttpGet.HttpHeaders()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.httpHeaders = tmp
                }
                if dict.keys.contains("path") {
                    self.path = dict["path"] as! String
                }
                if dict.keys.contains("port") {
                    self.port = dict["port"] as! Int32
                }
            }
        }
        public class TcpSocket : Tea.TeaModel {
            public var port: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["port"] = self.port!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("port") {
                    self.port = dict["port"] as! Int32
                }
            }
        }
        public var httpGet: Probe.ProbeHandler.HttpGet?

        public var tcpSocket: Probe.ProbeHandler.TcpSocket?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.httpGet?.validate()
            try self.tcpSocket?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.httpGet != nil {
                map["httpGet"] = self.httpGet?.toMap()
            }
            if self.tcpSocket != nil {
                map["tcpSocket"] = self.tcpSocket?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("httpGet") {
                var model = Probe.ProbeHandler.HttpGet()
                model.fromMap(dict["httpGet"] as! [String: Any])
                self.httpGet = model
            }
            if dict.keys.contains("tcpSocket") {
                var model = Probe.ProbeHandler.TcpSocket()
                model.fromMap(dict["tcpSocket"] as! [String: Any])
                self.tcpSocket = model
            }
        }
    }
    public var failureThreshold: Int32?

    public var initialDelaySeconds: Int32?

    public var periodSeconds: Int32?

    public var probeHandler: Probe.ProbeHandler?

    public var timeoutSeconds: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.probeHandler?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failureThreshold != nil {
            map["failureThreshold"] = self.failureThreshold!
        }
        if self.initialDelaySeconds != nil {
            map["initialDelaySeconds"] = self.initialDelaySeconds!
        }
        if self.periodSeconds != nil {
            map["periodSeconds"] = self.periodSeconds!
        }
        if self.probeHandler != nil {
            map["probeHandler"] = self.probeHandler?.toMap()
        }
        if self.timeoutSeconds != nil {
            map["timeoutSeconds"] = self.timeoutSeconds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("failureThreshold") {
            self.failureThreshold = dict["failureThreshold"] as! Int32
        }
        if dict.keys.contains("initialDelaySeconds") {
            self.initialDelaySeconds = dict["initialDelaySeconds"] as! Int32
        }
        if dict.keys.contains("periodSeconds") {
            self.periodSeconds = dict["periodSeconds"] as! Int32
        }
        if dict.keys.contains("probeHandler") {
            var model = Probe.ProbeHandler()
            model.fromMap(dict["probeHandler"] as! [String: Any])
            self.probeHandler = model
        }
        if dict.keys.contains("timeoutSeconds") {
            self.timeoutSeconds = dict["timeoutSeconds"] as! Int32
        }
    }
}

public class PublishApplicationVersionInput : Tea.TeaModel {
    public var description_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
    }
}

public class RouteConfig : Tea.TeaModel {
    public var routes: [PathConfig]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.routes != nil {
            var tmp : [Any] = []
            for k in self.routes! {
                tmp.append(k.toMap())
            }
            map["routes"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("routes") {
            var tmp : [PathConfig] = []
            for v in dict["routes"] as! [Any] {
                var model = PathConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.routes = tmp
        }
    }
}

public class RoutePolicy : Tea.TeaModel {
    public var condition: String?

    public var policyItems: [PolicyItem]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.condition != nil {
            map["condition"] = self.condition!
        }
        if self.policyItems != nil {
            var tmp : [Any] = []
            for k in self.policyItems! {
                tmp.append(k.toMap())
            }
            map["policyItems"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("condition") {
            self.condition = dict["condition"] as! String
        }
        if dict.keys.contains("policyItems") {
            var tmp : [PolicyItem] = []
            for v in dict["policyItems"] as! [Any] {
                var model = PolicyItem()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.policyItems = tmp
        }
    }
}

public class SLSConfig : Tea.TeaModel {
    public class CollectConfigs : Tea.TeaModel {
        public var logPath: String?

        public var logType: String?

        public var logstoreName: String?

        public var logtailName: String?

        public var projectName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logPath != nil {
                map["logPath"] = self.logPath!
            }
            if self.logType != nil {
                map["logType"] = self.logType!
            }
            if self.logstoreName != nil {
                map["logstoreName"] = self.logstoreName!
            }
            if self.logtailName != nil {
                map["logtailName"] = self.logtailName!
            }
            if self.projectName != nil {
                map["projectName"] = self.projectName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("logPath") {
                self.logPath = dict["logPath"] as! String
            }
            if dict.keys.contains("logType") {
                self.logType = dict["logType"] as! String
            }
            if dict.keys.contains("logstoreName") {
                self.logstoreName = dict["logstoreName"] as! String
            }
            if dict.keys.contains("logtailName") {
                self.logtailName = dict["logtailName"] as! String
            }
            if dict.keys.contains("projectName") {
                self.projectName = dict["projectName"] as! String
            }
        }
    }
    public var collectConfigs: [SLSConfig.CollectConfigs]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collectConfigs != nil {
            var tmp : [Any] = []
            for k in self.collectConfigs! {
                tmp.append(k.toMap())
            }
            map["collectConfigs"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("collectConfigs") {
            var tmp : [SLSConfig.CollectConfigs] = []
            for v in dict["collectConfigs"] as! [Any] {
                var model = SLSConfig.CollectConfigs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.collectConfigs = tmp
        }
    }
}

public class ScaleConfig : Tea.TeaModel {
    public var alwaysAllocateCPU: Bool?

    public var maximumInstanceCount: Int64?

    public var minimumInstanceCount: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alwaysAllocateCPU != nil {
            map["alwaysAllocateCPU"] = self.alwaysAllocateCPU!
        }
        if self.maximumInstanceCount != nil {
            map["maximumInstanceCount"] = self.maximumInstanceCount!
        }
        if self.minimumInstanceCount != nil {
            map["minimumInstanceCount"] = self.minimumInstanceCount!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("alwaysAllocateCPU") {
            self.alwaysAllocateCPU = dict["alwaysAllocateCPU"] as! Bool
        }
        if dict.keys.contains("maximumInstanceCount") {
            self.maximumInstanceCount = dict["maximumInstanceCount"] as! Int64
        }
        if dict.keys.contains("minimumInstanceCount") {
            self.minimumInstanceCount = dict["minimumInstanceCount"] as! Int64
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class SourceCodeAccount : Tea.TeaModel {
    public class Organizations : Tea.TeaModel {
        public var avatarUrl: String?

        public var id: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarUrl != nil {
                map["AvatarUrl"] = self.avatarUrl!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvatarUrl") {
                self.avatarUrl = dict["AvatarUrl"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var avatarUrl: String?

    public var id: String?

    public var name: String?

    public var organizations: [SourceCodeAccount.Organizations]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avatarUrl != nil {
            map["AvatarUrl"] = self.avatarUrl!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.organizations != nil {
            var tmp : [Any] = []
            for k in self.organizations! {
                tmp.append(k.toMap())
            }
            map["Organizations"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvatarUrl") {
            self.avatarUrl = dict["AvatarUrl"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Organizations") {
            var tmp : [SourceCodeAccount.Organizations] = []
            for v in dict["Organizations"] as! [Any] {
                var model = SourceCodeAccount.Organizations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.organizations = tmp
        }
    }
}

public class SourceCodeRepo : Tea.TeaModel {
    public var fullName: String?

    public var id: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fullName != nil {
            map["FullName"] = self.fullName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FullName") {
            self.fullName = dict["FullName"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class SourceCodeRepoBranch : Tea.TeaModel {
    public var commitId: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commitId != nil {
            map["CommitId"] = self.commitId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommitId") {
            self.commitId = dict["CommitId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class StaticsInfo : Tea.TeaModel {
    public var activeCPUUsage: Int64?

    public var cost: Double?

    public var diskUsage: Int64?

    public var functionName: String?

    public var gpuUsage: Int64?

    public var idleCPUUsage: Int64?

    public var instanceTrafficOut: Int64?

    public var invocations: Int64?

    public var invokeCDNOut: Int64?

    public var invokeInternetOut: Int64?

    public var memoryUsage: Int64?

    public var region: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activeCPUUsage != nil {
            map["activeCPUUsage"] = self.activeCPUUsage!
        }
        if self.cost != nil {
            map["cost"] = self.cost!
        }
        if self.diskUsage != nil {
            map["diskUsage"] = self.diskUsage!
        }
        if self.functionName != nil {
            map["functionName"] = self.functionName!
        }
        if self.gpuUsage != nil {
            map["gpuUsage"] = self.gpuUsage!
        }
        if self.idleCPUUsage != nil {
            map["idleCPUUsage"] = self.idleCPUUsage!
        }
        if self.instanceTrafficOut != nil {
            map["instanceTrafficOut"] = self.instanceTrafficOut!
        }
        if self.invocations != nil {
            map["invocations"] = self.invocations!
        }
        if self.invokeCDNOut != nil {
            map["invokeCDNOut"] = self.invokeCDNOut!
        }
        if self.invokeInternetOut != nil {
            map["invokeInternetOut"] = self.invokeInternetOut!
        }
        if self.memoryUsage != nil {
            map["memoryUsage"] = self.memoryUsage!
        }
        if self.region != nil {
            map["region"] = self.region!
        }
        if self.serviceName != nil {
            map["serviceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("activeCPUUsage") {
            self.activeCPUUsage = dict["activeCPUUsage"] as! Int64
        }
        if dict.keys.contains("cost") {
            self.cost = dict["cost"] as! Double
        }
        if dict.keys.contains("diskUsage") {
            self.diskUsage = dict["diskUsage"] as! Int64
        }
        if dict.keys.contains("functionName") {
            self.functionName = dict["functionName"] as! String
        }
        if dict.keys.contains("gpuUsage") {
            self.gpuUsage = dict["gpuUsage"] as! Int64
        }
        if dict.keys.contains("idleCPUUsage") {
            self.idleCPUUsage = dict["idleCPUUsage"] as! Int64
        }
        if dict.keys.contains("instanceTrafficOut") {
            self.instanceTrafficOut = dict["instanceTrafficOut"] as! Int64
        }
        if dict.keys.contains("invocations") {
            self.invocations = dict["invocations"] as! Int64
        }
        if dict.keys.contains("invokeCDNOut") {
            self.invokeCDNOut = dict["invokeCDNOut"] as! Int64
        }
        if dict.keys.contains("invokeInternetOut") {
            self.invokeInternetOut = dict["invokeInternetOut"] as! Int64
        }
        if dict.keys.contains("memoryUsage") {
            self.memoryUsage = dict["memoryUsage"] as! Int64
        }
        if dict.keys.contains("region") {
            self.region = dict["region"] as! String
        }
        if dict.keys.contains("serviceName") {
            self.serviceName = dict["serviceName"] as! String
        }
    }
}

public class Submenu : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var defaultSelected: Bool?

        public var itemDesc: String?

        public var itemType: String?

        public var relatingItems: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultSelected != nil {
                map["DefaultSelected"] = self.defaultSelected!
            }
            if self.itemDesc != nil {
                map["ItemDesc"] = self.itemDesc!
            }
            if self.itemType != nil {
                map["ItemType"] = self.itemType!
            }
            if self.relatingItems != nil {
                map["RelatingItems"] = self.relatingItems!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DefaultSelected") {
                self.defaultSelected = dict["DefaultSelected"] as! Bool
            }
            if dict.keys.contains("ItemDesc") {
                self.itemDesc = dict["ItemDesc"] as! String
            }
            if dict.keys.contains("ItemType") {
                self.itemType = dict["ItemType"] as! String
            }
            if dict.keys.contains("RelatingItems") {
                self.relatingItems = dict["RelatingItems"] as! [String]
            }
        }
    }
    public var items: [Submenu.Items]?

    public var submenuDesc: String?

    public var submenuType: String?

    public var submenus: [Submenu]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.submenuDesc != nil {
            map["SubmenuDesc"] = self.submenuDesc!
        }
        if self.submenuType != nil {
            map["SubmenuType"] = self.submenuType!
        }
        if self.submenus != nil {
            var tmp : [Any] = []
            for k in self.submenus! {
                tmp.append(k.toMap())
            }
            map["Submenus"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Items") {
            var tmp : [Submenu.Items] = []
            for v in dict["Items"] as! [Any] {
                var model = Submenu.Items()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.items = tmp
        }
        if dict.keys.contains("SubmenuDesc") {
            self.submenuDesc = dict["SubmenuDesc"] as! String
        }
        if dict.keys.contains("SubmenuType") {
            self.submenuType = dict["SubmenuType"] as! String
        }
        if dict.keys.contains("Submenus") {
            var tmp : [Submenu] = []
            for v in dict["Submenus"] as! [Any] {
                var model = Submenu()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.submenus = tmp
        }
    }
}

public class TLSConfig : Tea.TeaModel {
    public var cipherSuites: [String]?

    public var maxVersion: String?

    public var minVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cipherSuites != nil {
            map["cipherSuites"] = self.cipherSuites!
        }
        if self.maxVersion != nil {
            map["maxVersion"] = self.maxVersion!
        }
        if self.minVersion != nil {
            map["minVersion"] = self.minVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("cipherSuites") {
            self.cipherSuites = dict["cipherSuites"] as! [String]
        }
        if dict.keys.contains("maxVersion") {
            self.maxVersion = dict["maxVersion"] as! String
        }
        if dict.keys.contains("minVersion") {
            self.minVersion = dict["minVersion"] as! String
        }
    }
}

public class TomcatConfig : Tea.TeaModel {
    public var contextPath: String?

    public var maxThreads: Int32?

    public var port: Int32?

    public var uriEncoding: String?

    public var useBodyEncodingForUri: Bool?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contextPath != nil {
            map["ContextPath"] = self.contextPath!
        }
        if self.maxThreads != nil {
            map["MaxThreads"] = self.maxThreads!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.uriEncoding != nil {
            map["UriEncoding"] = self.uriEncoding!
        }
        if self.useBodyEncodingForUri != nil {
            map["UseBodyEncodingForUri"] = self.useBodyEncodingForUri!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContextPath") {
            self.contextPath = dict["ContextPath"] as! String
        }
        if dict.keys.contains("MaxThreads") {
            self.maxThreads = dict["MaxThreads"] as! Int32
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! Int32
        }
        if dict.keys.contains("UriEncoding") {
            self.uriEncoding = dict["UriEncoding"] as! String
        }
        if dict.keys.contains("UseBodyEncodingForUri") {
            self.useBodyEncodingForUri = dict["UseBodyEncodingForUri"] as! Bool
        }
        if dict.keys.contains("Version") {
            self.version = dict["Version"] as! String
        }
    }
}

public class TracingConfig : Tea.TeaModel {
    public var jaegerConfig: JaegerConfig?

    public var params: Any?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jaegerConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jaegerConfig != nil {
            map["jaegerConfig"] = self.jaegerConfig?.toMap()
        }
        if self.params != nil {
            map["params"] = self.params!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("jaegerConfig") {
            var model = JaegerConfig()
            model.fromMap(dict["jaegerConfig"] as! [String: Any])
            self.jaegerConfig = model
        }
        if dict.keys.contains("params") {
            self.params = dict["params"] as! Any
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class TrafficConfig : Tea.TeaModel {
    public var additionalVersionWeight: [String: Double]?

    public var createdTime: String?

    public var lastModifiedTime: String?

    public var requestId: String?

    public var resolvePolicy: String?

    public var routePolicy: RoutePolicy?

    public var versionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routePolicy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionalVersionWeight != nil {
            map["additionalVersionWeight"] = self.additionalVersionWeight!
        }
        if self.createdTime != nil {
            map["createdTime"] = self.createdTime!
        }
        if self.lastModifiedTime != nil {
            map["lastModifiedTime"] = self.lastModifiedTime!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resolvePolicy != nil {
            map["resolvePolicy"] = self.resolvePolicy!
        }
        if self.routePolicy != nil {
            map["routePolicy"] = self.routePolicy?.toMap()
        }
        if self.versionId != nil {
            map["versionId"] = self.versionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("additionalVersionWeight") {
            self.additionalVersionWeight = dict["additionalVersionWeight"] as! [String: Double]
        }
        if dict.keys.contains("createdTime") {
            self.createdTime = dict["createdTime"] as! String
        }
        if dict.keys.contains("lastModifiedTime") {
            self.lastModifiedTime = dict["lastModifiedTime"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("resolvePolicy") {
            self.resolvePolicy = dict["resolvePolicy"] as! String
        }
        if dict.keys.contains("routePolicy") {
            var model = RoutePolicy()
            model.fromMap(dict["routePolicy"] as! [String: Any])
            self.routePolicy = model
        }
        if dict.keys.contains("versionId") {
            self.versionId = dict["versionId"] as! String
        }
    }
}

public class UpdateApplicationInput : Tea.TeaModel {
    public var args: String?

    public var caPort: Int32?

    public var code: InputCodeLocation?

    public var command: String?

    public var cpu: Double?

    public var customDNS: CustomDNS?

    public var customHealthCheckConfig: CustomHealthCheckConfig?

    public var customRuntimeConfig: CustomRuntimeConfig?

    public var description_: String?

    public var diskSize: Int32?

    public var effectiveImmediately: Bool?

    public var enableAppMetric: Bool?

    public var environmentVariables: [String: String]?

    public var gpuMemorySize: Int32?

    public var handler: String?

    public var httpTriggerConfig: HTTPTriggerConfig?

    public var imageConfig: ImageConfig?

    public var initializationTimeout: Int32?

    public var initializer: String?

    public var instanceConcurrency: Int32?

    public var instanceLifecycleConfig: InstanceLifecycleConfig?

    public var instanceSoftConcurrency: Int32?

    public var instanceType: String?

    public var internetAccess: Bool?

    public var layers: [String]?

    public var livenessProbe: Probe?

    public var logConfig: LogConfig?

    public var memorySize: Int32?

    public var nasConfig: NASConfig?

    public var ossMountConfig: OSSMountConfig?

    public var runtime: String?

    public var scaleConfig: ScaleConfig?

    public var slsConfig: SLSConfig?

    public var startupProbe: Probe?

    public var timeout: Int32?

    public var tracingConfig: TracingConfig?

    public var vpcConfig: VPCConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.code?.validate()
        try self.customDNS?.validate()
        try self.customHealthCheckConfig?.validate()
        try self.customRuntimeConfig?.validate()
        try self.httpTriggerConfig?.validate()
        try self.imageConfig?.validate()
        try self.instanceLifecycleConfig?.validate()
        try self.livenessProbe?.validate()
        try self.logConfig?.validate()
        try self.nasConfig?.validate()
        try self.ossMountConfig?.validate()
        try self.scaleConfig?.validate()
        try self.slsConfig?.validate()
        try self.startupProbe?.validate()
        try self.tracingConfig?.validate()
        try self.vpcConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.args != nil {
            map["args"] = self.args!
        }
        if self.caPort != nil {
            map["caPort"] = self.caPort!
        }
        if self.code != nil {
            map["code"] = self.code?.toMap()
        }
        if self.command != nil {
            map["command"] = self.command!
        }
        if self.cpu != nil {
            map["cpu"] = self.cpu!
        }
        if self.customDNS != nil {
            map["customDNS"] = self.customDNS?.toMap()
        }
        if self.customHealthCheckConfig != nil {
            map["customHealthCheckConfig"] = self.customHealthCheckConfig?.toMap()
        }
        if self.customRuntimeConfig != nil {
            map["customRuntimeConfig"] = self.customRuntimeConfig?.toMap()
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.diskSize != nil {
            map["diskSize"] = self.diskSize!
        }
        if self.effectiveImmediately != nil {
            map["effectiveImmediately"] = self.effectiveImmediately!
        }
        if self.enableAppMetric != nil {
            map["enableAppMetric"] = self.enableAppMetric!
        }
        if self.environmentVariables != nil {
            map["environmentVariables"] = self.environmentVariables!
        }
        if self.gpuMemorySize != nil {
            map["gpuMemorySize"] = self.gpuMemorySize!
        }
        if self.handler != nil {
            map["handler"] = self.handler!
        }
        if self.httpTriggerConfig != nil {
            map["httpTriggerConfig"] = self.httpTriggerConfig?.toMap()
        }
        if self.imageConfig != nil {
            map["imageConfig"] = self.imageConfig?.toMap()
        }
        if self.initializationTimeout != nil {
            map["initializationTimeout"] = self.initializationTimeout!
        }
        if self.initializer != nil {
            map["initializer"] = self.initializer!
        }
        if self.instanceConcurrency != nil {
            map["instanceConcurrency"] = self.instanceConcurrency!
        }
        if self.instanceLifecycleConfig != nil {
            map["instanceLifecycleConfig"] = self.instanceLifecycleConfig?.toMap()
        }
        if self.instanceSoftConcurrency != nil {
            map["instanceSoftConcurrency"] = self.instanceSoftConcurrency!
        }
        if self.instanceType != nil {
            map["instanceType"] = self.instanceType!
        }
        if self.internetAccess != nil {
            map["internetAccess"] = self.internetAccess!
        }
        if self.layers != nil {
            map["layers"] = self.layers!
        }
        if self.livenessProbe != nil {
            map["livenessProbe"] = self.livenessProbe?.toMap()
        }
        if self.logConfig != nil {
            map["logConfig"] = self.logConfig?.toMap()
        }
        if self.memorySize != nil {
            map["memorySize"] = self.memorySize!
        }
        if self.nasConfig != nil {
            map["nasConfig"] = self.nasConfig?.toMap()
        }
        if self.ossMountConfig != nil {
            map["ossMountConfig"] = self.ossMountConfig?.toMap()
        }
        if self.runtime != nil {
            map["runtime"] = self.runtime!
        }
        if self.scaleConfig != nil {
            map["scaleConfig"] = self.scaleConfig?.toMap()
        }
        if self.slsConfig != nil {
            map["slsConfig"] = self.slsConfig?.toMap()
        }
        if self.startupProbe != nil {
            map["startupProbe"] = self.startupProbe?.toMap()
        }
        if self.timeout != nil {
            map["timeout"] = self.timeout!
        }
        if self.tracingConfig != nil {
            map["tracingConfig"] = self.tracingConfig?.toMap()
        }
        if self.vpcConfig != nil {
            map["vpcConfig"] = self.vpcConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("args") {
            self.args = dict["args"] as! String
        }
        if dict.keys.contains("caPort") {
            self.caPort = dict["caPort"] as! Int32
        }
        if dict.keys.contains("code") {
            var model = InputCodeLocation()
            model.fromMap(dict["code"] as! [String: Any])
            self.code = model
        }
        if dict.keys.contains("command") {
            self.command = dict["command"] as! String
        }
        if dict.keys.contains("cpu") {
            self.cpu = dict["cpu"] as! Double
        }
        if dict.keys.contains("customDNS") {
            var model = CustomDNS()
            model.fromMap(dict["customDNS"] as! [String: Any])
            self.customDNS = model
        }
        if dict.keys.contains("customHealthCheckConfig") {
            var model = CustomHealthCheckConfig()
            model.fromMap(dict["customHealthCheckConfig"] as! [String: Any])
            self.customHealthCheckConfig = model
        }
        if dict.keys.contains("customRuntimeConfig") {
            var model = CustomRuntimeConfig()
            model.fromMap(dict["customRuntimeConfig"] as! [String: Any])
            self.customRuntimeConfig = model
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("diskSize") {
            self.diskSize = dict["diskSize"] as! Int32
        }
        if dict.keys.contains("effectiveImmediately") {
            self.effectiveImmediately = dict["effectiveImmediately"] as! Bool
        }
        if dict.keys.contains("enableAppMetric") {
            self.enableAppMetric = dict["enableAppMetric"] as! Bool
        }
        if dict.keys.contains("environmentVariables") {
            self.environmentVariables = dict["environmentVariables"] as! [String: String]
        }
        if dict.keys.contains("gpuMemorySize") {
            self.gpuMemorySize = dict["gpuMemorySize"] as! Int32
        }
        if dict.keys.contains("handler") {
            self.handler = dict["handler"] as! String
        }
        if dict.keys.contains("httpTriggerConfig") {
            var model = HTTPTriggerConfig()
            model.fromMap(dict["httpTriggerConfig"] as! [String: Any])
            self.httpTriggerConfig = model
        }
        if dict.keys.contains("imageConfig") {
            var model = ImageConfig()
            model.fromMap(dict["imageConfig"] as! [String: Any])
            self.imageConfig = model
        }
        if dict.keys.contains("initializationTimeout") {
            self.initializationTimeout = dict["initializationTimeout"] as! Int32
        }
        if dict.keys.contains("initializer") {
            self.initializer = dict["initializer"] as! String
        }
        if dict.keys.contains("instanceConcurrency") {
            self.instanceConcurrency = dict["instanceConcurrency"] as! Int32
        }
        if dict.keys.contains("instanceLifecycleConfig") {
            var model = InstanceLifecycleConfig()
            model.fromMap(dict["instanceLifecycleConfig"] as! [String: Any])
            self.instanceLifecycleConfig = model
        }
        if dict.keys.contains("instanceSoftConcurrency") {
            self.instanceSoftConcurrency = dict["instanceSoftConcurrency"] as! Int32
        }
        if dict.keys.contains("instanceType") {
            self.instanceType = dict["instanceType"] as! String
        }
        if dict.keys.contains("internetAccess") {
            self.internetAccess = dict["internetAccess"] as! Bool
        }
        if dict.keys.contains("layers") {
            self.layers = dict["layers"] as! [String]
        }
        if dict.keys.contains("livenessProbe") {
            var model = Probe()
            model.fromMap(dict["livenessProbe"] as! [String: Any])
            self.livenessProbe = model
        }
        if dict.keys.contains("logConfig") {
            var model = LogConfig()
            model.fromMap(dict["logConfig"] as! [String: Any])
            self.logConfig = model
        }
        if dict.keys.contains("memorySize") {
            self.memorySize = dict["memorySize"] as! Int32
        }
        if dict.keys.contains("nasConfig") {
            var model = NASConfig()
            model.fromMap(dict["nasConfig"] as! [String: Any])
            self.nasConfig = model
        }
        if dict.keys.contains("ossMountConfig") {
            var model = OSSMountConfig()
            model.fromMap(dict["ossMountConfig"] as! [String: Any])
            self.ossMountConfig = model
        }
        if dict.keys.contains("runtime") {
            self.runtime = dict["runtime"] as! String
        }
        if dict.keys.contains("scaleConfig") {
            var model = ScaleConfig()
            model.fromMap(dict["scaleConfig"] as! [String: Any])
            self.scaleConfig = model
        }
        if dict.keys.contains("slsConfig") {
            var model = SLSConfig()
            model.fromMap(dict["slsConfig"] as! [String: Any])
            self.slsConfig = model
        }
        if dict.keys.contains("startupProbe") {
            var model = Probe()
            model.fromMap(dict["startupProbe"] as! [String: Any])
            self.startupProbe = model
        }
        if dict.keys.contains("timeout") {
            self.timeout = dict["timeout"] as! Int32
        }
        if dict.keys.contains("tracingConfig") {
            var model = TracingConfig()
            model.fromMap(dict["tracingConfig"] as! [String: Any])
            self.tracingConfig = model
        }
        if dict.keys.contains("vpcConfig") {
            var model = VPCConfig()
            model.fromMap(dict["vpcConfig"] as! [String: Any])
            self.vpcConfig = model
        }
    }
}

public class UpdateApplicationScaleConfigInput : Tea.TeaModel {
    public var alwaysAllocateCPU: Bool?

    public var maximumInstanceCount: Int64?

    public var minimumInstanceCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alwaysAllocateCPU != nil {
            map["alwaysAllocateCPU"] = self.alwaysAllocateCPU!
        }
        if self.maximumInstanceCount != nil {
            map["maximumInstanceCount"] = self.maximumInstanceCount!
        }
        if self.minimumInstanceCount != nil {
            map["minimumInstanceCount"] = self.minimumInstanceCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("alwaysAllocateCPU") {
            self.alwaysAllocateCPU = dict["alwaysAllocateCPU"] as! Bool
        }
        if dict.keys.contains("maximumInstanceCount") {
            self.maximumInstanceCount = dict["maximumInstanceCount"] as! Int64
        }
        if dict.keys.contains("minimumInstanceCount") {
            self.minimumInstanceCount = dict["minimumInstanceCount"] as! Int64
        }
    }
}

public class UpdateApplicationTrafficConfigInput : Tea.TeaModel {
    public var additionalVersionWeight: [String: Double]?

    public var resolvePolicy: String?

    public var routePolicy: RoutePolicy?

    public var versionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routePolicy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionalVersionWeight != nil {
            map["additionalVersionWeight"] = self.additionalVersionWeight!
        }
        if self.resolvePolicy != nil {
            map["resolvePolicy"] = self.resolvePolicy!
        }
        if self.routePolicy != nil {
            map["routePolicy"] = self.routePolicy?.toMap()
        }
        if self.versionId != nil {
            map["versionId"] = self.versionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("additionalVersionWeight") {
            self.additionalVersionWeight = dict["additionalVersionWeight"] as! [String: Double]
        }
        if dict.keys.contains("resolvePolicy") {
            self.resolvePolicy = dict["resolvePolicy"] as! String
        }
        if dict.keys.contains("routePolicy") {
            var model = RoutePolicy()
            model.fromMap(dict["routePolicy"] as! [String: Any])
            self.routePolicy = model
        }
        if dict.keys.contains("versionId") {
            self.versionId = dict["versionId"] as! String
        }
    }
}

public class UpdateAttributesInput : Tea.TeaModel {
    public var description_: String?

    public var httpTriggerConfig: HTTPTriggerConfig?

    public var versionID: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.httpTriggerConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.httpTriggerConfig != nil {
            map["httpTriggerConfig"] = self.httpTriggerConfig?.toMap()
        }
        if self.versionID != nil {
            map["versionID"] = self.versionID!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("httpTriggerConfig") {
            var model = HTTPTriggerConfig()
            model.fromMap(dict["httpTriggerConfig"] as! [String: Any])
            self.httpTriggerConfig = model
        }
        if dict.keys.contains("versionID") {
            self.versionID = dict["versionID"] as! String
        }
    }
}

public class UpdateCustomDomainInput : Tea.TeaModel {
    public var applicationID: String?

    public var applicationName: String?

    public var certConfig: CertConfig?

    public var keepFullPath: Bool?

    public var namespaceID: String?

    public var protocol_: String?

    public var tlsConfig: TLSConfig?

    public var wafConfig: WAFConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.certConfig?.validate()
        try self.tlsConfig?.validate()
        try self.wafConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationID != nil {
            map["applicationID"] = self.applicationID!
        }
        if self.applicationName != nil {
            map["applicationName"] = self.applicationName!
        }
        if self.certConfig != nil {
            map["certConfig"] = self.certConfig?.toMap()
        }
        if self.keepFullPath != nil {
            map["keepFullPath"] = self.keepFullPath!
        }
        if self.namespaceID != nil {
            map["namespaceID"] = self.namespaceID!
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.tlsConfig != nil {
            map["tlsConfig"] = self.tlsConfig?.toMap()
        }
        if self.wafConfig != nil {
            map["wafConfig"] = self.wafConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("applicationID") {
            self.applicationID = dict["applicationID"] as! String
        }
        if dict.keys.contains("applicationName") {
            self.applicationName = dict["applicationName"] as! String
        }
        if dict.keys.contains("certConfig") {
            var model = CertConfig()
            model.fromMap(dict["certConfig"] as! [String: Any])
            self.certConfig = model
        }
        if dict.keys.contains("keepFullPath") {
            self.keepFullPath = dict["keepFullPath"] as! Bool
        }
        if dict.keys.contains("namespaceID") {
            self.namespaceID = dict["namespaceID"] as! String
        }
        if dict.keys.contains("protocol") {
            self.protocol_ = dict["protocol"] as! String
        }
        if dict.keys.contains("tlsConfig") {
            var model = TLSConfig()
            model.fromMap(dict["tlsConfig"] as! [String: Any])
            self.tlsConfig = model
        }
        if dict.keys.contains("wafConfig") {
            var model = WAFConfig()
            model.fromMap(dict["wafConfig"] as! [String: Any])
            self.wafConfig = model
        }
    }
}

public class VPCConfig : Tea.TeaModel {
    public var anytunnelViaENI: Bool?

    public var role: String?

    public var securityGroupId: String?

    public var vSwitchIds: [String]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.anytunnelViaENI != nil {
            map["anytunnelViaENI"] = self.anytunnelViaENI!
        }
        if self.role != nil {
            map["role"] = self.role!
        }
        if self.securityGroupId != nil {
            map["securityGroupId"] = self.securityGroupId!
        }
        if self.vSwitchIds != nil {
            map["vSwitchIds"] = self.vSwitchIds!
        }
        if self.vpcId != nil {
            map["vpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("anytunnelViaENI") {
            self.anytunnelViaENI = dict["anytunnelViaENI"] as! Bool
        }
        if dict.keys.contains("role") {
            self.role = dict["role"] as! String
        }
        if dict.keys.contains("securityGroupId") {
            self.securityGroupId = dict["securityGroupId"] as! String
        }
        if dict.keys.contains("vSwitchIds") {
            self.vSwitchIds = dict["vSwitchIds"] as! [String]
        }
        if dict.keys.contains("vpcId") {
            self.vpcId = dict["vpcId"] as! String
        }
    }
}

public class Version : Tea.TeaModel {
    public var createdTime: String?

    public var description_: String?

    public var image: String?

    public var lastModifiedTime: String?

    public var requestId: String?

    public var versionId: String?

    public var weight: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createdTime != nil {
            map["createdTime"] = self.createdTime!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.image != nil {
            map["image"] = self.image!
        }
        if self.lastModifiedTime != nil {
            map["lastModifiedTime"] = self.lastModifiedTime!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.versionId != nil {
            map["versionId"] = self.versionId!
        }
        if self.weight != nil {
            map["weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("createdTime") {
            self.createdTime = dict["createdTime"] as! String
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("image") {
            self.image = dict["image"] as! String
        }
        if dict.keys.contains("lastModifiedTime") {
            self.lastModifiedTime = dict["lastModifiedTime"] as! String
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("versionId") {
            self.versionId = dict["versionId"] as! String
        }
        if dict.keys.contains("weight") {
            self.weight = dict["weight"] as! Double
        }
    }
}

public class VersionStatus : Tea.TeaModel {
    public var errorMessage: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("errorMessage") {
            self.errorMessage = dict["errorMessage"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
    }
}

public class WAFConfig : Tea.TeaModel {
    public var enableWAF: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableWAF != nil {
            map["enableWAF"] = self.enableWAF!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("enableWAF") {
            self.enableWAF = dict["enableWAF"] as! Bool
        }
    }
}

public class AbortAndRollbackChangeOrderRequest : Tea.TeaModel {
    public var changeOrderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
    }
}

public class AbortAndRollbackChangeOrderResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var data: AbortAndRollbackChangeOrderResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = AbortAndRollbackChangeOrderResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class AbortAndRollbackChangeOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AbortAndRollbackChangeOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AbortAndRollbackChangeOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AbortChangeOrderRequest : Tea.TeaModel {
    public var changeOrderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
    }
}

public class AbortChangeOrderResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var data: AbortChangeOrderResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = AbortChangeOrderResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class AbortChangeOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AbortChangeOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AbortChangeOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchStartApplicationsRequest : Tea.TeaModel {
    public var appIds: String?

    public var namespaceId: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppIds") {
            self.appIds = dict["AppIds"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Version") {
            self.version = dict["Version"] as! String
        }
    }
}

public class BatchStartApplicationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var data: BatchStartApplicationsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = BatchStartApplicationsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class BatchStartApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchStartApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchStartApplicationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BatchStopApplicationsRequest : Tea.TeaModel {
    public var appIds: String?

    public var namespaceId: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppIds") {
            self.appIds = dict["AppIds"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Version") {
            self.version = dict["Version"] as! String
        }
    }
}

public class BatchStopApplicationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var data: BatchStopApplicationsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = BatchStopApplicationsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class BatchStopApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchStopApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BatchStopApplicationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BindSlbRequest : Tea.TeaModel {
    public var appId: String?

    public var internet: String?

    public var internetSlbId: String?

    public var intranet: String?

    public var intranetSlbId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.internet != nil {
            map["Internet"] = self.internet!
        }
        if self.internetSlbId != nil {
            map["InternetSlbId"] = self.internetSlbId!
        }
        if self.intranet != nil {
            map["Intranet"] = self.intranet!
        }
        if self.intranetSlbId != nil {
            map["IntranetSlbId"] = self.intranetSlbId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Internet") {
            self.internet = dict["Internet"] as! String
        }
        if dict.keys.contains("InternetSlbId") {
            self.internetSlbId = dict["InternetSlbId"] as! String
        }
        if dict.keys.contains("Intranet") {
            self.intranet = dict["Intranet"] as! String
        }
        if dict.keys.contains("IntranetSlbId") {
            self.intranetSlbId = dict["IntranetSlbId"] as! String
        }
    }
}

public class BindSlbResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var data: BindSlbResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = BindSlbResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class BindSlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindSlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BindSlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfirmPipelineBatchRequest : Tea.TeaModel {
    public var confirm: Bool?

    public var pipelineId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.confirm != nil {
            map["Confirm"] = self.confirm!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Confirm") {
            self.confirm = dict["Confirm"] as! Bool
        }
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
    }
}

public class ConfirmPipelineBatchResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var pipelineId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
        }
    }
    public var code: String?

    public var data: ConfirmPipelineBatchResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ConfirmPipelineBatchResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class ConfirmPipelineBatchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfirmPipelineBatchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConfirmPipelineBatchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateApplicationRequest : Tea.TeaModel {
    public var acrAssumeRoleArn: String?

    public var acrInstanceId: String?

    public var appDescription: String?

    public var appName: String?

    public var appSource: String?

    public var associateEip: Bool?

    public var autoConfig: Bool?

    public var baseAppId: String?

    public var command: String?

    public var commandArgs: String?

    public var configMapMountDesc: String?

    public var cpu: Int32?

    public var customHostAlias: String?

    public var deploy: Bool?

    public var edasContainerVersion: String?

    public var enableEbpf: String?

    public var envs: String?

    public var imagePullSecrets: String?

    public var imageUrl: String?

    public var jarStartArgs: String?

    public var jarStartOptions: String?

    public var jdk: String?

    public var kafkaConfigs: String?

    public var liveness: String?

    public var memory: Int32?

    public var microRegistration: String?

    public var microRegistrationConfig: String?

    public var mountDesc: String?

    public var mountHost: String?

    public var namespaceId: String?

    public var nasConfigs: String?

    public var nasId: String?

    public var ossAkId: String?

    public var ossAkSecret: String?

    public var ossMountDescs: String?

    public var packageType: String?

    public var packageUrl: String?

    public var packageVersion: String?

    public var php: String?

    public var phpArmsConfigLocation: String?

    public var phpConfig: String?

    public var phpConfigLocation: String?

    public var postStart: String?

    public var preStop: String?

    public var programmingLanguage: String?

    public var pvtzDiscoverySvc: String?

    public var python: String?

    public var pythonModules: String?

    public var readiness: String?

    public var replicas: Int32?

    public var saeVersion: String?

    public var securityGroupId: String?

    public var serviceTags: String?

    public var slsConfigs: String?

    public var terminationGracePeriodSeconds: Int32?

    public var timezone: String?

    public var tomcatConfig: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public var warStartOptions: String?

    public var webContainer: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acrAssumeRoleArn != nil {
            map["AcrAssumeRoleArn"] = self.acrAssumeRoleArn!
        }
        if self.acrInstanceId != nil {
            map["AcrInstanceId"] = self.acrInstanceId!
        }
        if self.appDescription != nil {
            map["AppDescription"] = self.appDescription!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.appSource != nil {
            map["AppSource"] = self.appSource!
        }
        if self.associateEip != nil {
            map["AssociateEip"] = self.associateEip!
        }
        if self.autoConfig != nil {
            map["AutoConfig"] = self.autoConfig!
        }
        if self.baseAppId != nil {
            map["BaseAppId"] = self.baseAppId!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.commandArgs != nil {
            map["CommandArgs"] = self.commandArgs!
        }
        if self.configMapMountDesc != nil {
            map["ConfigMapMountDesc"] = self.configMapMountDesc!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.customHostAlias != nil {
            map["CustomHostAlias"] = self.customHostAlias!
        }
        if self.deploy != nil {
            map["Deploy"] = self.deploy!
        }
        if self.edasContainerVersion != nil {
            map["EdasContainerVersion"] = self.edasContainerVersion!
        }
        if self.enableEbpf != nil {
            map["EnableEbpf"] = self.enableEbpf!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.imagePullSecrets != nil {
            map["ImagePullSecrets"] = self.imagePullSecrets!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.jarStartArgs != nil {
            map["JarStartArgs"] = self.jarStartArgs!
        }
        if self.jarStartOptions != nil {
            map["JarStartOptions"] = self.jarStartOptions!
        }
        if self.jdk != nil {
            map["Jdk"] = self.jdk!
        }
        if self.kafkaConfigs != nil {
            map["KafkaConfigs"] = self.kafkaConfigs!
        }
        if self.liveness != nil {
            map["Liveness"] = self.liveness!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.microRegistration != nil {
            map["MicroRegistration"] = self.microRegistration!
        }
        if self.microRegistrationConfig != nil {
            map["MicroRegistrationConfig"] = self.microRegistrationConfig!
        }
        if self.mountDesc != nil {
            map["MountDesc"] = self.mountDesc!
        }
        if self.mountHost != nil {
            map["MountHost"] = self.mountHost!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.nasConfigs != nil {
            map["NasConfigs"] = self.nasConfigs!
        }
        if self.nasId != nil {
            map["NasId"] = self.nasId!
        }
        if self.ossAkId != nil {
            map["OssAkId"] = self.ossAkId!
        }
        if self.ossAkSecret != nil {
            map["OssAkSecret"] = self.ossAkSecret!
        }
        if self.ossMountDescs != nil {
            map["OssMountDescs"] = self.ossMountDescs!
        }
        if self.packageType != nil {
            map["PackageType"] = self.packageType!
        }
        if self.packageUrl != nil {
            map["PackageUrl"] = self.packageUrl!
        }
        if self.packageVersion != nil {
            map["PackageVersion"] = self.packageVersion!
        }
        if self.php != nil {
            map["Php"] = self.php!
        }
        if self.phpArmsConfigLocation != nil {
            map["PhpArmsConfigLocation"] = self.phpArmsConfigLocation!
        }
        if self.phpConfig != nil {
            map["PhpConfig"] = self.phpConfig!
        }
        if self.phpConfigLocation != nil {
            map["PhpConfigLocation"] = self.phpConfigLocation!
        }
        if self.postStart != nil {
            map["PostStart"] = self.postStart!
        }
        if self.preStop != nil {
            map["PreStop"] = self.preStop!
        }
        if self.programmingLanguage != nil {
            map["ProgrammingLanguage"] = self.programmingLanguage!
        }
        if self.pvtzDiscoverySvc != nil {
            map["PvtzDiscoverySvc"] = self.pvtzDiscoverySvc!
        }
        if self.python != nil {
            map["Python"] = self.python!
        }
        if self.pythonModules != nil {
            map["PythonModules"] = self.pythonModules!
        }
        if self.readiness != nil {
            map["Readiness"] = self.readiness!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.saeVersion != nil {
            map["SaeVersion"] = self.saeVersion!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.serviceTags != nil {
            map["ServiceTags"] = self.serviceTags!
        }
        if self.slsConfigs != nil {
            map["SlsConfigs"] = self.slsConfigs!
        }
        if self.terminationGracePeriodSeconds != nil {
            map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
        }
        if self.timezone != nil {
            map["Timezone"] = self.timezone!
        }
        if self.tomcatConfig != nil {
            map["TomcatConfig"] = self.tomcatConfig!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.warStartOptions != nil {
            map["WarStartOptions"] = self.warStartOptions!
        }
        if self.webContainer != nil {
            map["WebContainer"] = self.webContainer!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcrAssumeRoleArn") {
            self.acrAssumeRoleArn = dict["AcrAssumeRoleArn"] as! String
        }
        if dict.keys.contains("AcrInstanceId") {
            self.acrInstanceId = dict["AcrInstanceId"] as! String
        }
        if dict.keys.contains("AppDescription") {
            self.appDescription = dict["AppDescription"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("AppSource") {
            self.appSource = dict["AppSource"] as! String
        }
        if dict.keys.contains("AssociateEip") {
            self.associateEip = dict["AssociateEip"] as! Bool
        }
        if dict.keys.contains("AutoConfig") {
            self.autoConfig = dict["AutoConfig"] as! Bool
        }
        if dict.keys.contains("BaseAppId") {
            self.baseAppId = dict["BaseAppId"] as! String
        }
        if dict.keys.contains("Command") {
            self.command = dict["Command"] as! String
        }
        if dict.keys.contains("CommandArgs") {
            self.commandArgs = dict["CommandArgs"] as! String
        }
        if dict.keys.contains("ConfigMapMountDesc") {
            self.configMapMountDesc = dict["ConfigMapMountDesc"] as! String
        }
        if dict.keys.contains("Cpu") {
            self.cpu = dict["Cpu"] as! Int32
        }
        if dict.keys.contains("CustomHostAlias") {
            self.customHostAlias = dict["CustomHostAlias"] as! String
        }
        if dict.keys.contains("Deploy") {
            self.deploy = dict["Deploy"] as! Bool
        }
        if dict.keys.contains("EdasContainerVersion") {
            self.edasContainerVersion = dict["EdasContainerVersion"] as! String
        }
        if dict.keys.contains("EnableEbpf") {
            self.enableEbpf = dict["EnableEbpf"] as! String
        }
        if dict.keys.contains("Envs") {
            self.envs = dict["Envs"] as! String
        }
        if dict.keys.contains("ImagePullSecrets") {
            self.imagePullSecrets = dict["ImagePullSecrets"] as! String
        }
        if dict.keys.contains("ImageUrl") {
            self.imageUrl = dict["ImageUrl"] as! String
        }
        if dict.keys.contains("JarStartArgs") {
            self.jarStartArgs = dict["JarStartArgs"] as! String
        }
        if dict.keys.contains("JarStartOptions") {
            self.jarStartOptions = dict["JarStartOptions"] as! String
        }
        if dict.keys.contains("Jdk") {
            self.jdk = dict["Jdk"] as! String
        }
        if dict.keys.contains("KafkaConfigs") {
            self.kafkaConfigs = dict["KafkaConfigs"] as! String
        }
        if dict.keys.contains("Liveness") {
            self.liveness = dict["Liveness"] as! String
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Int32
        }
        if dict.keys.contains("MicroRegistration") {
            self.microRegistration = dict["MicroRegistration"] as! String
        }
        if dict.keys.contains("MicroRegistrationConfig") {
            self.microRegistrationConfig = dict["MicroRegistrationConfig"] as! String
        }
        if dict.keys.contains("MountDesc") {
            self.mountDesc = dict["MountDesc"] as! String
        }
        if dict.keys.contains("MountHost") {
            self.mountHost = dict["MountHost"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("NasConfigs") {
            self.nasConfigs = dict["NasConfigs"] as! String
        }
        if dict.keys.contains("NasId") {
            self.nasId = dict["NasId"] as! String
        }
        if dict.keys.contains("OssAkId") {
            self.ossAkId = dict["OssAkId"] as! String
        }
        if dict.keys.contains("OssAkSecret") {
            self.ossAkSecret = dict["OssAkSecret"] as! String
        }
        if dict.keys.contains("OssMountDescs") {
            self.ossMountDescs = dict["OssMountDescs"] as! String
        }
        if dict.keys.contains("PackageType") {
            self.packageType = dict["PackageType"] as! String
        }
        if dict.keys.contains("PackageUrl") {
            self.packageUrl = dict["PackageUrl"] as! String
        }
        if dict.keys.contains("PackageVersion") {
            self.packageVersion = dict["PackageVersion"] as! String
        }
        if dict.keys.contains("Php") {
            self.php = dict["Php"] as! String
        }
        if dict.keys.contains("PhpArmsConfigLocation") {
            self.phpArmsConfigLocation = dict["PhpArmsConfigLocation"] as! String
        }
        if dict.keys.contains("PhpConfig") {
            self.phpConfig = dict["PhpConfig"] as! String
        }
        if dict.keys.contains("PhpConfigLocation") {
            self.phpConfigLocation = dict["PhpConfigLocation"] as! String
        }
        if dict.keys.contains("PostStart") {
            self.postStart = dict["PostStart"] as! String
        }
        if dict.keys.contains("PreStop") {
            self.preStop = dict["PreStop"] as! String
        }
        if dict.keys.contains("ProgrammingLanguage") {
            self.programmingLanguage = dict["ProgrammingLanguage"] as! String
        }
        if dict.keys.contains("PvtzDiscoverySvc") {
            self.pvtzDiscoverySvc = dict["PvtzDiscoverySvc"] as! String
        }
        if dict.keys.contains("Python") {
            self.python = dict["Python"] as! String
        }
        if dict.keys.contains("PythonModules") {
            self.pythonModules = dict["PythonModules"] as! String
        }
        if dict.keys.contains("Readiness") {
            self.readiness = dict["Readiness"] as! String
        }
        if dict.keys.contains("Replicas") {
            self.replicas = dict["Replicas"] as! Int32
        }
        if dict.keys.contains("SaeVersion") {
            self.saeVersion = dict["SaeVersion"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("ServiceTags") {
            self.serviceTags = dict["ServiceTags"] as! String
        }
        if dict.keys.contains("SlsConfigs") {
            self.slsConfigs = dict["SlsConfigs"] as! String
        }
        if dict.keys.contains("TerminationGracePeriodSeconds") {
            self.terminationGracePeriodSeconds = dict["TerminationGracePeriodSeconds"] as! Int32
        }
        if dict.keys.contains("Timezone") {
            self.timezone = dict["Timezone"] as! String
        }
        if dict.keys.contains("TomcatConfig") {
            self.tomcatConfig = dict["TomcatConfig"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("WarStartOptions") {
            self.warStartOptions = dict["WarStartOptions"] as! String
        }
        if dict.keys.contains("WebContainer") {
            self.webContainer = dict["WebContainer"] as! String
        }
    }
}

public class CreateApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateApplicationResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateApplicationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class CreateApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var minReadyInstanceRatio: Int32?

    public var minReadyInstances: Int32?

    public var scalingRuleEnable: Bool?

    public var scalingRuleMetric: String?

    public var scalingRuleName: String?

    public var scalingRuleTimer: String?

    public var scalingRuleType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.minReadyInstanceRatio != nil {
            map["MinReadyInstanceRatio"] = self.minReadyInstanceRatio!
        }
        if self.minReadyInstances != nil {
            map["MinReadyInstances"] = self.minReadyInstances!
        }
        if self.scalingRuleEnable != nil {
            map["ScalingRuleEnable"] = self.scalingRuleEnable!
        }
        if self.scalingRuleMetric != nil {
            map["ScalingRuleMetric"] = self.scalingRuleMetric!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        if self.scalingRuleTimer != nil {
            map["ScalingRuleTimer"] = self.scalingRuleTimer!
        }
        if self.scalingRuleType != nil {
            map["ScalingRuleType"] = self.scalingRuleType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MinReadyInstanceRatio") {
            self.minReadyInstanceRatio = dict["MinReadyInstanceRatio"] as! Int32
        }
        if dict.keys.contains("MinReadyInstances") {
            self.minReadyInstances = dict["MinReadyInstances"] as! Int32
        }
        if dict.keys.contains("ScalingRuleEnable") {
            self.scalingRuleEnable = dict["ScalingRuleEnable"] as! Bool
        }
        if dict.keys.contains("ScalingRuleMetric") {
            self.scalingRuleMetric = dict["ScalingRuleMetric"] as! String
        }
        if dict.keys.contains("ScalingRuleName") {
            self.scalingRuleName = dict["ScalingRuleName"] as! String
        }
        if dict.keys.contains("ScalingRuleTimer") {
            self.scalingRuleTimer = dict["ScalingRuleTimer"] as! String
        }
        if dict.keys.contains("ScalingRuleType") {
            self.scalingRuleType = dict["ScalingRuleType"] as! String
        }
    }
}

public class CreateApplicationScalingRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Metric : Tea.TeaModel {
            public class Metrics : Tea.TeaModel {
                public var metricTargetAverageUtilization: Int32?

                public var metricType: String?

                public var slbId: String?

                public var slbLogstore: String?

                public var slbProject: String?

                public var vport: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricTargetAverageUtilization != nil {
                        map["MetricTargetAverageUtilization"] = self.metricTargetAverageUtilization!
                    }
                    if self.metricType != nil {
                        map["MetricType"] = self.metricType!
                    }
                    if self.slbId != nil {
                        map["SlbId"] = self.slbId!
                    }
                    if self.slbLogstore != nil {
                        map["SlbLogstore"] = self.slbLogstore!
                    }
                    if self.slbProject != nil {
                        map["SlbProject"] = self.slbProject!
                    }
                    if self.vport != nil {
                        map["Vport"] = self.vport!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MetricTargetAverageUtilization") {
                        self.metricTargetAverageUtilization = dict["MetricTargetAverageUtilization"] as! Int32
                    }
                    if dict.keys.contains("MetricType") {
                        self.metricType = dict["MetricType"] as! String
                    }
                    if dict.keys.contains("SlbId") {
                        self.slbId = dict["SlbId"] as! String
                    }
                    if dict.keys.contains("SlbLogstore") {
                        self.slbLogstore = dict["SlbLogstore"] as! String
                    }
                    if dict.keys.contains("SlbProject") {
                        self.slbProject = dict["SlbProject"] as! String
                    }
                    if dict.keys.contains("Vport") {
                        self.vport = dict["Vport"] as! String
                    }
                }
            }
            public var maxReplicas: Int32?

            public var metrics: [CreateApplicationScalingRuleResponseBody.Data.Metric.Metrics]?

            public var minReplicas: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.metrics != nil {
                    var tmp : [Any] = []
                    for k in self.metrics! {
                        tmp.append(k.toMap())
                    }
                    map["Metrics"] = tmp
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxReplicas") {
                    self.maxReplicas = dict["MaxReplicas"] as! Int32
                }
                if dict.keys.contains("Metrics") {
                    var tmp : [CreateApplicationScalingRuleResponseBody.Data.Metric.Metrics] = []
                    for v in dict["Metrics"] as! [Any] {
                        var model = CreateApplicationScalingRuleResponseBody.Data.Metric.Metrics()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.metrics = tmp
                }
                if dict.keys.contains("MinReplicas") {
                    self.minReplicas = dict["MinReplicas"] as! Int32
                }
            }
        }
        public class Timer : Tea.TeaModel {
            public class Schedules : Tea.TeaModel {
                public var atTime: String?

                public var maxReplicas: Int32?

                public var minReplicas: Int32?

                public var targetReplicas: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.atTime != nil {
                        map["AtTime"] = self.atTime!
                    }
                    if self.maxReplicas != nil {
                        map["MaxReplicas"] = self.maxReplicas!
                    }
                    if self.minReplicas != nil {
                        map["MinReplicas"] = self.minReplicas!
                    }
                    if self.targetReplicas != nil {
                        map["TargetReplicas"] = self.targetReplicas!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AtTime") {
                        self.atTime = dict["AtTime"] as! String
                    }
                    if dict.keys.contains("MaxReplicas") {
                        self.maxReplicas = dict["MaxReplicas"] as! Int32
                    }
                    if dict.keys.contains("MinReplicas") {
                        self.minReplicas = dict["MinReplicas"] as! Int32
                    }
                    if dict.keys.contains("TargetReplicas") {
                        self.targetReplicas = dict["TargetReplicas"] as! Int32
                    }
                }
            }
            public var beginDate: String?

            public var endDate: String?

            public var period: String?

            public var schedules: [CreateApplicationScalingRuleResponseBody.Data.Timer.Schedules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.beginDate != nil {
                    map["BeginDate"] = self.beginDate!
                }
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.schedules != nil {
                    var tmp : [Any] = []
                    for k in self.schedules! {
                        tmp.append(k.toMap())
                    }
                    map["Schedules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BeginDate") {
                    self.beginDate = dict["BeginDate"] as! String
                }
                if dict.keys.contains("EndDate") {
                    self.endDate = dict["EndDate"] as! String
                }
                if dict.keys.contains("Period") {
                    self.period = dict["Period"] as! String
                }
                if dict.keys.contains("Schedules") {
                    var tmp : [CreateApplicationScalingRuleResponseBody.Data.Timer.Schedules] = []
                    for v in dict["Schedules"] as! [Any] {
                        var model = CreateApplicationScalingRuleResponseBody.Data.Timer.Schedules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.schedules = tmp
                }
            }
        }
        public var appId: String?

        public var createTime: Int64?

        public var lastDisableTime: Int64?

        public var metric: CreateApplicationScalingRuleResponseBody.Data.Metric?

        public var scaleRuleEnabled: Bool?

        public var scaleRuleName: String?

        public var scaleRuleType: String?

        public var timer: CreateApplicationScalingRuleResponseBody.Data.Timer?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metric?.validate()
            try self.timer?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastDisableTime != nil {
                map["LastDisableTime"] = self.lastDisableTime!
            }
            if self.metric != nil {
                map["Metric"] = self.metric?.toMap()
            }
            if self.scaleRuleEnabled != nil {
                map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
            }
            if self.scaleRuleName != nil {
                map["ScaleRuleName"] = self.scaleRuleName!
            }
            if self.scaleRuleType != nil {
                map["ScaleRuleType"] = self.scaleRuleType!
            }
            if self.timer != nil {
                map["Timer"] = self.timer?.toMap()
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("LastDisableTime") {
                self.lastDisableTime = dict["LastDisableTime"] as! Int64
            }
            if dict.keys.contains("Metric") {
                var model = CreateApplicationScalingRuleResponseBody.Data.Metric()
                model.fromMap(dict["Metric"] as! [String: Any])
                self.metric = model
            }
            if dict.keys.contains("ScaleRuleEnabled") {
                self.scaleRuleEnabled = dict["ScaleRuleEnabled"] as! Bool
            }
            if dict.keys.contains("ScaleRuleName") {
                self.scaleRuleName = dict["ScaleRuleName"] as! String
            }
            if dict.keys.contains("ScaleRuleType") {
                self.scaleRuleType = dict["ScaleRuleType"] as! String
            }
            if dict.keys.contains("Timer") {
                var model = CreateApplicationScalingRuleResponseBody.Data.Timer()
                model.fromMap(dict["Timer"] as! [String: Any])
                self.timer = model
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: CreateApplicationScalingRuleResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateApplicationScalingRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class CreateApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateApplicationScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateConfigMapRequest : Tea.TeaModel {
    public var data: String?

    public var description_: String?

    public var name: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class CreateConfigMapResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configMapId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configMapId != nil {
                map["ConfigMapId"] = self.configMapId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigMapId") {
                self.configMapId = dict["ConfigMapId"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: CreateConfigMapResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateConfigMapResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class CreateConfigMapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateConfigMapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateConfigMapResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateGreyTagRouteRequest : Tea.TeaModel {
    public var albRules: String?

    public var appId: String?

    public var description_: String?

    public var dubboRules: String?

    public var name: String?

    public var scRules: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.albRules != nil {
            map["AlbRules"] = self.albRules!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dubboRules != nil {
            map["DubboRules"] = self.dubboRules!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.scRules != nil {
            map["ScRules"] = self.scRules!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlbRules") {
            self.albRules = dict["AlbRules"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DubboRules") {
            self.dubboRules = dict["DubboRules"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ScRules") {
            self.scRules = dict["ScRules"] as! String
        }
    }
}

public class CreateGreyTagRouteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var greyTagRouteId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.greyTagRouteId != nil {
                map["GreyTagRouteId"] = self.greyTagRouteId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GreyTagRouteId") {
                self.greyTagRouteId = dict["GreyTagRouteId"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: CreateGreyTagRouteResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateGreyTagRouteResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class CreateGreyTagRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateGreyTagRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateGreyTagRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIngressRequest : Tea.TeaModel {
    public var certId: String?

    public var certIds: String?

    public var defaultRule: String?

    public var description_: String?

    public var listenerPort: Int32?

    public var listenerProtocol: String?

    public var loadBalanceType: String?

    public var namespaceId: String?

    public var rules: String?

    public var slbId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certId != nil {
            map["CertId"] = self.certId!
        }
        if self.certIds != nil {
            map["CertIds"] = self.certIds!
        }
        if self.defaultRule != nil {
            map["DefaultRule"] = self.defaultRule!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.listenerProtocol != nil {
            map["ListenerProtocol"] = self.listenerProtocol!
        }
        if self.loadBalanceType != nil {
            map["LoadBalanceType"] = self.loadBalanceType!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.rules != nil {
            map["Rules"] = self.rules!
        }
        if self.slbId != nil {
            map["SlbId"] = self.slbId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertId") {
            self.certId = dict["CertId"] as! String
        }
        if dict.keys.contains("CertIds") {
            self.certIds = dict["CertIds"] as! String
        }
        if dict.keys.contains("DefaultRule") {
            self.defaultRule = dict["DefaultRule"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! Int32
        }
        if dict.keys.contains("ListenerProtocol") {
            self.listenerProtocol = dict["ListenerProtocol"] as! String
        }
        if dict.keys.contains("LoadBalanceType") {
            self.loadBalanceType = dict["LoadBalanceType"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("Rules") {
            self.rules = dict["Rules"] as! String
        }
        if dict.keys.contains("SlbId") {
            self.slbId = dict["SlbId"] as! String
        }
    }
}

public class CreateIngressResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var ingressId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ingressId != nil {
                map["IngressId"] = self.ingressId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IngressId") {
                self.ingressId = dict["IngressId"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: CreateIngressResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateIngressResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class CreateIngressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIngressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateIngressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateJobRequest : Tea.TeaModel {
    public var acrAssumeRoleArn: String?

    public var acrInstanceId: String?

    public var appDescription: String?

    public var appName: String?

    public var autoConfig: Bool?

    public var backoffLimit: Int64?

    public var command: String?

    public var commandArgs: String?

    public var concurrencyPolicy: String?

    public var configMapMountDesc: String?

    public var cpu: Int32?

    public var customHostAlias: String?

    public var edasContainerVersion: String?

    public var enableImageAccl: Bool?

    public var envs: String?

    public var imagePullSecrets: String?

    public var imageUrl: String?

    public var jarStartArgs: String?

    public var jarStartOptions: String?

    public var jdk: String?

    public var memory: Int32?

    public var mountDesc: String?

    public var mountHost: String?

    public var namespaceId: String?

    public var nasId: String?

    public var ossAkId: String?

    public var ossAkSecret: String?

    public var ossMountDescs: String?

    public var packageType: String?

    public var packageUrl: String?

    public var packageVersion: String?

    public var phpConfig: String?

    public var phpConfigLocation: String?

    public var postStart: String?

    public var preStop: String?

    public var programmingLanguage: String?

    public var python: String?

    public var pythonModules: String?

    public var refAppId: String?

    public var replicas: Int32?

    public var securityGroupId: String?

    public var slice: Bool?

    public var sliceEnvs: String?

    public var slsConfigs: String?

    public var terminationGracePeriodSeconds: Int32?

    public var timeout: Int64?

    public var timezone: String?

    public var tomcatConfig: String?

    public var triggerConfig: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public var warStartOptions: String?

    public var webContainer: String?

    public var workload: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acrAssumeRoleArn != nil {
            map["AcrAssumeRoleArn"] = self.acrAssumeRoleArn!
        }
        if self.acrInstanceId != nil {
            map["AcrInstanceId"] = self.acrInstanceId!
        }
        if self.appDescription != nil {
            map["AppDescription"] = self.appDescription!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.autoConfig != nil {
            map["AutoConfig"] = self.autoConfig!
        }
        if self.backoffLimit != nil {
            map["BackoffLimit"] = self.backoffLimit!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.commandArgs != nil {
            map["CommandArgs"] = self.commandArgs!
        }
        if self.concurrencyPolicy != nil {
            map["ConcurrencyPolicy"] = self.concurrencyPolicy!
        }
        if self.configMapMountDesc != nil {
            map["ConfigMapMountDesc"] = self.configMapMountDesc!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.customHostAlias != nil {
            map["CustomHostAlias"] = self.customHostAlias!
        }
        if self.edasContainerVersion != nil {
            map["EdasContainerVersion"] = self.edasContainerVersion!
        }
        if self.enableImageAccl != nil {
            map["EnableImageAccl"] = self.enableImageAccl!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.imagePullSecrets != nil {
            map["ImagePullSecrets"] = self.imagePullSecrets!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.jarStartArgs != nil {
            map["JarStartArgs"] = self.jarStartArgs!
        }
        if self.jarStartOptions != nil {
            map["JarStartOptions"] = self.jarStartOptions!
        }
        if self.jdk != nil {
            map["Jdk"] = self.jdk!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.mountDesc != nil {
            map["MountDesc"] = self.mountDesc!
        }
        if self.mountHost != nil {
            map["MountHost"] = self.mountHost!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.nasId != nil {
            map["NasId"] = self.nasId!
        }
        if self.ossAkId != nil {
            map["OssAkId"] = self.ossAkId!
        }
        if self.ossAkSecret != nil {
            map["OssAkSecret"] = self.ossAkSecret!
        }
        if self.ossMountDescs != nil {
            map["OssMountDescs"] = self.ossMountDescs!
        }
        if self.packageType != nil {
            map["PackageType"] = self.packageType!
        }
        if self.packageUrl != nil {
            map["PackageUrl"] = self.packageUrl!
        }
        if self.packageVersion != nil {
            map["PackageVersion"] = self.packageVersion!
        }
        if self.phpConfig != nil {
            map["PhpConfig"] = self.phpConfig!
        }
        if self.phpConfigLocation != nil {
            map["PhpConfigLocation"] = self.phpConfigLocation!
        }
        if self.postStart != nil {
            map["PostStart"] = self.postStart!
        }
        if self.preStop != nil {
            map["PreStop"] = self.preStop!
        }
        if self.programmingLanguage != nil {
            map["ProgrammingLanguage"] = self.programmingLanguage!
        }
        if self.python != nil {
            map["Python"] = self.python!
        }
        if self.pythonModules != nil {
            map["PythonModules"] = self.pythonModules!
        }
        if self.refAppId != nil {
            map["RefAppId"] = self.refAppId!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.slice != nil {
            map["Slice"] = self.slice!
        }
        if self.sliceEnvs != nil {
            map["SliceEnvs"] = self.sliceEnvs!
        }
        if self.slsConfigs != nil {
            map["SlsConfigs"] = self.slsConfigs!
        }
        if self.terminationGracePeriodSeconds != nil {
            map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.timezone != nil {
            map["Timezone"] = self.timezone!
        }
        if self.tomcatConfig != nil {
            map["TomcatConfig"] = self.tomcatConfig!
        }
        if self.triggerConfig != nil {
            map["TriggerConfig"] = self.triggerConfig!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.warStartOptions != nil {
            map["WarStartOptions"] = self.warStartOptions!
        }
        if self.webContainer != nil {
            map["WebContainer"] = self.webContainer!
        }
        if self.workload != nil {
            map["Workload"] = self.workload!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcrAssumeRoleArn") {
            self.acrAssumeRoleArn = dict["AcrAssumeRoleArn"] as! String
        }
        if dict.keys.contains("AcrInstanceId") {
            self.acrInstanceId = dict["AcrInstanceId"] as! String
        }
        if dict.keys.contains("AppDescription") {
            self.appDescription = dict["AppDescription"] as! String
        }
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("AutoConfig") {
            self.autoConfig = dict["AutoConfig"] as! Bool
        }
        if dict.keys.contains("BackoffLimit") {
            self.backoffLimit = dict["BackoffLimit"] as! Int64
        }
        if dict.keys.contains("Command") {
            self.command = dict["Command"] as! String
        }
        if dict.keys.contains("CommandArgs") {
            self.commandArgs = dict["CommandArgs"] as! String
        }
        if dict.keys.contains("ConcurrencyPolicy") {
            self.concurrencyPolicy = dict["ConcurrencyPolicy"] as! String
        }
        if dict.keys.contains("ConfigMapMountDesc") {
            self.configMapMountDesc = dict["ConfigMapMountDesc"] as! String
        }
        if dict.keys.contains("Cpu") {
            self.cpu = dict["Cpu"] as! Int32
        }
        if dict.keys.contains("CustomHostAlias") {
            self.customHostAlias = dict["CustomHostAlias"] as! String
        }
        if dict.keys.contains("EdasContainerVersion") {
            self.edasContainerVersion = dict["EdasContainerVersion"] as! String
        }
        if dict.keys.contains("EnableImageAccl") {
            self.enableImageAccl = dict["EnableImageAccl"] as! Bool
        }
        if dict.keys.contains("Envs") {
            self.envs = dict["Envs"] as! String
        }
        if dict.keys.contains("ImagePullSecrets") {
            self.imagePullSecrets = dict["ImagePullSecrets"] as! String
        }
        if dict.keys.contains("ImageUrl") {
            self.imageUrl = dict["ImageUrl"] as! String
        }
        if dict.keys.contains("JarStartArgs") {
            self.jarStartArgs = dict["JarStartArgs"] as! String
        }
        if dict.keys.contains("JarStartOptions") {
            self.jarStartOptions = dict["JarStartOptions"] as! String
        }
        if dict.keys.contains("Jdk") {
            self.jdk = dict["Jdk"] as! String
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Int32
        }
        if dict.keys.contains("MountDesc") {
            self.mountDesc = dict["MountDesc"] as! String
        }
        if dict.keys.contains("MountHost") {
            self.mountHost = dict["MountHost"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("NasId") {
            self.nasId = dict["NasId"] as! String
        }
        if dict.keys.contains("OssAkId") {
            self.ossAkId = dict["OssAkId"] as! String
        }
        if dict.keys.contains("OssAkSecret") {
            self.ossAkSecret = dict["OssAkSecret"] as! String
        }
        if dict.keys.contains("OssMountDescs") {
            self.ossMountDescs = dict["OssMountDescs"] as! String
        }
        if dict.keys.contains("PackageType") {
            self.packageType = dict["PackageType"] as! String
        }
        if dict.keys.contains("PackageUrl") {
            self.packageUrl = dict["PackageUrl"] as! String
        }
        if dict.keys.contains("PackageVersion") {
            self.packageVersion = dict["PackageVersion"] as! String
        }
        if dict.keys.contains("PhpConfig") {
            self.phpConfig = dict["PhpConfig"] as! String
        }
        if dict.keys.contains("PhpConfigLocation") {
            self.phpConfigLocation = dict["PhpConfigLocation"] as! String
        }
        if dict.keys.contains("PostStart") {
            self.postStart = dict["PostStart"] as! String
        }
        if dict.keys.contains("PreStop") {
            self.preStop = dict["PreStop"] as! String
        }
        if dict.keys.contains("ProgrammingLanguage") {
            self.programmingLanguage = dict["ProgrammingLanguage"] as! String
        }
        if dict.keys.contains("Python") {
            self.python = dict["Python"] as! String
        }
        if dict.keys.contains("PythonModules") {
            self.pythonModules = dict["PythonModules"] as! String
        }
        if dict.keys.contains("RefAppId") {
            self.refAppId = dict["RefAppId"] as! String
        }
        if dict.keys.contains("Replicas") {
            self.replicas = dict["Replicas"] as! Int32
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("Slice") {
            self.slice = dict["Slice"] as! Bool
        }
        if dict.keys.contains("SliceEnvs") {
            self.sliceEnvs = dict["SliceEnvs"] as! String
        }
        if dict.keys.contains("SlsConfigs") {
            self.slsConfigs = dict["SlsConfigs"] as! String
        }
        if dict.keys.contains("TerminationGracePeriodSeconds") {
            self.terminationGracePeriodSeconds = dict["TerminationGracePeriodSeconds"] as! Int32
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int64
        }
        if dict.keys.contains("Timezone") {
            self.timezone = dict["Timezone"] as! String
        }
        if dict.keys.contains("TomcatConfig") {
            self.tomcatConfig = dict["TomcatConfig"] as! String
        }
        if dict.keys.contains("TriggerConfig") {
            self.triggerConfig = dict["TriggerConfig"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("WarStartOptions") {
            self.warStartOptions = dict["WarStartOptions"] as! String
        }
        if dict.keys.contains("WebContainer") {
            self.webContainer = dict["WebContainer"] as! String
        }
        if dict.keys.contains("Workload") {
            self.workload = dict["Workload"] as! String
        }
    }
}

public class CreateJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateJobResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class CreateJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNamespaceRequest : Tea.TeaModel {
    public var enableMicroRegistration: Bool?

    public var nameSpaceShortId: String?

    public var namespaceDescription: String?

    public var namespaceId: String?

    public var namespaceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableMicroRegistration != nil {
            map["EnableMicroRegistration"] = self.enableMicroRegistration!
        }
        if self.nameSpaceShortId != nil {
            map["NameSpaceShortId"] = self.nameSpaceShortId!
        }
        if self.namespaceDescription != nil {
            map["NamespaceDescription"] = self.namespaceDescription!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.namespaceName != nil {
            map["NamespaceName"] = self.namespaceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnableMicroRegistration") {
            self.enableMicroRegistration = dict["EnableMicroRegistration"] as! Bool
        }
        if dict.keys.contains("NameSpaceShortId") {
            self.nameSpaceShortId = dict["NameSpaceShortId"] as! String
        }
        if dict.keys.contains("NamespaceDescription") {
            self.namespaceDescription = dict["NamespaceDescription"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("NamespaceName") {
            self.namespaceName = dict["NamespaceName"] as! String
        }
    }
}

public class CreateNamespaceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var enableMicroRegistration: Bool?

        public var nameSpaceShortId: String?

        public var namespaceDescription: String?

        public var namespaceId: String?

        public var namespaceName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableMicroRegistration != nil {
                map["EnableMicroRegistration"] = self.enableMicroRegistration!
            }
            if self.nameSpaceShortId != nil {
                map["NameSpaceShortId"] = self.nameSpaceShortId!
            }
            if self.namespaceDescription != nil {
                map["NamespaceDescription"] = self.namespaceDescription!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.namespaceName != nil {
                map["NamespaceName"] = self.namespaceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableMicroRegistration") {
                self.enableMicroRegistration = dict["EnableMicroRegistration"] as! Bool
            }
            if dict.keys.contains("NameSpaceShortId") {
                self.nameSpaceShortId = dict["NameSpaceShortId"] as! String
            }
            if dict.keys.contains("NamespaceDescription") {
                self.namespaceDescription = dict["NamespaceDescription"] as! String
            }
            if dict.keys.contains("NamespaceId") {
                self.namespaceId = dict["NamespaceId"] as! String
            }
            if dict.keys.contains("NamespaceName") {
                self.namespaceName = dict["NamespaceName"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateNamespaceResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateNamespaceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class CreateNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSecretRequest : Tea.TeaModel {
    public class SecretData : Tea.TeaModel {
        public var secretData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.secretData != nil {
                map["SecretData"] = self.secretData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecretData") {
                self.secretData = dict["SecretData"] as! String
            }
        }
    }
    public var namespaceId: String?

    public var secretData: CreateSecretRequest.SecretData?

    public var secretName: String?

    public var secretType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.secretData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.secretData != nil {
            map["SecretData"] = self.secretData?.toMap()
        }
        if self.secretName != nil {
            map["SecretName"] = self.secretName!
        }
        if self.secretType != nil {
            map["SecretType"] = self.secretType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("SecretData") {
            var model = CreateSecretRequest.SecretData()
            model.fromMap(dict["SecretData"] as! [String: Any])
            self.secretData = model
        }
        if dict.keys.contains("SecretName") {
            self.secretName = dict["SecretName"] as! String
        }
        if dict.keys.contains("SecretType") {
            self.secretType = dict["SecretType"] as! String
        }
    }
}

public class CreateSecretShrinkRequest : Tea.TeaModel {
    public var namespaceId: String?

    public var secretDataShrink: String?

    public var secretName: String?

    public var secretType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.secretDataShrink != nil {
            map["SecretData"] = self.secretDataShrink!
        }
        if self.secretName != nil {
            map["SecretName"] = self.secretName!
        }
        if self.secretType != nil {
            map["SecretType"] = self.secretType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("SecretData") {
            self.secretDataShrink = dict["SecretData"] as! String
        }
        if dict.keys.contains("SecretName") {
            self.secretName = dict["SecretName"] as! String
        }
        if dict.keys.contains("SecretType") {
            self.secretType = dict["SecretType"] as! String
        }
    }
}

public class CreateSecretResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var secretId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.secretId != nil {
                map["SecretId"] = self.secretId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecretId") {
                self.secretId = dict["SecretId"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: CreateSecretResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateSecretResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class CreateSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSecretResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class DeleteApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var data: DeleteApplicationResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DeleteApplicationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DeleteApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var scalingRuleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ScalingRuleName") {
            self.scalingRuleName = dict["ScalingRuleName"] as! String
        }
    }
}

public class DeleteApplicationScalingRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DeleteApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteApplicationScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteConfigMapRequest : Tea.TeaModel {
    public var configMapId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configMapId != nil {
            map["ConfigMapId"] = self.configMapId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigMapId") {
            self.configMapId = dict["ConfigMapId"] as! Int64
        }
    }
}

public class DeleteConfigMapResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configMapId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configMapId != nil {
                map["ConfigMapId"] = self.configMapId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigMapId") {
                self.configMapId = dict["ConfigMapId"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DeleteConfigMapResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DeleteConfigMapResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DeleteConfigMapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteConfigMapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteConfigMapResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteGreyTagRouteRequest : Tea.TeaModel {
    public var greyTagRouteId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.greyTagRouteId != nil {
            map["GreyTagRouteId"] = self.greyTagRouteId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GreyTagRouteId") {
            self.greyTagRouteId = dict["GreyTagRouteId"] as! Int64
        }
    }
}

public class DeleteGreyTagRouteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var greyTagRouteId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.greyTagRouteId != nil {
                map["GreyTagRouteId"] = self.greyTagRouteId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GreyTagRouteId") {
                self.greyTagRouteId = dict["GreyTagRouteId"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DeleteGreyTagRouteResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DeleteGreyTagRouteResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DeleteGreyTagRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGreyTagRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteGreyTagRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteHistoryJobRequest : Tea.TeaModel {
    public var appId: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DeleteHistoryJobResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DeleteHistoryJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHistoryJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteHistoryJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIngressRequest : Tea.TeaModel {
    public var ingressId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ingressId != nil {
            map["IngressId"] = self.ingressId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IngressId") {
            self.ingressId = dict["IngressId"] as! Int64
        }
    }
}

public class DeleteIngressResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var ingressId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ingressId != nil {
                map["IngressId"] = self.ingressId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IngressId") {
                self.ingressId = dict["IngressId"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DeleteIngressResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DeleteIngressResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DeleteIngressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIngressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteIngressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteJobRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class DeleteJobResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DeleteJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNamespaceRequest : Tea.TeaModel {
    public var nameSpaceShortId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nameSpaceShortId != nil {
            map["NameSpaceShortId"] = self.nameSpaceShortId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NameSpaceShortId") {
            self.nameSpaceShortId = dict["NameSpaceShortId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class DeleteNamespaceResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DeleteNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSecretRequest : Tea.TeaModel {
    public var namespaceId: String?

    public var secretId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.secretId != nil {
            map["SecretId"] = self.secretId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("SecretId") {
            self.secretId = dict["SecretId"] as! Int64
        }
    }
}

public class DeleteSecretResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var secretId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.secretId != nil {
                map["SecretId"] = self.secretId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecretId") {
                self.secretId = dict["SecretId"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DeleteSecretResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DeleteSecretResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DeleteSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSecretResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeployApplicationRequest : Tea.TeaModel {
    public var acrAssumeRoleArn: String?

    public var acrInstanceId: String?

    public var appId: String?

    public var associateEip: Bool?

    public var autoEnableApplicationScalingRule: Bool?

    public var batchWaitTime: Int32?

    public var changeOrderDesc: String?

    public var command: String?

    public var commandArgs: String?

    public var configMapMountDesc: String?

    public var cpu: Int32?

    public var customHostAlias: String?

    public var deploy: String?

    public var edasContainerVersion: String?

    public var enableAhas: String?

    public var enableGreyTagRoute: Bool?

    public var envs: String?

    public var imagePullSecrets: String?

    public var imageUrl: String?

    public var jarStartArgs: String?

    public var jarStartOptions: String?

    public var jdk: String?

    public var kafkaConfigs: String?

    public var liveness: String?

    public var memory: Int32?

    public var microRegistration: String?

    public var microRegistrationConfig: String?

    public var minReadyInstanceRatio: Int32?

    public var minReadyInstances: Int32?

    public var mountDesc: String?

    public var mountHost: String?

    public var nasConfigs: String?

    public var nasId: String?

    public var ossAkId: String?

    public var ossAkSecret: String?

    public var ossMountDescs: String?

    public var packageType: String?

    public var packageUrl: String?

    public var packageVersion: String?

    public var php: String?

    public var phpArmsConfigLocation: String?

    public var phpConfig: String?

    public var phpConfigLocation: String?

    public var postStart: String?

    public var preStop: String?

    public var pvtzDiscoverySvc: String?

    public var python: String?

    public var pythonModules: String?

    public var readiness: String?

    public var replicas: Int32?

    public var securityGroupId: String?

    public var serviceTags: String?

    public var slsConfigs: String?

    public var terminationGracePeriodSeconds: Int32?

    public var timezone: String?

    public var tomcatConfig: String?

    public var updateStrategy: String?

    public var vSwitchId: String?

    public var warStartOptions: String?

    public var webContainer: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acrAssumeRoleArn != nil {
            map["AcrAssumeRoleArn"] = self.acrAssumeRoleArn!
        }
        if self.acrInstanceId != nil {
            map["AcrInstanceId"] = self.acrInstanceId!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.associateEip != nil {
            map["AssociateEip"] = self.associateEip!
        }
        if self.autoEnableApplicationScalingRule != nil {
            map["AutoEnableApplicationScalingRule"] = self.autoEnableApplicationScalingRule!
        }
        if self.batchWaitTime != nil {
            map["BatchWaitTime"] = self.batchWaitTime!
        }
        if self.changeOrderDesc != nil {
            map["ChangeOrderDesc"] = self.changeOrderDesc!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.commandArgs != nil {
            map["CommandArgs"] = self.commandArgs!
        }
        if self.configMapMountDesc != nil {
            map["ConfigMapMountDesc"] = self.configMapMountDesc!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.customHostAlias != nil {
            map["CustomHostAlias"] = self.customHostAlias!
        }
        if self.deploy != nil {
            map["Deploy"] = self.deploy!
        }
        if self.edasContainerVersion != nil {
            map["EdasContainerVersion"] = self.edasContainerVersion!
        }
        if self.enableAhas != nil {
            map["EnableAhas"] = self.enableAhas!
        }
        if self.enableGreyTagRoute != nil {
            map["EnableGreyTagRoute"] = self.enableGreyTagRoute!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.imagePullSecrets != nil {
            map["ImagePullSecrets"] = self.imagePullSecrets!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.jarStartArgs != nil {
            map["JarStartArgs"] = self.jarStartArgs!
        }
        if self.jarStartOptions != nil {
            map["JarStartOptions"] = self.jarStartOptions!
        }
        if self.jdk != nil {
            map["Jdk"] = self.jdk!
        }
        if self.kafkaConfigs != nil {
            map["KafkaConfigs"] = self.kafkaConfigs!
        }
        if self.liveness != nil {
            map["Liveness"] = self.liveness!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.microRegistration != nil {
            map["MicroRegistration"] = self.microRegistration!
        }
        if self.microRegistrationConfig != nil {
            map["MicroRegistrationConfig"] = self.microRegistrationConfig!
        }
        if self.minReadyInstanceRatio != nil {
            map["MinReadyInstanceRatio"] = self.minReadyInstanceRatio!
        }
        if self.minReadyInstances != nil {
            map["MinReadyInstances"] = self.minReadyInstances!
        }
        if self.mountDesc != nil {
            map["MountDesc"] = self.mountDesc!
        }
        if self.mountHost != nil {
            map["MountHost"] = self.mountHost!
        }
        if self.nasConfigs != nil {
            map["NasConfigs"] = self.nasConfigs!
        }
        if self.nasId != nil {
            map["NasId"] = self.nasId!
        }
        if self.ossAkId != nil {
            map["OssAkId"] = self.ossAkId!
        }
        if self.ossAkSecret != nil {
            map["OssAkSecret"] = self.ossAkSecret!
        }
        if self.ossMountDescs != nil {
            map["OssMountDescs"] = self.ossMountDescs!
        }
        if self.packageType != nil {
            map["PackageType"] = self.packageType!
        }
        if self.packageUrl != nil {
            map["PackageUrl"] = self.packageUrl!
        }
        if self.packageVersion != nil {
            map["PackageVersion"] = self.packageVersion!
        }
        if self.php != nil {
            map["Php"] = self.php!
        }
        if self.phpArmsConfigLocation != nil {
            map["PhpArmsConfigLocation"] = self.phpArmsConfigLocation!
        }
        if self.phpConfig != nil {
            map["PhpConfig"] = self.phpConfig!
        }
        if self.phpConfigLocation != nil {
            map["PhpConfigLocation"] = self.phpConfigLocation!
        }
        if self.postStart != nil {
            map["PostStart"] = self.postStart!
        }
        if self.preStop != nil {
            map["PreStop"] = self.preStop!
        }
        if self.pvtzDiscoverySvc != nil {
            map["PvtzDiscoverySvc"] = self.pvtzDiscoverySvc!
        }
        if self.python != nil {
            map["Python"] = self.python!
        }
        if self.pythonModules != nil {
            map["PythonModules"] = self.pythonModules!
        }
        if self.readiness != nil {
            map["Readiness"] = self.readiness!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.serviceTags != nil {
            map["ServiceTags"] = self.serviceTags!
        }
        if self.slsConfigs != nil {
            map["SlsConfigs"] = self.slsConfigs!
        }
        if self.terminationGracePeriodSeconds != nil {
            map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
        }
        if self.timezone != nil {
            map["Timezone"] = self.timezone!
        }
        if self.tomcatConfig != nil {
            map["TomcatConfig"] = self.tomcatConfig!
        }
        if self.updateStrategy != nil {
            map["UpdateStrategy"] = self.updateStrategy!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.warStartOptions != nil {
            map["WarStartOptions"] = self.warStartOptions!
        }
        if self.webContainer != nil {
            map["WebContainer"] = self.webContainer!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcrAssumeRoleArn") {
            self.acrAssumeRoleArn = dict["AcrAssumeRoleArn"] as! String
        }
        if dict.keys.contains("AcrInstanceId") {
            self.acrInstanceId = dict["AcrInstanceId"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AssociateEip") {
            self.associateEip = dict["AssociateEip"] as! Bool
        }
        if dict.keys.contains("AutoEnableApplicationScalingRule") {
            self.autoEnableApplicationScalingRule = dict["AutoEnableApplicationScalingRule"] as! Bool
        }
        if dict.keys.contains("BatchWaitTime") {
            self.batchWaitTime = dict["BatchWaitTime"] as! Int32
        }
        if dict.keys.contains("ChangeOrderDesc") {
            self.changeOrderDesc = dict["ChangeOrderDesc"] as! String
        }
        if dict.keys.contains("Command") {
            self.command = dict["Command"] as! String
        }
        if dict.keys.contains("CommandArgs") {
            self.commandArgs = dict["CommandArgs"] as! String
        }
        if dict.keys.contains("ConfigMapMountDesc") {
            self.configMapMountDesc = dict["ConfigMapMountDesc"] as! String
        }
        if dict.keys.contains("Cpu") {
            self.cpu = dict["Cpu"] as! Int32
        }
        if dict.keys.contains("CustomHostAlias") {
            self.customHostAlias = dict["CustomHostAlias"] as! String
        }
        if dict.keys.contains("Deploy") {
            self.deploy = dict["Deploy"] as! String
        }
        if dict.keys.contains("EdasContainerVersion") {
            self.edasContainerVersion = dict["EdasContainerVersion"] as! String
        }
        if dict.keys.contains("EnableAhas") {
            self.enableAhas = dict["EnableAhas"] as! String
        }
        if dict.keys.contains("EnableGreyTagRoute") {
            self.enableGreyTagRoute = dict["EnableGreyTagRoute"] as! Bool
        }
        if dict.keys.contains("Envs") {
            self.envs = dict["Envs"] as! String
        }
        if dict.keys.contains("ImagePullSecrets") {
            self.imagePullSecrets = dict["ImagePullSecrets"] as! String
        }
        if dict.keys.contains("ImageUrl") {
            self.imageUrl = dict["ImageUrl"] as! String
        }
        if dict.keys.contains("JarStartArgs") {
            self.jarStartArgs = dict["JarStartArgs"] as! String
        }
        if dict.keys.contains("JarStartOptions") {
            self.jarStartOptions = dict["JarStartOptions"] as! String
        }
        if dict.keys.contains("Jdk") {
            self.jdk = dict["Jdk"] as! String
        }
        if dict.keys.contains("KafkaConfigs") {
            self.kafkaConfigs = dict["KafkaConfigs"] as! String
        }
        if dict.keys.contains("Liveness") {
            self.liveness = dict["Liveness"] as! String
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Int32
        }
        if dict.keys.contains("MicroRegistration") {
            self.microRegistration = dict["MicroRegistration"] as! String
        }
        if dict.keys.contains("MicroRegistrationConfig") {
            self.microRegistrationConfig = dict["MicroRegistrationConfig"] as! String
        }
        if dict.keys.contains("MinReadyInstanceRatio") {
            self.minReadyInstanceRatio = dict["MinReadyInstanceRatio"] as! Int32
        }
        if dict.keys.contains("MinReadyInstances") {
            self.minReadyInstances = dict["MinReadyInstances"] as! Int32
        }
        if dict.keys.contains("MountDesc") {
            self.mountDesc = dict["MountDesc"] as! String
        }
        if dict.keys.contains("MountHost") {
            self.mountHost = dict["MountHost"] as! String
        }
        if dict.keys.contains("NasConfigs") {
            self.nasConfigs = dict["NasConfigs"] as! String
        }
        if dict.keys.contains("NasId") {
            self.nasId = dict["NasId"] as! String
        }
        if dict.keys.contains("OssAkId") {
            self.ossAkId = dict["OssAkId"] as! String
        }
        if dict.keys.contains("OssAkSecret") {
            self.ossAkSecret = dict["OssAkSecret"] as! String
        }
        if dict.keys.contains("OssMountDescs") {
            self.ossMountDescs = dict["OssMountDescs"] as! String
        }
        if dict.keys.contains("PackageType") {
            self.packageType = dict["PackageType"] as! String
        }
        if dict.keys.contains("PackageUrl") {
            self.packageUrl = dict["PackageUrl"] as! String
        }
        if dict.keys.contains("PackageVersion") {
            self.packageVersion = dict["PackageVersion"] as! String
        }
        if dict.keys.contains("Php") {
            self.php = dict["Php"] as! String
        }
        if dict.keys.contains("PhpArmsConfigLocation") {
            self.phpArmsConfigLocation = dict["PhpArmsConfigLocation"] as! String
        }
        if dict.keys.contains("PhpConfig") {
            self.phpConfig = dict["PhpConfig"] as! String
        }
        if dict.keys.contains("PhpConfigLocation") {
            self.phpConfigLocation = dict["PhpConfigLocation"] as! String
        }
        if dict.keys.contains("PostStart") {
            self.postStart = dict["PostStart"] as! String
        }
        if dict.keys.contains("PreStop") {
            self.preStop = dict["PreStop"] as! String
        }
        if dict.keys.contains("PvtzDiscoverySvc") {
            self.pvtzDiscoverySvc = dict["PvtzDiscoverySvc"] as! String
        }
        if dict.keys.contains("Python") {
            self.python = dict["Python"] as! String
        }
        if dict.keys.contains("PythonModules") {
            self.pythonModules = dict["PythonModules"] as! String
        }
        if dict.keys.contains("Readiness") {
            self.readiness = dict["Readiness"] as! String
        }
        if dict.keys.contains("Replicas") {
            self.replicas = dict["Replicas"] as! Int32
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("ServiceTags") {
            self.serviceTags = dict["ServiceTags"] as! String
        }
        if dict.keys.contains("SlsConfigs") {
            self.slsConfigs = dict["SlsConfigs"] as! String
        }
        if dict.keys.contains("TerminationGracePeriodSeconds") {
            self.terminationGracePeriodSeconds = dict["TerminationGracePeriodSeconds"] as! Int32
        }
        if dict.keys.contains("Timezone") {
            self.timezone = dict["Timezone"] as! String
        }
        if dict.keys.contains("TomcatConfig") {
            self.tomcatConfig = dict["TomcatConfig"] as! String
        }
        if dict.keys.contains("UpdateStrategy") {
            self.updateStrategy = dict["UpdateStrategy"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("WarStartOptions") {
            self.warStartOptions = dict["WarStartOptions"] as! String
        }
        if dict.keys.contains("WebContainer") {
            self.webContainer = dict["WebContainer"] as! String
        }
    }
}

public class DeployApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var changeOrderId: String?

        public var isNeedApproval: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            if self.isNeedApproval != nil {
                map["IsNeedApproval"] = self.isNeedApproval!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
            if dict.keys.contains("IsNeedApproval") {
                self.isNeedApproval = dict["IsNeedApproval"] as! Bool
            }
        }
    }
    public var code: String?

    public var data: DeployApplicationResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DeployApplicationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DeployApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeployApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeployApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAppServiceDetailRequest : Tea.TeaModel {
    public var appId: String?

    public var nacosInstanceId: String?

    public var nacosNamespaceId: String?

    public var serviceGroup: String?

    public var serviceName: String?

    public var serviceType: String?

    public var serviceVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.nacosInstanceId != nil {
            map["NacosInstanceId"] = self.nacosInstanceId!
        }
        if self.nacosNamespaceId != nil {
            map["NacosNamespaceId"] = self.nacosNamespaceId!
        }
        if self.serviceGroup != nil {
            map["ServiceGroup"] = self.serviceGroup!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        if self.serviceVersion != nil {
            map["ServiceVersion"] = self.serviceVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("NacosInstanceId") {
            self.nacosInstanceId = dict["NacosInstanceId"] as! String
        }
        if dict.keys.contains("NacosNamespaceId") {
            self.nacosNamespaceId = dict["NacosNamespaceId"] as! String
        }
        if dict.keys.contains("ServiceGroup") {
            self.serviceGroup = dict["ServiceGroup"] as! String
        }
        if dict.keys.contains("ServiceName") {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("ServiceType") {
            self.serviceType = dict["ServiceType"] as! String
        }
        if dict.keys.contains("ServiceVersion") {
            self.serviceVersion = dict["ServiceVersion"] as! String
        }
    }
}

public class DescribeAppServiceDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Methods : Tea.TeaModel {
            public class ParameterDefinitions : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var methodController: String?

            public var name: String?

            public var nameDetail: String?

            public var parameterDefinitions: [DescribeAppServiceDetailResponseBody.Data.Methods.ParameterDefinitions]?

            public var parameterDetails: [String]?

            public var parameterTypes: [String]?

            public var paths: [String]?

            public var requestMethods: [String]?

            public var returnDetails: String?

            public var returnType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.methodController != nil {
                    map["MethodController"] = self.methodController!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nameDetail != nil {
                    map["NameDetail"] = self.nameDetail!
                }
                if self.parameterDefinitions != nil {
                    var tmp : [Any] = []
                    for k in self.parameterDefinitions! {
                        tmp.append(k.toMap())
                    }
                    map["ParameterDefinitions"] = tmp
                }
                if self.parameterDetails != nil {
                    map["ParameterDetails"] = self.parameterDetails!
                }
                if self.parameterTypes != nil {
                    map["ParameterTypes"] = self.parameterTypes!
                }
                if self.paths != nil {
                    map["Paths"] = self.paths!
                }
                if self.requestMethods != nil {
                    map["RequestMethods"] = self.requestMethods!
                }
                if self.returnDetails != nil {
                    map["ReturnDetails"] = self.returnDetails!
                }
                if self.returnType != nil {
                    map["ReturnType"] = self.returnType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MethodController") {
                    self.methodController = dict["MethodController"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NameDetail") {
                    self.nameDetail = dict["NameDetail"] as! String
                }
                if dict.keys.contains("ParameterDefinitions") {
                    var tmp : [DescribeAppServiceDetailResponseBody.Data.Methods.ParameterDefinitions] = []
                    for v in dict["ParameterDefinitions"] as! [Any] {
                        var model = DescribeAppServiceDetailResponseBody.Data.Methods.ParameterDefinitions()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.parameterDefinitions = tmp
                }
                if dict.keys.contains("ParameterDetails") {
                    self.parameterDetails = dict["ParameterDetails"] as! [String]
                }
                if dict.keys.contains("ParameterTypes") {
                    self.parameterTypes = dict["ParameterTypes"] as! [String]
                }
                if dict.keys.contains("Paths") {
                    self.paths = dict["Paths"] as! [String]
                }
                if dict.keys.contains("RequestMethods") {
                    self.requestMethods = dict["RequestMethods"] as! [String]
                }
                if dict.keys.contains("ReturnDetails") {
                    self.returnDetails = dict["ReturnDetails"] as! String
                }
                if dict.keys.contains("ReturnType") {
                    self.returnType = dict["ReturnType"] as! String
                }
            }
        }
        public var dubboApplicationName: String?

        public var edasAppName: String?

        public var group: String?

        public var metadata: [String: Any]?

        public var methods: [DescribeAppServiceDetailResponseBody.Data.Methods]?

        public var serviceName: String?

        public var servicePorts: [Int64]?

        public var serviceProtocol: String?

        public var serviceTags: [String]?

        public var serviceType: String?

        public var springApplicationName: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dubboApplicationName != nil {
                map["DubboApplicationName"] = self.dubboApplicationName!
            }
            if self.edasAppName != nil {
                map["EdasAppName"] = self.edasAppName!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.metadata != nil {
                map["Metadata"] = self.metadata!
            }
            if self.methods != nil {
                var tmp : [Any] = []
                for k in self.methods! {
                    tmp.append(k.toMap())
                }
                map["Methods"] = tmp
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.servicePorts != nil {
                map["ServicePorts"] = self.servicePorts!
            }
            if self.serviceProtocol != nil {
                map["ServiceProtocol"] = self.serviceProtocol!
            }
            if self.serviceTags != nil {
                map["ServiceTags"] = self.serviceTags!
            }
            if self.serviceType != nil {
                map["ServiceType"] = self.serviceType!
            }
            if self.springApplicationName != nil {
                map["SpringApplicationName"] = self.springApplicationName!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DubboApplicationName") {
                self.dubboApplicationName = dict["DubboApplicationName"] as! String
            }
            if dict.keys.contains("EdasAppName") {
                self.edasAppName = dict["EdasAppName"] as! String
            }
            if dict.keys.contains("Group") {
                self.group = dict["Group"] as! String
            }
            if dict.keys.contains("Metadata") {
                self.metadata = dict["Metadata"] as! [String: Any]
            }
            if dict.keys.contains("Methods") {
                var tmp : [DescribeAppServiceDetailResponseBody.Data.Methods] = []
                for v in dict["Methods"] as! [Any] {
                    var model = DescribeAppServiceDetailResponseBody.Data.Methods()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.methods = tmp
            }
            if dict.keys.contains("ServiceName") {
                self.serviceName = dict["ServiceName"] as! String
            }
            if dict.keys.contains("ServicePorts") {
                self.servicePorts = dict["ServicePorts"] as! [Int64]
            }
            if dict.keys.contains("ServiceProtocol") {
                self.serviceProtocol = dict["ServiceProtocol"] as! String
            }
            if dict.keys.contains("ServiceTags") {
                self.serviceTags = dict["ServiceTags"] as! [String]
            }
            if dict.keys.contains("ServiceType") {
                self.serviceType = dict["ServiceType"] as! String
            }
            if dict.keys.contains("SpringApplicationName") {
                self.springApplicationName = dict["SpringApplicationName"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: String?

    public var data: DescribeAppServiceDetailResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeAppServiceDetailResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeAppServiceDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAppServiceDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAppServiceDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApplicationConfigRequest : Tea.TeaModel {
    public var appId: String?

    public var versionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.versionId != nil {
            map["VersionId"] = self.versionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("VersionId") {
            self.versionId = dict["VersionId"] as! String
        }
    }
}

public class DescribeApplicationConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ConfigMapMountDesc : Tea.TeaModel {
            public var configMapId: Int64?

            public var configMapName: String?

            public var key: String?

            public var mountPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configMapId != nil {
                    map["ConfigMapId"] = self.configMapId!
                }
                if self.configMapName != nil {
                    map["ConfigMapName"] = self.configMapName!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigMapId") {
                    self.configMapId = dict["ConfigMapId"] as! Int64
                }
                if dict.keys.contains("ConfigMapName") {
                    self.configMapName = dict["ConfigMapName"] as! String
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("MountPath") {
                    self.mountPath = dict["MountPath"] as! String
                }
            }
        }
        public class MountDesc : Tea.TeaModel {
            public var mountPath: String?

            public var nasPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.nasPath != nil {
                    map["NasPath"] = self.nasPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MountPath") {
                    self.mountPath = dict["MountPath"] as! String
                }
                if dict.keys.contains("NasPath") {
                    self.nasPath = dict["NasPath"] as! String
                }
            }
        }
        public class OssMountDescs : Tea.TeaModel {
            public var bucketName: String?

            public var bucketPath: String?

            public var mountPath: String?

            public var readOnly: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucketName != nil {
                    map["bucketName"] = self.bucketName!
                }
                if self.bucketPath != nil {
                    map["bucketPath"] = self.bucketPath!
                }
                if self.mountPath != nil {
                    map["mountPath"] = self.mountPath!
                }
                if self.readOnly != nil {
                    map["readOnly"] = self.readOnly!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("bucketName") {
                    self.bucketName = dict["bucketName"] as! String
                }
                if dict.keys.contains("bucketPath") {
                    self.bucketPath = dict["bucketPath"] as! String
                }
                if dict.keys.contains("mountPath") {
                    self.mountPath = dict["mountPath"] as! String
                }
                if dict.keys.contains("readOnly") {
                    self.readOnly = dict["readOnly"] as! Bool
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var acrAssumeRoleArn: String?

        public var acrInstanceId: String?

        public var appDescription: String?

        public var appId: String?

        public var appName: String?

        public var appSource: String?

        public var associateEip: Bool?

        public var batchWaitTime: Int32?

        public var command: String?

        public var commandArgs: String?

        public var configMapMountDesc: [DescribeApplicationConfigResponseBody.Data.ConfigMapMountDesc]?

        public var cpu: Int32?

        public var customHostAlias: String?

        public var edasContainerVersion: String?

        public var enableAhas: String?

        public var enableGreyTagRoute: Bool?

        public var envs: String?

        public var imagePullSecrets: String?

        public var imageUrl: String?

        public var jarStartArgs: String?

        public var jarStartOptions: String?

        public var jdk: String?

        public var kafkaConfigs: String?

        public var liveness: String?

        public var memory: Int32?

        public var microRegistration: String?

        public var minReadyInstanceRatio: Int32?

        public var minReadyInstances: Int32?

        public var mountDesc: [DescribeApplicationConfigResponseBody.Data.MountDesc]?

        public var mountHost: String?

        public var mseApplicationId: String?

        public var mseApplicationName: String?

        public var namespaceId: String?

        public var nasConfigs: String?

        public var nasId: String?

        public var ossAkId: String?

        public var ossAkSecret: String?

        public var ossMountDescs: [DescribeApplicationConfigResponseBody.Data.OssMountDescs]?

        public var packageType: String?

        public var packageUrl: String?

        public var packageVersion: String?

        public var php: String?

        public var phpArmsConfigLocation: String?

        public var phpConfig: String?

        public var phpConfigLocation: String?

        public var postStart: String?

        public var preStop: String?

        public var programmingLanguage: String?

        public var pvtzDiscovery: String?

        public var python: String?

        public var pythonModules: String?

        public var readiness: String?

        public var regionId: String?

        public var replicas: Int32?

        public var securityGroupId: String?

        public var serviceTags: [String: String]?

        public var slsConfigs: String?

        public var tags: [DescribeApplicationConfigResponseBody.Data.Tags]?

        public var terminationGracePeriodSeconds: Int32?

        public var timezone: String?

        public var tomcatConfig: String?

        public var updateStrategy: String?

        public var vSwitchId: String?

        public var vpcId: String?

        public var warStartOptions: String?

        public var webContainer: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acrAssumeRoleArn != nil {
                map["AcrAssumeRoleArn"] = self.acrAssumeRoleArn!
            }
            if self.acrInstanceId != nil {
                map["AcrInstanceId"] = self.acrInstanceId!
            }
            if self.appDescription != nil {
                map["AppDescription"] = self.appDescription!
            }
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.appSource != nil {
                map["AppSource"] = self.appSource!
            }
            if self.associateEip != nil {
                map["AssociateEip"] = self.associateEip!
            }
            if self.batchWaitTime != nil {
                map["BatchWaitTime"] = self.batchWaitTime!
            }
            if self.command != nil {
                map["Command"] = self.command!
            }
            if self.commandArgs != nil {
                map["CommandArgs"] = self.commandArgs!
            }
            if self.configMapMountDesc != nil {
                var tmp : [Any] = []
                for k in self.configMapMountDesc! {
                    tmp.append(k.toMap())
                }
                map["ConfigMapMountDesc"] = tmp
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.customHostAlias != nil {
                map["CustomHostAlias"] = self.customHostAlias!
            }
            if self.edasContainerVersion != nil {
                map["EdasContainerVersion"] = self.edasContainerVersion!
            }
            if self.enableAhas != nil {
                map["EnableAhas"] = self.enableAhas!
            }
            if self.enableGreyTagRoute != nil {
                map["EnableGreyTagRoute"] = self.enableGreyTagRoute!
            }
            if self.envs != nil {
                map["Envs"] = self.envs!
            }
            if self.imagePullSecrets != nil {
                map["ImagePullSecrets"] = self.imagePullSecrets!
            }
            if self.imageUrl != nil {
                map["ImageUrl"] = self.imageUrl!
            }
            if self.jarStartArgs != nil {
                map["JarStartArgs"] = self.jarStartArgs!
            }
            if self.jarStartOptions != nil {
                map["JarStartOptions"] = self.jarStartOptions!
            }
            if self.jdk != nil {
                map["Jdk"] = self.jdk!
            }
            if self.kafkaConfigs != nil {
                map["KafkaConfigs"] = self.kafkaConfigs!
            }
            if self.liveness != nil {
                map["Liveness"] = self.liveness!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.microRegistration != nil {
                map["MicroRegistration"] = self.microRegistration!
            }
            if self.minReadyInstanceRatio != nil {
                map["MinReadyInstanceRatio"] = self.minReadyInstanceRatio!
            }
            if self.minReadyInstances != nil {
                map["MinReadyInstances"] = self.minReadyInstances!
            }
            if self.mountDesc != nil {
                var tmp : [Any] = []
                for k in self.mountDesc! {
                    tmp.append(k.toMap())
                }
                map["MountDesc"] = tmp
            }
            if self.mountHost != nil {
                map["MountHost"] = self.mountHost!
            }
            if self.mseApplicationId != nil {
                map["MseApplicationId"] = self.mseApplicationId!
            }
            if self.mseApplicationName != nil {
                map["MseApplicationName"] = self.mseApplicationName!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.nasConfigs != nil {
                map["NasConfigs"] = self.nasConfigs!
            }
            if self.nasId != nil {
                map["NasId"] = self.nasId!
            }
            if self.ossAkId != nil {
                map["OssAkId"] = self.ossAkId!
            }
            if self.ossAkSecret != nil {
                map["OssAkSecret"] = self.ossAkSecret!
            }
            if self.ossMountDescs != nil {
                var tmp : [Any] = []
                for k in self.ossMountDescs! {
                    tmp.append(k.toMap())
                }
                map["OssMountDescs"] = tmp
            }
            if self.packageType != nil {
                map["PackageType"] = self.packageType!
            }
            if self.packageUrl != nil {
                map["PackageUrl"] = self.packageUrl!
            }
            if self.packageVersion != nil {
                map["PackageVersion"] = self.packageVersion!
            }
            if self.php != nil {
                map["Php"] = self.php!
            }
            if self.phpArmsConfigLocation != nil {
                map["PhpArmsConfigLocation"] = self.phpArmsConfigLocation!
            }
            if self.phpConfig != nil {
                map["PhpConfig"] = self.phpConfig!
            }
            if self.phpConfigLocation != nil {
                map["PhpConfigLocation"] = self.phpConfigLocation!
            }
            if self.postStart != nil {
                map["PostStart"] = self.postStart!
            }
            if self.preStop != nil {
                map["PreStop"] = self.preStop!
            }
            if self.programmingLanguage != nil {
                map["ProgrammingLanguage"] = self.programmingLanguage!
            }
            if self.pvtzDiscovery != nil {
                map["PvtzDiscovery"] = self.pvtzDiscovery!
            }
            if self.python != nil {
                map["Python"] = self.python!
            }
            if self.pythonModules != nil {
                map["PythonModules"] = self.pythonModules!
            }
            if self.readiness != nil {
                map["Readiness"] = self.readiness!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.replicas != nil {
                map["Replicas"] = self.replicas!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.serviceTags != nil {
                map["ServiceTags"] = self.serviceTags!
            }
            if self.slsConfigs != nil {
                map["SlsConfigs"] = self.slsConfigs!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.terminationGracePeriodSeconds != nil {
                map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
            }
            if self.timezone != nil {
                map["Timezone"] = self.timezone!
            }
            if self.tomcatConfig != nil {
                map["TomcatConfig"] = self.tomcatConfig!
            }
            if self.updateStrategy != nil {
                map["UpdateStrategy"] = self.updateStrategy!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.warStartOptions != nil {
                map["WarStartOptions"] = self.warStartOptions!
            }
            if self.webContainer != nil {
                map["WebContainer"] = self.webContainer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcrAssumeRoleArn") {
                self.acrAssumeRoleArn = dict["AcrAssumeRoleArn"] as! String
            }
            if dict.keys.contains("AcrInstanceId") {
                self.acrInstanceId = dict["AcrInstanceId"] as! String
            }
            if dict.keys.contains("AppDescription") {
                self.appDescription = dict["AppDescription"] as! String
            }
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("AppSource") {
                self.appSource = dict["AppSource"] as! String
            }
            if dict.keys.contains("AssociateEip") {
                self.associateEip = dict["AssociateEip"] as! Bool
            }
            if dict.keys.contains("BatchWaitTime") {
                self.batchWaitTime = dict["BatchWaitTime"] as! Int32
            }
            if dict.keys.contains("Command") {
                self.command = dict["Command"] as! String
            }
            if dict.keys.contains("CommandArgs") {
                self.commandArgs = dict["CommandArgs"] as! String
            }
            if dict.keys.contains("ConfigMapMountDesc") {
                var tmp : [DescribeApplicationConfigResponseBody.Data.ConfigMapMountDesc] = []
                for v in dict["ConfigMapMountDesc"] as! [Any] {
                    var model = DescribeApplicationConfigResponseBody.Data.ConfigMapMountDesc()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configMapMountDesc = tmp
            }
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("CustomHostAlias") {
                self.customHostAlias = dict["CustomHostAlias"] as! String
            }
            if dict.keys.contains("EdasContainerVersion") {
                self.edasContainerVersion = dict["EdasContainerVersion"] as! String
            }
            if dict.keys.contains("EnableAhas") {
                self.enableAhas = dict["EnableAhas"] as! String
            }
            if dict.keys.contains("EnableGreyTagRoute") {
                self.enableGreyTagRoute = dict["EnableGreyTagRoute"] as! Bool
            }
            if dict.keys.contains("Envs") {
                self.envs = dict["Envs"] as! String
            }
            if dict.keys.contains("ImagePullSecrets") {
                self.imagePullSecrets = dict["ImagePullSecrets"] as! String
            }
            if dict.keys.contains("ImageUrl") {
                self.imageUrl = dict["ImageUrl"] as! String
            }
            if dict.keys.contains("JarStartArgs") {
                self.jarStartArgs = dict["JarStartArgs"] as! String
            }
            if dict.keys.contains("JarStartOptions") {
                self.jarStartOptions = dict["JarStartOptions"] as! String
            }
            if dict.keys.contains("Jdk") {
                self.jdk = dict["Jdk"] as! String
            }
            if dict.keys.contains("KafkaConfigs") {
                self.kafkaConfigs = dict["KafkaConfigs"] as! String
            }
            if dict.keys.contains("Liveness") {
                self.liveness = dict["Liveness"] as! String
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Int32
            }
            if dict.keys.contains("MicroRegistration") {
                self.microRegistration = dict["MicroRegistration"] as! String
            }
            if dict.keys.contains("MinReadyInstanceRatio") {
                self.minReadyInstanceRatio = dict["MinReadyInstanceRatio"] as! Int32
            }
            if dict.keys.contains("MinReadyInstances") {
                self.minReadyInstances = dict["MinReadyInstances"] as! Int32
            }
            if dict.keys.contains("MountDesc") {
                var tmp : [DescribeApplicationConfigResponseBody.Data.MountDesc] = []
                for v in dict["MountDesc"] as! [Any] {
                    var model = DescribeApplicationConfigResponseBody.Data.MountDesc()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mountDesc = tmp
            }
            if dict.keys.contains("MountHost") {
                self.mountHost = dict["MountHost"] as! String
            }
            if dict.keys.contains("MseApplicationId") {
                self.mseApplicationId = dict["MseApplicationId"] as! String
            }
            if dict.keys.contains("MseApplicationName") {
                self.mseApplicationName = dict["MseApplicationName"] as! String
            }
            if dict.keys.contains("NamespaceId") {
                self.namespaceId = dict["NamespaceId"] as! String
            }
            if dict.keys.contains("NasConfigs") {
                self.nasConfigs = dict["NasConfigs"] as! String
            }
            if dict.keys.contains("NasId") {
                self.nasId = dict["NasId"] as! String
            }
            if dict.keys.contains("OssAkId") {
                self.ossAkId = dict["OssAkId"] as! String
            }
            if dict.keys.contains("OssAkSecret") {
                self.ossAkSecret = dict["OssAkSecret"] as! String
            }
            if dict.keys.contains("OssMountDescs") {
                var tmp : [DescribeApplicationConfigResponseBody.Data.OssMountDescs] = []
                for v in dict["OssMountDescs"] as! [Any] {
                    var model = DescribeApplicationConfigResponseBody.Data.OssMountDescs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ossMountDescs = tmp
            }
            if dict.keys.contains("PackageType") {
                self.packageType = dict["PackageType"] as! String
            }
            if dict.keys.contains("PackageUrl") {
                self.packageUrl = dict["PackageUrl"] as! String
            }
            if dict.keys.contains("PackageVersion") {
                self.packageVersion = dict["PackageVersion"] as! String
            }
            if dict.keys.contains("Php") {
                self.php = dict["Php"] as! String
            }
            if dict.keys.contains("PhpArmsConfigLocation") {
                self.phpArmsConfigLocation = dict["PhpArmsConfigLocation"] as! String
            }
            if dict.keys.contains("PhpConfig") {
                self.phpConfig = dict["PhpConfig"] as! String
            }
            if dict.keys.contains("PhpConfigLocation") {
                self.phpConfigLocation = dict["PhpConfigLocation"] as! String
            }
            if dict.keys.contains("PostStart") {
                self.postStart = dict["PostStart"] as! String
            }
            if dict.keys.contains("PreStop") {
                self.preStop = dict["PreStop"] as! String
            }
            if dict.keys.contains("ProgrammingLanguage") {
                self.programmingLanguage = dict["ProgrammingLanguage"] as! String
            }
            if dict.keys.contains("PvtzDiscovery") {
                self.pvtzDiscovery = dict["PvtzDiscovery"] as! String
            }
            if dict.keys.contains("Python") {
                self.python = dict["Python"] as! String
            }
            if dict.keys.contains("PythonModules") {
                self.pythonModules = dict["PythonModules"] as! String
            }
            if dict.keys.contains("Readiness") {
                self.readiness = dict["Readiness"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Replicas") {
                self.replicas = dict["Replicas"] as! Int32
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("ServiceTags") {
                self.serviceTags = dict["ServiceTags"] as! [String: String]
            }
            if dict.keys.contains("SlsConfigs") {
                self.slsConfigs = dict["SlsConfigs"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeApplicationConfigResponseBody.Data.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeApplicationConfigResponseBody.Data.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TerminationGracePeriodSeconds") {
                self.terminationGracePeriodSeconds = dict["TerminationGracePeriodSeconds"] as! Int32
            }
            if dict.keys.contains("Timezone") {
                self.timezone = dict["Timezone"] as! String
            }
            if dict.keys.contains("TomcatConfig") {
                self.tomcatConfig = dict["TomcatConfig"] as! String
            }
            if dict.keys.contains("UpdateStrategy") {
                self.updateStrategy = dict["UpdateStrategy"] as! String
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
            if dict.keys.contains("WarStartOptions") {
                self.warStartOptions = dict["WarStartOptions"] as! String
            }
            if dict.keys.contains("WebContainer") {
                self.webContainer = dict["WebContainer"] as! String
            }
        }
    }
    public var code: String?

    public var data: DescribeApplicationConfigResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeApplicationConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeApplicationConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApplicationConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApplicationGroupsRequest : Tea.TeaModel {
    public var appId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeApplicationGroupsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var edasContainerVersion: String?

        public var groupId: String?

        public var groupName: String?

        public var groupType: Int32?

        public var imageUrl: String?

        public var jdk: String?

        public var packageType: String?

        public var packageUrl: String?

        public var packageVersion: String?

        public var replicas: Int32?

        public var runningInstances: Int32?

        public var webContainer: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.edasContainerVersion != nil {
                map["EdasContainerVersion"] = self.edasContainerVersion!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.groupType != nil {
                map["GroupType"] = self.groupType!
            }
            if self.imageUrl != nil {
                map["ImageUrl"] = self.imageUrl!
            }
            if self.jdk != nil {
                map["Jdk"] = self.jdk!
            }
            if self.packageType != nil {
                map["PackageType"] = self.packageType!
            }
            if self.packageUrl != nil {
                map["PackageUrl"] = self.packageUrl!
            }
            if self.packageVersion != nil {
                map["PackageVersion"] = self.packageVersion!
            }
            if self.replicas != nil {
                map["Replicas"] = self.replicas!
            }
            if self.runningInstances != nil {
                map["RunningInstances"] = self.runningInstances!
            }
            if self.webContainer != nil {
                map["WebContainer"] = self.webContainer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EdasContainerVersion") {
                self.edasContainerVersion = dict["EdasContainerVersion"] as! String
            }
            if dict.keys.contains("GroupId") {
                self.groupId = dict["GroupId"] as! String
            }
            if dict.keys.contains("GroupName") {
                self.groupName = dict["GroupName"] as! String
            }
            if dict.keys.contains("GroupType") {
                self.groupType = dict["GroupType"] as! Int32
            }
            if dict.keys.contains("ImageUrl") {
                self.imageUrl = dict["ImageUrl"] as! String
            }
            if dict.keys.contains("Jdk") {
                self.jdk = dict["Jdk"] as! String
            }
            if dict.keys.contains("PackageType") {
                self.packageType = dict["PackageType"] as! String
            }
            if dict.keys.contains("PackageUrl") {
                self.packageUrl = dict["PackageUrl"] as! String
            }
            if dict.keys.contains("PackageVersion") {
                self.packageVersion = dict["PackageVersion"] as! String
            }
            if dict.keys.contains("Replicas") {
                self.replicas = dict["Replicas"] as! Int32
            }
            if dict.keys.contains("RunningInstances") {
                self.runningInstances = dict["RunningInstances"] as! Int32
            }
            if dict.keys.contains("WebContainer") {
                self.webContainer = dict["WebContainer"] as! String
            }
        }
    }
    public var code: String?

    public var data: [DescribeApplicationGroupsResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [DescribeApplicationGroupsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeApplicationGroupsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeApplicationGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApplicationGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApplicationImageRequest : Tea.TeaModel {
    public var appId: String?

    public var imageUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ImageUrl") {
            self.imageUrl = dict["ImageUrl"] as! String
        }
    }
}

public class DescribeApplicationImageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var crUrl: String?

        public var logo: String?

        public var regionId: String?

        public var repoName: String?

        public var repoNamespace: String?

        public var repoOriginType: String?

        public var repoTag: String?

        public var repoType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.crUrl != nil {
                map["CrUrl"] = self.crUrl!
            }
            if self.logo != nil {
                map["Logo"] = self.logo!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.repoName != nil {
                map["RepoName"] = self.repoName!
            }
            if self.repoNamespace != nil {
                map["RepoNamespace"] = self.repoNamespace!
            }
            if self.repoOriginType != nil {
                map["RepoOriginType"] = self.repoOriginType!
            }
            if self.repoTag != nil {
                map["RepoTag"] = self.repoTag!
            }
            if self.repoType != nil {
                map["RepoType"] = self.repoType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CrUrl") {
                self.crUrl = dict["CrUrl"] as! String
            }
            if dict.keys.contains("Logo") {
                self.logo = dict["Logo"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RepoName") {
                self.repoName = dict["RepoName"] as! String
            }
            if dict.keys.contains("RepoNamespace") {
                self.repoNamespace = dict["RepoNamespace"] as! String
            }
            if dict.keys.contains("RepoOriginType") {
                self.repoOriginType = dict["RepoOriginType"] as! String
            }
            if dict.keys.contains("RepoTag") {
                self.repoTag = dict["RepoTag"] as! String
            }
            if dict.keys.contains("RepoType") {
                self.repoType = dict["RepoType"] as! String
            }
        }
    }
    public var code: String?

    public var data: DescribeApplicationImageResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeApplicationImageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeApplicationImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApplicationImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApplicationInstancesRequest : Tea.TeaModel {
    public var appId: String?

    public var currentPage: Int32?

    public var groupId: String?

    public var pageSize: Int32?

    public var reverse: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.reverse != nil {
            map["Reverse"] = self.reverse!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("GroupId") {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Reverse") {
            self.reverse = dict["Reverse"] as! Bool
        }
    }
}

public class DescribeApplicationInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Instances : Tea.TeaModel {
            public var createTimeStamp: Int64?

            public var debugStatus: Bool?

            public var eip: String?

            public var finishTimeStamp: Int64?

            public var groupId: String?

            public var imageUrl: String?

            public var instanceContainerIp: String?

            public var instanceContainerRestarts: Int64?

            public var instanceContainerStatus: String?

            public var instanceHealthStatus: String?

            public var instanceId: String?

            public var packageVersion: String?

            public var vSwitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTimeStamp != nil {
                    map["CreateTimeStamp"] = self.createTimeStamp!
                }
                if self.debugStatus != nil {
                    map["DebugStatus"] = self.debugStatus!
                }
                if self.eip != nil {
                    map["Eip"] = self.eip!
                }
                if self.finishTimeStamp != nil {
                    map["FinishTimeStamp"] = self.finishTimeStamp!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.imageUrl != nil {
                    map["ImageUrl"] = self.imageUrl!
                }
                if self.instanceContainerIp != nil {
                    map["InstanceContainerIp"] = self.instanceContainerIp!
                }
                if self.instanceContainerRestarts != nil {
                    map["InstanceContainerRestarts"] = self.instanceContainerRestarts!
                }
                if self.instanceContainerStatus != nil {
                    map["InstanceContainerStatus"] = self.instanceContainerStatus!
                }
                if self.instanceHealthStatus != nil {
                    map["InstanceHealthStatus"] = self.instanceHealthStatus!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.packageVersion != nil {
                    map["PackageVersion"] = self.packageVersion!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTimeStamp") {
                    self.createTimeStamp = dict["CreateTimeStamp"] as! Int64
                }
                if dict.keys.contains("DebugStatus") {
                    self.debugStatus = dict["DebugStatus"] as! Bool
                }
                if dict.keys.contains("Eip") {
                    self.eip = dict["Eip"] as! String
                }
                if dict.keys.contains("FinishTimeStamp") {
                    self.finishTimeStamp = dict["FinishTimeStamp"] as! Int64
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("ImageUrl") {
                    self.imageUrl = dict["ImageUrl"] as! String
                }
                if dict.keys.contains("InstanceContainerIp") {
                    self.instanceContainerIp = dict["InstanceContainerIp"] as! String
                }
                if dict.keys.contains("InstanceContainerRestarts") {
                    self.instanceContainerRestarts = dict["InstanceContainerRestarts"] as! Int64
                }
                if dict.keys.contains("InstanceContainerStatus") {
                    self.instanceContainerStatus = dict["InstanceContainerStatus"] as! String
                }
                if dict.keys.contains("InstanceHealthStatus") {
                    self.instanceHealthStatus = dict["InstanceHealthStatus"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("PackageVersion") {
                    self.packageVersion = dict["PackageVersion"] as! String
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
            }
        }
        public var currentPage: Int32?

        public var instances: [DescribeApplicationInstancesResponseBody.Data.Instances]?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.instances != nil {
                var tmp : [Any] = []
                for k in self.instances! {
                    tmp.append(k.toMap())
                }
                map["Instances"] = tmp
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("Instances") {
                var tmp : [DescribeApplicationInstancesResponseBody.Data.Instances] = []
                for v in dict["Instances"] as! [Any] {
                    var model = DescribeApplicationInstancesResponseBody.Data.Instances()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instances = tmp
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: DescribeApplicationInstancesResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeApplicationInstancesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeApplicationInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApplicationInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var scalingRuleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ScalingRuleName") {
            self.scalingRuleName = dict["ScalingRuleName"] as! String
        }
    }
}

public class DescribeApplicationScalingRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Metric : Tea.TeaModel {
            public class Metrics : Tea.TeaModel {
                public var metricTargetAverageUtilization: Int32?

                public var metricType: String?

                public var slbId: String?

                public var slbLogstore: String?

                public var slbProject: String?

                public var vport: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricTargetAverageUtilization != nil {
                        map["MetricTargetAverageUtilization"] = self.metricTargetAverageUtilization!
                    }
                    if self.metricType != nil {
                        map["MetricType"] = self.metricType!
                    }
                    if self.slbId != nil {
                        map["SlbId"] = self.slbId!
                    }
                    if self.slbLogstore != nil {
                        map["SlbLogstore"] = self.slbLogstore!
                    }
                    if self.slbProject != nil {
                        map["SlbProject"] = self.slbProject!
                    }
                    if self.vport != nil {
                        map["Vport"] = self.vport!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MetricTargetAverageUtilization") {
                        self.metricTargetAverageUtilization = dict["MetricTargetAverageUtilization"] as! Int32
                    }
                    if dict.keys.contains("MetricType") {
                        self.metricType = dict["MetricType"] as! String
                    }
                    if dict.keys.contains("SlbId") {
                        self.slbId = dict["SlbId"] as! String
                    }
                    if dict.keys.contains("SlbLogstore") {
                        self.slbLogstore = dict["SlbLogstore"] as! String
                    }
                    if dict.keys.contains("SlbProject") {
                        self.slbProject = dict["SlbProject"] as! String
                    }
                    if dict.keys.contains("Vport") {
                        self.vport = dict["Vport"] as! String
                    }
                }
            }
            public class MetricsStatus : Tea.TeaModel {
                public class CurrentMetrics : Tea.TeaModel {
                    public var currentValue: Int64?

                    public var name: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.currentValue != nil {
                            map["CurrentValue"] = self.currentValue!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CurrentValue") {
                            self.currentValue = dict["CurrentValue"] as! Int64
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public class NextScaleMetrics : Tea.TeaModel {
                    public var name: String?

                    public var nextScaleInAverageUtilization: Int32?

                    public var nextScaleOutAverageUtilization: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.nextScaleInAverageUtilization != nil {
                            map["NextScaleInAverageUtilization"] = self.nextScaleInAverageUtilization!
                        }
                        if self.nextScaleOutAverageUtilization != nil {
                            map["NextScaleOutAverageUtilization"] = self.nextScaleOutAverageUtilization!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("NextScaleInAverageUtilization") {
                            self.nextScaleInAverageUtilization = dict["NextScaleInAverageUtilization"] as! Int32
                        }
                        if dict.keys.contains("NextScaleOutAverageUtilization") {
                            self.nextScaleOutAverageUtilization = dict["NextScaleOutAverageUtilization"] as! Int32
                        }
                    }
                }
                public var currentMetrics: [DescribeApplicationScalingRuleResponseBody.Data.Metric.MetricsStatus.CurrentMetrics]?

                public var currentReplicas: Int64?

                public var desiredReplicas: Int64?

                public var lastScaleTime: String?

                public var nextScaleMetrics: [DescribeApplicationScalingRuleResponseBody.Data.Metric.MetricsStatus.NextScaleMetrics]?

                public var nextScaleTimePeriod: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.currentMetrics != nil {
                        var tmp : [Any] = []
                        for k in self.currentMetrics! {
                            tmp.append(k.toMap())
                        }
                        map["CurrentMetrics"] = tmp
                    }
                    if self.currentReplicas != nil {
                        map["CurrentReplicas"] = self.currentReplicas!
                    }
                    if self.desiredReplicas != nil {
                        map["DesiredReplicas"] = self.desiredReplicas!
                    }
                    if self.lastScaleTime != nil {
                        map["LastScaleTime"] = self.lastScaleTime!
                    }
                    if self.nextScaleMetrics != nil {
                        var tmp : [Any] = []
                        for k in self.nextScaleMetrics! {
                            tmp.append(k.toMap())
                        }
                        map["NextScaleMetrics"] = tmp
                    }
                    if self.nextScaleTimePeriod != nil {
                        map["NextScaleTimePeriod"] = self.nextScaleTimePeriod!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CurrentMetrics") {
                        var tmp : [DescribeApplicationScalingRuleResponseBody.Data.Metric.MetricsStatus.CurrentMetrics] = []
                        for v in dict["CurrentMetrics"] as! [Any] {
                            var model = DescribeApplicationScalingRuleResponseBody.Data.Metric.MetricsStatus.CurrentMetrics()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.currentMetrics = tmp
                    }
                    if dict.keys.contains("CurrentReplicas") {
                        self.currentReplicas = dict["CurrentReplicas"] as! Int64
                    }
                    if dict.keys.contains("DesiredReplicas") {
                        self.desiredReplicas = dict["DesiredReplicas"] as! Int64
                    }
                    if dict.keys.contains("LastScaleTime") {
                        self.lastScaleTime = dict["LastScaleTime"] as! String
                    }
                    if dict.keys.contains("NextScaleMetrics") {
                        var tmp : [DescribeApplicationScalingRuleResponseBody.Data.Metric.MetricsStatus.NextScaleMetrics] = []
                        for v in dict["NextScaleMetrics"] as! [Any] {
                            var model = DescribeApplicationScalingRuleResponseBody.Data.Metric.MetricsStatus.NextScaleMetrics()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.nextScaleMetrics = tmp
                    }
                    if dict.keys.contains("NextScaleTimePeriod") {
                        self.nextScaleTimePeriod = dict["NextScaleTimePeriod"] as! Int32
                    }
                }
            }
            public class ScaleDownRules : Tea.TeaModel {
                public var disabled: Bool?

                public var stabilizationWindowSeconds: Int64?

                public var step: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.disabled != nil {
                        map["Disabled"] = self.disabled!
                    }
                    if self.stabilizationWindowSeconds != nil {
                        map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                    }
                    if self.step != nil {
                        map["Step"] = self.step!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Disabled") {
                        self.disabled = dict["Disabled"] as! Bool
                    }
                    if dict.keys.contains("StabilizationWindowSeconds") {
                        self.stabilizationWindowSeconds = dict["StabilizationWindowSeconds"] as! Int64
                    }
                    if dict.keys.contains("Step") {
                        self.step = dict["Step"] as! Int64
                    }
                }
            }
            public class ScaleUpRules : Tea.TeaModel {
                public var disabled: Bool?

                public var stabilizationWindowSeconds: Int64?

                public var step: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.disabled != nil {
                        map["Disabled"] = self.disabled!
                    }
                    if self.stabilizationWindowSeconds != nil {
                        map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                    }
                    if self.step != nil {
                        map["Step"] = self.step!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Disabled") {
                        self.disabled = dict["Disabled"] as! Bool
                    }
                    if dict.keys.contains("StabilizationWindowSeconds") {
                        self.stabilizationWindowSeconds = dict["StabilizationWindowSeconds"] as! Int64
                    }
                    if dict.keys.contains("Step") {
                        self.step = dict["Step"] as! Int64
                    }
                }
            }
            public var maxReplicas: Int32?

            public var metrics: [DescribeApplicationScalingRuleResponseBody.Data.Metric.Metrics]?

            public var metricsStatus: DescribeApplicationScalingRuleResponseBody.Data.Metric.MetricsStatus?

            public var minReplicas: Int32?

            public var scaleDownRules: DescribeApplicationScalingRuleResponseBody.Data.Metric.ScaleDownRules?

            public var scaleUpRules: DescribeApplicationScalingRuleResponseBody.Data.Metric.ScaleUpRules?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.metricsStatus?.validate()
                try self.scaleDownRules?.validate()
                try self.scaleUpRules?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.metrics != nil {
                    var tmp : [Any] = []
                    for k in self.metrics! {
                        tmp.append(k.toMap())
                    }
                    map["Metrics"] = tmp
                }
                if self.metricsStatus != nil {
                    map["MetricsStatus"] = self.metricsStatus?.toMap()
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                if self.scaleDownRules != nil {
                    map["ScaleDownRules"] = self.scaleDownRules?.toMap()
                }
                if self.scaleUpRules != nil {
                    map["ScaleUpRules"] = self.scaleUpRules?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxReplicas") {
                    self.maxReplicas = dict["MaxReplicas"] as! Int32
                }
                if dict.keys.contains("Metrics") {
                    var tmp : [DescribeApplicationScalingRuleResponseBody.Data.Metric.Metrics] = []
                    for v in dict["Metrics"] as! [Any] {
                        var model = DescribeApplicationScalingRuleResponseBody.Data.Metric.Metrics()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.metrics = tmp
                }
                if dict.keys.contains("MetricsStatus") {
                    var model = DescribeApplicationScalingRuleResponseBody.Data.Metric.MetricsStatus()
                    model.fromMap(dict["MetricsStatus"] as! [String: Any])
                    self.metricsStatus = model
                }
                if dict.keys.contains("MinReplicas") {
                    self.minReplicas = dict["MinReplicas"] as! Int32
                }
                if dict.keys.contains("ScaleDownRules") {
                    var model = DescribeApplicationScalingRuleResponseBody.Data.Metric.ScaleDownRules()
                    model.fromMap(dict["ScaleDownRules"] as! [String: Any])
                    self.scaleDownRules = model
                }
                if dict.keys.contains("ScaleUpRules") {
                    var model = DescribeApplicationScalingRuleResponseBody.Data.Metric.ScaleUpRules()
                    model.fromMap(dict["ScaleUpRules"] as! [String: Any])
                    self.scaleUpRules = model
                }
            }
        }
        public class Timer : Tea.TeaModel {
            public class Schedules : Tea.TeaModel {
                public var atTime: String?

                public var maxReplicas: Int32?

                public var minReplicas: Int32?

                public var targetReplicas: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.atTime != nil {
                        map["AtTime"] = self.atTime!
                    }
                    if self.maxReplicas != nil {
                        map["MaxReplicas"] = self.maxReplicas!
                    }
                    if self.minReplicas != nil {
                        map["MinReplicas"] = self.minReplicas!
                    }
                    if self.targetReplicas != nil {
                        map["TargetReplicas"] = self.targetReplicas!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AtTime") {
                        self.atTime = dict["AtTime"] as! String
                    }
                    if dict.keys.contains("MaxReplicas") {
                        self.maxReplicas = dict["MaxReplicas"] as! Int32
                    }
                    if dict.keys.contains("MinReplicas") {
                        self.minReplicas = dict["MinReplicas"] as! Int32
                    }
                    if dict.keys.contains("TargetReplicas") {
                        self.targetReplicas = dict["TargetReplicas"] as! Int32
                    }
                }
            }
            public var beginDate: String?

            public var endDate: String?

            public var period: String?

            public var schedules: [DescribeApplicationScalingRuleResponseBody.Data.Timer.Schedules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.beginDate != nil {
                    map["BeginDate"] = self.beginDate!
                }
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.schedules != nil {
                    var tmp : [Any] = []
                    for k in self.schedules! {
                        tmp.append(k.toMap())
                    }
                    map["Schedules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BeginDate") {
                    self.beginDate = dict["BeginDate"] as! String
                }
                if dict.keys.contains("EndDate") {
                    self.endDate = dict["EndDate"] as! String
                }
                if dict.keys.contains("Period") {
                    self.period = dict["Period"] as! String
                }
                if dict.keys.contains("Schedules") {
                    var tmp : [DescribeApplicationScalingRuleResponseBody.Data.Timer.Schedules] = []
                    for v in dict["Schedules"] as! [Any] {
                        var model = DescribeApplicationScalingRuleResponseBody.Data.Timer.Schedules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.schedules = tmp
                }
            }
        }
        public var appId: String?

        public var createTime: Int64?

        public var lastDisableTime: Int64?

        public var metric: DescribeApplicationScalingRuleResponseBody.Data.Metric?

        public var minReadyInstanceRatio: Int32?

        public var minReadyInstances: Int32?

        public var scaleRuleEnabled: Bool?

        public var scaleRuleName: String?

        public var scaleRuleType: String?

        public var timer: DescribeApplicationScalingRuleResponseBody.Data.Timer?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metric?.validate()
            try self.timer?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastDisableTime != nil {
                map["LastDisableTime"] = self.lastDisableTime!
            }
            if self.metric != nil {
                map["Metric"] = self.metric?.toMap()
            }
            if self.minReadyInstanceRatio != nil {
                map["MinReadyInstanceRatio"] = self.minReadyInstanceRatio!
            }
            if self.minReadyInstances != nil {
                map["MinReadyInstances"] = self.minReadyInstances!
            }
            if self.scaleRuleEnabled != nil {
                map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
            }
            if self.scaleRuleName != nil {
                map["ScaleRuleName"] = self.scaleRuleName!
            }
            if self.scaleRuleType != nil {
                map["ScaleRuleType"] = self.scaleRuleType!
            }
            if self.timer != nil {
                map["Timer"] = self.timer?.toMap()
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("LastDisableTime") {
                self.lastDisableTime = dict["LastDisableTime"] as! Int64
            }
            if dict.keys.contains("Metric") {
                var model = DescribeApplicationScalingRuleResponseBody.Data.Metric()
                model.fromMap(dict["Metric"] as! [String: Any])
                self.metric = model
            }
            if dict.keys.contains("MinReadyInstanceRatio") {
                self.minReadyInstanceRatio = dict["MinReadyInstanceRatio"] as! Int32
            }
            if dict.keys.contains("MinReadyInstances") {
                self.minReadyInstances = dict["MinReadyInstances"] as! Int32
            }
            if dict.keys.contains("ScaleRuleEnabled") {
                self.scaleRuleEnabled = dict["ScaleRuleEnabled"] as! Bool
            }
            if dict.keys.contains("ScaleRuleName") {
                self.scaleRuleName = dict["ScaleRuleName"] as! String
            }
            if dict.keys.contains("ScaleRuleType") {
                self.scaleRuleType = dict["ScaleRuleType"] as! String
            }
            if dict.keys.contains("Timer") {
                var model = DescribeApplicationScalingRuleResponseBody.Data.Timer()
                model.fromMap(dict["Timer"] as! [String: Any])
                self.timer = model
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeApplicationScalingRuleResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeApplicationScalingRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApplicationScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApplicationScalingRulesRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class DescribeApplicationScalingRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ApplicationScalingRules : Tea.TeaModel {
            public class Metric : Tea.TeaModel {
                public class Metrics : Tea.TeaModel {
                    public var metricTargetAverageUtilization: Int32?

                    public var metricType: String?

                    public var slbId: String?

                    public var slbLogstore: String?

                    public var slbProject: String?

                    public var vport: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.metricTargetAverageUtilization != nil {
                            map["MetricTargetAverageUtilization"] = self.metricTargetAverageUtilization!
                        }
                        if self.metricType != nil {
                            map["MetricType"] = self.metricType!
                        }
                        if self.slbId != nil {
                            map["SlbId"] = self.slbId!
                        }
                        if self.slbLogstore != nil {
                            map["SlbLogstore"] = self.slbLogstore!
                        }
                        if self.slbProject != nil {
                            map["SlbProject"] = self.slbProject!
                        }
                        if self.vport != nil {
                            map["Vport"] = self.vport!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("MetricTargetAverageUtilization") {
                            self.metricTargetAverageUtilization = dict["MetricTargetAverageUtilization"] as! Int32
                        }
                        if dict.keys.contains("MetricType") {
                            self.metricType = dict["MetricType"] as! String
                        }
                        if dict.keys.contains("SlbId") {
                            self.slbId = dict["SlbId"] as! String
                        }
                        if dict.keys.contains("SlbLogstore") {
                            self.slbLogstore = dict["SlbLogstore"] as! String
                        }
                        if dict.keys.contains("SlbProject") {
                            self.slbProject = dict["SlbProject"] as! String
                        }
                        if dict.keys.contains("Vport") {
                            self.vport = dict["Vport"] as! String
                        }
                    }
                }
                public class MetricsStatus : Tea.TeaModel {
                    public class CurrentMetrics : Tea.TeaModel {
                        public var currentValue: Int64?

                        public var name: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.currentValue != nil {
                                map["CurrentValue"] = self.currentValue!
                            }
                            if self.name != nil {
                                map["Name"] = self.name!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CurrentValue") {
                                self.currentValue = dict["CurrentValue"] as! Int64
                            }
                            if dict.keys.contains("Name") {
                                self.name = dict["Name"] as! String
                            }
                            if dict.keys.contains("Type") {
                                self.type = dict["Type"] as! String
                            }
                        }
                    }
                    public class NextScaleMetrics : Tea.TeaModel {
                        public var name: String?

                        public var nextScaleInAverageUtilization: Int32?

                        public var nextScaleOutAverageUtilization: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.name != nil {
                                map["Name"] = self.name!
                            }
                            if self.nextScaleInAverageUtilization != nil {
                                map["NextScaleInAverageUtilization"] = self.nextScaleInAverageUtilization!
                            }
                            if self.nextScaleOutAverageUtilization != nil {
                                map["NextScaleOutAverageUtilization"] = self.nextScaleOutAverageUtilization!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Name") {
                                self.name = dict["Name"] as! String
                            }
                            if dict.keys.contains("NextScaleInAverageUtilization") {
                                self.nextScaleInAverageUtilization = dict["NextScaleInAverageUtilization"] as! Int32
                            }
                            if dict.keys.contains("NextScaleOutAverageUtilization") {
                                self.nextScaleOutAverageUtilization = dict["NextScaleOutAverageUtilization"] as! Int32
                            }
                        }
                    }
                    public var currentMetrics: [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.MetricsStatus.CurrentMetrics]?

                    public var currentReplicas: Int64?

                    public var desiredReplicas: Int64?

                    public var lastScaleTime: String?

                    public var maxReplicas: Int64?

                    public var minReplicas: Int64?

                    public var nextScaleMetrics: [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.MetricsStatus.NextScaleMetrics]?

                    public var nextScaleTimePeriod: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.currentMetrics != nil {
                            var tmp : [Any] = []
                            for k in self.currentMetrics! {
                                tmp.append(k.toMap())
                            }
                            map["CurrentMetrics"] = tmp
                        }
                        if self.currentReplicas != nil {
                            map["CurrentReplicas"] = self.currentReplicas!
                        }
                        if self.desiredReplicas != nil {
                            map["DesiredReplicas"] = self.desiredReplicas!
                        }
                        if self.lastScaleTime != nil {
                            map["LastScaleTime"] = self.lastScaleTime!
                        }
                        if self.maxReplicas != nil {
                            map["MaxReplicas"] = self.maxReplicas!
                        }
                        if self.minReplicas != nil {
                            map["MinReplicas"] = self.minReplicas!
                        }
                        if self.nextScaleMetrics != nil {
                            var tmp : [Any] = []
                            for k in self.nextScaleMetrics! {
                                tmp.append(k.toMap())
                            }
                            map["NextScaleMetrics"] = tmp
                        }
                        if self.nextScaleTimePeriod != nil {
                            map["NextScaleTimePeriod"] = self.nextScaleTimePeriod!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CurrentMetrics") {
                            var tmp : [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.MetricsStatus.CurrentMetrics] = []
                            for v in dict["CurrentMetrics"] as! [Any] {
                                var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.MetricsStatus.CurrentMetrics()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.currentMetrics = tmp
                        }
                        if dict.keys.contains("CurrentReplicas") {
                            self.currentReplicas = dict["CurrentReplicas"] as! Int64
                        }
                        if dict.keys.contains("DesiredReplicas") {
                            self.desiredReplicas = dict["DesiredReplicas"] as! Int64
                        }
                        if dict.keys.contains("LastScaleTime") {
                            self.lastScaleTime = dict["LastScaleTime"] as! String
                        }
                        if dict.keys.contains("MaxReplicas") {
                            self.maxReplicas = dict["MaxReplicas"] as! Int64
                        }
                        if dict.keys.contains("MinReplicas") {
                            self.minReplicas = dict["MinReplicas"] as! Int64
                        }
                        if dict.keys.contains("NextScaleMetrics") {
                            var tmp : [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.MetricsStatus.NextScaleMetrics] = []
                            for v in dict["NextScaleMetrics"] as! [Any] {
                                var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.MetricsStatus.NextScaleMetrics()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.nextScaleMetrics = tmp
                        }
                        if dict.keys.contains("NextScaleTimePeriod") {
                            self.nextScaleTimePeriod = dict["NextScaleTimePeriod"] as! Int32
                        }
                    }
                }
                public class ScaleDownRules : Tea.TeaModel {
                    public var disabled: Bool?

                    public var stabilizationWindowSeconds: Int64?

                    public var step: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.disabled != nil {
                            map["Disabled"] = self.disabled!
                        }
                        if self.stabilizationWindowSeconds != nil {
                            map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                        }
                        if self.step != nil {
                            map["Step"] = self.step!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Disabled") {
                            self.disabled = dict["Disabled"] as! Bool
                        }
                        if dict.keys.contains("StabilizationWindowSeconds") {
                            self.stabilizationWindowSeconds = dict["StabilizationWindowSeconds"] as! Int64
                        }
                        if dict.keys.contains("Step") {
                            self.step = dict["Step"] as! Int64
                        }
                    }
                }
                public class ScaleUpRules : Tea.TeaModel {
                    public var disabled: Bool?

                    public var stabilizationWindowSeconds: Int64?

                    public var step: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.disabled != nil {
                            map["Disabled"] = self.disabled!
                        }
                        if self.stabilizationWindowSeconds != nil {
                            map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                        }
                        if self.step != nil {
                            map["Step"] = self.step!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Disabled") {
                            self.disabled = dict["Disabled"] as! Bool
                        }
                        if dict.keys.contains("StabilizationWindowSeconds") {
                            self.stabilizationWindowSeconds = dict["StabilizationWindowSeconds"] as! Int64
                        }
                        if dict.keys.contains("Step") {
                            self.step = dict["Step"] as! Int64
                        }
                    }
                }
                public var maxReplicas: Int32?

                public var metrics: [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.Metrics]?

                public var metricsStatus: DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.MetricsStatus?

                public var minReplicas: Int32?

                public var scaleDownRules: DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.ScaleDownRules?

                public var scaleUpRules: DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.ScaleUpRules?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.metricsStatus?.validate()
                    try self.scaleDownRules?.validate()
                    try self.scaleUpRules?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxReplicas != nil {
                        map["MaxReplicas"] = self.maxReplicas!
                    }
                    if self.metrics != nil {
                        var tmp : [Any] = []
                        for k in self.metrics! {
                            tmp.append(k.toMap())
                        }
                        map["Metrics"] = tmp
                    }
                    if self.metricsStatus != nil {
                        map["MetricsStatus"] = self.metricsStatus?.toMap()
                    }
                    if self.minReplicas != nil {
                        map["MinReplicas"] = self.minReplicas!
                    }
                    if self.scaleDownRules != nil {
                        map["ScaleDownRules"] = self.scaleDownRules?.toMap()
                    }
                    if self.scaleUpRules != nil {
                        map["ScaleUpRules"] = self.scaleUpRules?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MaxReplicas") {
                        self.maxReplicas = dict["MaxReplicas"] as! Int32
                    }
                    if dict.keys.contains("Metrics") {
                        var tmp : [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.Metrics] = []
                        for v in dict["Metrics"] as! [Any] {
                            var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.Metrics()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.metrics = tmp
                    }
                    if dict.keys.contains("MetricsStatus") {
                        var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.MetricsStatus()
                        model.fromMap(dict["MetricsStatus"] as! [String: Any])
                        self.metricsStatus = model
                    }
                    if dict.keys.contains("MinReplicas") {
                        self.minReplicas = dict["MinReplicas"] as! Int32
                    }
                    if dict.keys.contains("ScaleDownRules") {
                        var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.ScaleDownRules()
                        model.fromMap(dict["ScaleDownRules"] as! [String: Any])
                        self.scaleDownRules = model
                    }
                    if dict.keys.contains("ScaleUpRules") {
                        var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.ScaleUpRules()
                        model.fromMap(dict["ScaleUpRules"] as! [String: Any])
                        self.scaleUpRules = model
                    }
                }
            }
            public class Timer : Tea.TeaModel {
                public class Schedules : Tea.TeaModel {
                    public var atTime: String?

                    public var maxReplicas: Int64?

                    public var minReplicas: Int64?

                    public var targetReplicas: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.atTime != nil {
                            map["AtTime"] = self.atTime!
                        }
                        if self.maxReplicas != nil {
                            map["MaxReplicas"] = self.maxReplicas!
                        }
                        if self.minReplicas != nil {
                            map["MinReplicas"] = self.minReplicas!
                        }
                        if self.targetReplicas != nil {
                            map["TargetReplicas"] = self.targetReplicas!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AtTime") {
                            self.atTime = dict["AtTime"] as! String
                        }
                        if dict.keys.contains("MaxReplicas") {
                            self.maxReplicas = dict["MaxReplicas"] as! Int64
                        }
                        if dict.keys.contains("MinReplicas") {
                            self.minReplicas = dict["MinReplicas"] as! Int64
                        }
                        if dict.keys.contains("TargetReplicas") {
                            self.targetReplicas = dict["TargetReplicas"] as! Int32
                        }
                    }
                }
                public var beginDate: String?

                public var endDate: String?

                public var period: String?

                public var schedules: [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Timer.Schedules]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.beginDate != nil {
                        map["BeginDate"] = self.beginDate!
                    }
                    if self.endDate != nil {
                        map["EndDate"] = self.endDate!
                    }
                    if self.period != nil {
                        map["Period"] = self.period!
                    }
                    if self.schedules != nil {
                        var tmp : [Any] = []
                        for k in self.schedules! {
                            tmp.append(k.toMap())
                        }
                        map["Schedules"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BeginDate") {
                        self.beginDate = dict["BeginDate"] as! String
                    }
                    if dict.keys.contains("EndDate") {
                        self.endDate = dict["EndDate"] as! String
                    }
                    if dict.keys.contains("Period") {
                        self.period = dict["Period"] as! String
                    }
                    if dict.keys.contains("Schedules") {
                        var tmp : [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Timer.Schedules] = []
                        for v in dict["Schedules"] as! [Any] {
                            var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Timer.Schedules()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.schedules = tmp
                    }
                }
            }
            public var appId: String?

            public var createTime: Int64?

            public var lastDisableTime: Int64?

            public var metric: DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric?

            public var minReadyInstanceRatio: Int32?

            public var minReadyInstances: Int32?

            public var scaleRuleEnabled: Bool?

            public var scaleRuleName: String?

            public var scaleRuleType: String?

            public var timer: DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Timer?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.metric?.validate()
                try self.timer?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.lastDisableTime != nil {
                    map["LastDisableTime"] = self.lastDisableTime!
                }
                if self.metric != nil {
                    map["Metric"] = self.metric?.toMap()
                }
                if self.minReadyInstanceRatio != nil {
                    map["MinReadyInstanceRatio"] = self.minReadyInstanceRatio!
                }
                if self.minReadyInstances != nil {
                    map["MinReadyInstances"] = self.minReadyInstances!
                }
                if self.scaleRuleEnabled != nil {
                    map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
                }
                if self.scaleRuleName != nil {
                    map["ScaleRuleName"] = self.scaleRuleName!
                }
                if self.scaleRuleType != nil {
                    map["ScaleRuleType"] = self.scaleRuleType!
                }
                if self.timer != nil {
                    map["Timer"] = self.timer?.toMap()
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("LastDisableTime") {
                    self.lastDisableTime = dict["LastDisableTime"] as! Int64
                }
                if dict.keys.contains("Metric") {
                    var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric()
                    model.fromMap(dict["Metric"] as! [String: Any])
                    self.metric = model
                }
                if dict.keys.contains("MinReadyInstanceRatio") {
                    self.minReadyInstanceRatio = dict["MinReadyInstanceRatio"] as! Int32
                }
                if dict.keys.contains("MinReadyInstances") {
                    self.minReadyInstances = dict["MinReadyInstances"] as! Int32
                }
                if dict.keys.contains("ScaleRuleEnabled") {
                    self.scaleRuleEnabled = dict["ScaleRuleEnabled"] as! Bool
                }
                if dict.keys.contains("ScaleRuleName") {
                    self.scaleRuleName = dict["ScaleRuleName"] as! String
                }
                if dict.keys.contains("ScaleRuleType") {
                    self.scaleRuleType = dict["ScaleRuleType"] as! String
                }
                if dict.keys.contains("Timer") {
                    var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Timer()
                    model.fromMap(dict["Timer"] as! [String: Any])
                    self.timer = model
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
            }
        }
        public var applicationScalingRules: [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules]?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationScalingRules != nil {
                var tmp : [Any] = []
                for k in self.applicationScalingRules! {
                    tmp.append(k.toMap())
                }
                map["ApplicationScalingRules"] = tmp
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ApplicationScalingRules") {
                var tmp : [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules] = []
                for v in dict["ApplicationScalingRules"] as! [Any] {
                    var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.applicationScalingRules = tmp
            }
            if dict.keys.contains("CurrentPage") {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: DescribeApplicationScalingRulesResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeApplicationScalingRulesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeApplicationScalingRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationScalingRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApplicationScalingRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApplicationSlbsRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class DescribeApplicationSlbsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Internet : Tea.TeaModel {
            public var httpsCaCertId: String?

            public var httpsCertId: String?

            public var port: Int32?

            public var protocol_: String?

            public var targetPort: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.httpsCaCertId != nil {
                    map["HttpsCaCertId"] = self.httpsCaCertId!
                }
                if self.httpsCertId != nil {
                    map["HttpsCertId"] = self.httpsCertId!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.targetPort != nil {
                    map["TargetPort"] = self.targetPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HttpsCaCertId") {
                    self.httpsCaCertId = dict["HttpsCaCertId"] as! String
                }
                if dict.keys.contains("HttpsCertId") {
                    self.httpsCertId = dict["HttpsCertId"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Protocol") {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("TargetPort") {
                    self.targetPort = dict["TargetPort"] as! Int32
                }
            }
        }
        public class Intranet : Tea.TeaModel {
            public var httpsCaCertId: String?

            public var httpsCertId: String?

            public var port: Int32?

            public var protocol_: String?

            public var targetPort: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.httpsCaCertId != nil {
                    map["HttpsCaCertId"] = self.httpsCaCertId!
                }
                if self.httpsCertId != nil {
                    map["HttpsCertId"] = self.httpsCertId!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.targetPort != nil {
                    map["TargetPort"] = self.targetPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HttpsCaCertId") {
                    self.httpsCaCertId = dict["HttpsCaCertId"] as! String
                }
                if dict.keys.contains("HttpsCertId") {
                    self.httpsCertId = dict["HttpsCertId"] as! String
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int32
                }
                if dict.keys.contains("Protocol") {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("TargetPort") {
                    self.targetPort = dict["TargetPort"] as! Int32
                }
            }
        }
        public var internet: [DescribeApplicationSlbsResponseBody.Data.Internet]?

        public var internetIp: String?

        public var internetSlbExpired: Bool?

        public var internetSlbId: String?

        public var intranet: [DescribeApplicationSlbsResponseBody.Data.Intranet]?

        public var intranetIp: String?

        public var intranetSlbExpired: Bool?

        public var intranetSlbId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.internet != nil {
                var tmp : [Any] = []
                for k in self.internet! {
                    tmp.append(k.toMap())
                }
                map["Internet"] = tmp
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.internetSlbExpired != nil {
                map["InternetSlbExpired"] = self.internetSlbExpired!
            }
            if self.internetSlbId != nil {
                map["InternetSlbId"] = self.internetSlbId!
            }
            if self.intranet != nil {
                var tmp : [Any] = []
                for k in self.intranet! {
                    tmp.append(k.toMap())
                }
                map["Intranet"] = tmp
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.intranetSlbExpired != nil {
                map["IntranetSlbExpired"] = self.intranetSlbExpired!
            }
            if self.intranetSlbId != nil {
                map["IntranetSlbId"] = self.intranetSlbId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Internet") {
                var tmp : [DescribeApplicationSlbsResponseBody.Data.Internet] = []
                for v in dict["Internet"] as! [Any] {
                    var model = DescribeApplicationSlbsResponseBody.Data.Internet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.internet = tmp
            }
            if dict.keys.contains("InternetIp") {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("InternetSlbExpired") {
                self.internetSlbExpired = dict["InternetSlbExpired"] as! Bool
            }
            if dict.keys.contains("InternetSlbId") {
                self.internetSlbId = dict["InternetSlbId"] as! String
            }
            if dict.keys.contains("Intranet") {
                var tmp : [DescribeApplicationSlbsResponseBody.Data.Intranet] = []
                for v in dict["Intranet"] as! [Any] {
                    var model = DescribeApplicationSlbsResponseBody.Data.Intranet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.intranet = tmp
            }
            if dict.keys.contains("IntranetIp") {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("IntranetSlbExpired") {
                self.intranetSlbExpired = dict["IntranetSlbExpired"] as! Bool
            }
            if dict.keys.contains("IntranetSlbId") {
                self.intranetSlbId = dict["IntranetSlbId"] as! String
            }
        }
    }
    public var code: String?

    public var data: DescribeApplicationSlbsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeApplicationSlbsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeApplicationSlbsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationSlbsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApplicationSlbsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApplicationStatusRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class DescribeApplicationStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var armsAdvancedEnabled: String?

        public var armsApmInfo: String?

        public var createTime: String?

        public var currentStatus: String?

        public var enableAgent: Bool?

        public var fileSizeLimit: Int64?

        public var lastChangeOrderId: String?

        public var lastChangeOrderRunning: Bool?

        public var lastChangeOrderStatus: String?

        public var runningInstances: Int32?

        public var subStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.armsAdvancedEnabled != nil {
                map["ArmsAdvancedEnabled"] = self.armsAdvancedEnabled!
            }
            if self.armsApmInfo != nil {
                map["ArmsApmInfo"] = self.armsApmInfo!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.currentStatus != nil {
                map["CurrentStatus"] = self.currentStatus!
            }
            if self.enableAgent != nil {
                map["EnableAgent"] = self.enableAgent!
            }
            if self.fileSizeLimit != nil {
                map["FileSizeLimit"] = self.fileSizeLimit!
            }
            if self.lastChangeOrderId != nil {
                map["LastChangeOrderId"] = self.lastChangeOrderId!
            }
            if self.lastChangeOrderRunning != nil {
                map["LastChangeOrderRunning"] = self.lastChangeOrderRunning!
            }
            if self.lastChangeOrderStatus != nil {
                map["LastChangeOrderStatus"] = self.lastChangeOrderStatus!
            }
            if self.runningInstances != nil {
                map["RunningInstances"] = self.runningInstances!
            }
            if self.subStatus != nil {
                map["SubStatus"] = self.subStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("ArmsAdvancedEnabled") {
                self.armsAdvancedEnabled = dict["ArmsAdvancedEnabled"] as! String
            }
            if dict.keys.contains("ArmsApmInfo") {
                self.armsApmInfo = dict["ArmsApmInfo"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CurrentStatus") {
                self.currentStatus = dict["CurrentStatus"] as! String
            }
            if dict.keys.contains("EnableAgent") {
                self.enableAgent = dict["EnableAgent"] as! Bool
            }
            if dict.keys.contains("FileSizeLimit") {
                self.fileSizeLimit = dict["FileSizeLimit"] as! Int64
            }
            if dict.keys.contains("LastChangeOrderId") {
                self.lastChangeOrderId = dict["LastChangeOrderId"] as! String
            }
            if dict.keys.contains("LastChangeOrderRunning") {
                self.lastChangeOrderRunning = dict["LastChangeOrderRunning"] as! Bool
            }
            if dict.keys.contains("LastChangeOrderStatus") {
                self.lastChangeOrderStatus = dict["LastChangeOrderStatus"] as! String
            }
            if dict.keys.contains("RunningInstances") {
                self.runningInstances = dict["RunningInstances"] as! Int32
            }
            if dict.keys.contains("SubStatus") {
                self.subStatus = dict["SubStatus"] as! String
            }
        }
    }
    public var code: String?

    public var data: DescribeApplicationStatusResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeApplicationStatusResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeApplicationStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApplicationStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeChangeOrderRequest : Tea.TeaModel {
    public var changeOrderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChangeOrderId") {
            self.changeOrderId = dict["ChangeOrderId"] as! String
        }
    }
}

public class DescribeChangeOrderResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Pipelines : Tea.TeaModel {
            public var batchType: Int32?

            public var parallelCount: Int32?

            public var pipelineId: String?

            public var pipelineName: String?

            public var startTime: Int64?

            public var status: Int32?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.batchType != nil {
                    map["BatchType"] = self.batchType!
                }
                if self.parallelCount != nil {
                    map["ParallelCount"] = self.parallelCount!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.pipelineName != nil {
                    map["PipelineName"] = self.pipelineName!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BatchType") {
                    self.batchType = dict["BatchType"] as! Int32
                }
                if dict.keys.contains("ParallelCount") {
                    self.parallelCount = dict["ParallelCount"] as! Int32
                }
                if dict.keys.contains("PipelineId") {
                    self.pipelineId = dict["PipelineId"] as! String
                }
                if dict.keys.contains("PipelineName") {
                    self.pipelineName = dict["PipelineName"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
            }
        }
        public var appId: String?

        public var appName: String?

        public var approvalId: String?

        public var auto: Bool?

        public var batchCount: Int32?

        public var batchType: String?

        public var batchWaitTime: Int32?

        public var changeOrderId: String?

        public var coType: String?

        public var coTypeCode: String?

        public var createTime: String?

        public var currentPipelineId: String?

        public var description_: String?

        public var errorMessage: String?

        public var pipelines: [DescribeChangeOrderResponseBody.Data.Pipelines]?

        public var status: Int32?

        public var subStatus: Int32?

        public var supportRollback: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.approvalId != nil {
                map["ApprovalId"] = self.approvalId!
            }
            if self.auto != nil {
                map["Auto"] = self.auto!
            }
            if self.batchCount != nil {
                map["BatchCount"] = self.batchCount!
            }
            if self.batchType != nil {
                map["BatchType"] = self.batchType!
            }
            if self.batchWaitTime != nil {
                map["BatchWaitTime"] = self.batchWaitTime!
            }
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            if self.coType != nil {
                map["CoType"] = self.coType!
            }
            if self.coTypeCode != nil {
                map["CoTypeCode"] = self.coTypeCode!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.currentPipelineId != nil {
                map["CurrentPipelineId"] = self.currentPipelineId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.pipelines != nil {
                var tmp : [Any] = []
                for k in self.pipelines! {
                    tmp.append(k.toMap())
                }
                map["Pipelines"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subStatus != nil {
                map["SubStatus"] = self.subStatus!
            }
            if self.supportRollback != nil {
                map["SupportRollback"] = self.supportRollback!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("ApprovalId") {
                self.approvalId = dict["ApprovalId"] as! String
            }
            if dict.keys.contains("Auto") {
                self.auto = dict["Auto"] as! Bool
            }
            if dict.keys.contains("BatchCount") {
                self.batchCount = dict["BatchCount"] as! Int32
            }
            if dict.keys.contains("BatchType") {
                self.batchType = dict["BatchType"] as! String
            }
            if dict.keys.contains("BatchWaitTime") {
                self.batchWaitTime = dict["BatchWaitTime"] as! Int32
            }
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
            if dict.keys.contains("CoType") {
                self.coType = dict["CoType"] as! String
            }
            if dict.keys.contains("CoTypeCode") {
                self.coTypeCode = dict["CoTypeCode"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("CurrentPipelineId") {
                self.currentPipelineId = dict["CurrentPipelineId"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("Pipelines") {
                var tmp : [DescribeChangeOrderResponseBody.Data.Pipelines] = []
                for v in dict["Pipelines"] as! [Any] {
                    var model = DescribeChangeOrderResponseBody.Data.Pipelines()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.pipelines = tmp
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! Int32
            }
            if dict.keys.contains("SubStatus") {
                self.subStatus = dict["SubStatus"] as! Int32
            }
            if dict.keys.contains("SupportRollback") {
                self.supportRollback = dict["SupportRollback"] as! Bool
            }
        }
    }
    public var code: String?

    public var data: DescribeChangeOrderResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeChangeOrderResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeChangeOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeChangeOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeChangeOrderResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeComponentsRequest : Tea.TeaModel {
    public var appId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeComponentsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var componentDescription: String?

        public var componentKey: String?

        public var expired: Bool?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.componentDescription != nil {
                map["ComponentDescription"] = self.componentDescription!
            }
            if self.componentKey != nil {
                map["ComponentKey"] = self.componentKey!
            }
            if self.expired != nil {
                map["Expired"] = self.expired!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComponentDescription") {
                self.componentDescription = dict["ComponentDescription"] as! String
            }
            if dict.keys.contains("ComponentKey") {
                self.componentKey = dict["ComponentKey"] as! String
            }
            if dict.keys.contains("Expired") {
                self.expired = dict["Expired"] as! Bool
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var code: String?

    public var data: [DescribeComponentsResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [DescribeComponentsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeComponentsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeComponentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeComponentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeComponentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeConfigMapRequest : Tea.TeaModel {
    public var configMapId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configMapId != nil {
            map["ConfigMapId"] = self.configMapId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigMapId") {
            self.configMapId = dict["ConfigMapId"] as! Int64
        }
    }
}

public class DescribeConfigMapResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RelateApps : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
            }
        }
        public var configMapId: Int64?

        public var createTime: Int64?

        public var data: [String: Any]?

        public var description_: String?

        public var name: String?

        public var namespaceId: String?

        public var relateApps: [DescribeConfigMapResponseBody.Data.RelateApps]?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configMapId != nil {
                map["ConfigMapId"] = self.configMapId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.relateApps != nil {
                var tmp : [Any] = []
                for k in self.relateApps! {
                    tmp.append(k.toMap())
                }
                map["RelateApps"] = tmp
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigMapId") {
                self.configMapId = dict["ConfigMapId"] as! Int64
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Data") {
                self.data = dict["Data"] as! [String: Any]
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NamespaceId") {
                self.namespaceId = dict["NamespaceId"] as! String
            }
            if dict.keys.contains("RelateApps") {
                var tmp : [DescribeConfigMapResponseBody.Data.RelateApps] = []
                for v in dict["RelateApps"] as! [Any] {
                    var model = DescribeConfigMapResponseBody.Data.RelateApps()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.relateApps = tmp
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeConfigMapResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeConfigMapResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeConfigMapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConfigMapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeConfigMapResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeConfigurationPriceRequest : Tea.TeaModel {
    public var cpu: Int32?

    public var memory: Int32?

    public var workload: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.workload != nil {
            map["Workload"] = self.workload!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cpu") {
            self.cpu = dict["Cpu"] as! Int32
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Int32
        }
        if dict.keys.contains("Workload") {
            self.workload = dict["Workload"] as! String
        }
    }
}

public class DescribeConfigurationPriceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class BagUsage : Tea.TeaModel {
            public var cpu: Double?

            public var mem: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.mem != nil {
                    map["Mem"] = self.mem!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cpu") {
                    self.cpu = dict["Cpu"] as! Double
                }
                if dict.keys.contains("Mem") {
                    self.mem = dict["Mem"] as! Double
                }
            }
        }
        public class CpuMemPrice : Tea.TeaModel {
            public class Order : Tea.TeaModel {
                public var discountAmount: Double?

                public var originalAmount: Double?

                public var ruleIds: [String]?

                public var tradeAmount: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.discountAmount != nil {
                        map["DiscountAmount"] = self.discountAmount!
                    }
                    if self.originalAmount != nil {
                        map["OriginalAmount"] = self.originalAmount!
                    }
                    if self.ruleIds != nil {
                        map["RuleIds"] = self.ruleIds!
                    }
                    if self.tradeAmount != nil {
                        map["TradeAmount"] = self.tradeAmount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DiscountAmount") {
                        self.discountAmount = dict["DiscountAmount"] as! Double
                    }
                    if dict.keys.contains("OriginalAmount") {
                        self.originalAmount = dict["OriginalAmount"] as! Double
                    }
                    if dict.keys.contains("RuleIds") {
                        self.ruleIds = dict["RuleIds"] as! [String]
                    }
                    if dict.keys.contains("TradeAmount") {
                        self.tradeAmount = dict["TradeAmount"] as! Double
                    }
                }
            }
            public class Rules : Tea.TeaModel {
                public var name: String?

                public var ruleDescId: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.ruleDescId != nil {
                        map["RuleDescId"] = self.ruleDescId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("RuleDescId") {
                        self.ruleDescId = dict["RuleDescId"] as! Double
                    }
                }
            }
            public var order: DescribeConfigurationPriceResponseBody.Data.CpuMemPrice.Order?

            public var rules: [DescribeConfigurationPriceResponseBody.Data.CpuMemPrice.Rules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.order?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.order != nil {
                    map["Order"] = self.order?.toMap()
                }
                if self.rules != nil {
                    var tmp : [Any] = []
                    for k in self.rules! {
                        tmp.append(k.toMap())
                    }
                    map["Rules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Order") {
                    var model = DescribeConfigurationPriceResponseBody.Data.CpuMemPrice.Order()
                    model.fromMap(dict["Order"] as! [String: Any])
                    self.order = model
                }
                if dict.keys.contains("Rules") {
                    var tmp : [DescribeConfigurationPriceResponseBody.Data.CpuMemPrice.Rules] = []
                    for v in dict["Rules"] as! [Any] {
                        var model = DescribeConfigurationPriceResponseBody.Data.CpuMemPrice.Rules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.rules = tmp
                }
            }
        }
        public class Order : Tea.TeaModel {
            public var discountAmount: Double?

            public var originalAmount: Double?

            public var ruleIds: [String]?

            public var tradeAmount: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.discountAmount != nil {
                    map["DiscountAmount"] = self.discountAmount!
                }
                if self.originalAmount != nil {
                    map["OriginalAmount"] = self.originalAmount!
                }
                if self.ruleIds != nil {
                    map["RuleIds"] = self.ruleIds!
                }
                if self.tradeAmount != nil {
                    map["TradeAmount"] = self.tradeAmount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DiscountAmount") {
                    self.discountAmount = dict["DiscountAmount"] as! Double
                }
                if dict.keys.contains("OriginalAmount") {
                    self.originalAmount = dict["OriginalAmount"] as! Double
                }
                if dict.keys.contains("RuleIds") {
                    self.ruleIds = dict["RuleIds"] as! [String]
                }
                if dict.keys.contains("TradeAmount") {
                    self.tradeAmount = dict["TradeAmount"] as! Double
                }
            }
        }
        public class RequestPrice : Tea.TeaModel {
            public class Order : Tea.TeaModel {
                public var discountAmount: Double?

                public var originalAmount: Double?

                public var ruleIds: [String]?

                public var tradeAmount: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.discountAmount != nil {
                        map["DiscountAmount"] = self.discountAmount!
                    }
                    if self.originalAmount != nil {
                        map["OriginalAmount"] = self.originalAmount!
                    }
                    if self.ruleIds != nil {
                        map["RuleIds"] = self.ruleIds!
                    }
                    if self.tradeAmount != nil {
                        map["TradeAmount"] = self.tradeAmount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DiscountAmount") {
                        self.discountAmount = dict["DiscountAmount"] as! Double
                    }
                    if dict.keys.contains("OriginalAmount") {
                        self.originalAmount = dict["OriginalAmount"] as! Double
                    }
                    if dict.keys.contains("RuleIds") {
                        self.ruleIds = dict["RuleIds"] as! [String]
                    }
                    if dict.keys.contains("TradeAmount") {
                        self.tradeAmount = dict["TradeAmount"] as! Double
                    }
                }
            }
            public class Rules : Tea.TeaModel {
                public var name: String?

                public var ruleDescId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.ruleDescId != nil {
                        map["RuleDescId"] = self.ruleDescId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("RuleDescId") {
                        self.ruleDescId = dict["RuleDescId"] as! Int64
                    }
                }
            }
            public var order: DescribeConfigurationPriceResponseBody.Data.RequestPrice.Order?

            public var rules: [DescribeConfigurationPriceResponseBody.Data.RequestPrice.Rules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.order?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.order != nil {
                    map["Order"] = self.order?.toMap()
                }
                if self.rules != nil {
                    var tmp : [Any] = []
                    for k in self.rules! {
                        tmp.append(k.toMap())
                    }
                    map["Rules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Order") {
                    var model = DescribeConfigurationPriceResponseBody.Data.RequestPrice.Order()
                    model.fromMap(dict["Order"] as! [String: Any])
                    self.order = model
                }
                if dict.keys.contains("Rules") {
                    var tmp : [DescribeConfigurationPriceResponseBody.Data.RequestPrice.Rules] = []
                    for v in dict["Rules"] as! [Any] {
                        var model = DescribeConfigurationPriceResponseBody.Data.RequestPrice.Rules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.rules = tmp
                }
            }
        }
        public class Rules : Tea.TeaModel {
            public var name: String?

            public var ruleDescId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ruleDescId != nil {
                    map["RuleDescId"] = self.ruleDescId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RuleDescId") {
                    self.ruleDescId = dict["RuleDescId"] as! Int64
                }
            }
        }
        public class TrafficPrice : Tea.TeaModel {
            public class Order : Tea.TeaModel {
                public var discountAmount: Double?

                public var originalAmount: Double?

                public var ruleIds: [String]?

                public var tradeAmount: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.discountAmount != nil {
                        map["DiscountAmount"] = self.discountAmount!
                    }
                    if self.originalAmount != nil {
                        map["OriginalAmount"] = self.originalAmount!
                    }
                    if self.ruleIds != nil {
                        map["RuleIds"] = self.ruleIds!
                    }
                    if self.tradeAmount != nil {
                        map["TradeAmount"] = self.tradeAmount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DiscountAmount") {
                        self.discountAmount = dict["DiscountAmount"] as! Double
                    }
                    if dict.keys.contains("OriginalAmount") {
                        self.originalAmount = dict["OriginalAmount"] as! Double
                    }
                    if dict.keys.contains("RuleIds") {
                        self.ruleIds = dict["RuleIds"] as! [String]
                    }
                    if dict.keys.contains("TradeAmount") {
                        self.tradeAmount = dict["TradeAmount"] as! Double
                    }
                }
            }
            public class Rules : Tea.TeaModel {
                public var name: String?

                public var ruleDescId: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.ruleDescId != nil {
                        map["RuleDescId"] = self.ruleDescId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("RuleDescId") {
                        self.ruleDescId = dict["RuleDescId"] as! Double
                    }
                }
            }
            public var order: DescribeConfigurationPriceResponseBody.Data.TrafficPrice.Order?

            public var rules: [DescribeConfigurationPriceResponseBody.Data.TrafficPrice.Rules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.order?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.order != nil {
                    map["Order"] = self.order?.toMap()
                }
                if self.rules != nil {
                    var tmp : [Any] = []
                    for k in self.rules! {
                        tmp.append(k.toMap())
                    }
                    map["Rules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Order") {
                    var model = DescribeConfigurationPriceResponseBody.Data.TrafficPrice.Order()
                    model.fromMap(dict["Order"] as! [String: Any])
                    self.order = model
                }
                if dict.keys.contains("Rules") {
                    var tmp : [DescribeConfigurationPriceResponseBody.Data.TrafficPrice.Rules] = []
                    for v in dict["Rules"] as! [Any] {
                        var model = DescribeConfigurationPriceResponseBody.Data.TrafficPrice.Rules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.rules = tmp
                }
            }
        }
        public var bagUsage: DescribeConfigurationPriceResponseBody.Data.BagUsage?

        public var cpuMemPrice: DescribeConfigurationPriceResponseBody.Data.CpuMemPrice?

        public var order: DescribeConfigurationPriceResponseBody.Data.Order?

        public var requestPrice: DescribeConfigurationPriceResponseBody.Data.RequestPrice?

        public var rules: [DescribeConfigurationPriceResponseBody.Data.Rules]?

        public var trafficPrice: DescribeConfigurationPriceResponseBody.Data.TrafficPrice?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.bagUsage?.validate()
            try self.cpuMemPrice?.validate()
            try self.order?.validate()
            try self.requestPrice?.validate()
            try self.trafficPrice?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bagUsage != nil {
                map["BagUsage"] = self.bagUsage?.toMap()
            }
            if self.cpuMemPrice != nil {
                map["CpuMemPrice"] = self.cpuMemPrice?.toMap()
            }
            if self.order != nil {
                map["Order"] = self.order?.toMap()
            }
            if self.requestPrice != nil {
                map["RequestPrice"] = self.requestPrice?.toMap()
            }
            if self.rules != nil {
                var tmp : [Any] = []
                for k in self.rules! {
                    tmp.append(k.toMap())
                }
                map["Rules"] = tmp
            }
            if self.trafficPrice != nil {
                map["TrafficPrice"] = self.trafficPrice?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BagUsage") {
                var model = DescribeConfigurationPriceResponseBody.Data.BagUsage()
                model.fromMap(dict["BagUsage"] as! [String: Any])
                self.bagUsage = model
            }
            if dict.keys.contains("CpuMemPrice") {
                var model = DescribeConfigurationPriceResponseBody.Data.CpuMemPrice()
                model.fromMap(dict["CpuMemPrice"] as! [String: Any])
                self.cpuMemPrice = model
            }
            if dict.keys.contains("Order") {
                var model = DescribeConfigurationPriceResponseBody.Data.Order()
                model.fromMap(dict["Order"] as! [String: Any])
                self.order = model
            }
            if dict.keys.contains("RequestPrice") {
                var model = DescribeConfigurationPriceResponseBody.Data.RequestPrice()
                model.fromMap(dict["RequestPrice"] as! [String: Any])
                self.requestPrice = model
            }
            if dict.keys.contains("Rules") {
                var tmp : [DescribeConfigurationPriceResponseBody.Data.Rules] = []
                for v in dict["Rules"] as! [Any] {
                    var model = DescribeConfigurationPriceResponseBody.Data.Rules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.rules = tmp
            }
            if dict.keys.contains("TrafficPrice") {
                var model = DescribeConfigurationPriceResponseBody.Data.TrafficPrice()
                model.fromMap(dict["TrafficPrice"] as! [String: Any])
                self.trafficPrice = model
            }
        }
    }
    public var code: String?

    public var data: DescribeConfigurationPriceResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeConfigurationPriceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeConfigurationPriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConfigurationPriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeConfigurationPriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEdasContainersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var disabled: Bool?

        public var edasContainerVersion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disabled != nil {
                map["Disabled"] = self.disabled!
            }
            if self.edasContainerVersion != nil {
                map["EdasContainerVersion"] = self.edasContainerVersion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Disabled") {
                self.disabled = dict["Disabled"] as! Bool
            }
            if dict.keys.contains("EdasContainerVersion") {
                self.edasContainerVersion = dict["EdasContainerVersion"] as! String
            }
        }
    }
    public var code: String?

    public var data: [DescribeEdasContainersResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [DescribeEdasContainersResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeEdasContainersResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeEdasContainersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEdasContainersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEdasContainersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeGreyTagRouteRequest : Tea.TeaModel {
    public var greyTagRouteId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.greyTagRouteId != nil {
            map["GreyTagRouteId"] = self.greyTagRouteId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GreyTagRouteId") {
            self.greyTagRouteId = dict["GreyTagRouteId"] as! Int64
        }
    }
}

public class DescribeGreyTagRouteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AlbRules : Tea.TeaModel {
            public class Items : Tea.TeaModel {
                public var cond: String?

                public var expr: String?

                public var index: Int32?

                public var name: String?

                public var operator_: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cond != nil {
                        map["cond"] = self.cond!
                    }
                    if self.expr != nil {
                        map["expr"] = self.expr!
                    }
                    if self.index != nil {
                        map["index"] = self.index!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.operator_ != nil {
                        map["operator"] = self.operator_!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("cond") {
                        self.cond = dict["cond"] as! String
                    }
                    if dict.keys.contains("expr") {
                        self.expr = dict["expr"] as! String
                    }
                    if dict.keys.contains("index") {
                        self.index = dict["index"] as! Int32
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("operator") {
                        self.operator_ = dict["operator"] as! String
                    }
                    if dict.keys.contains("type") {
                        self.type = dict["type"] as! String
                    }
                    if dict.keys.contains("value") {
                        self.value = dict["value"] as! String
                    }
                }
            }
            public var condition: String?

            public var ingressId: String?

            public var items: [DescribeGreyTagRouteResponseBody.Data.AlbRules.Items]?

            public var serviceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["condition"] = self.condition!
                }
                if self.ingressId != nil {
                    map["ingressId"] = self.ingressId!
                }
                if self.items != nil {
                    var tmp : [Any] = []
                    for k in self.items! {
                        tmp.append(k.toMap())
                    }
                    map["items"] = tmp
                }
                if self.serviceId != nil {
                    map["serviceId"] = self.serviceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("condition") {
                    self.condition = dict["condition"] as! String
                }
                if dict.keys.contains("ingressId") {
                    self.ingressId = dict["ingressId"] as! String
                }
                if dict.keys.contains("items") {
                    var tmp : [DescribeGreyTagRouteResponseBody.Data.AlbRules.Items] = []
                    for v in dict["items"] as! [Any] {
                        var model = DescribeGreyTagRouteResponseBody.Data.AlbRules.Items()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.items = tmp
                }
                if dict.keys.contains("serviceId") {
                    self.serviceId = dict["serviceId"] as! String
                }
            }
        }
        public class DubboRules : Tea.TeaModel {
            public class Items : Tea.TeaModel {
                public var cond: String?

                public var expr: String?

                public var index: Int32?

                public var name: String?

                public var operator_: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cond != nil {
                        map["cond"] = self.cond!
                    }
                    if self.expr != nil {
                        map["expr"] = self.expr!
                    }
                    if self.index != nil {
                        map["index"] = self.index!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.operator_ != nil {
                        map["operator"] = self.operator_!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("cond") {
                        self.cond = dict["cond"] as! String
                    }
                    if dict.keys.contains("expr") {
                        self.expr = dict["expr"] as! String
                    }
                    if dict.keys.contains("index") {
                        self.index = dict["index"] as! Int32
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("operator") {
                        self.operator_ = dict["operator"] as! String
                    }
                    if dict.keys.contains("type") {
                        self.type = dict["type"] as! String
                    }
                    if dict.keys.contains("value") {
                        self.value = dict["value"] as! String
                    }
                }
            }
            public var condition: String?

            public var group: String?

            public var items: [DescribeGreyTagRouteResponseBody.Data.DubboRules.Items]?

            public var methodName: String?

            public var serviceName: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["condition"] = self.condition!
                }
                if self.group != nil {
                    map["group"] = self.group!
                }
                if self.items != nil {
                    var tmp : [Any] = []
                    for k in self.items! {
                        tmp.append(k.toMap())
                    }
                    map["items"] = tmp
                }
                if self.methodName != nil {
                    map["methodName"] = self.methodName!
                }
                if self.serviceName != nil {
                    map["serviceName"] = self.serviceName!
                }
                if self.version != nil {
                    map["version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("condition") {
                    self.condition = dict["condition"] as! String
                }
                if dict.keys.contains("group") {
                    self.group = dict["group"] as! String
                }
                if dict.keys.contains("items") {
                    var tmp : [DescribeGreyTagRouteResponseBody.Data.DubboRules.Items] = []
                    for v in dict["items"] as! [Any] {
                        var model = DescribeGreyTagRouteResponseBody.Data.DubboRules.Items()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.items = tmp
                }
                if dict.keys.contains("methodName") {
                    self.methodName = dict["methodName"] as! String
                }
                if dict.keys.contains("serviceName") {
                    self.serviceName = dict["serviceName"] as! String
                }
                if dict.keys.contains("version") {
                    self.version = dict["version"] as! String
                }
            }
        }
        public class ScRules : Tea.TeaModel {
            public class Items : Tea.TeaModel {
                public var cond: String?

                public var expr: String?

                public var index: Int32?

                public var name: String?

                public var operator_: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cond != nil {
                        map["cond"] = self.cond!
                    }
                    if self.expr != nil {
                        map["expr"] = self.expr!
                    }
                    if self.index != nil {
                        map["index"] = self.index!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.operator_ != nil {
                        map["operator"] = self.operator_!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("cond") {
                        self.cond = dict["cond"] as! String
                    }
                    if dict.keys.contains("expr") {
                        self.expr = dict["expr"] as! String
                    }
                    if dict.keys.contains("index") {
                        self.index = dict["index"] as! Int32
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("operator") {
                        self.operator_ = dict["operator"] as! String
                    }
                    if dict.keys.contains("type") {
                        self.type = dict["type"] as! String
                    }
                    if dict.keys.contains("value") {
                        self.value = dict["value"] as! String
                    }
                }
            }
            public var condition: String?

            public var items: [DescribeGreyTagRouteResponseBody.Data.ScRules.Items]?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["condition"] = self.condition!
                }
                if self.items != nil {
                    var tmp : [Any] = []
                    for k in self.items! {
                        tmp.append(k.toMap())
                    }
                    map["items"] = tmp
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("condition") {
                    self.condition = dict["condition"] as! String
                }
                if dict.keys.contains("items") {
                    var tmp : [DescribeGreyTagRouteResponseBody.Data.ScRules.Items] = []
                    for v in dict["items"] as! [Any] {
                        var model = DescribeGreyTagRouteResponseBody.Data.ScRules.Items()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.items = tmp
                }
                if dict.keys.contains("path") {
                    self.path = dict["path"] as! String
                }
            }
        }
        public var albRules: [DescribeGreyTagRouteResponseBody.Data.AlbRules]?

        public var appId: String?

        public var createTime: Int64?

        public var description_: String?

        public var dubboRules: [DescribeGreyTagRouteResponseBody.Data.DubboRules]?

        public var greyTagRouteId: Int64?

        public var name: String?

        public var scRules: [DescribeGreyTagRouteResponseBody.Data.ScRules]?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.albRules != nil {
                var tmp : [Any] = []
                for k in self.albRules! {
                    tmp.append(k.toMap())
                }
                map["AlbRules"] = tmp
            }
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dubboRules != nil {
                var tmp : [Any] = []
                for k in self.dubboRules! {
                    tmp.append(k.toMap())
                }
                map["DubboRules"] = tmp
            }
            if self.greyTagRouteId != nil {
                map["GreyTagRouteId"] = self.greyTagRouteId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.scRules != nil {
                var tmp : [Any] = []
                for k in self.scRules! {
                    tmp.append(k.toMap())
                }
                map["ScRules"] = tmp
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AlbRules") {
                var tmp : [DescribeGreyTagRouteResponseBody.Data.AlbRules] = []
                for v in dict["AlbRules"] as! [Any] {
                    var model = DescribeGreyTagRouteResponseBody.Data.AlbRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.albRules = tmp
            }
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DubboRules") {
                var tmp : [DescribeGreyTagRouteResponseBody.Data.DubboRules] = []
                for v in dict["DubboRules"] as! [Any] {
                    var model = DescribeGreyTagRouteResponseBody.Data.DubboRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dubboRules = tmp
            }
            if dict.keys.contains("GreyTagRouteId") {
                self.greyTagRouteId = dict["GreyTagRouteId"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ScRules") {
                var tmp : [DescribeGreyTagRouteResponseBody.Data.ScRules] = []
                for v in dict["ScRules"] as! [Any] {
                    var model = DescribeGreyTagRouteResponseBody.Data.ScRules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.scRules = tmp
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeGreyTagRouteResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeGreyTagRouteResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeGreyTagRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGreyTagRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeGreyTagRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIngressRequest : Tea.TeaModel {
    public var ingressId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ingressId != nil {
            map["IngressId"] = self.ingressId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IngressId") {
            self.ingressId = dict["IngressId"] as! Int64
        }
    }
}

public class DescribeIngressResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class DefaultRule : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var backendProtocol: String?

            public var containerPort: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.backendProtocol != nil {
                    map["BackendProtocol"] = self.backendProtocol!
                }
                if self.containerPort != nil {
                    map["ContainerPort"] = self.containerPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("BackendProtocol") {
                    self.backendProtocol = dict["BackendProtocol"] as! String
                }
                if dict.keys.contains("ContainerPort") {
                    self.containerPort = dict["ContainerPort"] as! Int32
                }
            }
        }
        public class Rules : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var backendProtocol: String?

            public var containerPort: Int32?

            public var domain: String?

            public var path: String?

            public var rewritePath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.backendProtocol != nil {
                    map["BackendProtocol"] = self.backendProtocol!
                }
                if self.containerPort != nil {
                    map["ContainerPort"] = self.containerPort!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.rewritePath != nil {
                    map["RewritePath"] = self.rewritePath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("BackendProtocol") {
                    self.backendProtocol = dict["BackendProtocol"] as! String
                }
                if dict.keys.contains("ContainerPort") {
                    self.containerPort = dict["ContainerPort"] as! Int32
                }
                if dict.keys.contains("Domain") {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("Path") {
                    self.path = dict["Path"] as! String
                }
                if dict.keys.contains("RewritePath") {
                    self.rewritePath = dict["RewritePath"] as! String
                }
            }
        }
        public var certId: String?

        public var certIds: String?

        public var defaultRule: DescribeIngressResponseBody.Data.DefaultRule?

        public var description_: String?

        public var id: Int64?

        public var listenerPort: Int32?

        public var listenerProtocol: String?

        public var loadBalanceType: String?

        public var name: String?

        public var namespaceId: String?

        public var rules: [DescribeIngressResponseBody.Data.Rules]?

        public var slbId: String?

        public var slbType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.defaultRule?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certId != nil {
                map["CertId"] = self.certId!
            }
            if self.certIds != nil {
                map["CertIds"] = self.certIds!
            }
            if self.defaultRule != nil {
                map["DefaultRule"] = self.defaultRule?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.listenerPort != nil {
                map["ListenerPort"] = self.listenerPort!
            }
            if self.listenerProtocol != nil {
                map["ListenerProtocol"] = self.listenerProtocol!
            }
            if self.loadBalanceType != nil {
                map["LoadBalanceType"] = self.loadBalanceType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.rules != nil {
                var tmp : [Any] = []
                for k in self.rules! {
                    tmp.append(k.toMap())
                }
                map["Rules"] = tmp
            }
            if self.slbId != nil {
                map["SlbId"] = self.slbId!
            }
            if self.slbType != nil {
                map["SlbType"] = self.slbType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CertId") {
                self.certId = dict["CertId"] as! String
            }
            if dict.keys.contains("CertIds") {
                self.certIds = dict["CertIds"] as! String
            }
            if dict.keys.contains("DefaultRule") {
                var model = DescribeIngressResponseBody.Data.DefaultRule()
                model.fromMap(dict["DefaultRule"] as! [String: Any])
                self.defaultRule = model
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("ListenerPort") {
                self.listenerPort = dict["ListenerPort"] as! Int32
            }
            if dict.keys.contains("ListenerProtocol") {
                self.listenerProtocol = dict["ListenerProtocol"] as! String
            }
            if dict.keys.contains("LoadBalanceType") {
                self.loadBalanceType = dict["LoadBalanceType"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NamespaceId") {
                self.namespaceId = dict["NamespaceId"] as! String
            }
            if dict.keys.contains("Rules") {
                var tmp : [DescribeIngressResponseBody.Data.Rules] = []
                for v in dict["Rules"] as! [Any] {
                    var model = DescribeIngressResponseBody.Data.Rules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.rules = tmp
            }
            if dict.keys.contains("SlbId") {
                self.slbId = dict["SlbId"] as! String
            }
            if dict.keys.contains("SlbType") {
                self.slbType = dict["SlbType"] as! String
            }
        }
    }
    public var code: String?

    public var data: DescribeIngressResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeIngressResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeIngressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIngressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIngressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceLogRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeInstanceLogResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeInstanceLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceSpecificationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var cpu: Int32?

        public var enable: Bool?

        public var id: Int32?

        public var memory: Int32?

        public var specInfo: String?

        public var version: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.specInfo != nil {
                map["SpecInfo"] = self.specInfo!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! Int32
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Int32
            }
            if dict.keys.contains("SpecInfo") {
                self.specInfo = dict["SpecInfo"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: [DescribeInstanceSpecificationsResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [DescribeInstanceSpecificationsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeInstanceSpecificationsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeInstanceSpecificationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceSpecificationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceSpecificationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeJobRequest : Tea.TeaModel {
    public var appId: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DescribeJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ConfigMapMountDesc : Tea.TeaModel {
            public var configMapId: Int64?

            public var configMapName: String?

            public var key: String?

            public var mountPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configMapId != nil {
                    map["ConfigMapId"] = self.configMapId!
                }
                if self.configMapName != nil {
                    map["ConfigMapName"] = self.configMapName!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigMapId") {
                    self.configMapId = dict["ConfigMapId"] as! Int64
                }
                if dict.keys.contains("ConfigMapName") {
                    self.configMapName = dict["ConfigMapName"] as! String
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("MountPath") {
                    self.mountPath = dict["MountPath"] as! String
                }
            }
        }
        public class MountDesc : Tea.TeaModel {
            public var mountPath: String?

            public var nasPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.nasPath != nil {
                    map["NasPath"] = self.nasPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MountPath") {
                    self.mountPath = dict["MountPath"] as! String
                }
                if dict.keys.contains("NasPath") {
                    self.nasPath = dict["NasPath"] as! String
                }
            }
        }
        public class OssMountDescs : Tea.TeaModel {
            public var bucketName: String?

            public var bucketPath: String?

            public var mountPath: String?

            public var readOnly: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucketName != nil {
                    map["bucketName"] = self.bucketName!
                }
                if self.bucketPath != nil {
                    map["bucketPath"] = self.bucketPath!
                }
                if self.mountPath != nil {
                    map["mountPath"] = self.mountPath!
                }
                if self.readOnly != nil {
                    map["readOnly"] = self.readOnly!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("bucketName") {
                    self.bucketName = dict["bucketName"] as! String
                }
                if dict.keys.contains("bucketPath") {
                    self.bucketPath = dict["bucketPath"] as! String
                }
                if dict.keys.contains("mountPath") {
                    self.mountPath = dict["mountPath"] as! String
                }
                if dict.keys.contains("readOnly") {
                    self.readOnly = dict["readOnly"] as! Bool
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var acrAssumeRoleArn: String?

        public var acrInstanceId: String?

        public var appDescription: String?

        public var appId: String?

        public var appName: String?

        public var backoffLimit: Int64?

        public var command: String?

        public var commandArgs: String?

        public var concurrencyPolicy: String?

        public var configMapMountDesc: [DescribeJobResponseBody.Data.ConfigMapMountDesc]?

        public var cpu: Int32?

        public var customHostAlias: String?

        public var edasContainerVersion: String?

        public var envs: String?

        public var imagePullSecrets: String?

        public var imageUrl: String?

        public var jarStartArgs: String?

        public var jarStartOptions: String?

        public var jdk: String?

        public var memory: Int32?

        public var mountDesc: [DescribeJobResponseBody.Data.MountDesc]?

        public var mountHost: String?

        public var namespaceId: String?

        public var nasConfigs: String?

        public var nasId: String?

        public var ossAkId: String?

        public var ossAkSecret: String?

        public var ossMountDescs: [DescribeJobResponseBody.Data.OssMountDescs]?

        public var packageType: String?

        public var packageUrl: String?

        public var packageVersion: String?

        public var phpConfig: String?

        public var phpConfigLocation: String?

        public var postStart: String?

        public var preStop: String?

        public var programmingLanguage: String?

        public var publicWebHookUrls: [String]?

        public var python: String?

        public var pythonModules: String?

        public var refAppId: String?

        public var refedAppIds: [String]?

        public var regionId: String?

        public var replicas: Int32?

        public var securityGroupId: String?

        public var slice: Bool?

        public var sliceEnvs: String?

        public var slsConfigs: String?

        public var suspend: Bool?

        public var tags: [DescribeJobResponseBody.Data.Tags]?

        public var terminationGracePeriodSeconds: Int32?

        public var timeout: Int64?

        public var timezone: String?

        public var tomcatConfig: String?

        public var triggerConfig: String?

        public var vSwitchId: String?

        public var vpcId: String?

        public var vpcWebHookUrls: [String]?

        public var warStartOptions: String?

        public var webContainer: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acrAssumeRoleArn != nil {
                map["AcrAssumeRoleArn"] = self.acrAssumeRoleArn!
            }
            if self.acrInstanceId != nil {
                map["AcrInstanceId"] = self.acrInstanceId!
            }
            if self.appDescription != nil {
                map["AppDescription"] = self.appDescription!
            }
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.backoffLimit != nil {
                map["BackoffLimit"] = self.backoffLimit!
            }
            if self.command != nil {
                map["Command"] = self.command!
            }
            if self.commandArgs != nil {
                map["CommandArgs"] = self.commandArgs!
            }
            if self.concurrencyPolicy != nil {
                map["ConcurrencyPolicy"] = self.concurrencyPolicy!
            }
            if self.configMapMountDesc != nil {
                var tmp : [Any] = []
                for k in self.configMapMountDesc! {
                    tmp.append(k.toMap())
                }
                map["ConfigMapMountDesc"] = tmp
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.customHostAlias != nil {
                map["CustomHostAlias"] = self.customHostAlias!
            }
            if self.edasContainerVersion != nil {
                map["EdasContainerVersion"] = self.edasContainerVersion!
            }
            if self.envs != nil {
                map["Envs"] = self.envs!
            }
            if self.imagePullSecrets != nil {
                map["ImagePullSecrets"] = self.imagePullSecrets!
            }
            if self.imageUrl != nil {
                map["ImageUrl"] = self.imageUrl!
            }
            if self.jarStartArgs != nil {
                map["JarStartArgs"] = self.jarStartArgs!
            }
            if self.jarStartOptions != nil {
                map["JarStartOptions"] = self.jarStartOptions!
            }
            if self.jdk != nil {
                map["Jdk"] = self.jdk!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.mountDesc != nil {
                var tmp : [Any] = []
                for k in self.mountDesc! {
                    tmp.append(k.toMap())
                }
                map["MountDesc"] = tmp
            }
            if self.mountHost != nil {
                map["MountHost"] = self.mountHost!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.nasConfigs != nil {
                map["NasConfigs"] = self.nasConfigs!
            }
            if self.nasId != nil {
                map["NasId"] = self.nasId!
            }
            if self.ossAkId != nil {
                map["OssAkId"] = self.ossAkId!
            }
            if self.ossAkSecret != nil {
                map["OssAkSecret"] = self.ossAkSecret!
            }
            if self.ossMountDescs != nil {
                var tmp : [Any] = []
                for k in self.ossMountDescs! {
                    tmp.append(k.toMap())
                }
                map["OssMountDescs"] = tmp
            }
            if self.packageType != nil {
                map["PackageType"] = self.packageType!
            }
            if self.packageUrl != nil {
                map["PackageUrl"] = self.packageUrl!
            }
            if self.packageVersion != nil {
                map["PackageVersion"] = self.packageVersion!
            }
            if self.phpConfig != nil {
                map["PhpConfig"] = self.phpConfig!
            }
            if self.phpConfigLocation != nil {
                map["PhpConfigLocation"] = self.phpConfigLocation!
            }
            if self.postStart != nil {
                map["PostStart"] = self.postStart!
            }
            if self.preStop != nil {
                map["PreStop"] = self.preStop!
            }
            if self.programmingLanguage != nil {
                map["ProgrammingLanguage"] = self.programmingLanguage!
            }
            if self.publicWebHookUrls != nil {
                map["PublicWebHookUrls"] = self.publicWebHookUrls!
            }
            if self.python != nil {
                map["Python"] = self.python!
            }
            if self.pythonModules != nil {
                map["PythonModules"] = self.pythonModules!
            }
            if self.refAppId != nil {
                map["RefAppId"] = self.refAppId!
            }
            if self.refedAppIds != nil {
                map["RefedAppIds"] = self.refedAppIds!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.replicas != nil {
                map["Replicas"] = self.replicas!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.slice != nil {
                map["Slice"] = self.slice!
            }
            if self.sliceEnvs != nil {
                map["SliceEnvs"] = self.sliceEnvs!
            }
            if self.slsConfigs != nil {
                map["SlsConfigs"] = self.slsConfigs!
            }
            if self.suspend != nil {
                map["Suspend"] = self.suspend!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.terminationGracePeriodSeconds != nil {
                map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout!
            }
            if self.timezone != nil {
                map["Timezone"] = self.timezone!
            }
            if self.tomcatConfig != nil {
                map["TomcatConfig"] = self.tomcatConfig!
            }
            if self.triggerConfig != nil {
                map["TriggerConfig"] = self.triggerConfig!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.vpcWebHookUrls != nil {
                map["VpcWebHookUrls"] = self.vpcWebHookUrls!
            }
            if self.warStartOptions != nil {
                map["WarStartOptions"] = self.warStartOptions!
            }
            if self.webContainer != nil {
                map["WebContainer"] = self.webContainer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcrAssumeRoleArn") {
                self.acrAssumeRoleArn = dict["AcrAssumeRoleArn"] as! String
            }
            if dict.keys.contains("AcrInstanceId") {
                self.acrInstanceId = dict["AcrInstanceId"] as! String
            }
            if dict.keys.contains("AppDescription") {
                self.appDescription = dict["AppDescription"] as! String
            }
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("AppName") {
                self.appName = dict["AppName"] as! String
            }
            if dict.keys.contains("BackoffLimit") {
                self.backoffLimit = dict["BackoffLimit"] as! Int64
            }
            if dict.keys.contains("Command") {
                self.command = dict["Command"] as! String
            }
            if dict.keys.contains("CommandArgs") {
                self.commandArgs = dict["CommandArgs"] as! String
            }
            if dict.keys.contains("ConcurrencyPolicy") {
                self.concurrencyPolicy = dict["ConcurrencyPolicy"] as! String
            }
            if dict.keys.contains("ConfigMapMountDesc") {
                var tmp : [DescribeJobResponseBody.Data.ConfigMapMountDesc] = []
                for v in dict["ConfigMapMountDesc"] as! [Any] {
                    var model = DescribeJobResponseBody.Data.ConfigMapMountDesc()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configMapMountDesc = tmp
            }
            if dict.keys.contains("Cpu") {
                self.cpu = dict["Cpu"] as! Int32
            }
            if dict.keys.contains("CustomHostAlias") {
                self.customHostAlias = dict["CustomHostAlias"] as! String
            }
            if dict.keys.contains("EdasContainerVersion") {
                self.edasContainerVersion = dict["EdasContainerVersion"] as! String
            }
            if dict.keys.contains("Envs") {
                self.envs = dict["Envs"] as! String
            }
            if dict.keys.contains("ImagePullSecrets") {
                self.imagePullSecrets = dict["ImagePullSecrets"] as! String
            }
            if dict.keys.contains("ImageUrl") {
                self.imageUrl = dict["ImageUrl"] as! String
            }
            if dict.keys.contains("JarStartArgs") {
                self.jarStartArgs = dict["JarStartArgs"] as! String
            }
            if dict.keys.contains("JarStartOptions") {
                self.jarStartOptions = dict["JarStartOptions"] as! String
            }
            if dict.keys.contains("Jdk") {
                self.jdk = dict["Jdk"] as! String
            }
            if dict.keys.contains("Memory") {
                self.memory = dict["Memory"] as! Int32
            }
            if dict.keys.contains("MountDesc") {
                var tmp : [DescribeJobResponseBody.Data.MountDesc] = []
                for v in dict["MountDesc"] as! [Any] {
                    var model = DescribeJobResponseBody.Data.MountDesc()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.mountDesc = tmp
            }
            if dict.keys.contains("MountHost") {
                self.mountHost = dict["MountHost"] as! String
            }
            if dict.keys.contains("NamespaceId") {
                self.namespaceId = dict["NamespaceId"] as! String
            }
            if dict.keys.contains("NasConfigs") {
                self.nasConfigs = dict["NasConfigs"] as! String
            }
            if dict.keys.contains("NasId") {
                self.nasId = dict["NasId"] as! String
            }
            if dict.keys.contains("OssAkId") {
                self.ossAkId = dict["OssAkId"] as! String
            }
            if dict.keys.contains("OssAkSecret") {
                self.ossAkSecret = dict["OssAkSecret"] as! String
            }
            if dict.keys.contains("OssMountDescs") {
                var tmp : [DescribeJobResponseBody.Data.OssMountDescs] = []
                for v in dict["OssMountDescs"] as! [Any] {
                    var model = DescribeJobResponseBody.Data.OssMountDescs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ossMountDescs = tmp
            }
            if dict.keys.contains("PackageType") {
                self.packageType = dict["PackageType"] as! String
            }
            if dict.keys.contains("PackageUrl") {
                self.packageUrl = dict["PackageUrl"] as! String
            }
            if dict.keys.contains("PackageVersion") {
                self.packageVersion = dict["PackageVersion"] as! String
            }
            if dict.keys.contains("PhpConfig") {
                self.phpConfig = dict["PhpConfig"] as! String
            }
            if dict.keys.contains("PhpConfigLocation") {
                self.phpConfigLocation = dict["PhpConfigLocation"] as! String
            }
            if dict.keys.contains("PostStart") {
                self.postStart = dict["PostStart"] as! String
            }
            if dict.keys.contains("PreStop") {
                self.preStop = dict["PreStop"] as! String
            }
            if dict.keys.contains("ProgrammingLanguage") {
                self.programmingLanguage = dict["ProgrammingLanguage"] as! String
            }
            if dict.keys.contains("PublicWebHookUrls") {
                self.publicWebHookUrls = dict["PublicWebHookUrls"] as! [String]
            }
            if dict.keys.contains("Python") {
                self.python = dict["Python"] as! String
            }
            if dict.keys.contains("PythonModules") {
                self.pythonModules = dict["PythonModules"] as! String
            }
            if dict.keys.contains("RefAppId") {
                self.refAppId = dict["RefAppId"] as! String
            }
            if dict.keys.contains("RefedAppIds") {
                self.refedAppIds = dict["RefedAppIds"] as! [String]
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Replicas") {
                self.replicas = dict["Replicas"] as! Int32
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("Slice") {
                self.slice = dict["Slice"] as! Bool
            }
            if dict.keys.contains("SliceEnvs") {
                self.sliceEnvs = dict["SliceEnvs"] as! String
            }
            if dict.keys.contains("SlsConfigs") {
                self.slsConfigs = dict["SlsConfigs"] as! String
            }
            if dict.keys.contains("Suspend") {
                self.suspend = dict["Suspend"] as! Bool
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeJobResponseBody.Data.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeJobResponseBody.Data.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TerminationGracePeriodSeconds") {
                self.terminationGracePeriodSeconds = dict["TerminationGracePeriodSeconds"] as! Int32
            }
            if dict.keys.contains("Timeout") {
                self.timeout = dict["Timeout"] as! Int64
            }
            if dict.keys.contains("Timezone") {
                self.timezone = dict["Timezone"] as! String
            }
            if dict.keys.contains("TomcatConfig") {
                self.tomcatConfig = dict["TomcatConfig"] as! String
            }
            if dict.keys.contains("TriggerConfig") {
                self.triggerConfig = dict["TriggerConfig"] as! String
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
            if dict.keys.contains("VpcWebHookUrls") {
                self.vpcWebHookUrls = dict["VpcWebHookUrls"] as! [String]
            }
            if dict.keys.contains("WarStartOptions") {
                self.warStartOptions = dict["WarStartOptions"] as! String
            }
            if dict.keys.contains("WebContainer") {
                self.webContainer = dict["WebContainer"] as! String
            }
        }
    }
    public var code: String?

    public var data: DescribeJobResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeJobHistoryRequest : Tea.TeaModel {
    public var appId: String?

    public var currentPage: Int64?

    public var pageSize: Int64?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class DescribeJobHistoryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Jobs : Tea.TeaModel {
            public var active: Int64?

            public var completionTime: Int64?

            public var failed: Int64?

            public var jobId: String?

            public var message: String?

            public var startTime: Int64?

            public var state: String?

            public var succeeded: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.active != nil {
                    map["Active"] = self.active!
                }
                if self.completionTime != nil {
                    map["CompletionTime"] = self.completionTime!
                }
                if self.failed != nil {
                    map["Failed"] = self.failed!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.succeeded != nil {
                    map["Succeeded"] = self.succeeded!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Active") {
                    self.active = dict["Active"] as! Int64
                }
                if dict.keys.contains("CompletionTime") {
                    self.completionTime = dict["CompletionTime"] as! Int64
                }
                if dict.keys.contains("Failed") {
                    self.failed = dict["Failed"] as! Int64
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Succeeded") {
                    self.succeeded = dict["Succeeded"] as! Int64
                }
            }
        }
        public var currentPage: Int64?

        public var jobs: [DescribeJobHistoryResponseBody.Data.Jobs]?

        public var pageSize: Int64?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.jobs != nil {
                var tmp : [Any] = []
                for k in self.jobs! {
                    tmp.append(k.toMap())
                }
                map["Jobs"] = tmp
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") {
                self.currentPage = dict["CurrentPage"] as! Int64
            }
            if dict.keys.contains("Jobs") {
                var tmp : [DescribeJobHistoryResponseBody.Data.Jobs] = []
                for v in dict["Jobs"] as! [Any] {
                    var model = DescribeJobHistoryResponseBody.Data.Jobs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.jobs = tmp
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeJobHistoryResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeJobHistoryResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeJobHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeJobHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeJobHistoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeJobStatusRequest : Tea.TeaModel {
    public var appId: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DescribeJobStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var active: Int64?

        public var completionTime: Int64?

        public var failed: Int64?

        public var jobId: String?

        public var message: String?

        public var startTime: Int64?

        public var state: String?

        public var succeeded: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.active != nil {
                map["Active"] = self.active!
            }
            if self.completionTime != nil {
                map["CompletionTime"] = self.completionTime!
            }
            if self.failed != nil {
                map["Failed"] = self.failed!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.succeeded != nil {
                map["Succeeded"] = self.succeeded!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Active") {
                self.active = dict["Active"] as! Int64
            }
            if dict.keys.contains("CompletionTime") {
                self.completionTime = dict["CompletionTime"] as! Int64
            }
            if dict.keys.contains("Failed") {
                self.failed = dict["Failed"] as! Int64
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Succeeded") {
                self.succeeded = dict["Succeeded"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeJobStatusResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeJobStatusResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeJobStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeJobStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeJobStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNamespaceRequest : Tea.TeaModel {
    public var nameSpaceShortId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nameSpaceShortId != nil {
            map["NameSpaceShortId"] = self.nameSpaceShortId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NameSpaceShortId") {
            self.nameSpaceShortId = dict["NameSpaceShortId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class DescribeNamespaceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var enableMicroRegistration: Bool?

        public var nameSpaceShortId: String?

        public var namespaceDescription: String?

        public var namespaceId: String?

        public var namespaceName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableMicroRegistration != nil {
                map["EnableMicroRegistration"] = self.enableMicroRegistration!
            }
            if self.nameSpaceShortId != nil {
                map["NameSpaceShortId"] = self.nameSpaceShortId!
            }
            if self.namespaceDescription != nil {
                map["NamespaceDescription"] = self.namespaceDescription!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.namespaceName != nil {
                map["NamespaceName"] = self.namespaceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableMicroRegistration") {
                self.enableMicroRegistration = dict["EnableMicroRegistration"] as! Bool
            }
            if dict.keys.contains("NameSpaceShortId") {
                self.nameSpaceShortId = dict["NameSpaceShortId"] as! String
            }
            if dict.keys.contains("NamespaceDescription") {
                self.namespaceDescription = dict["NamespaceDescription"] as! String
            }
            if dict.keys.contains("NamespaceId") {
                self.namespaceId = dict["NamespaceId"] as! String
            }
            if dict.keys.contains("NamespaceName") {
                self.namespaceName = dict["NamespaceName"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public var code: String?

    public var data: DescribeNamespaceResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeNamespaceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNamespaceListRequest : Tea.TeaModel {
    public var containCustom: Bool?

    public var hybridCloudExclude: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.containCustom != nil {
            map["ContainCustom"] = self.containCustom!
        }
        if self.hybridCloudExclude != nil {
            map["HybridCloudExclude"] = self.hybridCloudExclude!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContainCustom") {
            self.containCustom = dict["ContainCustom"] as! Bool
        }
        if dict.keys.contains("HybridCloudExclude") {
            self.hybridCloudExclude = dict["HybridCloudExclude"] as! Bool
        }
    }
}

public class DescribeNamespaceListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var agentInstall: String?

        public var current: Bool?

        public var custom: Bool?

        public var hybridCloudEnable: Bool?

        public var nameSpaceShortId: String?

        public var namespaceId: String?

        public var namespaceName: String?

        public var regionId: String?

        public var securityGroupId: String?

        public var vSwitchId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentInstall != nil {
                map["AgentInstall"] = self.agentInstall!
            }
            if self.current != nil {
                map["Current"] = self.current!
            }
            if self.custom != nil {
                map["Custom"] = self.custom!
            }
            if self.hybridCloudEnable != nil {
                map["HybridCloudEnable"] = self.hybridCloudEnable!
            }
            if self.nameSpaceShortId != nil {
                map["NameSpaceShortId"] = self.nameSpaceShortId!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.namespaceName != nil {
                map["NamespaceName"] = self.namespaceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentInstall") {
                self.agentInstall = dict["AgentInstall"] as! String
            }
            if dict.keys.contains("Current") {
                self.current = dict["Current"] as! Bool
            }
            if dict.keys.contains("Custom") {
                self.custom = dict["Custom"] as! Bool
            }
            if dict.keys.contains("HybridCloudEnable") {
                self.hybridCloudEnable = dict["HybridCloudEnable"] as! Bool
            }
            if dict.keys.contains("NameSpaceShortId") {
                self.nameSpaceShortId = dict["NameSpaceShortId"] as! String
            }
            if dict.keys.contains("NamespaceId") {
                self.namespaceId = dict["NamespaceId"] as! String
            }
            if dict.keys.contains("NamespaceName") {
                self.namespaceName = dict["NamespaceName"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var code: String?

    public var data: [DescribeNamespaceListResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [DescribeNamespaceListResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = DescribeNamespaceListResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeNamespaceListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNamespaceListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNamespaceListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNamespaceResourcesRequest : Tea.TeaModel {
    public var nameSpaceShortId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nameSpaceShortId != nil {
            map["NameSpaceShortId"] = self.nameSpaceShortId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NameSpaceShortId") {
            self.nameSpaceShortId = dict["NameSpaceShortId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class DescribeNamespaceResourcesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appCount: Int64?

        public var belongRegion: String?

        public var description_: String?

        public var jumpServerAppId: String?

        public var jumpServerIp: String?

        public var lastChangeOrderId: String?

        public var lastChangeOrderRunning: Bool?

        public var lastChangeOrderStatus: String?

        public var nameSpaceShortId: String?

        public var namespaceId: String?

        public var namespaceName: String?

        public var notificationExpired: Bool?

        public var securityGroupId: String?

        public var tenantId: String?

        public var userId: String?

        public var vSwitchId: String?

        public var vSwitchName: String?

        public var vpcId: String?

        public var vpcName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appCount != nil {
                map["AppCount"] = self.appCount!
            }
            if self.belongRegion != nil {
                map["BelongRegion"] = self.belongRegion!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.jumpServerAppId != nil {
                map["JumpServerAppId"] = self.jumpServerAppId!
            }
            if self.jumpServerIp != nil {
                map["JumpServerIp"] = self.jumpServerIp!
            }
            if self.lastChangeOrderId != nil {
                map["LastChangeOrderId"] = self.lastChangeOrderId!
            }
            if self.lastChangeOrderRunning != nil {
                map["LastChangeOrderRunning"] = self.lastChangeOrderRunning!
            }
            if self.lastChangeOrderStatus != nil {
                map["LastChangeOrderStatus"] = self.lastChangeOrderStatus!
            }
            if self.nameSpaceShortId != nil {
                map["NameSpaceShortId"] = self.nameSpaceShortId!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.namespaceName != nil {
                map["NamespaceName"] = self.namespaceName!
            }
            if self.notificationExpired != nil {
                map["NotificationExpired"] = self.notificationExpired!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vSwitchName != nil {
                map["VSwitchName"] = self.vSwitchName!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.vpcName != nil {
                map["VpcName"] = self.vpcName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppCount") {
                self.appCount = dict["AppCount"] as! Int64
            }
            if dict.keys.contains("BelongRegion") {
                self.belongRegion = dict["BelongRegion"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("JumpServerAppId") {
                self.jumpServerAppId = dict["JumpServerAppId"] as! String
            }
            if dict.keys.contains("JumpServerIp") {
                self.jumpServerIp = dict["JumpServerIp"] as! String
            }
            if dict.keys.contains("LastChangeOrderId") {
                self.lastChangeOrderId = dict["LastChangeOrderId"] as! String
            }
            if dict.keys.contains("LastChangeOrderRunning") {
                self.lastChangeOrderRunning = dict["LastChangeOrderRunning"] as! Bool
            }
            if dict.keys.contains("LastChangeOrderStatus") {
                self.lastChangeOrderStatus = dict["LastChangeOrderStatus"] as! String
            }
            if dict.keys.contains("NameSpaceShortId") {
                self.nameSpaceShortId = dict["NameSpaceShortId"] as! String
            }
            if dict.keys.contains("NamespaceId") {
                self.namespaceId = dict["NamespaceId"] as! String
            }
            if dict.keys.contains("NamespaceName") {
                self.namespaceName = dict["NamespaceName"] as! String
            }
            if dict.keys.contains("NotificationExpired") {
                self.notificationExpired = dict["NotificationExpired"] as! Bool
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VSwitchName") {
                self.vSwitchName = dict["VSwitchName"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
            if dict.keys.contains("VpcName") {
                self.vpcName = dict["VpcName"] as! String
            }
        }
    }
    public var code: String?

    public var data: DescribeNamespaceResourcesResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeNamespaceResourcesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeNamespaceResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNamespaceResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNamespaceResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNamespacesRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class DescribeNamespacesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Namespaces : Tea.TeaModel {
            public var accessKey: String?

            public var addressServerHost: String?

            public var nameSpaceShortId: String?

            public var namespaceDescription: String?

            public var namespaceId: String?

            public var namespaceName: String?

            public var regionId: String?

            public var secretKey: String?

            public var tenantId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessKey != nil {
                    map["AccessKey"] = self.accessKey!
                }
                if self.addressServerHost != nil {
                    map["AddressServerHost"] = self.addressServerHost!
                }
                if self.nameSpaceShortId != nil {
                    map["NameSpaceShortId"] = self.nameSpaceShortId!
                }
                if self.namespaceDescription != nil {
                    map["NamespaceDescription"] = self.namespaceDescription!
                }
                if self.namespaceId != nil {
                    map["NamespaceId"] = self.namespaceId!
                }
                if self.namespaceName != nil {
                    map["NamespaceName"] = self.namespaceName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.secretKey != nil {
                    map["SecretKey"] = self.secretKey!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessKey") {
                    self.accessKey = dict["AccessKey"] as! String
                }
                if dict.keys.contains("AddressServerHost") {
                    self.addressServerHost = dict["AddressServerHost"] as! String
                }
                if dict.keys.contains("NameSpaceShortId") {
                    self.nameSpaceShortId = dict["NameSpaceShortId"] as! String
                }
                if dict.keys.contains("NamespaceDescription") {
                    self.namespaceDescription = dict["NamespaceDescription"] as! String
                }
                if dict.keys.contains("NamespaceId") {
                    self.namespaceId = dict["NamespaceId"] as! String
                }
                if dict.keys.contains("NamespaceName") {
                    self.namespaceName = dict["NamespaceName"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SecretKey") {
                    self.secretKey = dict["SecretKey"] as! String
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! String
                }
            }
        }
        public var currentPage: Int32?

        public var namespaces: [DescribeNamespacesResponseBody.Data.Namespaces]?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.namespaces != nil {
                var tmp : [Any] = []
                for k in self.namespaces! {
                    tmp.append(k.toMap())
                }
                map["Namespaces"] = tmp
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("Namespaces") {
                var tmp : [DescribeNamespacesResponseBody.Data.Namespaces] = []
                for v in dict["Namespaces"] as! [Any] {
                    var model = DescribeNamespacesResponseBody.Data.Namespaces()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.namespaces = tmp
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: DescribeNamespacesResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeNamespacesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeNamespacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNamespacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNamespacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePipelineRequest : Tea.TeaModel {
    public var pipelineId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PipelineId") {
            self.pipelineId = dict["PipelineId"] as! String
        }
    }
}

public class DescribePipelineResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class StageList : Tea.TeaModel {
            public class TaskList : Tea.TeaModel {
                public var errorCode: String?

                public var errorIgnore: Int32?

                public var errorMessage: String?

                public var message: String?

                public var showManualIgnore: Bool?

                public var stageId: String?

                public var status: Int32?

                public var taskId: String?

                public var taskName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorIgnore != nil {
                        map["ErrorIgnore"] = self.errorIgnore!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.showManualIgnore != nil {
                        map["ShowManualIgnore"] = self.showManualIgnore!
                    }
                    if self.stageId != nil {
                        map["StageId"] = self.stageId!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.taskId != nil {
                        map["TaskId"] = self.taskId!
                    }
                    if self.taskName != nil {
                        map["TaskName"] = self.taskName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorIgnore") {
                        self.errorIgnore = dict["ErrorIgnore"] as! Int32
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("Message") {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("ShowManualIgnore") {
                        self.showManualIgnore = dict["ShowManualIgnore"] as! Bool
                    }
                    if dict.keys.contains("StageId") {
                        self.stageId = dict["StageId"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! Int32
                    }
                    if dict.keys.contains("TaskId") {
                        self.taskId = dict["TaskId"] as! String
                    }
                    if dict.keys.contains("TaskName") {
                        self.taskName = dict["TaskName"] as! String
                    }
                }
            }
            public var executorType: Int32?

            public var stageId: String?

            public var stageName: String?

            public var status: Int32?

            public var taskList: [DescribePipelineResponseBody.Data.StageList.TaskList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.executorType != nil {
                    map["ExecutorType"] = self.executorType!
                }
                if self.stageId != nil {
                    map["StageId"] = self.stageId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskList != nil {
                    var tmp : [Any] = []
                    for k in self.taskList! {
                        tmp.append(k.toMap())
                    }
                    map["TaskList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ExecutorType") {
                    self.executorType = dict["ExecutorType"] as! Int32
                }
                if dict.keys.contains("StageId") {
                    self.stageId = dict["StageId"] as! String
                }
                if dict.keys.contains("StageName") {
                    self.stageName = dict["StageName"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("TaskList") {
                    var tmp : [DescribePipelineResponseBody.Data.StageList.TaskList] = []
                    for v in dict["TaskList"] as! [Any] {
                        var model = DescribePipelineResponseBody.Data.StageList.TaskList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.taskList = tmp
                }
            }
        }
        public var coStatus: String?

        public var currentStageId: String?

        public var nextPipelineId: String?

        public var pipelineId: String?

        public var pipelineName: String?

        public var pipelineStatus: Int32?

        public var showBatch: Bool?

        public var stageList: [DescribePipelineResponseBody.Data.StageList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.coStatus != nil {
                map["CoStatus"] = self.coStatus!
            }
            if self.currentStageId != nil {
                map["CurrentStageId"] = self.currentStageId!
            }
            if self.nextPipelineId != nil {
                map["NextPipelineId"] = self.nextPipelineId!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.pipelineName != nil {
                map["PipelineName"] = self.pipelineName!
            }
            if self.pipelineStatus != nil {
                map["PipelineStatus"] = self.pipelineStatus!
            }
            if self.showBatch != nil {
                map["ShowBatch"] = self.showBatch!
            }
            if self.stageList != nil {
                var tmp : [Any] = []
                for k in self.stageList! {
                    tmp.append(k.toMap())
                }
                map["StageList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CoStatus") {
                self.coStatus = dict["CoStatus"] as! String
            }
            if dict.keys.contains("CurrentStageId") {
                self.currentStageId = dict["CurrentStageId"] as! String
            }
            if dict.keys.contains("NextPipelineId") {
                self.nextPipelineId = dict["NextPipelineId"] as! String
            }
            if dict.keys.contains("PipelineId") {
                self.pipelineId = dict["PipelineId"] as! String
            }
            if dict.keys.contains("PipelineName") {
                self.pipelineName = dict["PipelineName"] as! String
            }
            if dict.keys.contains("PipelineStatus") {
                self.pipelineStatus = dict["PipelineStatus"] as! Int32
            }
            if dict.keys.contains("ShowBatch") {
                self.showBatch = dict["ShowBatch"] as! Bool
            }
            if dict.keys.contains("StageList") {
                var tmp : [DescribePipelineResponseBody.Data.StageList] = []
                for v in dict["StageList"] as! [Any] {
                    var model = DescribePipelineResponseBody.Data.StageList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.stageList = tmp
            }
        }
    }
    public var code: String?

    public var data: DescribePipelineResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribePipelineResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public class Region : Tea.TeaModel {
            public class RecommendZones : Tea.TeaModel {
                public var recommendZone: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.recommendZone != nil {
                        map["RecommendZone"] = self.recommendZone!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RecommendZone") {
                        self.recommendZone = dict["RecommendZone"] as! [String]
                    }
                }
            }
            public var localName: String?

            public var recommendZones: DescribeRegionsResponseBody.Regions.Region.RecommendZones?

            public var regionEndpoint: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.recommendZones?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localName != nil {
                    map["LocalName"] = self.localName!
                }
                if self.recommendZones != nil {
                    map["RecommendZones"] = self.recommendZones?.toMap()
                }
                if self.regionEndpoint != nil {
                    map["RegionEndpoint"] = self.regionEndpoint!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LocalName") {
                    self.localName = dict["LocalName"] as! String
                }
                if dict.keys.contains("RecommendZones") {
                    var model = DescribeRegionsResponseBody.Regions.Region.RecommendZones()
                    model.fromMap(dict["RecommendZones"] as! [String: Any])
                    self.recommendZones = model
                }
                if dict.keys.contains("RegionEndpoint") {
                    self.regionEndpoint = dict["RegionEndpoint"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var region: [DescribeRegionsResponseBody.Regions.Region]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.region != nil {
                var tmp : [Any] = []
                for k in self.region! {
                    tmp.append(k.toMap())
                }
                map["Region"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Region") {
                var tmp : [DescribeRegionsResponseBody.Regions.Region] = []
                for v in dict["Region"] as! [Any] {
                    var model = DescribeRegionsResponseBody.Regions.Region()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.region = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var regions: DescribeRegionsResponseBody.Regions?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.regions != nil {
            map["Regions"] = self.regions?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Regions") {
            var model = DescribeRegionsResponseBody.Regions()
            model.fromMap(dict["Regions"] as! [String: Any])
            self.regions = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRegionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSecretRequest : Tea.TeaModel {
    public var namespaceId: String?

    public var secretId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.secretId != nil {
            map["SecretId"] = self.secretId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("SecretId") {
            self.secretId = dict["SecretId"] as! Int64
        }
    }
}

public class DescribeSecretResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RelateApps : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
            }
        }
        public var createTime: Int64?

        public var namespaceId: String?

        public var relateApps: [DescribeSecretResponseBody.Data.RelateApps]?

        public var secretData: [String: String]?

        public var secretId: Int64?

        public var secretName: String?

        public var secretType: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.relateApps != nil {
                var tmp : [Any] = []
                for k in self.relateApps! {
                    tmp.append(k.toMap())
                }
                map["RelateApps"] = tmp
            }
            if self.secretData != nil {
                map["SecretData"] = self.secretData!
            }
            if self.secretId != nil {
                map["SecretId"] = self.secretId!
            }
            if self.secretName != nil {
                map["SecretName"] = self.secretName!
            }
            if self.secretType != nil {
                map["SecretType"] = self.secretType!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("NamespaceId") {
                self.namespaceId = dict["NamespaceId"] as! String
            }
            if dict.keys.contains("RelateApps") {
                var tmp : [DescribeSecretResponseBody.Data.RelateApps] = []
                for v in dict["RelateApps"] as! [Any] {
                    var model = DescribeSecretResponseBody.Data.RelateApps()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.relateApps = tmp
            }
            if dict.keys.contains("SecretData") {
                self.secretData = dict["SecretData"] as! [String: String]
            }
            if dict.keys.contains("SecretId") {
                self.secretId = dict["SecretId"] as! Int64
            }
            if dict.keys.contains("SecretName") {
                self.secretName = dict["SecretName"] as! String
            }
            if dict.keys.contains("SecretType") {
                self.secretType = dict["SecretType"] as! String
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeSecretResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeSecretResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DescribeSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSecretResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var scalingRuleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ScalingRuleName") {
            self.scalingRuleName = dict["ScalingRuleName"] as! String
        }
    }
}

public class DisableApplicationScalingRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class DisableApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableApplicationScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var scalingRuleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ScalingRuleName") {
            self.scalingRuleName = dict["ScalingRuleName"] as! String
        }
    }
}

public class EnableApplicationScalingRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class EnableApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableApplicationScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExecJobRequest : Tea.TeaModel {
    public var appId: String?

    public var command: String?

    public var commandArgs: String?

    public var envs: String?

    public var eventId: String?

    public var jarStartArgs: String?

    public var jarStartOptions: String?

    public var replicas: String?

    public var time: String?

    public var warStartOptions: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.commandArgs != nil {
            map["CommandArgs"] = self.commandArgs!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.jarStartArgs != nil {
            map["JarStartArgs"] = self.jarStartArgs!
        }
        if self.jarStartOptions != nil {
            map["JarStartOptions"] = self.jarStartOptions!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.time != nil {
            map["Time"] = self.time!
        }
        if self.warStartOptions != nil {
            map["WarStartOptions"] = self.warStartOptions!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Command") {
            self.command = dict["Command"] as! String
        }
        if dict.keys.contains("CommandArgs") {
            self.commandArgs = dict["CommandArgs"] as! String
        }
        if dict.keys.contains("Envs") {
            self.envs = dict["Envs"] as! String
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("JarStartArgs") {
            self.jarStartArgs = dict["JarStartArgs"] as! String
        }
        if dict.keys.contains("JarStartOptions") {
            self.jarStartOptions = dict["JarStartOptions"] as! String
        }
        if dict.keys.contains("Replicas") {
            self.replicas = dict["Replicas"] as! String
        }
        if dict.keys.contains("Time") {
            self.time = dict["Time"] as! String
        }
        if dict.keys.contains("WarStartOptions") {
            self.warStartOptions = dict["WarStartOptions"] as! String
        }
    }
}

public class ExecJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var msg: String?

        public var success: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.msg != nil {
                map["Msg"] = self.msg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! String
            }
            if dict.keys.contains("Data") {
                self.data = dict["Data"] as! String
            }
            if dict.keys.contains("Msg") {
                self.msg = dict["Msg"] as! String
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! String
            }
        }
    }
    public var code: String?

    public var data: ExecJobResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ExecJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class ExecJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExecJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetArmsTopNMetricRequest : Tea.TeaModel {
    public var appSource: String?

    public var cpuStrategy: String?

    public var endTime: Int64?

    public var limit: Int64?

    public var orderBy: String?

    public var regionId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appSource != nil {
            map["AppSource"] = self.appSource!
        }
        if self.cpuStrategy != nil {
            map["CpuStrategy"] = self.cpuStrategy!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppSource") {
            self.appSource = dict["AppSource"] as! String
        }
        if dict.keys.contains("CpuStrategy") {
            self.cpuStrategy = dict["CpuStrategy"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! Int64
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class GetArmsTopNMetricResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var count: Int64?

        public var error: Int64?

        public var name: String?

        public var regionId: String?

        public var rt: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.error != nil {
                map["Error"] = self.error!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.rt != nil {
                map["Rt"] = self.rt!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("Count") {
                self.count = dict["Count"] as! Int64
            }
            if dict.keys.contains("Error") {
                self.error = dict["Error"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Rt") {
                self.rt = dict["Rt"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: [GetArmsTopNMetricResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [GetArmsTopNMetricResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetArmsTopNMetricResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetArmsTopNMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetArmsTopNMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetArmsTopNMetricResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAvailabilityMetricRequest : Tea.TeaModel {
    public var appSource: String?

    public var cpuStrategy: String?

    public var limit: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appSource != nil {
            map["AppSource"] = self.appSource!
        }
        if self.cpuStrategy != nil {
            map["CpuStrategy"] = self.cpuStrategy!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppSource") {
            self.appSource = dict["AppSource"] as! String
        }
        if dict.keys.contains("CpuStrategy") {
            self.cpuStrategy = dict["CpuStrategy"] as! String
        }
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetAvailabilityMetricResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var enableAutoscale: Int64?

        public var errorInstances: Int64?

        public var instances: Int64?

        public var name: String?

        public var regionId: String?

        public var runnings: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.enableAutoscale != nil {
                map["EnableAutoscale"] = self.enableAutoscale!
            }
            if self.errorInstances != nil {
                map["ErrorInstances"] = self.errorInstances!
            }
            if self.instances != nil {
                map["Instances"] = self.instances!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.runnings != nil {
                map["Runnings"] = self.runnings!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("EnableAutoscale") {
                self.enableAutoscale = dict["EnableAutoscale"] as! Int64
            }
            if dict.keys.contains("ErrorInstances") {
                self.errorInstances = dict["ErrorInstances"] as! Int64
            }
            if dict.keys.contains("Instances") {
                self.instances = dict["Instances"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Runnings") {
                self.runnings = dict["Runnings"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: [GetAvailabilityMetricResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [GetAvailabilityMetricResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetAvailabilityMetricResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAvailabilityMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAvailabilityMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAvailabilityMetricResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetChangeOrderMetricRequest : Tea.TeaModel {
    public var appSource: String?

    public var cpuStrategy: String?

    public var createTime: String?

    public var limit: Int64?

    public var orderBy: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appSource != nil {
            map["AppSource"] = self.appSource!
        }
        if self.cpuStrategy != nil {
            map["CpuStrategy"] = self.cpuStrategy!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppSource") {
            self.appSource = dict["AppSource"] as! String
        }
        if dict.keys.contains("CpuStrategy") {
            self.cpuStrategy = dict["CpuStrategy"] as! String
        }
        if dict.keys.contains("CreateTime") {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! Int64
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetChangeOrderMetricResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var error: Int64?

        public var errorPercent: Double?

        public var name: String?

        public var regionId: String?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.error != nil {
                map["Error"] = self.error!
            }
            if self.errorPercent != nil {
                map["ErrorPercent"] = self.errorPercent!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("Error") {
                self.error = dict["Error"] as! Int64
            }
            if dict.keys.contains("ErrorPercent") {
                self.errorPercent = dict["ErrorPercent"] as! Double
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: [GetChangeOrderMetricResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [GetChangeOrderMetricResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetChangeOrderMetricResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetChangeOrderMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetChangeOrderMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetChangeOrderMetricResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetScaleAppMetricRequest : Tea.TeaModel {
    public var appSource: String?

    public var cpuStrategy: String?

    public var limit: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appSource != nil {
            map["AppSource"] = self.appSource!
        }
        if self.cpuStrategy != nil {
            map["CpuStrategy"] = self.cpuStrategy!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppSource") {
            self.appSource = dict["AppSource"] as! String
        }
        if dict.keys.contains("CpuStrategy") {
            self.cpuStrategy = dict["CpuStrategy"] as! String
        }
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetScaleAppMetricResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var maxReplicas: Int64?

        public var name: String?

        public var regionId: String?

        public var runnings: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.maxReplicas != nil {
                map["MaxReplicas"] = self.maxReplicas!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.runnings != nil {
                map["Runnings"] = self.runnings!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("MaxReplicas") {
                self.maxReplicas = dict["MaxReplicas"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("Runnings") {
                self.runnings = dict["Runnings"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: [GetScaleAppMetricResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [GetScaleAppMetricResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetScaleAppMetricResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetScaleAppMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetScaleAppMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetScaleAppMetricResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetWarningEventMetricRequest : Tea.TeaModel {
    public var appSource: String?

    public var cpuStrategy: String?

    public var endTime: Int64?

    public var limit: Int64?

    public var regionId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appSource != nil {
            map["AppSource"] = self.appSource!
        }
        if self.cpuStrategy != nil {
            map["CpuStrategy"] = self.cpuStrategy!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppSource") {
            self.appSource = dict["AppSource"] as! String
        }
        if dict.keys.contains("CpuStrategy") {
            self.cpuStrategy = dict["CpuStrategy"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Limit") {
            self.limit = dict["Limit"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class GetWarningEventMetricResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var name: String?

        public var regionId: String?

        public var warningCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.warningCount != nil {
                map["WarningCount"] = self.warningCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("WarningCount") {
                self.warningCount = dict["WarningCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: [GetWarningEventMetricResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [GetWarningEventMetricResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetWarningEventMetricResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetWarningEventMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWarningEventMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetWarningEventMetricResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAppEventsRequest : Tea.TeaModel {
    public var appId: String?

    public var currentPage: Int32?

    public var eventType: String?

    public var namespace: String?

    public var objectKind: String?

    public var objectName: String?

    public var pageSize: Int32?

    public var reason: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.objectKind != nil {
            map["ObjectKind"] = self.objectKind!
        }
        if self.objectName != nil {
            map["ObjectName"] = self.objectName!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("EventType") {
            self.eventType = dict["EventType"] as! String
        }
        if dict.keys.contains("Namespace") {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("ObjectKind") {
            self.objectKind = dict["ObjectKind"] as! String
        }
        if dict.keys.contains("ObjectName") {
            self.objectName = dict["ObjectName"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Reason") {
            self.reason = dict["Reason"] as! String
        }
    }
}

public class ListAppEventsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AppEventEntity : Tea.TeaModel {
            public var eventType: String?

            public var firstTimestamp: String?

            public var lastTimestamp: String?

            public var message: String?

            public var objectKind: String?

            public var objectName: String?

            public var reason: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventType != nil {
                    map["EventType"] = self.eventType!
                }
                if self.firstTimestamp != nil {
                    map["FirstTimestamp"] = self.firstTimestamp!
                }
                if self.lastTimestamp != nil {
                    map["LastTimestamp"] = self.lastTimestamp!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.objectKind != nil {
                    map["ObjectKind"] = self.objectKind!
                }
                if self.objectName != nil {
                    map["ObjectName"] = self.objectName!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EventType") {
                    self.eventType = dict["EventType"] as! String
                }
                if dict.keys.contains("FirstTimestamp") {
                    self.firstTimestamp = dict["FirstTimestamp"] as! String
                }
                if dict.keys.contains("LastTimestamp") {
                    self.lastTimestamp = dict["LastTimestamp"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("ObjectKind") {
                    self.objectKind = dict["ObjectKind"] as! String
                }
                if dict.keys.contains("ObjectName") {
                    self.objectName = dict["ObjectName"] as! String
                }
                if dict.keys.contains("Reason") {
                    self.reason = dict["Reason"] as! String
                }
            }
        }
        public var appEventEntity: [ListAppEventsResponseBody.Data.AppEventEntity]?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appEventEntity != nil {
                var tmp : [Any] = []
                for k in self.appEventEntity! {
                    tmp.append(k.toMap())
                }
                map["AppEventEntity"] = tmp
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppEventEntity") {
                var tmp : [ListAppEventsResponseBody.Data.AppEventEntity] = []
                for v in dict["AppEventEntity"] as! [Any] {
                    var model = ListAppEventsResponseBody.Data.AppEventEntity()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.appEventEntity = tmp
            }
            if dict.keys.contains("CurrentPage") {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListAppEventsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListAppEventsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAppEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAppEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAppEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAppServicesPageRequest : Tea.TeaModel {
    public var appId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var serviceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ServiceType") {
            self.serviceType = dict["ServiceType"] as! String
        }
    }
}

public class ListAppServicesPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var edasAppId: String?

            public var edasAppName: String?

            public var group: String?

            public var instanceNum: Int64?

            public var serviceName: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.edasAppId != nil {
                    map["EdasAppId"] = self.edasAppId!
                }
                if self.edasAppName != nil {
                    map["EdasAppName"] = self.edasAppName!
                }
                if self.group != nil {
                    map["Group"] = self.group!
                }
                if self.instanceNum != nil {
                    map["InstanceNum"] = self.instanceNum!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EdasAppId") {
                    self.edasAppId = dict["EdasAppId"] as! String
                }
                if dict.keys.contains("EdasAppName") {
                    self.edasAppName = dict["EdasAppName"] as! String
                }
                if dict.keys.contains("Group") {
                    self.group = dict["Group"] as! String
                }
                if dict.keys.contains("InstanceNum") {
                    self.instanceNum = dict["InstanceNum"] as! Int64
                }
                if dict.keys.contains("ServiceName") {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! String
                }
            }
        }
        public var currentPage: String?

        public var pageNumber: String?

        public var pageSize: String?

        public var result: [ListAppServicesPageResponseBody.Data.Result]?

        public var totalSize: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") {
                self.currentPage = dict["CurrentPage"] as! String
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! String
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! String
            }
            if dict.keys.contains("Result") {
                var tmp : [ListAppServicesPageResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListAppServicesPageResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListAppServicesPageResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListAppServicesPageResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListAppServicesPageResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class ListAppServicesPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAppServicesPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAppServicesPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAppVersionsRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class ListAppVersionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var buildPackageUrl: String?

        public var createTime: String?

        public var id: String?

        public var type: String?

        public var warUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.buildPackageUrl != nil {
                map["BuildPackageUrl"] = self.buildPackageUrl!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.warUrl != nil {
                map["WarUrl"] = self.warUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BuildPackageUrl") {
                self.buildPackageUrl = dict["BuildPackageUrl"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("WarUrl") {
                self.warUrl = dict["WarUrl"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListAppVersionsResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListAppVersionsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListAppVersionsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAppVersionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAppVersionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAppVersionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListApplicationsRequest : Tea.TeaModel {
    public var appName: String?

    public var appSource: String?

    public var currentPage: Int32?

    public var fieldType: String?

    public var fieldValue: String?

    public var namespaceId: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var reverse: Bool?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.appSource != nil {
            map["AppSource"] = self.appSource!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.fieldType != nil {
            map["FieldType"] = self.fieldType!
        }
        if self.fieldValue != nil {
            map["FieldValue"] = self.fieldValue!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.reverse != nil {
            map["Reverse"] = self.reverse!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("AppSource") {
            self.appSource = dict["AppSource"] as! String
        }
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("FieldType") {
            self.fieldType = dict["FieldType"] as! String
        }
        if dict.keys.contains("FieldValue") {
            self.fieldValue = dict["FieldValue"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Reverse") {
            self.reverse = dict["Reverse"] as! Bool
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
    }
}

public class ListApplicationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Applications : Tea.TeaModel {
            public class Children : Tea.TeaModel {
                public class Tags : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var appDeletingStatus: Bool?

                public var appDescription: String?

                public var appId: String?

                public var appName: String?

                public var baseAppId: String?

                public var cpu: Int32?

                public var instances: Int32?

                public var mem: Int32?

                public var mseEnabled: Bool?

                public var namespaceId: String?

                public var programmingLanguage: String?

                public var regionId: String?

                public var runningInstances: Int32?

                public var scaleRuleEnabled: Bool?

                public var scaleRuleType: String?

                public var tags: [ListApplicationsResponseBody.Data.Applications.Children.Tags]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appDeletingStatus != nil {
                        map["AppDeletingStatus"] = self.appDeletingStatus!
                    }
                    if self.appDescription != nil {
                        map["AppDescription"] = self.appDescription!
                    }
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appName != nil {
                        map["AppName"] = self.appName!
                    }
                    if self.baseAppId != nil {
                        map["BaseAppId"] = self.baseAppId!
                    }
                    if self.cpu != nil {
                        map["Cpu"] = self.cpu!
                    }
                    if self.instances != nil {
                        map["Instances"] = self.instances!
                    }
                    if self.mem != nil {
                        map["Mem"] = self.mem!
                    }
                    if self.mseEnabled != nil {
                        map["MseEnabled"] = self.mseEnabled!
                    }
                    if self.namespaceId != nil {
                        map["NamespaceId"] = self.namespaceId!
                    }
                    if self.programmingLanguage != nil {
                        map["ProgrammingLanguage"] = self.programmingLanguage!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    if self.runningInstances != nil {
                        map["RunningInstances"] = self.runningInstances!
                    }
                    if self.scaleRuleEnabled != nil {
                        map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
                    }
                    if self.scaleRuleType != nil {
                        map["ScaleRuleType"] = self.scaleRuleType!
                    }
                    if self.tags != nil {
                        var tmp : [Any] = []
                        for k in self.tags! {
                            tmp.append(k.toMap())
                        }
                        map["Tags"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AppDeletingStatus") {
                        self.appDeletingStatus = dict["AppDeletingStatus"] as! Bool
                    }
                    if dict.keys.contains("AppDescription") {
                        self.appDescription = dict["AppDescription"] as! String
                    }
                    if dict.keys.contains("AppId") {
                        self.appId = dict["AppId"] as! String
                    }
                    if dict.keys.contains("AppName") {
                        self.appName = dict["AppName"] as! String
                    }
                    if dict.keys.contains("BaseAppId") {
                        self.baseAppId = dict["BaseAppId"] as! String
                    }
                    if dict.keys.contains("Cpu") {
                        self.cpu = dict["Cpu"] as! Int32
                    }
                    if dict.keys.contains("Instances") {
                        self.instances = dict["Instances"] as! Int32
                    }
                    if dict.keys.contains("Mem") {
                        self.mem = dict["Mem"] as! Int32
                    }
                    if dict.keys.contains("MseEnabled") {
                        self.mseEnabled = dict["MseEnabled"] as! Bool
                    }
                    if dict.keys.contains("NamespaceId") {
                        self.namespaceId = dict["NamespaceId"] as! String
                    }
                    if dict.keys.contains("ProgrammingLanguage") {
                        self.programmingLanguage = dict["ProgrammingLanguage"] as! String
                    }
                    if dict.keys.contains("RegionId") {
                        self.regionId = dict["RegionId"] as! String
                    }
                    if dict.keys.contains("RunningInstances") {
                        self.runningInstances = dict["RunningInstances"] as! Int32
                    }
                    if dict.keys.contains("ScaleRuleEnabled") {
                        self.scaleRuleEnabled = dict["ScaleRuleEnabled"] as! Bool
                    }
                    if dict.keys.contains("ScaleRuleType") {
                        self.scaleRuleType = dict["ScaleRuleType"] as! String
                    }
                    if dict.keys.contains("Tags") {
                        var tmp : [ListApplicationsResponseBody.Data.Applications.Children.Tags] = []
                        for v in dict["Tags"] as! [Any] {
                            var model = ListApplicationsResponseBody.Data.Applications.Children.Tags()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tags = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var appDeletingStatus: Bool?

            public var appDescription: String?

            public var appId: String?

            public var appName: String?

            public var baseAppId: String?

            public var children: [ListApplicationsResponseBody.Data.Applications.Children]?

            public var cpu: Int32?

            public var instances: Int32?

            public var mem: Int32?

            public var mseEnabled: Bool?

            public var mseNamespaceId: String?

            public var namespaceId: String?

            public var programmingLanguage: String?

            public var regionId: String?

            public var runningInstances: Int32?

            public var tags: [ListApplicationsResponseBody.Data.Applications.Tags]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appDeletingStatus != nil {
                    map["AppDeletingStatus"] = self.appDeletingStatus!
                }
                if self.appDescription != nil {
                    map["AppDescription"] = self.appDescription!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.baseAppId != nil {
                    map["BaseAppId"] = self.baseAppId!
                }
                if self.children != nil {
                    var tmp : [Any] = []
                    for k in self.children! {
                        tmp.append(k.toMap())
                    }
                    map["Children"] = tmp
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.instances != nil {
                    map["Instances"] = self.instances!
                }
                if self.mem != nil {
                    map["Mem"] = self.mem!
                }
                if self.mseEnabled != nil {
                    map["MseEnabled"] = self.mseEnabled!
                }
                if self.mseNamespaceId != nil {
                    map["MseNamespaceId"] = self.mseNamespaceId!
                }
                if self.namespaceId != nil {
                    map["NamespaceId"] = self.namespaceId!
                }
                if self.programmingLanguage != nil {
                    map["ProgrammingLanguage"] = self.programmingLanguage!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.runningInstances != nil {
                    map["RunningInstances"] = self.runningInstances!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppDeletingStatus") {
                    self.appDeletingStatus = dict["AppDeletingStatus"] as! Bool
                }
                if dict.keys.contains("AppDescription") {
                    self.appDescription = dict["AppDescription"] as! String
                }
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("BaseAppId") {
                    self.baseAppId = dict["BaseAppId"] as! String
                }
                if dict.keys.contains("Children") {
                    var tmp : [ListApplicationsResponseBody.Data.Applications.Children] = []
                    for v in dict["Children"] as! [Any] {
                        var model = ListApplicationsResponseBody.Data.Applications.Children()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.children = tmp
                }
                if dict.keys.contains("Cpu") {
                    self.cpu = dict["Cpu"] as! Int32
                }
                if dict.keys.contains("Instances") {
                    self.instances = dict["Instances"] as! Int32
                }
                if dict.keys.contains("Mem") {
                    self.mem = dict["Mem"] as! Int32
                }
                if dict.keys.contains("MseEnabled") {
                    self.mseEnabled = dict["MseEnabled"] as! Bool
                }
                if dict.keys.contains("MseNamespaceId") {
                    self.mseNamespaceId = dict["MseNamespaceId"] as! String
                }
                if dict.keys.contains("NamespaceId") {
                    self.namespaceId = dict["NamespaceId"] as! String
                }
                if dict.keys.contains("ProgrammingLanguage") {
                    self.programmingLanguage = dict["ProgrammingLanguage"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RunningInstances") {
                    self.runningInstances = dict["RunningInstances"] as! Int32
                }
                if dict.keys.contains("Tags") {
                    var tmp : [ListApplicationsResponseBody.Data.Applications.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = ListApplicationsResponseBody.Data.Applications.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
            }
        }
        public var applications: [ListApplicationsResponseBody.Data.Applications]?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applications != nil {
                var tmp : [Any] = []
                for k in self.applications! {
                    tmp.append(k.toMap())
                }
                map["Applications"] = tmp
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Applications") {
                var tmp : [ListApplicationsResponseBody.Data.Applications] = []
                for v in dict["Applications"] as! [Any] {
                    var model = ListApplicationsResponseBody.Data.Applications()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.applications = tmp
            }
            if dict.keys.contains("CurrentPage") {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: String?

    public var currentPage: Int32?

    public var data: ListApplicationsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalSize != nil {
            map["TotalSize"] = self.totalSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ListApplicationsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalSize") {
            self.totalSize = dict["TotalSize"] as! Int32
        }
    }
}

public class ListApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListApplicationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListChangeOrdersRequest : Tea.TeaModel {
    public var appId: String?

    public var coStatus: String?

    public var coType: String?

    public var currentPage: Int32?

    public var key: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.coStatus != nil {
            map["CoStatus"] = self.coStatus!
        }
        if self.coType != nil {
            map["CoType"] = self.coType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CoStatus") {
            self.coStatus = dict["CoStatus"] as! String
        }
        if dict.keys.contains("CoType") {
            self.coType = dict["CoType"] as! String
        }
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListChangeOrdersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ChangeOrderList : Tea.TeaModel {
            public var appId: String?

            public var batchCount: Int32?

            public var batchType: String?

            public var changeOrderId: String?

            public var coType: String?

            public var coTypeCode: String?

            public var createTime: String?

            public var createUserId: String?

            public var description_: String?

            public var finishTime: String?

            public var groupId: String?

            public var source: String?

            public var status: Int32?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.batchCount != nil {
                    map["BatchCount"] = self.batchCount!
                }
                if self.batchType != nil {
                    map["BatchType"] = self.batchType!
                }
                if self.changeOrderId != nil {
                    map["ChangeOrderId"] = self.changeOrderId!
                }
                if self.coType != nil {
                    map["CoType"] = self.coType!
                }
                if self.coTypeCode != nil {
                    map["CoTypeCode"] = self.coTypeCode!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUserId != nil {
                    map["CreateUserId"] = self.createUserId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("BatchCount") {
                    self.batchCount = dict["BatchCount"] as! Int32
                }
                if dict.keys.contains("BatchType") {
                    self.batchType = dict["BatchType"] as! String
                }
                if dict.keys.contains("ChangeOrderId") {
                    self.changeOrderId = dict["ChangeOrderId"] as! String
                }
                if dict.keys.contains("CoType") {
                    self.coType = dict["CoType"] as! String
                }
                if dict.keys.contains("CoTypeCode") {
                    self.coTypeCode = dict["CoTypeCode"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateUserId") {
                    self.createUserId = dict["CreateUserId"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var changeOrderList: [ListChangeOrdersResponseBody.Data.ChangeOrderList]?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderList != nil {
                var tmp : [Any] = []
                for k in self.changeOrderList! {
                    tmp.append(k.toMap())
                }
                map["ChangeOrderList"] = tmp
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderList") {
                var tmp : [ListChangeOrdersResponseBody.Data.ChangeOrderList] = []
                for v in dict["ChangeOrderList"] as! [Any] {
                    var model = ListChangeOrdersResponseBody.Data.ChangeOrderList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.changeOrderList = tmp
            }
            if dict.keys.contains("CurrentPage") {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListChangeOrdersResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListChangeOrdersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class ListChangeOrdersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListChangeOrdersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListChangeOrdersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListConsumedServicesRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class ListConsumedServicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var group2Ip: String?

        public var groups: [String]?

        public var ips: [String]?

        public var name: String?

        public var type: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.group2Ip != nil {
                map["Group2Ip"] = self.group2Ip!
            }
            if self.groups != nil {
                map["Groups"] = self.groups!
            }
            if self.ips != nil {
                map["Ips"] = self.ips!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("Group2Ip") {
                self.group2Ip = dict["Group2Ip"] as! String
            }
            if dict.keys.contains("Groups") {
                self.groups = dict["Groups"] as! [String]
            }
            if dict.keys.contains("Ips") {
                self.ips = dict["Ips"] as! [String]
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListConsumedServicesResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListConsumedServicesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListConsumedServicesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class ListConsumedServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConsumedServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListConsumedServicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGreyTagRouteRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class ListGreyTagRouteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class AlbRules : Tea.TeaModel {
                public class Items : Tea.TeaModel {
                    public var cond: String?

                    public var expr: String?

                    public var index: Int32?

                    public var name: String?

                    public var operator_: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cond != nil {
                            map["cond"] = self.cond!
                        }
                        if self.expr != nil {
                            map["expr"] = self.expr!
                        }
                        if self.index != nil {
                            map["index"] = self.index!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        if self.operator_ != nil {
                            map["operator"] = self.operator_!
                        }
                        if self.type != nil {
                            map["type"] = self.type!
                        }
                        if self.value != nil {
                            map["value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("cond") {
                            self.cond = dict["cond"] as! String
                        }
                        if dict.keys.contains("expr") {
                            self.expr = dict["expr"] as! String
                        }
                        if dict.keys.contains("index") {
                            self.index = dict["index"] as! Int32
                        }
                        if dict.keys.contains("name") {
                            self.name = dict["name"] as! String
                        }
                        if dict.keys.contains("operator") {
                            self.operator_ = dict["operator"] as! String
                        }
                        if dict.keys.contains("type") {
                            self.type = dict["type"] as! String
                        }
                        if dict.keys.contains("value") {
                            self.value = dict["value"] as! String
                        }
                    }
                }
                public var condition: String?

                public var ingressId: String?

                public var items: [ListGreyTagRouteResponseBody.Data.Result.AlbRules.Items]?

                public var serviceName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.condition != nil {
                        map["condition"] = self.condition!
                    }
                    if self.ingressId != nil {
                        map["ingressId"] = self.ingressId!
                    }
                    if self.items != nil {
                        var tmp : [Any] = []
                        for k in self.items! {
                            tmp.append(k.toMap())
                        }
                        map["items"] = tmp
                    }
                    if self.serviceName != nil {
                        map["serviceName"] = self.serviceName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("condition") {
                        self.condition = dict["condition"] as! String
                    }
                    if dict.keys.contains("ingressId") {
                        self.ingressId = dict["ingressId"] as! String
                    }
                    if dict.keys.contains("items") {
                        var tmp : [ListGreyTagRouteResponseBody.Data.Result.AlbRules.Items] = []
                        for v in dict["items"] as! [Any] {
                            var model = ListGreyTagRouteResponseBody.Data.Result.AlbRules.Items()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.items = tmp
                    }
                    if dict.keys.contains("serviceName") {
                        self.serviceName = dict["serviceName"] as! String
                    }
                }
            }
            public class DubboRules : Tea.TeaModel {
                public class Items : Tea.TeaModel {
                    public var cond: String?

                    public var expr: String?

                    public var index: Int32?

                    public var name: String?

                    public var operator_: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cond != nil {
                            map["cond"] = self.cond!
                        }
                        if self.expr != nil {
                            map["expr"] = self.expr!
                        }
                        if self.index != nil {
                            map["index"] = self.index!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        if self.operator_ != nil {
                            map["operator"] = self.operator_!
                        }
                        if self.type != nil {
                            map["type"] = self.type!
                        }
                        if self.value != nil {
                            map["value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("cond") {
                            self.cond = dict["cond"] as! String
                        }
                        if dict.keys.contains("expr") {
                            self.expr = dict["expr"] as! String
                        }
                        if dict.keys.contains("index") {
                            self.index = dict["index"] as! Int32
                        }
                        if dict.keys.contains("name") {
                            self.name = dict["name"] as! String
                        }
                        if dict.keys.contains("operator") {
                            self.operator_ = dict["operator"] as! String
                        }
                        if dict.keys.contains("type") {
                            self.type = dict["type"] as! String
                        }
                        if dict.keys.contains("value") {
                            self.value = dict["value"] as! String
                        }
                    }
                }
                public var condition: String?

                public var group: String?

                public var items: [ListGreyTagRouteResponseBody.Data.Result.DubboRules.Items]?

                public var methodName: String?

                public var serviceName: String?

                public var version: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.condition != nil {
                        map["condition"] = self.condition!
                    }
                    if self.group != nil {
                        map["group"] = self.group!
                    }
                    if self.items != nil {
                        var tmp : [Any] = []
                        for k in self.items! {
                            tmp.append(k.toMap())
                        }
                        map["items"] = tmp
                    }
                    if self.methodName != nil {
                        map["methodName"] = self.methodName!
                    }
                    if self.serviceName != nil {
                        map["serviceName"] = self.serviceName!
                    }
                    if self.version != nil {
                        map["version"] = self.version!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("condition") {
                        self.condition = dict["condition"] as! String
                    }
                    if dict.keys.contains("group") {
                        self.group = dict["group"] as! String
                    }
                    if dict.keys.contains("items") {
                        var tmp : [ListGreyTagRouteResponseBody.Data.Result.DubboRules.Items] = []
                        for v in dict["items"] as! [Any] {
                            var model = ListGreyTagRouteResponseBody.Data.Result.DubboRules.Items()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.items = tmp
                    }
                    if dict.keys.contains("methodName") {
                        self.methodName = dict["methodName"] as! String
                    }
                    if dict.keys.contains("serviceName") {
                        self.serviceName = dict["serviceName"] as! String
                    }
                    if dict.keys.contains("version") {
                        self.version = dict["version"] as! String
                    }
                }
            }
            public class ScRules : Tea.TeaModel {
                public class Items : Tea.TeaModel {
                    public var cond: String?

                    public var expr: String?

                    public var index: Int32?

                    public var name: String?

                    public var operator_: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cond != nil {
                            map["cond"] = self.cond!
                        }
                        if self.expr != nil {
                            map["expr"] = self.expr!
                        }
                        if self.index != nil {
                            map["index"] = self.index!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        if self.operator_ != nil {
                            map["operator"] = self.operator_!
                        }
                        if self.type != nil {
                            map["type"] = self.type!
                        }
                        if self.value != nil {
                            map["value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("cond") {
                            self.cond = dict["cond"] as! String
                        }
                        if dict.keys.contains("expr") {
                            self.expr = dict["expr"] as! String
                        }
                        if dict.keys.contains("index") {
                            self.index = dict["index"] as! Int32
                        }
                        if dict.keys.contains("name") {
                            self.name = dict["name"] as! String
                        }
                        if dict.keys.contains("operator") {
                            self.operator_ = dict["operator"] as! String
                        }
                        if dict.keys.contains("type") {
                            self.type = dict["type"] as! String
                        }
                        if dict.keys.contains("value") {
                            self.value = dict["value"] as! String
                        }
                    }
                }
                public var condition: String?

                public var items: [ListGreyTagRouteResponseBody.Data.Result.ScRules.Items]?

                public var path: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.condition != nil {
                        map["condition"] = self.condition!
                    }
                    if self.items != nil {
                        var tmp : [Any] = []
                        for k in self.items! {
                            tmp.append(k.toMap())
                        }
                        map["items"] = tmp
                    }
                    if self.path != nil {
                        map["path"] = self.path!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("condition") {
                        self.condition = dict["condition"] as! String
                    }
                    if dict.keys.contains("items") {
                        var tmp : [ListGreyTagRouteResponseBody.Data.Result.ScRules.Items] = []
                        for v in dict["items"] as! [Any] {
                            var model = ListGreyTagRouteResponseBody.Data.Result.ScRules.Items()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.items = tmp
                    }
                    if dict.keys.contains("path") {
                        self.path = dict["path"] as! String
                    }
                }
            }
            public var albRules: [ListGreyTagRouteResponseBody.Data.Result.AlbRules]?

            public var createTime: Int64?

            public var description_: String?

            public var dubboRules: [ListGreyTagRouteResponseBody.Data.Result.DubboRules]?

            public var greyTagRouteId: Int64?

            public var name: String?

            public var scRules: [ListGreyTagRouteResponseBody.Data.Result.ScRules]?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.albRules != nil {
                    var tmp : [Any] = []
                    for k in self.albRules! {
                        tmp.append(k.toMap())
                    }
                    map["AlbRules"] = tmp
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.dubboRules != nil {
                    var tmp : [Any] = []
                    for k in self.dubboRules! {
                        tmp.append(k.toMap())
                    }
                    map["DubboRules"] = tmp
                }
                if self.greyTagRouteId != nil {
                    map["GreyTagRouteId"] = self.greyTagRouteId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.scRules != nil {
                    var tmp : [Any] = []
                    for k in self.scRules! {
                        tmp.append(k.toMap())
                    }
                    map["ScRules"] = tmp
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlbRules") {
                    var tmp : [ListGreyTagRouteResponseBody.Data.Result.AlbRules] = []
                    for v in dict["AlbRules"] as! [Any] {
                        var model = ListGreyTagRouteResponseBody.Data.Result.AlbRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.albRules = tmp
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DubboRules") {
                    var tmp : [ListGreyTagRouteResponseBody.Data.Result.DubboRules] = []
                    for v in dict["DubboRules"] as! [Any] {
                        var model = ListGreyTagRouteResponseBody.Data.Result.DubboRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.dubboRules = tmp
                }
                if dict.keys.contains("GreyTagRouteId") {
                    self.greyTagRouteId = dict["GreyTagRouteId"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ScRules") {
                    var tmp : [ListGreyTagRouteResponseBody.Data.Result.ScRules] = []
                    for v in dict["ScRules"] as! [Any] {
                        var model = ListGreyTagRouteResponseBody.Data.Result.ScRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.scRules = tmp
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
            }
        }
        public var currentPage: Int32?

        public var pageSize: Int32?

        public var result: [ListGreyTagRouteResponseBody.Data.Result]?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Result") {
                var tmp : [ListGreyTagRouteResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListGreyTagRouteResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: ListGreyTagRouteResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListGreyTagRouteResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class ListGreyTagRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGreyTagRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGreyTagRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIngressesRequest : Tea.TeaModel {
    public var appId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class ListIngressesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class IngressList : Tea.TeaModel {
            public var certId: String?

            public var certIds: String?

            public var description_: String?

            public var id: Int64?

            public var listenerPort: String?

            public var listenerProtocol: String?

            public var loadBalanceType: String?

            public var mseGatewayId: String?

            public var mseGatewayPort: String?

            public var mseGatewayProtocol: String?

            public var name: String?

            public var namespaceId: String?

            public var slbId: String?

            public var slbType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.certId != nil {
                    map["CertId"] = self.certId!
                }
                if self.certIds != nil {
                    map["CertIds"] = self.certIds!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.listenerPort != nil {
                    map["ListenerPort"] = self.listenerPort!
                }
                if self.listenerProtocol != nil {
                    map["ListenerProtocol"] = self.listenerProtocol!
                }
                if self.loadBalanceType != nil {
                    map["LoadBalanceType"] = self.loadBalanceType!
                }
                if self.mseGatewayId != nil {
                    map["MseGatewayId"] = self.mseGatewayId!
                }
                if self.mseGatewayPort != nil {
                    map["MseGatewayPort"] = self.mseGatewayPort!
                }
                if self.mseGatewayProtocol != nil {
                    map["MseGatewayProtocol"] = self.mseGatewayProtocol!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespaceId != nil {
                    map["NamespaceId"] = self.namespaceId!
                }
                if self.slbId != nil {
                    map["SlbId"] = self.slbId!
                }
                if self.slbType != nil {
                    map["SlbType"] = self.slbType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CertId") {
                    self.certId = dict["CertId"] as! String
                }
                if dict.keys.contains("CertIds") {
                    self.certIds = dict["CertIds"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("ListenerPort") {
                    self.listenerPort = dict["ListenerPort"] as! String
                }
                if dict.keys.contains("ListenerProtocol") {
                    self.listenerProtocol = dict["ListenerProtocol"] as! String
                }
                if dict.keys.contains("LoadBalanceType") {
                    self.loadBalanceType = dict["LoadBalanceType"] as! String
                }
                if dict.keys.contains("MseGatewayId") {
                    self.mseGatewayId = dict["MseGatewayId"] as! String
                }
                if dict.keys.contains("MseGatewayPort") {
                    self.mseGatewayPort = dict["MseGatewayPort"] as! String
                }
                if dict.keys.contains("MseGatewayProtocol") {
                    self.mseGatewayProtocol = dict["MseGatewayProtocol"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NamespaceId") {
                    self.namespaceId = dict["NamespaceId"] as! String
                }
                if dict.keys.contains("SlbId") {
                    self.slbId = dict["SlbId"] as! String
                }
                if dict.keys.contains("SlbType") {
                    self.slbType = dict["SlbType"] as! String
                }
            }
        }
        public var ingressList: [ListIngressesResponseBody.Data.IngressList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ingressList != nil {
                var tmp : [Any] = []
                for k in self.ingressList! {
                    tmp.append(k.toMap())
                }
                map["IngressList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IngressList") {
                var tmp : [ListIngressesResponseBody.Data.IngressList] = []
                for v in dict["IngressList"] as! [Any] {
                    var model = ListIngressesResponseBody.Data.IngressList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ingressList = tmp
            }
        }
    }
    public var code: String?

    public var data: ListIngressesResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListIngressesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class ListIngressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIngressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListIngressesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListJobsRequest : Tea.TeaModel {
    public var appName: String?

    public var currentPage: Int32?

    public var fieldType: String?

    public var fieldValue: String?

    public var namespaceId: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var reverse: Bool?

    public var tags: String?

    public var workload: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.fieldType != nil {
            map["FieldType"] = self.fieldType!
        }
        if self.fieldValue != nil {
            map["FieldValue"] = self.fieldValue!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.reverse != nil {
            map["Reverse"] = self.reverse!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.workload != nil {
            map["Workload"] = self.workload!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("FieldType") {
            self.fieldType = dict["FieldType"] as! String
        }
        if dict.keys.contains("FieldValue") {
            self.fieldValue = dict["FieldValue"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Reverse") {
            self.reverse = dict["Reverse"] as! Bool
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("Workload") {
            self.workload = dict["Workload"] as! String
        }
    }
}

public class ListJobsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Applications : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var active: Int64?

            public var appDescription: String?

            public var appId: String?

            public var appName: String?

            public var completionTime: Int64?

            public var cpu: Int32?

            public var failed: Int64?

            public var lastChangeorderState: String?

            public var lastJobState: String?

            public var lastStartTime: Int64?

            public var mem: Int32?

            public var message: String?

            public var namespaceId: String?

            public var regionId: String?

            public var succeeded: Int64?

            public var suspend: Bool?

            public var tags: [ListJobsResponseBody.Data.Applications.Tags]?

            public var triggerConfig: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.active != nil {
                    map["Active"] = self.active!
                }
                if self.appDescription != nil {
                    map["AppDescription"] = self.appDescription!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.completionTime != nil {
                    map["CompletionTime"] = self.completionTime!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.failed != nil {
                    map["Failed"] = self.failed!
                }
                if self.lastChangeorderState != nil {
                    map["LastChangeorderState"] = self.lastChangeorderState!
                }
                if self.lastJobState != nil {
                    map["LastJobState"] = self.lastJobState!
                }
                if self.lastStartTime != nil {
                    map["LastStartTime"] = self.lastStartTime!
                }
                if self.mem != nil {
                    map["Mem"] = self.mem!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.namespaceId != nil {
                    map["NamespaceId"] = self.namespaceId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.succeeded != nil {
                    map["Succeeded"] = self.succeeded!
                }
                if self.suspend != nil {
                    map["Suspend"] = self.suspend!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.triggerConfig != nil {
                    map["TriggerConfig"] = self.triggerConfig!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Active") {
                    self.active = dict["Active"] as! Int64
                }
                if dict.keys.contains("AppDescription") {
                    self.appDescription = dict["AppDescription"] as! String
                }
                if dict.keys.contains("AppId") {
                    self.appId = dict["AppId"] as! String
                }
                if dict.keys.contains("AppName") {
                    self.appName = dict["AppName"] as! String
                }
                if dict.keys.contains("CompletionTime") {
                    self.completionTime = dict["CompletionTime"] as! Int64
                }
                if dict.keys.contains("Cpu") {
                    self.cpu = dict["Cpu"] as! Int32
                }
                if dict.keys.contains("Failed") {
                    self.failed = dict["Failed"] as! Int64
                }
                if dict.keys.contains("LastChangeorderState") {
                    self.lastChangeorderState = dict["LastChangeorderState"] as! String
                }
                if dict.keys.contains("LastJobState") {
                    self.lastJobState = dict["LastJobState"] as! String
                }
                if dict.keys.contains("LastStartTime") {
                    self.lastStartTime = dict["LastStartTime"] as! Int64
                }
                if dict.keys.contains("Mem") {
                    self.mem = dict["Mem"] as! Int32
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("NamespaceId") {
                    self.namespaceId = dict["NamespaceId"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Succeeded") {
                    self.succeeded = dict["Succeeded"] as! Int64
                }
                if dict.keys.contains("Suspend") {
                    self.suspend = dict["Suspend"] as! Bool
                }
                if dict.keys.contains("Tags") {
                    var tmp : [ListJobsResponseBody.Data.Applications.Tags] = []
                    for v in dict["Tags"] as! [Any] {
                        var model = ListJobsResponseBody.Data.Applications.Tags()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tags = tmp
                }
                if dict.keys.contains("TriggerConfig") {
                    self.triggerConfig = dict["TriggerConfig"] as! String
                }
            }
        }
        public var applications: [ListJobsResponseBody.Data.Applications]?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applications != nil {
                var tmp : [Any] = []
                for k in self.applications! {
                    tmp.append(k.toMap())
                }
                map["Applications"] = tmp
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Applications") {
                var tmp : [ListJobsResponseBody.Data.Applications] = []
                for v in dict["Applications"] as! [Any] {
                    var model = ListJobsResponseBody.Data.Applications()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.applications = tmp
            }
            if dict.keys.contains("CurrentPage") {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: String?

    public var currentPage: Int32?

    public var data: ListJobsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalSize != nil {
            map["TotalSize"] = self.totalSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Data") {
            var model = ListJobsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TotalSize") {
            self.totalSize = dict["TotalSize"] as! Int32
        }
    }
}

public class ListJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLogConfigsRequest : Tea.TeaModel {
    public var appId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListLogConfigsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class LogConfigs : Tea.TeaModel {
            public var configName: String?

            public var createTime: String?

            public var logDir: String?

            public var logType: String?

            public var regionId: String?

            public var slsLogStore: String?

            public var slsProject: String?

            public var storeType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configName != nil {
                    map["ConfigName"] = self.configName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.logDir != nil {
                    map["LogDir"] = self.logDir!
                }
                if self.logType != nil {
                    map["LogType"] = self.logType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.slsLogStore != nil {
                    map["SlsLogStore"] = self.slsLogStore!
                }
                if self.slsProject != nil {
                    map["SlsProject"] = self.slsProject!
                }
                if self.storeType != nil {
                    map["StoreType"] = self.storeType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigName") {
                    self.configName = dict["ConfigName"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("LogDir") {
                    self.logDir = dict["LogDir"] as! String
                }
                if dict.keys.contains("LogType") {
                    self.logType = dict["LogType"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SlsLogStore") {
                    self.slsLogStore = dict["SlsLogStore"] as! String
                }
                if dict.keys.contains("SlsProject") {
                    self.slsProject = dict["SlsProject"] as! String
                }
                if dict.keys.contains("StoreType") {
                    self.storeType = dict["StoreType"] as! String
                }
            }
        }
        public var currentPage: Int32?

        public var logConfigs: [ListLogConfigsResponseBody.Data.LogConfigs]?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.logConfigs != nil {
                var tmp : [Any] = []
                for k in self.logConfigs! {
                    tmp.append(k.toMap())
                }
                map["LogConfigs"] = tmp
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CurrentPage") {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("LogConfigs") {
                var tmp : [ListLogConfigsResponseBody.Data.LogConfigs] = []
                for v in dict["LogConfigs"] as! [Any] {
                    var model = ListLogConfigsResponseBody.Data.LogConfigs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logConfigs = tmp
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListLogConfigsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListLogConfigsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class ListLogConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLogConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLogConfigsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNamespaceChangeOrdersRequest : Tea.TeaModel {
    public var coStatus: String?

    public var coType: String?

    public var currentPage: Int32?

    public var key: String?

    public var namespaceId: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coStatus != nil {
            map["CoStatus"] = self.coStatus!
        }
        if self.coType != nil {
            map["CoType"] = self.coType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoStatus") {
            self.coStatus = dict["CoStatus"] as! String
        }
        if dict.keys.contains("CoType") {
            self.coType = dict["CoType"] as! String
        }
        if dict.keys.contains("CurrentPage") {
            self.currentPage = dict["CurrentPage"] as! Int32
        }
        if dict.keys.contains("Key") {
            self.key = dict["Key"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListNamespaceChangeOrdersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ChangeOrderList : Tea.TeaModel {
            public var batchCount: Int32?

            public var batchType: String?

            public var changeOrderId: String?

            public var coType: String?

            public var coTypeCode: String?

            public var createTime: String?

            public var createUserId: String?

            public var description_: String?

            public var finishTime: String?

            public var groupId: String?

            public var namespaceId: String?

            public var pipelines: String?

            public var source: String?

            public var status: Int32?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.batchCount != nil {
                    map["BatchCount"] = self.batchCount!
                }
                if self.batchType != nil {
                    map["BatchType"] = self.batchType!
                }
                if self.changeOrderId != nil {
                    map["ChangeOrderId"] = self.changeOrderId!
                }
                if self.coType != nil {
                    map["CoType"] = self.coType!
                }
                if self.coTypeCode != nil {
                    map["CoTypeCode"] = self.coTypeCode!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUserId != nil {
                    map["CreateUserId"] = self.createUserId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.namespaceId != nil {
                    map["NamespaceId"] = self.namespaceId!
                }
                if self.pipelines != nil {
                    map["Pipelines"] = self.pipelines!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BatchCount") {
                    self.batchCount = dict["BatchCount"] as! Int32
                }
                if dict.keys.contains("BatchType") {
                    self.batchType = dict["BatchType"] as! String
                }
                if dict.keys.contains("ChangeOrderId") {
                    self.changeOrderId = dict["ChangeOrderId"] as! String
                }
                if dict.keys.contains("CoType") {
                    self.coType = dict["CoType"] as! String
                }
                if dict.keys.contains("CoTypeCode") {
                    self.coTypeCode = dict["CoTypeCode"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreateUserId") {
                    self.createUserId = dict["CreateUserId"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("FinishTime") {
                    self.finishTime = dict["FinishTime"] as! String
                }
                if dict.keys.contains("GroupId") {
                    self.groupId = dict["GroupId"] as! String
                }
                if dict.keys.contains("NamespaceId") {
                    self.namespaceId = dict["NamespaceId"] as! String
                }
                if dict.keys.contains("Pipelines") {
                    self.pipelines = dict["Pipelines"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! Int32
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var changeOrderList: [ListNamespaceChangeOrdersResponseBody.Data.ChangeOrderList]?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderList != nil {
                var tmp : [Any] = []
                for k in self.changeOrderList! {
                    tmp.append(k.toMap())
                }
                map["ChangeOrderList"] = tmp
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderList") {
                var tmp : [ListNamespaceChangeOrdersResponseBody.Data.ChangeOrderList] = []
                for v in dict["ChangeOrderList"] as! [Any] {
                    var model = ListNamespaceChangeOrdersResponseBody.Data.ChangeOrderList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.changeOrderList = tmp
            }
            if dict.keys.contains("CurrentPage") {
                self.currentPage = dict["CurrentPage"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalSize") {
                self.totalSize = dict["TotalSize"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListNamespaceChangeOrdersResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListNamespaceChangeOrdersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class ListNamespaceChangeOrdersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNamespaceChangeOrdersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNamespaceChangeOrdersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNamespacedConfigMapsRequest : Tea.TeaModel {
    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class ListNamespacedConfigMapsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ConfigMaps : Tea.TeaModel {
            public class RelateApps : Tea.TeaModel {
                public var appId: String?

                public var appName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appName != nil {
                        map["AppName"] = self.appName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AppId") {
                        self.appId = dict["AppId"] as! String
                    }
                    if dict.keys.contains("AppName") {
                        self.appName = dict["AppName"] as! String
                    }
                }
            }
            public var configMapId: Int64?

            public var createTime: Int64?

            public var data: [String: Any]?

            public var description_: String?

            public var name: String?

            public var namespaceId: String?

            public var relateApps: [ListNamespacedConfigMapsResponseBody.Data.ConfigMaps.RelateApps]?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configMapId != nil {
                    map["ConfigMapId"] = self.configMapId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespaceId != nil {
                    map["NamespaceId"] = self.namespaceId!
                }
                if self.relateApps != nil {
                    var tmp : [Any] = []
                    for k in self.relateApps! {
                        tmp.append(k.toMap())
                    }
                    map["RelateApps"] = tmp
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigMapId") {
                    self.configMapId = dict["ConfigMapId"] as! Int64
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! [String: Any]
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NamespaceId") {
                    self.namespaceId = dict["NamespaceId"] as! String
                }
                if dict.keys.contains("RelateApps") {
                    var tmp : [ListNamespacedConfigMapsResponseBody.Data.ConfigMaps.RelateApps] = []
                    for v in dict["RelateApps"] as! [Any] {
                        var model = ListNamespacedConfigMapsResponseBody.Data.ConfigMaps.RelateApps()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.relateApps = tmp
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
            }
        }
        public var configMaps: [ListNamespacedConfigMapsResponseBody.Data.ConfigMaps]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configMaps != nil {
                var tmp : [Any] = []
                for k in self.configMaps! {
                    tmp.append(k.toMap())
                }
                map["ConfigMaps"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigMaps") {
                var tmp : [ListNamespacedConfigMapsResponseBody.Data.ConfigMaps] = []
                for v in dict["ConfigMaps"] as! [Any] {
                    var model = ListNamespacedConfigMapsResponseBody.Data.ConfigMaps()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configMaps = tmp
            }
        }
    }
    public var code: String?

    public var data: ListNamespacedConfigMapsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListNamespacedConfigMapsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class ListNamespacedConfigMapsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNamespacedConfigMapsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNamespacedConfigMapsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPublishedServicesRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class ListPublishedServicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var group2Ip: String?

        public var groups: [String]?

        public var ips: [String]?

        public var name: String?

        public var type: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.group2Ip != nil {
                map["Group2Ip"] = self.group2Ip!
            }
            if self.groups != nil {
                map["Groups"] = self.groups!
            }
            if self.ips != nil {
                map["Ips"] = self.ips!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("Group2Ip") {
                self.group2Ip = dict["Group2Ip"] as! String
            }
            if dict.keys.contains("Groups") {
                self.groups = dict["Groups"] as! [String]
            }
            if dict.keys.contains("Ips") {
                self.ips = dict["Ips"] as! [String]
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListPublishedServicesResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListPublishedServicesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListPublishedServicesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class ListPublishedServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPublishedServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPublishedServicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSecretsRequest : Tea.TeaModel {
    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
    }
}

public class ListSecretsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Secrets : Tea.TeaModel {
            public class RelateApps : Tea.TeaModel {
                public var appId: String?

                public var appName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appName != nil {
                        map["AppName"] = self.appName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AppId") {
                        self.appId = dict["AppId"] as! String
                    }
                    if dict.keys.contains("AppName") {
                        self.appName = dict["AppName"] as! String
                    }
                }
            }
            public var createTime: Int64?

            public var namespaceId: String?

            public var relateApps: [ListSecretsResponseBody.Data.Secrets.RelateApps]?

            public var secretId: Int64?

            public var secretName: String?

            public var secretType: String?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.namespaceId != nil {
                    map["NamespaceId"] = self.namespaceId!
                }
                if self.relateApps != nil {
                    var tmp : [Any] = []
                    for k in self.relateApps! {
                        tmp.append(k.toMap())
                    }
                    map["RelateApps"] = tmp
                }
                if self.secretId != nil {
                    map["SecretId"] = self.secretId!
                }
                if self.secretName != nil {
                    map["SecretName"] = self.secretName!
                }
                if self.secretType != nil {
                    map["SecretType"] = self.secretType!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("NamespaceId") {
                    self.namespaceId = dict["NamespaceId"] as! String
                }
                if dict.keys.contains("RelateApps") {
                    var tmp : [ListSecretsResponseBody.Data.Secrets.RelateApps] = []
                    for v in dict["RelateApps"] as! [Any] {
                        var model = ListSecretsResponseBody.Data.Secrets.RelateApps()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.relateApps = tmp
                }
                if dict.keys.contains("SecretId") {
                    self.secretId = dict["SecretId"] as! Int64
                }
                if dict.keys.contains("SecretName") {
                    self.secretName = dict["SecretName"] as! String
                }
                if dict.keys.contains("SecretType") {
                    self.secretType = dict["SecretType"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! Int64
                }
            }
        }
        public var secrets: [ListSecretsResponseBody.Data.Secrets]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.secrets != nil {
                var tmp : [Any] = []
                for k in self.secrets! {
                    tmp.append(k.toMap())
                }
                map["Secrets"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Secrets") {
                var tmp : [ListSecretsResponseBody.Data.Secrets] = []
                for v in dict["Secrets"] as! [Any] {
                    var model = ListSecretsResponseBody.Data.Secrets()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.secrets = tmp
            }
        }
    }
    public var code: String?

    public var data: ListSecretsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListSecretsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class ListSecretsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSecretsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSecretsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public var nextToken: String?

    public var regionId: String?

    public var resourceIds: String?

    public var resourceType: String?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceIds") {
            self.resourceIds = dict["ResourceIds"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class TagResources : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var nextToken: String?

        public var tagResources: [ListTagResourcesResponseBody.Data.TagResources]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.tagResources != nil {
                var tmp : [Any] = []
                for k in self.tagResources! {
                    tmp.append(k.toMap())
                }
                map["TagResources"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NextToken") {
                self.nextToken = dict["NextToken"] as! String
            }
            if dict.keys.contains("TagResources") {
                var tmp : [ListTagResourcesResponseBody.Data.TagResources] = []
                for v in dict["TagResources"] as! [Any] {
                    var model = ListTagResourcesResponseBody.Data.TagResources()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagResources = tmp
            }
        }
    }
    public var code: String?

    public var data: ListTagResourcesResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListTagResourcesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenSaeServiceResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class OpenSaeServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenSaeServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OpenSaeServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryResourceStaticsRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class QueryResourceStaticsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RealTimeRes : Tea.TeaModel {
            public var cpu: Double?

            public var memory: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cpu") {
                    self.cpu = dict["Cpu"] as! Double
                }
                if dict.keys.contains("Memory") {
                    self.memory = dict["Memory"] as! Double
                }
            }
        }
        public class Summary : Tea.TeaModel {
            public var cpu: Double?

            public var memory: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cpu") {
                    self.cpu = dict["Cpu"] as! Double
                }
                if dict.keys.contains("Memory") {
                    self.memory = dict["Memory"] as! Double
                }
            }
        }
        public var realTimeRes: QueryResourceStaticsResponseBody.Data.RealTimeRes?

        public var summary: QueryResourceStaticsResponseBody.Data.Summary?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.realTimeRes?.validate()
            try self.summary?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.realTimeRes != nil {
                map["RealTimeRes"] = self.realTimeRes?.toMap()
            }
            if self.summary != nil {
                map["Summary"] = self.summary?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RealTimeRes") {
                var model = QueryResourceStaticsResponseBody.Data.RealTimeRes()
                model.fromMap(dict["RealTimeRes"] as! [String: Any])
                self.realTimeRes = model
            }
            if dict.keys.contains("Summary") {
                var model = QueryResourceStaticsResponseBody.Data.Summary()
                model.fromMap(dict["Summary"] as! [String: Any])
                self.summary = model
            }
        }
    }
    public var code: String?

    public var data: QueryResourceStaticsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = QueryResourceStaticsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class QueryResourceStaticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryResourceStaticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = QueryResourceStaticsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReduceApplicationCapacityByInstanceIdsRequest : Tea.TeaModel {
    public var appId: String?

    public var instanceIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
    }
}

public class ReduceApplicationCapacityByInstanceIdsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var data: ReduceApplicationCapacityByInstanceIdsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ReduceApplicationCapacityByInstanceIdsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class ReduceApplicationCapacityByInstanceIdsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReduceApplicationCapacityByInstanceIdsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReduceApplicationCapacityByInstanceIdsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RescaleApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var autoEnableApplicationScalingRule: Bool?

    public var minReadyInstanceRatio: Int32?

    public var minReadyInstances: Int32?

    public var replicas: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.autoEnableApplicationScalingRule != nil {
            map["AutoEnableApplicationScalingRule"] = self.autoEnableApplicationScalingRule!
        }
        if self.minReadyInstanceRatio != nil {
            map["MinReadyInstanceRatio"] = self.minReadyInstanceRatio!
        }
        if self.minReadyInstances != nil {
            map["MinReadyInstances"] = self.minReadyInstances!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AutoEnableApplicationScalingRule") {
            self.autoEnableApplicationScalingRule = dict["AutoEnableApplicationScalingRule"] as! Bool
        }
        if dict.keys.contains("MinReadyInstanceRatio") {
            self.minReadyInstanceRatio = dict["MinReadyInstanceRatio"] as! Int32
        }
        if dict.keys.contains("MinReadyInstances") {
            self.minReadyInstances = dict["MinReadyInstances"] as! Int32
        }
        if dict.keys.contains("Replicas") {
            self.replicas = dict["Replicas"] as! Int32
        }
    }
}

public class RescaleApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var data: RescaleApplicationResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = RescaleApplicationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class RescaleApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RescaleApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RescaleApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RescaleApplicationVerticallyRequest : Tea.TeaModel {
    public var appId: String?

    public var cpu: String?

    public var memory: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Cpu") {
            self.cpu = dict["Cpu"] as! String
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! String
        }
    }
}

public class RescaleApplicationVerticallyResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var data: RescaleApplicationVerticallyResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = RescaleApplicationVerticallyResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class RescaleApplicationVerticallyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RescaleApplicationVerticallyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RescaleApplicationVerticallyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestartApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var autoEnableApplicationScalingRule: Bool?

    public var minReadyInstanceRatio: Int32?

    public var minReadyInstances: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.autoEnableApplicationScalingRule != nil {
            map["AutoEnableApplicationScalingRule"] = self.autoEnableApplicationScalingRule!
        }
        if self.minReadyInstanceRatio != nil {
            map["MinReadyInstanceRatio"] = self.minReadyInstanceRatio!
        }
        if self.minReadyInstances != nil {
            map["MinReadyInstances"] = self.minReadyInstances!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AutoEnableApplicationScalingRule") {
            self.autoEnableApplicationScalingRule = dict["AutoEnableApplicationScalingRule"] as! Bool
        }
        if dict.keys.contains("MinReadyInstanceRatio") {
            self.minReadyInstanceRatio = dict["MinReadyInstanceRatio"] as! Int32
        }
        if dict.keys.contains("MinReadyInstances") {
            self.minReadyInstances = dict["MinReadyInstances"] as! Int32
        }
    }
}

public class RestartApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var data: RestartApplicationResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = RestartApplicationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class RestartApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RestartApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestartInstancesRequest : Tea.TeaModel {
    public var appId: String?

    public var instanceIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
    }
}

public class RestartInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var data: RestartInstancesResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = RestartInstancesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class RestartInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RestartInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RollbackApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var autoEnableApplicationScalingRule: String?

    public var batchWaitTime: Int32?

    public var minReadyInstanceRatio: Int32?

    public var minReadyInstances: Int32?

    public var updateStrategy: String?

    public var versionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.autoEnableApplicationScalingRule != nil {
            map["AutoEnableApplicationScalingRule"] = self.autoEnableApplicationScalingRule!
        }
        if self.batchWaitTime != nil {
            map["BatchWaitTime"] = self.batchWaitTime!
        }
        if self.minReadyInstanceRatio != nil {
            map["MinReadyInstanceRatio"] = self.minReadyInstanceRatio!
        }
        if self.minReadyInstances != nil {
            map["MinReadyInstances"] = self.minReadyInstances!
        }
        if self.updateStrategy != nil {
            map["UpdateStrategy"] = self.updateStrategy!
        }
        if self.versionId != nil {
            map["VersionId"] = self.versionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("AutoEnableApplicationScalingRule") {
            self.autoEnableApplicationScalingRule = dict["AutoEnableApplicationScalingRule"] as! String
        }
        if dict.keys.contains("BatchWaitTime") {
            self.batchWaitTime = dict["BatchWaitTime"] as! Int32
        }
        if dict.keys.contains("MinReadyInstanceRatio") {
            self.minReadyInstanceRatio = dict["MinReadyInstanceRatio"] as! Int32
        }
        if dict.keys.contains("MinReadyInstances") {
            self.minReadyInstances = dict["MinReadyInstances"] as! Int32
        }
        if dict.keys.contains("UpdateStrategy") {
            self.updateStrategy = dict["UpdateStrategy"] as! String
        }
        if dict.keys.contains("VersionId") {
            self.versionId = dict["VersionId"] as! String
        }
    }
}

public class RollbackApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public var isNeedApproval: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            if self.isNeedApproval != nil {
                map["IsNeedApproval"] = self.isNeedApproval!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
            if dict.keys.contains("IsNeedApproval") {
                self.isNeedApproval = dict["IsNeedApproval"] as! Bool
            }
        }
    }
    public var code: String?

    public var data: RollbackApplicationResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = RollbackApplicationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class RollbackApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RollbackApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RollbackApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class StartApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var data: StartApplicationResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = StartApplicationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class StartApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class StopApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var data: StopApplicationResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = StopApplicationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class StopApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopApplicationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SuspendJobRequest : Tea.TeaModel {
    public var appId: String?

    public var suspend: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.suspend != nil {
            map["Suspend"] = self.suspend!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Suspend") {
            self.suspend = dict["Suspend"] as! Bool
        }
    }
}

public class SuspendJobResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class SuspendJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SuspendJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceIds: String?

    public var resourceType: String?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceIds") {
            self.resourceIds = dict["ResourceIds"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnbindSlbRequest : Tea.TeaModel {
    public var appId: String?

    public var internet: Bool?

    public var intranet: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.internet != nil {
            map["Internet"] = self.internet!
        }
        if self.intranet != nil {
            map["Intranet"] = self.intranet!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Internet") {
            self.internet = dict["Internet"] as! Bool
        }
        if dict.keys.contains("Intranet") {
            self.intranet = dict["Intranet"] as! Bool
        }
    }
}

public class UnbindSlbResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var data: UnbindSlbResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = UnbindSlbResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class UnbindSlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindSlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnbindSlbResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var deleteAll: Bool?

    public var regionId: String?

    public var resourceIds: String?

    public var resourceType: String?

    public var tagKeys: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteAll != nil {
            map["DeleteAll"] = self.deleteAll!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKeys != nil {
            map["TagKeys"] = self.tagKeys!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteAll") {
            self.deleteAll = dict["DeleteAll"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceIds") {
            self.resourceIds = dict["ResourceIds"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKeys") {
            self.tagKeys = dict["TagKeys"] as! String
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAppSecurityGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class UpdateAppSecurityGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class UpdateAppSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAppSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAppSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateApplicationDescriptionRequest : Tea.TeaModel {
    public var appDescription: String?

    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appDescription != nil {
            map["AppDescription"] = self.appDescription!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppDescription") {
            self.appDescription = dict["AppDescription"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
    }
}

public class UpdateApplicationDescriptionResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class UpdateApplicationDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApplicationDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateApplicationDescriptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var minReadyInstanceRatio: Int32?

    public var minReadyInstances: Int32?

    public var scalingRuleMetric: String?

    public var scalingRuleName: String?

    public var scalingRuleTimer: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.minReadyInstanceRatio != nil {
            map["MinReadyInstanceRatio"] = self.minReadyInstanceRatio!
        }
        if self.minReadyInstances != nil {
            map["MinReadyInstances"] = self.minReadyInstances!
        }
        if self.scalingRuleMetric != nil {
            map["ScalingRuleMetric"] = self.scalingRuleMetric!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        if self.scalingRuleTimer != nil {
            map["ScalingRuleTimer"] = self.scalingRuleTimer!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("MinReadyInstanceRatio") {
            self.minReadyInstanceRatio = dict["MinReadyInstanceRatio"] as! Int32
        }
        if dict.keys.contains("MinReadyInstances") {
            self.minReadyInstances = dict["MinReadyInstances"] as! Int32
        }
        if dict.keys.contains("ScalingRuleMetric") {
            self.scalingRuleMetric = dict["ScalingRuleMetric"] as! String
        }
        if dict.keys.contains("ScalingRuleName") {
            self.scalingRuleName = dict["ScalingRuleName"] as! String
        }
        if dict.keys.contains("ScalingRuleTimer") {
            self.scalingRuleTimer = dict["ScalingRuleTimer"] as! String
        }
    }
}

public class UpdateApplicationScalingRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Metric : Tea.TeaModel {
            public class Metrics : Tea.TeaModel {
                public var metricTargetAverageUtilization: Int32?

                public var metricType: String?

                public var slbId: String?

                public var slbLogstore: String?

                public var slbProject: String?

                public var vport: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricTargetAverageUtilization != nil {
                        map["MetricTargetAverageUtilization"] = self.metricTargetAverageUtilization!
                    }
                    if self.metricType != nil {
                        map["MetricType"] = self.metricType!
                    }
                    if self.slbId != nil {
                        map["SlbId"] = self.slbId!
                    }
                    if self.slbLogstore != nil {
                        map["SlbLogstore"] = self.slbLogstore!
                    }
                    if self.slbProject != nil {
                        map["SlbProject"] = self.slbProject!
                    }
                    if self.vport != nil {
                        map["Vport"] = self.vport!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MetricTargetAverageUtilization") {
                        self.metricTargetAverageUtilization = dict["MetricTargetAverageUtilization"] as! Int32
                    }
                    if dict.keys.contains("MetricType") {
                        self.metricType = dict["MetricType"] as! String
                    }
                    if dict.keys.contains("SlbId") {
                        self.slbId = dict["SlbId"] as! String
                    }
                    if dict.keys.contains("SlbLogstore") {
                        self.slbLogstore = dict["SlbLogstore"] as! String
                    }
                    if dict.keys.contains("SlbProject") {
                        self.slbProject = dict["SlbProject"] as! String
                    }
                    if dict.keys.contains("Vport") {
                        self.vport = dict["Vport"] as! String
                    }
                }
            }
            public var maxReplicas: Int32?

            public var metrics: [UpdateApplicationScalingRuleResponseBody.Data.Metric.Metrics]?

            public var minReplicas: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.metrics != nil {
                    var tmp : [Any] = []
                    for k in self.metrics! {
                        tmp.append(k.toMap())
                    }
                    map["Metrics"] = tmp
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxReplicas") {
                    self.maxReplicas = dict["MaxReplicas"] as! Int32
                }
                if dict.keys.contains("Metrics") {
                    var tmp : [UpdateApplicationScalingRuleResponseBody.Data.Metric.Metrics] = []
                    for v in dict["Metrics"] as! [Any] {
                        var model = UpdateApplicationScalingRuleResponseBody.Data.Metric.Metrics()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.metrics = tmp
                }
                if dict.keys.contains("MinReplicas") {
                    self.minReplicas = dict["MinReplicas"] as! Int32
                }
            }
        }
        public class Timer : Tea.TeaModel {
            public class Schedules : Tea.TeaModel {
                public var atTime: String?

                public var maxReplicas: Int32?

                public var minReplicas: Int32?

                public var targetReplicas: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.atTime != nil {
                        map["AtTime"] = self.atTime!
                    }
                    if self.maxReplicas != nil {
                        map["MaxReplicas"] = self.maxReplicas!
                    }
                    if self.minReplicas != nil {
                        map["MinReplicas"] = self.minReplicas!
                    }
                    if self.targetReplicas != nil {
                        map["TargetReplicas"] = self.targetReplicas!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AtTime") {
                        self.atTime = dict["AtTime"] as! String
                    }
                    if dict.keys.contains("MaxReplicas") {
                        self.maxReplicas = dict["MaxReplicas"] as! Int32
                    }
                    if dict.keys.contains("MinReplicas") {
                        self.minReplicas = dict["MinReplicas"] as! Int32
                    }
                    if dict.keys.contains("TargetReplicas") {
                        self.targetReplicas = dict["TargetReplicas"] as! Int32
                    }
                }
            }
            public var beginDate: String?

            public var endDate: String?

            public var period: String?

            public var schedules: [UpdateApplicationScalingRuleResponseBody.Data.Timer.Schedules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.beginDate != nil {
                    map["BeginDate"] = self.beginDate!
                }
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.schedules != nil {
                    var tmp : [Any] = []
                    for k in self.schedules! {
                        tmp.append(k.toMap())
                    }
                    map["Schedules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BeginDate") {
                    self.beginDate = dict["BeginDate"] as! String
                }
                if dict.keys.contains("EndDate") {
                    self.endDate = dict["EndDate"] as! String
                }
                if dict.keys.contains("Period") {
                    self.period = dict["Period"] as! String
                }
                if dict.keys.contains("Schedules") {
                    var tmp : [UpdateApplicationScalingRuleResponseBody.Data.Timer.Schedules] = []
                    for v in dict["Schedules"] as! [Any] {
                        var model = UpdateApplicationScalingRuleResponseBody.Data.Timer.Schedules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.schedules = tmp
                }
            }
        }
        public var appId: String?

        public var createTime: Int64?

        public var lastDisableTime: Int64?

        public var metric: UpdateApplicationScalingRuleResponseBody.Data.Metric?

        public var scaleRuleEnabled: Bool?

        public var scaleRuleName: String?

        public var scaleRuleType: String?

        public var timer: UpdateApplicationScalingRuleResponseBody.Data.Timer?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metric?.validate()
            try self.timer?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastDisableTime != nil {
                map["LastDisableTime"] = self.lastDisableTime!
            }
            if self.metric != nil {
                map["Metric"] = self.metric?.toMap()
            }
            if self.scaleRuleEnabled != nil {
                map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
            }
            if self.scaleRuleName != nil {
                map["ScaleRuleName"] = self.scaleRuleName!
            }
            if self.scaleRuleType != nil {
                map["ScaleRuleType"] = self.scaleRuleType!
            }
            if self.timer != nil {
                map["Timer"] = self.timer?.toMap()
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("LastDisableTime") {
                self.lastDisableTime = dict["LastDisableTime"] as! Int64
            }
            if dict.keys.contains("Metric") {
                var model = UpdateApplicationScalingRuleResponseBody.Data.Metric()
                model.fromMap(dict["Metric"] as! [String: Any])
                self.metric = model
            }
            if dict.keys.contains("ScaleRuleEnabled") {
                self.scaleRuleEnabled = dict["ScaleRuleEnabled"] as! Bool
            }
            if dict.keys.contains("ScaleRuleName") {
                self.scaleRuleName = dict["ScaleRuleName"] as! String
            }
            if dict.keys.contains("ScaleRuleType") {
                self.scaleRuleType = dict["ScaleRuleType"] as! String
            }
            if dict.keys.contains("Timer") {
                var model = UpdateApplicationScalingRuleResponseBody.Data.Timer()
                model.fromMap(dict["Timer"] as! [String: Any])
                self.timer = model
            }
            if dict.keys.contains("UpdateTime") {
                self.updateTime = dict["UpdateTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: UpdateApplicationScalingRuleResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = UpdateApplicationScalingRuleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class UpdateApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateApplicationScalingRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateApplicationVswitchesRequest : Tea.TeaModel {
    public var appId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class UpdateApplicationVswitchesResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class UpdateApplicationVswitchesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApplicationVswitchesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateApplicationVswitchesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateConfigMapRequest : Tea.TeaModel {
    public var configMapId: Int64?

    public var data: String?

    public var description_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configMapId != nil {
            map["ConfigMapId"] = self.configMapId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigMapId") {
            self.configMapId = dict["ConfigMapId"] as! Int64
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
    }
}

public class UpdateConfigMapResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configMapId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configMapId != nil {
                map["ConfigMapId"] = self.configMapId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigMapId") {
                self.configMapId = dict["ConfigMapId"] as! String
            }
        }
    }
    public var code: String?

    public var data: UpdateConfigMapResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = UpdateConfigMapResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class UpdateConfigMapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateConfigMapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateConfigMapResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateGreyTagRouteRequest : Tea.TeaModel {
    public var albRules: String?

    public var description_: String?

    public var dubboRules: String?

    public var greyTagRouteId: Int64?

    public var scRules: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.albRules != nil {
            map["AlbRules"] = self.albRules!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dubboRules != nil {
            map["DubboRules"] = self.dubboRules!
        }
        if self.greyTagRouteId != nil {
            map["GreyTagRouteId"] = self.greyTagRouteId!
        }
        if self.scRules != nil {
            map["ScRules"] = self.scRules!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlbRules") {
            self.albRules = dict["AlbRules"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DubboRules") {
            self.dubboRules = dict["DubboRules"] as! String
        }
        if dict.keys.contains("GreyTagRouteId") {
            self.greyTagRouteId = dict["GreyTagRouteId"] as! Int64
        }
        if dict.keys.contains("ScRules") {
            self.scRules = dict["ScRules"] as! String
        }
    }
}

public class UpdateGreyTagRouteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var greyTagRouteId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.greyTagRouteId != nil {
                map["GreyTagRouteId"] = self.greyTagRouteId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("GreyTagRouteId") {
                self.greyTagRouteId = dict["GreyTagRouteId"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: UpdateGreyTagRouteResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = UpdateGreyTagRouteResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class UpdateGreyTagRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGreyTagRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateGreyTagRouteResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateIngressRequest : Tea.TeaModel {
    public var certId: String?

    public var certIds: String?

    public var defaultRule: String?

    public var description_: String?

    public var ingressId: Int64?

    public var listenerPort: String?

    public var listenerProtocol: String?

    public var loadBalanceType: String?

    public var rules: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certId != nil {
            map["CertId"] = self.certId!
        }
        if self.certIds != nil {
            map["CertIds"] = self.certIds!
        }
        if self.defaultRule != nil {
            map["DefaultRule"] = self.defaultRule!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ingressId != nil {
            map["IngressId"] = self.ingressId!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.listenerProtocol != nil {
            map["ListenerProtocol"] = self.listenerProtocol!
        }
        if self.loadBalanceType != nil {
            map["LoadBalanceType"] = self.loadBalanceType!
        }
        if self.rules != nil {
            map["Rules"] = self.rules!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CertId") {
            self.certId = dict["CertId"] as! String
        }
        if dict.keys.contains("CertIds") {
            self.certIds = dict["CertIds"] as! String
        }
        if dict.keys.contains("DefaultRule") {
            self.defaultRule = dict["DefaultRule"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IngressId") {
            self.ingressId = dict["IngressId"] as! Int64
        }
        if dict.keys.contains("ListenerPort") {
            self.listenerPort = dict["ListenerPort"] as! String
        }
        if dict.keys.contains("ListenerProtocol") {
            self.listenerProtocol = dict["ListenerProtocol"] as! String
        }
        if dict.keys.contains("LoadBalanceType") {
            self.loadBalanceType = dict["LoadBalanceType"] as! String
        }
        if dict.keys.contains("Rules") {
            self.rules = dict["Rules"] as! String
        }
    }
}

public class UpdateIngressResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var ingressId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ingressId != nil {
                map["IngressId"] = self.ingressId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IngressId") {
                self.ingressId = dict["IngressId"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: UpdateIngressResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = UpdateIngressResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class UpdateIngressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIngressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateIngressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateJobRequest : Tea.TeaModel {
    public var acrAssumeRoleArn: String?

    public var acrInstanceId: String?

    public var appId: String?

    public var backoffLimit: Int64?

    public var command: String?

    public var commandArgs: String?

    public var concurrencyPolicy: String?

    public var configMapMountDesc: String?

    public var customHostAlias: String?

    public var edasContainerVersion: String?

    public var enableImageAccl: Bool?

    public var envs: String?

    public var imagePullSecrets: String?

    public var imageUrl: String?

    public var jarStartArgs: String?

    public var jarStartOptions: String?

    public var jdk: String?

    public var mountDesc: String?

    public var mountHost: String?

    public var nasId: String?

    public var ossAkId: String?

    public var ossAkSecret: String?

    public var ossMountDescs: String?

    public var packageUrl: String?

    public var packageVersion: String?

    public var php: String?

    public var phpConfig: String?

    public var phpConfigLocation: String?

    public var postStart: String?

    public var preStop: String?

    public var programmingLanguage: String?

    public var python: String?

    public var pythonModules: String?

    public var refAppId: String?

    public var replicas: String?

    public var slice: Bool?

    public var sliceEnvs: String?

    public var slsConfigs: String?

    public var terminationGracePeriodSeconds: Int32?

    public var timeout: Int64?

    public var timezone: String?

    public var tomcatConfig: String?

    public var triggerConfig: String?

    public var warStartOptions: String?

    public var webContainer: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acrAssumeRoleArn != nil {
            map["AcrAssumeRoleArn"] = self.acrAssumeRoleArn!
        }
        if self.acrInstanceId != nil {
            map["AcrInstanceId"] = self.acrInstanceId!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.backoffLimit != nil {
            map["BackoffLimit"] = self.backoffLimit!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.commandArgs != nil {
            map["CommandArgs"] = self.commandArgs!
        }
        if self.concurrencyPolicy != nil {
            map["ConcurrencyPolicy"] = self.concurrencyPolicy!
        }
        if self.configMapMountDesc != nil {
            map["ConfigMapMountDesc"] = self.configMapMountDesc!
        }
        if self.customHostAlias != nil {
            map["CustomHostAlias"] = self.customHostAlias!
        }
        if self.edasContainerVersion != nil {
            map["EdasContainerVersion"] = self.edasContainerVersion!
        }
        if self.enableImageAccl != nil {
            map["EnableImageAccl"] = self.enableImageAccl!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.imagePullSecrets != nil {
            map["ImagePullSecrets"] = self.imagePullSecrets!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.jarStartArgs != nil {
            map["JarStartArgs"] = self.jarStartArgs!
        }
        if self.jarStartOptions != nil {
            map["JarStartOptions"] = self.jarStartOptions!
        }
        if self.jdk != nil {
            map["Jdk"] = self.jdk!
        }
        if self.mountDesc != nil {
            map["MountDesc"] = self.mountDesc!
        }
        if self.mountHost != nil {
            map["MountHost"] = self.mountHost!
        }
        if self.nasId != nil {
            map["NasId"] = self.nasId!
        }
        if self.ossAkId != nil {
            map["OssAkId"] = self.ossAkId!
        }
        if self.ossAkSecret != nil {
            map["OssAkSecret"] = self.ossAkSecret!
        }
        if self.ossMountDescs != nil {
            map["OssMountDescs"] = self.ossMountDescs!
        }
        if self.packageUrl != nil {
            map["PackageUrl"] = self.packageUrl!
        }
        if self.packageVersion != nil {
            map["PackageVersion"] = self.packageVersion!
        }
        if self.php != nil {
            map["Php"] = self.php!
        }
        if self.phpConfig != nil {
            map["PhpConfig"] = self.phpConfig!
        }
        if self.phpConfigLocation != nil {
            map["PhpConfigLocation"] = self.phpConfigLocation!
        }
        if self.postStart != nil {
            map["PostStart"] = self.postStart!
        }
        if self.preStop != nil {
            map["PreStop"] = self.preStop!
        }
        if self.programmingLanguage != nil {
            map["ProgrammingLanguage"] = self.programmingLanguage!
        }
        if self.python != nil {
            map["Python"] = self.python!
        }
        if self.pythonModules != nil {
            map["PythonModules"] = self.pythonModules!
        }
        if self.refAppId != nil {
            map["RefAppId"] = self.refAppId!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.slice != nil {
            map["Slice"] = self.slice!
        }
        if self.sliceEnvs != nil {
            map["SliceEnvs"] = self.sliceEnvs!
        }
        if self.slsConfigs != nil {
            map["SlsConfigs"] = self.slsConfigs!
        }
        if self.terminationGracePeriodSeconds != nil {
            map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.timezone != nil {
            map["Timezone"] = self.timezone!
        }
        if self.tomcatConfig != nil {
            map["TomcatConfig"] = self.tomcatConfig!
        }
        if self.triggerConfig != nil {
            map["TriggerConfig"] = self.triggerConfig!
        }
        if self.warStartOptions != nil {
            map["WarStartOptions"] = self.warStartOptions!
        }
        if self.webContainer != nil {
            map["WebContainer"] = self.webContainer!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcrAssumeRoleArn") {
            self.acrAssumeRoleArn = dict["AcrAssumeRoleArn"] as! String
        }
        if dict.keys.contains("AcrInstanceId") {
            self.acrInstanceId = dict["AcrInstanceId"] as! String
        }
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("BackoffLimit") {
            self.backoffLimit = dict["BackoffLimit"] as! Int64
        }
        if dict.keys.contains("Command") {
            self.command = dict["Command"] as! String
        }
        if dict.keys.contains("CommandArgs") {
            self.commandArgs = dict["CommandArgs"] as! String
        }
        if dict.keys.contains("ConcurrencyPolicy") {
            self.concurrencyPolicy = dict["ConcurrencyPolicy"] as! String
        }
        if dict.keys.contains("ConfigMapMountDesc") {
            self.configMapMountDesc = dict["ConfigMapMountDesc"] as! String
        }
        if dict.keys.contains("CustomHostAlias") {
            self.customHostAlias = dict["CustomHostAlias"] as! String
        }
        if dict.keys.contains("EdasContainerVersion") {
            self.edasContainerVersion = dict["EdasContainerVersion"] as! String
        }
        if dict.keys.contains("EnableImageAccl") {
            self.enableImageAccl = dict["EnableImageAccl"] as! Bool
        }
        if dict.keys.contains("Envs") {
            self.envs = dict["Envs"] as! String
        }
        if dict.keys.contains("ImagePullSecrets") {
            self.imagePullSecrets = dict["ImagePullSecrets"] as! String
        }
        if dict.keys.contains("ImageUrl") {
            self.imageUrl = dict["ImageUrl"] as! String
        }
        if dict.keys.contains("JarStartArgs") {
            self.jarStartArgs = dict["JarStartArgs"] as! String
        }
        if dict.keys.contains("JarStartOptions") {
            self.jarStartOptions = dict["JarStartOptions"] as! String
        }
        if dict.keys.contains("Jdk") {
            self.jdk = dict["Jdk"] as! String
        }
        if dict.keys.contains("MountDesc") {
            self.mountDesc = dict["MountDesc"] as! String
        }
        if dict.keys.contains("MountHost") {
            self.mountHost = dict["MountHost"] as! String
        }
        if dict.keys.contains("NasId") {
            self.nasId = dict["NasId"] as! String
        }
        if dict.keys.contains("OssAkId") {
            self.ossAkId = dict["OssAkId"] as! String
        }
        if dict.keys.contains("OssAkSecret") {
            self.ossAkSecret = dict["OssAkSecret"] as! String
        }
        if dict.keys.contains("OssMountDescs") {
            self.ossMountDescs = dict["OssMountDescs"] as! String
        }
        if dict.keys.contains("PackageUrl") {
            self.packageUrl = dict["PackageUrl"] as! String
        }
        if dict.keys.contains("PackageVersion") {
            self.packageVersion = dict["PackageVersion"] as! String
        }
        if dict.keys.contains("Php") {
            self.php = dict["Php"] as! String
        }
        if dict.keys.contains("PhpConfig") {
            self.phpConfig = dict["PhpConfig"] as! String
        }
        if dict.keys.contains("PhpConfigLocation") {
            self.phpConfigLocation = dict["PhpConfigLocation"] as! String
        }
        if dict.keys.contains("PostStart") {
            self.postStart = dict["PostStart"] as! String
        }
        if dict.keys.contains("PreStop") {
            self.preStop = dict["PreStop"] as! String
        }
        if dict.keys.contains("ProgrammingLanguage") {
            self.programmingLanguage = dict["ProgrammingLanguage"] as! String
        }
        if dict.keys.contains("Python") {
            self.python = dict["Python"] as! String
        }
        if dict.keys.contains("PythonModules") {
            self.pythonModules = dict["PythonModules"] as! String
        }
        if dict.keys.contains("RefAppId") {
            self.refAppId = dict["RefAppId"] as! String
        }
        if dict.keys.contains("Replicas") {
            self.replicas = dict["Replicas"] as! String
        }
        if dict.keys.contains("Slice") {
            self.slice = dict["Slice"] as! Bool
        }
        if dict.keys.contains("SliceEnvs") {
            self.sliceEnvs = dict["SliceEnvs"] as! String
        }
        if dict.keys.contains("SlsConfigs") {
            self.slsConfigs = dict["SlsConfigs"] as! String
        }
        if dict.keys.contains("TerminationGracePeriodSeconds") {
            self.terminationGracePeriodSeconds = dict["TerminationGracePeriodSeconds"] as! Int32
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int64
        }
        if dict.keys.contains("Timezone") {
            self.timezone = dict["Timezone"] as! String
        }
        if dict.keys.contains("TomcatConfig") {
            self.tomcatConfig = dict["TomcatConfig"] as! String
        }
        if dict.keys.contains("TriggerConfig") {
            self.triggerConfig = dict["TriggerConfig"] as! String
        }
        if dict.keys.contains("WarStartOptions") {
            self.warStartOptions = dict["WarStartOptions"] as! String
        }
        if dict.keys.contains("WebContainer") {
            self.webContainer = dict["WebContainer"] as! String
        }
    }
}

public class UpdateJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AppId") {
                self.appId = dict["AppId"] as! String
            }
            if dict.keys.contains("ChangeOrderId") {
                self.changeOrderId = dict["ChangeOrderId"] as! String
            }
        }
    }
    public var code: String?

    public var data: UpdateJobResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = UpdateJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class UpdateJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNamespaceRequest : Tea.TeaModel {
    public var enableMicroRegistration: Bool?

    public var nameSpaceShortId: String?

    public var namespaceDescription: String?

    public var namespaceId: String?

    public var namespaceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableMicroRegistration != nil {
            map["EnableMicroRegistration"] = self.enableMicroRegistration!
        }
        if self.nameSpaceShortId != nil {
            map["NameSpaceShortId"] = self.nameSpaceShortId!
        }
        if self.namespaceDescription != nil {
            map["NamespaceDescription"] = self.namespaceDescription!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.namespaceName != nil {
            map["NamespaceName"] = self.namespaceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EnableMicroRegistration") {
            self.enableMicroRegistration = dict["EnableMicroRegistration"] as! Bool
        }
        if dict.keys.contains("NameSpaceShortId") {
            self.nameSpaceShortId = dict["NameSpaceShortId"] as! String
        }
        if dict.keys.contains("NamespaceDescription") {
            self.namespaceDescription = dict["NamespaceDescription"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("NamespaceName") {
            self.namespaceName = dict["NamespaceName"] as! String
        }
    }
}

public class UpdateNamespaceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var enableMicroRegistration: Bool?

        public var nameSpaceShortId: String?

        public var namespaceDescription: String?

        public var namespaceId: String?

        public var namespaceName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableMicroRegistration != nil {
                map["EnableMicroRegistration"] = self.enableMicroRegistration!
            }
            if self.nameSpaceShortId != nil {
                map["NameSpaceShortId"] = self.nameSpaceShortId!
            }
            if self.namespaceDescription != nil {
                map["NamespaceDescription"] = self.namespaceDescription!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.namespaceName != nil {
                map["NamespaceName"] = self.namespaceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableMicroRegistration") {
                self.enableMicroRegistration = dict["EnableMicroRegistration"] as! Bool
            }
            if dict.keys.contains("NameSpaceShortId") {
                self.nameSpaceShortId = dict["NameSpaceShortId"] as! String
            }
            if dict.keys.contains("NamespaceDescription") {
                self.namespaceDescription = dict["NamespaceDescription"] as! String
            }
            if dict.keys.contains("NamespaceId") {
                self.namespaceId = dict["NamespaceId"] as! String
            }
            if dict.keys.contains("NamespaceName") {
                self.namespaceName = dict["NamespaceName"] as! String
            }
            if dict.keys.contains("RegionId") {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public var code: String?

    public var data: UpdateNamespaceResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = UpdateNamespaceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class UpdateNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateNamespaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateNamespaceVpcRequest : Tea.TeaModel {
    public var nameSpaceShortId: String?

    public var namespaceId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nameSpaceShortId != nil {
            map["NameSpaceShortId"] = self.nameSpaceShortId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NameSpaceShortId") {
            self.nameSpaceShortId = dict["NameSpaceShortId"] as! String
        }
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class UpdateNamespaceVpcResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class UpdateNamespaceVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNamespaceVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateNamespaceVpcResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSecretRequest : Tea.TeaModel {
    public class SecretData : Tea.TeaModel {
        public var secretData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.secretData != nil {
                map["SecretData"] = self.secretData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecretData") {
                self.secretData = dict["SecretData"] as! String
            }
        }
    }
    public var namespaceId: String?

    public var secretData: UpdateSecretRequest.SecretData?

    public var secretId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.secretData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.secretData != nil {
            map["SecretData"] = self.secretData?.toMap()
        }
        if self.secretId != nil {
            map["SecretId"] = self.secretId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("SecretData") {
            var model = UpdateSecretRequest.SecretData()
            model.fromMap(dict["SecretData"] as! [String: Any])
            self.secretData = model
        }
        if dict.keys.contains("SecretId") {
            self.secretId = dict["SecretId"] as! Int64
        }
    }
}

public class UpdateSecretShrinkRequest : Tea.TeaModel {
    public var namespaceId: String?

    public var secretDataShrink: String?

    public var secretId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.secretDataShrink != nil {
            map["SecretData"] = self.secretDataShrink!
        }
        if self.secretId != nil {
            map["SecretId"] = self.secretId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NamespaceId") {
            self.namespaceId = dict["NamespaceId"] as! String
        }
        if dict.keys.contains("SecretData") {
            self.secretDataShrink = dict["SecretData"] as! String
        }
        if dict.keys.contains("SecretId") {
            self.secretId = dict["SecretId"] as! Int64
        }
    }
}

public class UpdateSecretResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var secretId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.secretId != nil {
                map["SecretId"] = self.secretId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecretId") {
                self.secretId = dict["SecretId"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: UpdateSecretResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = UpdateSecretResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
    }
}

public class UpdateSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateSecretResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
