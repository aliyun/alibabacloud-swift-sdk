import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AclConfig : Tea.TeaModel {
    public var aclEntries: [AclEntryConfig]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntries != nil {
            var tmp : [Any] = []
            for k in self.aclEntries! {
                tmp.append(k.toMap())
            }
            map["aclEntries"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["aclEntries"] as? [Any?] {
            var tmp : [AclEntryConfig] = []
            for v in value {
                if v != nil {
                    var model = AclEntryConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.aclEntries = tmp
        }
    }
}

public class AclEntryConfig : Tea.TeaModel {
    public var entry: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entry != nil {
            map["entry"] = self.entry!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["entry"] as? String {
            self.entry = value
        }
    }
}

public class AppStackInstance : Tea.TeaModel {
    public class Endpoints : Tea.TeaModel {
        public var address: String?

        public var name: String?

        public var protocol_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Address"] as? String {
                self.address = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Protocol"] as? String {
                self.protocol_ = value
            }
        }
    }
    public class Parameters : Tea.TeaModel {
        public var name: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var createTime: Int64?

    public var endpoints: [AppStackInstance.Endpoints]?

    public var instanceId: String?

    public var instanceName: String?

    public var parameters: [AppStackInstance.Parameters]?

    public var stackId: String?

    public var status: String?

    public var updateTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.endpoints != nil {
            var tmp : [Any] = []
            for k in self.endpoints! {
                tmp.append(k.toMap())
            }
            map["Endpoints"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.parameters != nil {
            var tmp : [Any] = []
            for k in self.parameters! {
                tmp.append(k.toMap())
            }
            map["Parameters"] = tmp
        }
        if self.stackId != nil {
            map["StackId"] = self.stackId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["Endpoints"] as? [Any?] {
            var tmp : [AppStackInstance.Endpoints] = []
            for v in value {
                if v != nil {
                    var model = AppStackInstance.Endpoints()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.endpoints = tmp
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["InstanceName"] as? String {
            self.instanceName = value
        }
        if let value = dict["Parameters"] as? [Any?] {
            var tmp : [AppStackInstance.Parameters] = []
            for v in value {
                if v != nil {
                    var model = AppStackInstance.Parameters()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.parameters = tmp
        }
        if let value = dict["StackId"] as? String {
            self.stackId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["UpdateTime"] as? Int64 {
            self.updateTime = value
        }
    }
}

public class AppStackResource : Tea.TeaModel {
    public var createTime: Int64?

    public var instanceId: String?

    public var productCode: String?

    public var resourceId: String?

    public var resourceName: String?

    public var resourceType: String?

    public var stackId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.productCode != nil {
            map["ProductCode"] = self.productCode!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceName != nil {
            map["ResourceName"] = self.resourceName!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.stackId != nil {
            map["StackId"] = self.stackId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["ProductCode"] as? String {
            self.productCode = value
        }
        if let value = dict["ResourceId"] as? String {
            self.resourceId = value
        }
        if let value = dict["ResourceName"] as? String {
            self.resourceName = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["StackId"] as? String {
            self.stackId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class AppStackTask : Tea.TeaModel {
    public class Steps : Tea.TeaModel {
        public var code: String?

        public var duration: Int64?

        public var endTime: Int64?

        public var id: String?

        public var message: String?

        public var name: String?

        public var startTime: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Code"] as? String {
                self.code = value
            }
            if let value = dict["Duration"] as? Int64 {
                self.duration = value
            }
            if let value = dict["EndTime"] as? Int64 {
                self.endTime = value
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["StartTime"] as? Int64 {
                self.startTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var createTime: Int64?

    public var endTime: Int64?

    public var instanceId: String?

    public var stackId: String?

    public var startTime: Int64?

    public var status: String?

    public var steps: [AppStackTask.Steps]?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.stackId != nil {
            map["StackId"] = self.stackId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.steps != nil {
            var tmp : [Any] = []
            for k in self.steps! {
                tmp.append(k.toMap())
            }
            map["Steps"] = tmp
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["StackId"] as? String {
            self.stackId = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Steps"] as? [Any?] {
            var tmp : [AppStackTask.Steps] = []
            for v in value {
                if v != nil {
                    var model = AppStackTask.Steps()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.steps = tmp
        }
        if let value = dict["TaskId"] as? String {
            self.taskId = value
        }
    }
}

public class Application : Tea.TeaModel {
    public var requestId: String?

    public var applicationId: String?

    public var applicationName: String?

    public var args: String?

    public var caPort: Int32?

    public var codeChecksum: String?

    public var codeSize: Int64?

    public var command: String?

    public var cpu: Double?

    public var createdTime: String?

    public var customDNS: CustomDNS?

    public var customDomainName: String?

    public var customHealthCheckConfig: CustomHealthCheckConfig?

    public var customHostAlias: CustomHostAlias?

    public var customRuntimeConfig: CustomRuntimeConfig?

    public var description_: String?

    public var diskSize: Int32?

    public var enableAppMetric: Bool?

    public var enableArmsAdvanced: Bool?

    public var environmentVariables: [String: String]?

    public var gpuMemorySize: Int32?

    public var handler: String?

    public var httpTriggerConfig: HTTPTriggerConfig?

    public var imageConfig: ImageConfig?

    public var initializationTimeout: Int32?

    public var initializer: String?

    public var instanceConcurrency: Int32?

    public var instanceLifecycleConfig: InstanceLifecycleConfig?

    public var instanceSoftConcurrency: Int32?

    public var instanceType: String?

    public var internetAccess: Bool?

    public var lastModifiedTime: String?

    public var layers: [String]?

    public var layersArnV2: [String]?

    public var livenessProbe: Probe?

    public var logConfig: LogConfig?

    public var memorySize: Int32?

    public var namespace: String?

    public var namespaceID: String?

    public var namespaceName: String?

    public var nasConfig: NASConfig?

    public var ossMountConfig: OSSMountConfig?

    public var programmingLanguage: String?

    public var runtime: String?

    public var scaleConfig: ScaleConfig?

    public var slsConfig: SLSConfig?

    public var startupProbe: Probe?

    public var timeout: Int32?

    public var tracingConfig: TracingConfig?

    public var urlInternet: String?

    public var urlIntranet: String?

    public var version: Version?

    public var vpcConfig: VPCConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.customDNS?.validate()
        try self.customHealthCheckConfig?.validate()
        try self.customHostAlias?.validate()
        try self.customRuntimeConfig?.validate()
        try self.httpTriggerConfig?.validate()
        try self.imageConfig?.validate()
        try self.instanceLifecycleConfig?.validate()
        try self.livenessProbe?.validate()
        try self.logConfig?.validate()
        try self.nasConfig?.validate()
        try self.ossMountConfig?.validate()
        try self.scaleConfig?.validate()
        try self.slsConfig?.validate()
        try self.startupProbe?.validate()
        try self.tracingConfig?.validate()
        try self.version?.validate()
        try self.vpcConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.applicationId != nil {
            map["applicationId"] = self.applicationId!
        }
        if self.applicationName != nil {
            map["applicationName"] = self.applicationName!
        }
        if self.args != nil {
            map["args"] = self.args!
        }
        if self.caPort != nil {
            map["caPort"] = self.caPort!
        }
        if self.codeChecksum != nil {
            map["codeChecksum"] = self.codeChecksum!
        }
        if self.codeSize != nil {
            map["codeSize"] = self.codeSize!
        }
        if self.command != nil {
            map["command"] = self.command!
        }
        if self.cpu != nil {
            map["cpu"] = self.cpu!
        }
        if self.createdTime != nil {
            map["createdTime"] = self.createdTime!
        }
        if self.customDNS != nil {
            map["customDNS"] = self.customDNS?.toMap()
        }
        if self.customDomainName != nil {
            map["customDomainName"] = self.customDomainName!
        }
        if self.customHealthCheckConfig != nil {
            map["customHealthCheckConfig"] = self.customHealthCheckConfig?.toMap()
        }
        if self.customHostAlias != nil {
            map["customHostAlias"] = self.customHostAlias?.toMap()
        }
        if self.customRuntimeConfig != nil {
            map["customRuntimeConfig"] = self.customRuntimeConfig?.toMap()
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.diskSize != nil {
            map["diskSize"] = self.diskSize!
        }
        if self.enableAppMetric != nil {
            map["enableAppMetric"] = self.enableAppMetric!
        }
        if self.enableArmsAdvanced != nil {
            map["enableArmsAdvanced"] = self.enableArmsAdvanced!
        }
        if self.environmentVariables != nil {
            map["environmentVariables"] = self.environmentVariables!
        }
        if self.gpuMemorySize != nil {
            map["gpuMemorySize"] = self.gpuMemorySize!
        }
        if self.handler != nil {
            map["handler"] = self.handler!
        }
        if self.httpTriggerConfig != nil {
            map["httpTriggerConfig"] = self.httpTriggerConfig?.toMap()
        }
        if self.imageConfig != nil {
            map["imageConfig"] = self.imageConfig?.toMap()
        }
        if self.initializationTimeout != nil {
            map["initializationTimeout"] = self.initializationTimeout!
        }
        if self.initializer != nil {
            map["initializer"] = self.initializer!
        }
        if self.instanceConcurrency != nil {
            map["instanceConcurrency"] = self.instanceConcurrency!
        }
        if self.instanceLifecycleConfig != nil {
            map["instanceLifecycleConfig"] = self.instanceLifecycleConfig?.toMap()
        }
        if self.instanceSoftConcurrency != nil {
            map["instanceSoftConcurrency"] = self.instanceSoftConcurrency!
        }
        if self.instanceType != nil {
            map["instanceType"] = self.instanceType!
        }
        if self.internetAccess != nil {
            map["internetAccess"] = self.internetAccess!
        }
        if self.lastModifiedTime != nil {
            map["lastModifiedTime"] = self.lastModifiedTime!
        }
        if self.layers != nil {
            map["layers"] = self.layers!
        }
        if self.layersArnV2 != nil {
            map["layersArnV2"] = self.layersArnV2!
        }
        if self.livenessProbe != nil {
            map["livenessProbe"] = self.livenessProbe?.toMap()
        }
        if self.logConfig != nil {
            map["logConfig"] = self.logConfig?.toMap()
        }
        if self.memorySize != nil {
            map["memorySize"] = self.memorySize!
        }
        if self.namespace != nil {
            map["namespace"] = self.namespace!
        }
        if self.namespaceID != nil {
            map["namespaceID"] = self.namespaceID!
        }
        if self.namespaceName != nil {
            map["namespaceName"] = self.namespaceName!
        }
        if self.nasConfig != nil {
            map["nasConfig"] = self.nasConfig?.toMap()
        }
        if self.ossMountConfig != nil {
            map["ossMountConfig"] = self.ossMountConfig?.toMap()
        }
        if self.programmingLanguage != nil {
            map["programmingLanguage"] = self.programmingLanguage!
        }
        if self.runtime != nil {
            map["runtime"] = self.runtime!
        }
        if self.scaleConfig != nil {
            map["scaleConfig"] = self.scaleConfig?.toMap()
        }
        if self.slsConfig != nil {
            map["slsConfig"] = self.slsConfig?.toMap()
        }
        if self.startupProbe != nil {
            map["startupProbe"] = self.startupProbe?.toMap()
        }
        if self.timeout != nil {
            map["timeout"] = self.timeout!
        }
        if self.tracingConfig != nil {
            map["tracingConfig"] = self.tracingConfig?.toMap()
        }
        if self.urlInternet != nil {
            map["urlInternet"] = self.urlInternet!
        }
        if self.urlIntranet != nil {
            map["urlIntranet"] = self.urlIntranet!
        }
        if self.version != nil {
            map["version"] = self.version?.toMap()
        }
        if self.vpcConfig != nil {
            map["vpcConfig"] = self.vpcConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["applicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["applicationName"] as? String {
            self.applicationName = value
        }
        if let value = dict["args"] as? String {
            self.args = value
        }
        if let value = dict["caPort"] as? Int32 {
            self.caPort = value
        }
        if let value = dict["codeChecksum"] as? String {
            self.codeChecksum = value
        }
        if let value = dict["codeSize"] as? Int64 {
            self.codeSize = value
        }
        if let value = dict["command"] as? String {
            self.command = value
        }
        if let value = dict["cpu"] as? Double {
            self.cpu = value
        }
        if let value = dict["createdTime"] as? String {
            self.createdTime = value
        }
        if let value = dict["customDNS"] as? [String: Any?] {
            var model = CustomDNS()
            model.fromMap(value)
            self.customDNS = model
        }
        if let value = dict["customDomainName"] as? String {
            self.customDomainName = value
        }
        if let value = dict["customHealthCheckConfig"] as? [String: Any?] {
            var model = CustomHealthCheckConfig()
            model.fromMap(value)
            self.customHealthCheckConfig = model
        }
        if let value = dict["customHostAlias"] as? [String: Any?] {
            var model = CustomHostAlias()
            model.fromMap(value)
            self.customHostAlias = model
        }
        if let value = dict["customRuntimeConfig"] as? [String: Any?] {
            var model = CustomRuntimeConfig()
            model.fromMap(value)
            self.customRuntimeConfig = model
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["diskSize"] as? Int32 {
            self.diskSize = value
        }
        if let value = dict["enableAppMetric"] as? Bool {
            self.enableAppMetric = value
        }
        if let value = dict["enableArmsAdvanced"] as? Bool {
            self.enableArmsAdvanced = value
        }
        if let value = dict["environmentVariables"] as? [String: String] {
            self.environmentVariables = value
        }
        if let value = dict["gpuMemorySize"] as? Int32 {
            self.gpuMemorySize = value
        }
        if let value = dict["handler"] as? String {
            self.handler = value
        }
        if let value = dict["httpTriggerConfig"] as? [String: Any?] {
            var model = HTTPTriggerConfig()
            model.fromMap(value)
            self.httpTriggerConfig = model
        }
        if let value = dict["imageConfig"] as? [String: Any?] {
            var model = ImageConfig()
            model.fromMap(value)
            self.imageConfig = model
        }
        if let value = dict["initializationTimeout"] as? Int32 {
            self.initializationTimeout = value
        }
        if let value = dict["initializer"] as? String {
            self.initializer = value
        }
        if let value = dict["instanceConcurrency"] as? Int32 {
            self.instanceConcurrency = value
        }
        if let value = dict["instanceLifecycleConfig"] as? [String: Any?] {
            var model = InstanceLifecycleConfig()
            model.fromMap(value)
            self.instanceLifecycleConfig = model
        }
        if let value = dict["instanceSoftConcurrency"] as? Int32 {
            self.instanceSoftConcurrency = value
        }
        if let value = dict["instanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["internetAccess"] as? Bool {
            self.internetAccess = value
        }
        if let value = dict["lastModifiedTime"] as? String {
            self.lastModifiedTime = value
        }
        if let value = dict["layers"] as? [String] {
            self.layers = value
        }
        if let value = dict["layersArnV2"] as? [String] {
            self.layersArnV2 = value
        }
        if let value = dict["livenessProbe"] as? [String: Any?] {
            var model = Probe()
            model.fromMap(value)
            self.livenessProbe = model
        }
        if let value = dict["logConfig"] as? [String: Any?] {
            var model = LogConfig()
            model.fromMap(value)
            self.logConfig = model
        }
        if let value = dict["memorySize"] as? Int32 {
            self.memorySize = value
        }
        if let value = dict["namespace"] as? String {
            self.namespace = value
        }
        if let value = dict["namespaceID"] as? String {
            self.namespaceID = value
        }
        if let value = dict["namespaceName"] as? String {
            self.namespaceName = value
        }
        if let value = dict["nasConfig"] as? [String: Any?] {
            var model = NASConfig()
            model.fromMap(value)
            self.nasConfig = model
        }
        if let value = dict["ossMountConfig"] as? [String: Any?] {
            var model = OSSMountConfig()
            model.fromMap(value)
            self.ossMountConfig = model
        }
        if let value = dict["programmingLanguage"] as? String {
            self.programmingLanguage = value
        }
        if let value = dict["runtime"] as? String {
            self.runtime = value
        }
        if let value = dict["scaleConfig"] as? [String: Any?] {
            var model = ScaleConfig()
            model.fromMap(value)
            self.scaleConfig = model
        }
        if let value = dict["slsConfig"] as? [String: Any?] {
            var model = SLSConfig()
            model.fromMap(value)
            self.slsConfig = model
        }
        if let value = dict["startupProbe"] as? [String: Any?] {
            var model = Probe()
            model.fromMap(value)
            self.startupProbe = model
        }
        if let value = dict["timeout"] as? Int32 {
            self.timeout = value
        }
        if let value = dict["tracingConfig"] as? [String: Any?] {
            var model = TracingConfig()
            model.fromMap(value)
            self.tracingConfig = model
        }
        if let value = dict["urlInternet"] as? String {
            self.urlInternet = value
        }
        if let value = dict["urlIntranet"] as? String {
            self.urlIntranet = value
        }
        if let value = dict["version"] as? [String: Any?] {
            var model = Version()
            model.fromMap(value)
            self.version = model
        }
        if let value = dict["vpcConfig"] as? [String: Any?] {
            var model = VPCConfig()
            model.fromMap(value)
            self.vpcConfig = model
        }
    }
}

public class ApplicationStatus : Tea.TeaModel {
    public var instanceCount: Int64?

    public var scaleConfig: ScaleConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scaleConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceCount != nil {
            map["instanceCount"] = self.instanceCount!
        }
        if self.scaleConfig != nil {
            map["scaleConfig"] = self.scaleConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["instanceCount"] as? Int64 {
            self.instanceCount = value
        }
        if let value = dict["scaleConfig"] as? [String: Any?] {
            var model = ScaleConfig()
            model.fromMap(value)
            self.scaleConfig = model
        }
    }
}

public class ApplicationWithStatus : Tea.TeaModel {
    public var application: Application?

    public var status: ApplicationStatus?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.application?.validate()
        try self.status?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.application != nil {
            map["application"] = self.application?.toMap()
        }
        if self.status != nil {
            map["status"] = self.status?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["application"] as? [String: Any?] {
            var model = Application()
            model.fromMap(value)
            self.application = model
        }
        if let value = dict["status"] as? [String: Any?] {
            var model = ApplicationStatus()
            model.fromMap(value)
            self.status = model
        }
    }
}

public class ArmsConfig : Tea.TeaModel {
    public var agentVersion: String?

    public var appId: String?

    public var licenseKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentVersion != nil {
            map["agentVersion"] = self.agentVersion!
        }
        if self.appId != nil {
            map["appId"] = self.appId!
        }
        if self.licenseKey != nil {
            map["licenseKey"] = self.licenseKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["agentVersion"] as? String {
            self.agentVersion = value
        }
        if let value = dict["appId"] as? String {
            self.appId = value
        }
        if let value = dict["licenseKey"] as? String {
            self.licenseKey = value
        }
    }
}

public class BuildPipeline : Tea.TeaModel {
    public class BuildConfig : Tea.TeaModel {
        public var beforeBuildCommand: String?

        public var buildType: String?

        public var dockerfilePath: String?

        public var runCommand: String?

        public var runtimeType: String?

        public var runtimeVersion: String?

        public var tomcatConfig: TomcatConfig?

        public var workingDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.tomcatConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.beforeBuildCommand != nil {
                map["BeforeBuildCommand"] = self.beforeBuildCommand!
            }
            if self.buildType != nil {
                map["BuildType"] = self.buildType!
            }
            if self.dockerfilePath != nil {
                map["DockerfilePath"] = self.dockerfilePath!
            }
            if self.runCommand != nil {
                map["RunCommand"] = self.runCommand!
            }
            if self.runtimeType != nil {
                map["RuntimeType"] = self.runtimeType!
            }
            if self.runtimeVersion != nil {
                map["RuntimeVersion"] = self.runtimeVersion!
            }
            if self.tomcatConfig != nil {
                map["TomcatConfig"] = self.tomcatConfig?.toMap()
            }
            if self.workingDir != nil {
                map["WorkingDir"] = self.workingDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BeforeBuildCommand"] as? String {
                self.beforeBuildCommand = value
            }
            if let value = dict["BuildType"] as? String {
                self.buildType = value
            }
            if let value = dict["DockerfilePath"] as? String {
                self.dockerfilePath = value
            }
            if let value = dict["RunCommand"] as? String {
                self.runCommand = value
            }
            if let value = dict["RuntimeType"] as? String {
                self.runtimeType = value
            }
            if let value = dict["RuntimeVersion"] as? String {
                self.runtimeVersion = value
            }
            if let value = dict["TomcatConfig"] as? [String: Any?] {
                var model = TomcatConfig()
                model.fromMap(value)
                self.tomcatConfig = model
            }
            if let value = dict["WorkingDir"] as? String {
                self.workingDir = value
            }
        }
    }
    public class CodeConfig : Tea.TeaModel {
        public var accountId: String?

        public var branchName: String?

        public var commitId: String?

        public var commitUrl: String?

        public var organizationId: String?

        public var provider: String?

        public var repoFullName: String?

        public var repoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.branchName != nil {
                map["BranchName"] = self.branchName!
            }
            if self.commitId != nil {
                map["CommitId"] = self.commitId!
            }
            if self.commitUrl != nil {
                map["CommitUrl"] = self.commitUrl!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.provider != nil {
                map["Provider"] = self.provider!
            }
            if self.repoFullName != nil {
                map["RepoFullName"] = self.repoFullName!
            }
            if self.repoId != nil {
                map["RepoId"] = self.repoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? String {
                self.accountId = value
            }
            if let value = dict["BranchName"] as? String {
                self.branchName = value
            }
            if let value = dict["CommitId"] as? String {
                self.commitId = value
            }
            if let value = dict["CommitUrl"] as? String {
                self.commitUrl = value
            }
            if let value = dict["OrganizationId"] as? String {
                self.organizationId = value
            }
            if let value = dict["Provider"] as? String {
                self.provider = value
            }
            if let value = dict["RepoFullName"] as? String {
                self.repoFullName = value
            }
            if let value = dict["RepoId"] as? String {
                self.repoId = value
            }
        }
    }
    public class DeployConfig : Tea.TeaModel {
        public var alwaysAllocateCPU: Bool?

        public var maximumInstanceCount: Int32?

        public var minimumInstanceCount: Int32?

        public var updateApplicationInput: String?

        public var updateTraffic: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alwaysAllocateCPU != nil {
                map["AlwaysAllocateCPU"] = self.alwaysAllocateCPU!
            }
            if self.maximumInstanceCount != nil {
                map["MaximumInstanceCount"] = self.maximumInstanceCount!
            }
            if self.minimumInstanceCount != nil {
                map["MinimumInstanceCount"] = self.minimumInstanceCount!
            }
            if self.updateApplicationInput != nil {
                map["UpdateApplicationInput"] = self.updateApplicationInput!
            }
            if self.updateTraffic != nil {
                map["UpdateTraffic"] = self.updateTraffic!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlwaysAllocateCPU"] as? Bool {
                self.alwaysAllocateCPU = value
            }
            if let value = dict["MaximumInstanceCount"] as? Int32 {
                self.maximumInstanceCount = value
            }
            if let value = dict["MinimumInstanceCount"] as? Int32 {
                self.minimumInstanceCount = value
            }
            if let value = dict["UpdateApplicationInput"] as? String {
                self.updateApplicationInput = value
            }
            if let value = dict["UpdateTraffic"] as? Bool {
                self.updateTraffic = value
            }
        }
    }
    public class ImageConfig : Tea.TeaModel {
        public var instanceType: String?

        public var namespace: String?

        public var repository: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.repository != nil {
                map["Repository"] = self.repository!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["Namespace"] as? String {
                self.namespace = value
            }
            if let value = dict["Repository"] as? String {
                self.repository = value
            }
        }
    }
    public class PackageConfig : Tea.TeaModel {
        public var packageName: String?

        public var packageType: String?

        public var packageUrl: String?

        public var packageVersion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.packageName != nil {
                map["PackageName"] = self.packageName!
            }
            if self.packageType != nil {
                map["PackageType"] = self.packageType!
            }
            if self.packageUrl != nil {
                map["PackageUrl"] = self.packageUrl!
            }
            if self.packageVersion != nil {
                map["PackageVersion"] = self.packageVersion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PackageName"] as? String {
                self.packageName = value
            }
            if let value = dict["PackageType"] as? String {
                self.packageType = value
            }
            if let value = dict["PackageUrl"] as? String {
                self.packageUrl = value
            }
            if let value = dict["PackageVersion"] as? String {
                self.packageVersion = value
            }
        }
    }
    public class TriggerConfig : Tea.TeaModel {
        public var branchName: String?

        public var tagName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.branchName != nil {
                map["BranchName"] = self.branchName!
            }
            if self.tagName != nil {
                map["TagName"] = self.tagName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BranchName"] as? String {
                self.branchName = value
            }
            if let value = dict["TagName"] as? String {
                self.tagName = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var applicationId: String?

    public var applicationName: String?

    public var buildConfig: BuildPipeline.BuildConfig?

    public var codeConfig: BuildPipeline.CodeConfig?

    public var deployConfig: BuildPipeline.DeployConfig?

    public var enabled: Bool?

    public var imageConfig: BuildPipeline.ImageConfig?

    public var packageConfig: BuildPipeline.PackageConfig?

    public var triggerConfig: BuildPipeline.TriggerConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.buildConfig?.validate()
        try self.codeConfig?.validate()
        try self.deployConfig?.validate()
        try self.imageConfig?.validate()
        try self.packageConfig?.validate()
        try self.triggerConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.applicationName != nil {
            map["ApplicationName"] = self.applicationName!
        }
        if self.buildConfig != nil {
            map["BuildConfig"] = self.buildConfig?.toMap()
        }
        if self.codeConfig != nil {
            map["CodeConfig"] = self.codeConfig?.toMap()
        }
        if self.deployConfig != nil {
            map["DeployConfig"] = self.deployConfig?.toMap()
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.imageConfig != nil {
            map["ImageConfig"] = self.imageConfig?.toMap()
        }
        if self.packageConfig != nil {
            map["PackageConfig"] = self.packageConfig?.toMap()
        }
        if self.triggerConfig != nil {
            map["TriggerConfig"] = self.triggerConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["ApplicationName"] as? String {
            self.applicationName = value
        }
        if let value = dict["BuildConfig"] as? [String: Any?] {
            var model = BuildPipeline.BuildConfig()
            model.fromMap(value)
            self.buildConfig = model
        }
        if let value = dict["CodeConfig"] as? [String: Any?] {
            var model = BuildPipeline.CodeConfig()
            model.fromMap(value)
            self.codeConfig = model
        }
        if let value = dict["DeployConfig"] as? [String: Any?] {
            var model = BuildPipeline.DeployConfig()
            model.fromMap(value)
            self.deployConfig = model
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["ImageConfig"] as? [String: Any?] {
            var model = BuildPipeline.ImageConfig()
            model.fromMap(value)
            self.imageConfig = model
        }
        if let value = dict["PackageConfig"] as? [String: Any?] {
            var model = BuildPipeline.PackageConfig()
            model.fromMap(value)
            self.packageConfig = model
        }
        if let value = dict["TriggerConfig"] as? [String: Any?] {
            var model = BuildPipeline.TriggerConfig()
            model.fromMap(value)
            self.triggerConfig = model
        }
    }
}

public class BuildPipelineRun : Tea.TeaModel {
    public class BuildConfig : Tea.TeaModel {
        public class Trigger : Tea.TeaModel {
            public var branchName: String?

            public var tagName: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.branchName != nil {
                    map["BranchName"] = self.branchName!
                }
                if self.tagName != nil {
                    map["TagName"] = self.tagName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BranchName"] as? String {
                    self.branchName = value
                }
                if let value = dict["TagName"] as? String {
                    self.tagName = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var beforeBuildCommand: String?

        public var buildType: String?

        public var dockerfilePath: String?

        public var runCommand: String?

        public var runtimeType: String?

        public var runtimeVersion: String?

        public var tomcatConfig: TomcatConfig?

        public var trigger: BuildPipelineRun.BuildConfig.Trigger?

        public var workingDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.tomcatConfig?.validate()
            try self.trigger?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.beforeBuildCommand != nil {
                map["BeforeBuildCommand"] = self.beforeBuildCommand!
            }
            if self.buildType != nil {
                map["BuildType"] = self.buildType!
            }
            if self.dockerfilePath != nil {
                map["DockerfilePath"] = self.dockerfilePath!
            }
            if self.runCommand != nil {
                map["RunCommand"] = self.runCommand!
            }
            if self.runtimeType != nil {
                map["RuntimeType"] = self.runtimeType!
            }
            if self.runtimeVersion != nil {
                map["RuntimeVersion"] = self.runtimeVersion!
            }
            if self.tomcatConfig != nil {
                map["TomcatConfig"] = self.tomcatConfig?.toMap()
            }
            if self.trigger != nil {
                map["Trigger"] = self.trigger?.toMap()
            }
            if self.workingDir != nil {
                map["WorkingDir"] = self.workingDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BeforeBuildCommand"] as? String {
                self.beforeBuildCommand = value
            }
            if let value = dict["BuildType"] as? String {
                self.buildType = value
            }
            if let value = dict["DockerfilePath"] as? String {
                self.dockerfilePath = value
            }
            if let value = dict["RunCommand"] as? String {
                self.runCommand = value
            }
            if let value = dict["RuntimeType"] as? String {
                self.runtimeType = value
            }
            if let value = dict["RuntimeVersion"] as? String {
                self.runtimeVersion = value
            }
            if let value = dict["TomcatConfig"] as? [String: Any?] {
                var model = TomcatConfig()
                model.fromMap(value)
                self.tomcatConfig = model
            }
            if let value = dict["Trigger"] as? [String: Any?] {
                var model = BuildPipelineRun.BuildConfig.Trigger()
                model.fromMap(value)
                self.trigger = model
            }
            if let value = dict["WorkingDir"] as? String {
                self.workingDir = value
            }
        }
    }
    public class CodeConfig : Tea.TeaModel {
        public var accountId: String?

        public var branchName: String?

        public var commitId: String?

        public var commitUrl: String?

        public var organizationId: String?

        public var provider: String?

        public var repoFullName: String?

        public var repoId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.branchName != nil {
                map["BranchName"] = self.branchName!
            }
            if self.commitId != nil {
                map["CommitId"] = self.commitId!
            }
            if self.commitUrl != nil {
                map["CommitUrl"] = self.commitUrl!
            }
            if self.organizationId != nil {
                map["OrganizationId"] = self.organizationId!
            }
            if self.provider != nil {
                map["Provider"] = self.provider!
            }
            if self.repoFullName != nil {
                map["RepoFullName"] = self.repoFullName!
            }
            if self.repoId != nil {
                map["RepoId"] = self.repoId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountId"] as? String {
                self.accountId = value
            }
            if let value = dict["BranchName"] as? String {
                self.branchName = value
            }
            if let value = dict["CommitId"] as? String {
                self.commitId = value
            }
            if let value = dict["CommitUrl"] as? String {
                self.commitUrl = value
            }
            if let value = dict["OrganizationId"] as? String {
                self.organizationId = value
            }
            if let value = dict["Provider"] as? String {
                self.provider = value
            }
            if let value = dict["RepoFullName"] as? String {
                self.repoFullName = value
            }
            if let value = dict["RepoId"] as? String {
                self.repoId = value
            }
        }
    }
    public class DeployConfig : Tea.TeaModel {
        public var alwaysAllocateCPU: Bool?

        public var maximumInstanceCount: Int32?

        public var minimumInstanceCount: Int32?

        public var updateApplicationInput: String?

        public var updateTraffic: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alwaysAllocateCPU != nil {
                map["AlwaysAllocateCPU"] = self.alwaysAllocateCPU!
            }
            if self.maximumInstanceCount != nil {
                map["MaximumInstanceCount"] = self.maximumInstanceCount!
            }
            if self.minimumInstanceCount != nil {
                map["MinimumInstanceCount"] = self.minimumInstanceCount!
            }
            if self.updateApplicationInput != nil {
                map["UpdateApplicationInput"] = self.updateApplicationInput!
            }
            if self.updateTraffic != nil {
                map["UpdateTraffic"] = self.updateTraffic!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlwaysAllocateCPU"] as? Bool {
                self.alwaysAllocateCPU = value
            }
            if let value = dict["MaximumInstanceCount"] as? Int32 {
                self.maximumInstanceCount = value
            }
            if let value = dict["MinimumInstanceCount"] as? Int32 {
                self.minimumInstanceCount = value
            }
            if let value = dict["UpdateApplicationInput"] as? String {
                self.updateApplicationInput = value
            }
            if let value = dict["UpdateTraffic"] as? Bool {
                self.updateTraffic = value
            }
        }
    }
    public class ImageConfig : Tea.TeaModel {
        public var instanceType: String?

        public var namespace: String?

        public var repository: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.namespace != nil {
                map["Namespace"] = self.namespace!
            }
            if self.repository != nil {
                map["Repository"] = self.repository!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceType"] as? String {
                self.instanceType = value
            }
            if let value = dict["Namespace"] as? String {
                self.namespace = value
            }
            if let value = dict["Repository"] as? String {
                self.repository = value
            }
        }
    }
    public class PackageConfig : Tea.TeaModel {
        public var packageName: String?

        public var packageType: String?

        public var packageUrl: String?

        public var packageVersion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.packageName != nil {
                map["PackageName"] = self.packageName!
            }
            if self.packageType != nil {
                map["PackageType"] = self.packageType!
            }
            if self.packageUrl != nil {
                map["PackageUrl"] = self.packageUrl!
            }
            if self.packageVersion != nil {
                map["PackageVersion"] = self.packageVersion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PackageName"] as? String {
                self.packageName = value
            }
            if let value = dict["PackageType"] as? String {
                self.packageType = value
            }
            if let value = dict["PackageUrl"] as? String {
                self.packageUrl = value
            }
            if let value = dict["PackageVersion"] as? String {
                self.packageVersion = value
            }
        }
    }
    public class Steps : Tea.TeaModel {
        public var description_: String?

        public var duration: Int64?

        public var endTime: Int64?

        public var id: String?

        public var name: String?

        public var result: String?

        public var startTime: Int64?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.result != nil {
                map["Result"] = self.result!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Duration"] as? Int64 {
                self.duration = value
            }
            if let value = dict["EndTime"] as? Int64 {
                self.endTime = value
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Result"] as? String {
                self.result = value
            }
            if let value = dict["StartTime"] as? Int64 {
                self.startTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public class TriggerConfig : Tea.TeaModel {
        public var branchName: String?

        public var tagName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.branchName != nil {
                map["BranchName"] = self.branchName!
            }
            if self.tagName != nil {
                map["TagName"] = self.tagName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BranchName"] as? String {
                self.branchName = value
            }
            if let value = dict["TagName"] as? String {
                self.tagName = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var buildConfig: BuildPipelineRun.BuildConfig?

    public var buildDuration: Int64?

    public var codeConfig: BuildPipelineRun.CodeConfig?

    public var createTime: Int64?

    public var deployConfig: BuildPipelineRun.DeployConfig?

    public var deployDuration: Int64?

    public var endTime: Int64?

    public var imageConfig: BuildPipelineRun.ImageConfig?

    public var packageConfig: BuildPipelineRun.PackageConfig?

    public var pipelineId: String?

    public var pipelineRunId: String?

    public var startTime: Int64?

    public var status: String?

    public var steps: [BuildPipelineRun.Steps]?

    public var triggerConfig: BuildPipelineRun.TriggerConfig?

    public var versionId: String?

    public var waitDuration: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.buildConfig?.validate()
        try self.codeConfig?.validate()
        try self.deployConfig?.validate()
        try self.imageConfig?.validate()
        try self.packageConfig?.validate()
        try self.triggerConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.buildConfig != nil {
            map["BuildConfig"] = self.buildConfig?.toMap()
        }
        if self.buildDuration != nil {
            map["BuildDuration"] = self.buildDuration!
        }
        if self.codeConfig != nil {
            map["CodeConfig"] = self.codeConfig?.toMap()
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.deployConfig != nil {
            map["DeployConfig"] = self.deployConfig?.toMap()
        }
        if self.deployDuration != nil {
            map["DeployDuration"] = self.deployDuration!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.imageConfig != nil {
            map["ImageConfig"] = self.imageConfig?.toMap()
        }
        if self.packageConfig != nil {
            map["PackageConfig"] = self.packageConfig?.toMap()
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.pipelineRunId != nil {
            map["PipelineRunId"] = self.pipelineRunId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.steps != nil {
            var tmp : [Any] = []
            for k in self.steps! {
                tmp.append(k.toMap())
            }
            map["Steps"] = tmp
        }
        if self.triggerConfig != nil {
            map["TriggerConfig"] = self.triggerConfig?.toMap()
        }
        if self.versionId != nil {
            map["VersionId"] = self.versionId!
        }
        if self.waitDuration != nil {
            map["WaitDuration"] = self.waitDuration!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BuildConfig"] as? [String: Any?] {
            var model = BuildPipelineRun.BuildConfig()
            model.fromMap(value)
            self.buildConfig = model
        }
        if let value = dict["BuildDuration"] as? Int64 {
            self.buildDuration = value
        }
        if let value = dict["CodeConfig"] as? [String: Any?] {
            var model = BuildPipelineRun.CodeConfig()
            model.fromMap(value)
            self.codeConfig = model
        }
        if let value = dict["CreateTime"] as? Int64 {
            self.createTime = value
        }
        if let value = dict["DeployConfig"] as? [String: Any?] {
            var model = BuildPipelineRun.DeployConfig()
            model.fromMap(value)
            self.deployConfig = model
        }
        if let value = dict["DeployDuration"] as? Int64 {
            self.deployDuration = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["ImageConfig"] as? [String: Any?] {
            var model = BuildPipelineRun.ImageConfig()
            model.fromMap(value)
            self.imageConfig = model
        }
        if let value = dict["PackageConfig"] as? [String: Any?] {
            var model = BuildPipelineRun.PackageConfig()
            model.fromMap(value)
            self.packageConfig = model
        }
        if let value = dict["PipelineId"] as? String {
            self.pipelineId = value
        }
        if let value = dict["PipelineRunId"] as? String {
            self.pipelineRunId = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["Steps"] as? [Any?] {
            var tmp : [BuildPipelineRun.Steps] = []
            for v in value {
                if v != nil {
                    var model = BuildPipelineRun.Steps()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.steps = tmp
        }
        if let value = dict["TriggerConfig"] as? [String: Any?] {
            var model = BuildPipelineRun.TriggerConfig()
            model.fromMap(value)
            self.triggerConfig = model
        }
        if let value = dict["VersionId"] as? String {
            self.versionId = value
        }
        if let value = dict["WaitDuration"] as? Int64 {
            self.waitDuration = value
        }
    }
}

public class BuildPipelineRunLogLine : Tea.TeaModel {
    public var content: String?

    public var offset: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["Offset"] as? Int64 {
            self.offset = value
        }
    }
}

public class CertConfig : Tea.TeaModel {
    public var certName: String?

    public var certificate: String?

    public var privateKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certName != nil {
            map["certName"] = self.certName!
        }
        if self.certificate != nil {
            map["certificate"] = self.certificate!
        }
        if self.privateKey != nil {
            map["privateKey"] = self.privateKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["certName"] as? String {
            self.certName = value
        }
        if let value = dict["certificate"] as? String {
            self.certificate = value
        }
        if let value = dict["privateKey"] as? String {
            self.privateKey = value
        }
    }
}

public class Container : Tea.TeaModel {
    public var args: String?

    public var command: String?

    public var environmentVariables: [String: String]?

    public var image: String?

    public var imageRegistryConfig: ImageRegistryConfig?

    public var metricsCollectConfig: MetricsCollectConfig?

    public var port: Int32?

    public var requestConcurrency: Int32?

    public var requestTimeout: Int32?

    public var resources: ContainerResources?

    public var SLSCollectConfigs: SLSCollectConfigs?

    public var startupProbe: StartupProbe?

    public var webNASConfig: WebNASConfig?

    public var webOSSConfig: WebOSSConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageRegistryConfig?.validate()
        try self.metricsCollectConfig?.validate()
        try self.resources?.validate()
        try self.SLSCollectConfigs?.validate()
        try self.startupProbe?.validate()
        try self.webNASConfig?.validate()
        try self.webOSSConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.args != nil {
            map["Args"] = self.args!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.environmentVariables != nil {
            map["EnvironmentVariables"] = self.environmentVariables!
        }
        if self.image != nil {
            map["Image"] = self.image!
        }
        if self.imageRegistryConfig != nil {
            map["ImageRegistryConfig"] = self.imageRegistryConfig?.toMap()
        }
        if self.metricsCollectConfig != nil {
            map["MetricsCollectConfig"] = self.metricsCollectConfig?.toMap()
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.requestConcurrency != nil {
            map["RequestConcurrency"] = self.requestConcurrency!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.resources != nil {
            map["Resources"] = self.resources?.toMap()
        }
        if self.SLSCollectConfigs != nil {
            map["SLSCollectConfigs"] = self.SLSCollectConfigs?.toMap()
        }
        if self.startupProbe != nil {
            map["StartupProbe"] = self.startupProbe?.toMap()
        }
        if self.webNASConfig != nil {
            map["WebNASConfig"] = self.webNASConfig?.toMap()
        }
        if self.webOSSConfig != nil {
            map["WebOSSConfig"] = self.webOSSConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Args"] as? String {
            self.args = value
        }
        if let value = dict["Command"] as? String {
            self.command = value
        }
        if let value = dict["EnvironmentVariables"] as? [String: String] {
            self.environmentVariables = value
        }
        if let value = dict["Image"] as? String {
            self.image = value
        }
        if let value = dict["ImageRegistryConfig"] as? [String: Any?] {
            var model = ImageRegistryConfig()
            model.fromMap(value)
            self.imageRegistryConfig = model
        }
        if let value = dict["MetricsCollectConfig"] as? [String: Any?] {
            var model = MetricsCollectConfig()
            model.fromMap(value)
            self.metricsCollectConfig = model
        }
        if let value = dict["Port"] as? Int32 {
            self.port = value
        }
        if let value = dict["RequestConcurrency"] as? Int32 {
            self.requestConcurrency = value
        }
        if let value = dict["RequestTimeout"] as? Int32 {
            self.requestTimeout = value
        }
        if let value = dict["Resources"] as? [String: Any?] {
            var model = ContainerResources()
            model.fromMap(value)
            self.resources = model
        }
        if let value = dict["SLSCollectConfigs"] as? [String: Any?] {
            var model = SLSCollectConfigs()
            model.fromMap(value)
            self.SLSCollectConfigs = model
        }
        if let value = dict["StartupProbe"] as? [String: Any?] {
            var model = StartupProbe()
            model.fromMap(value)
            self.startupProbe = model
        }
        if let value = dict["WebNASConfig"] as? [String: Any?] {
            var model = WebNASConfig()
            model.fromMap(value)
            self.webNASConfig = model
        }
        if let value = dict["WebOSSConfig"] as? [String: Any?] {
            var model = WebOSSConfig()
            model.fromMap(value)
            self.webOSSConfig = model
        }
    }
}

public class ContainerResources : Tea.TeaModel {
    public var cpu: Int32?

    public var memory: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Cpu"] as? Int32 {
            self.cpu = value
        }
        if let value = dict["Memory"] as? Int32 {
            self.memory = value
        }
    }
}

public class CreateApplicationInput : Tea.TeaModel {
    public var applicationName: String?

    public var args: String?

    public var caPort: Int32?

    public var code: InputCodeLocation?

    public var command: String?

    public var cpu: Double?

    public var customDNS: CustomDNS?

    public var customHealthCheckConfig: CustomHealthCheckConfig?

    public var customHostAlias: CustomHostAlias?

    public var customRuntimeConfig: CustomRuntimeConfig?

    public var description_: String?

    public var diskSize: Int32?

    public var enableAppMetric: Bool?

    public var environmentVariables: [String: String]?

    public var gpuMemorySize: Int32?

    public var handler: String?

    public var httpTriggerConfig: HTTPTriggerConfig?

    public var imageConfig: ImageConfig?

    public var initializationTimeout: Int32?

    public var initializer: String?

    public var instanceConcurrency: Int32?

    public var instanceLifecycleConfig: InstanceLifecycleConfig?

    public var instanceSoftConcurrency: Int32?

    public var instanceType: String?

    public var internetAccess: Bool?

    public var layers: [String]?

    public var livenessProbe: Probe?

    public var logConfig: LogConfig?

    public var memorySize: Int32?

    public var namespaceID: String?

    public var nasConfig: NASConfig?

    public var ossMountConfig: OSSMountConfig?

    public var programmingLanguage: String?

    public var runtime: String?

    public var scaleConfig: ScaleConfig?

    public var slsConfig: SLSConfig?

    public var startupProbe: Probe?

    public var timeout: Int32?

    public var tracingConfig: TracingConfig?

    public var vpcConfig: VPCConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.code?.validate()
        try self.customDNS?.validate()
        try self.customHealthCheckConfig?.validate()
        try self.customHostAlias?.validate()
        try self.customRuntimeConfig?.validate()
        try self.httpTriggerConfig?.validate()
        try self.imageConfig?.validate()
        try self.instanceLifecycleConfig?.validate()
        try self.livenessProbe?.validate()
        try self.logConfig?.validate()
        try self.nasConfig?.validate()
        try self.ossMountConfig?.validate()
        try self.scaleConfig?.validate()
        try self.slsConfig?.validate()
        try self.startupProbe?.validate()
        try self.tracingConfig?.validate()
        try self.vpcConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationName != nil {
            map["applicationName"] = self.applicationName!
        }
        if self.args != nil {
            map["args"] = self.args!
        }
        if self.caPort != nil {
            map["caPort"] = self.caPort!
        }
        if self.code != nil {
            map["code"] = self.code?.toMap()
        }
        if self.command != nil {
            map["command"] = self.command!
        }
        if self.cpu != nil {
            map["cpu"] = self.cpu!
        }
        if self.customDNS != nil {
            map["customDNS"] = self.customDNS?.toMap()
        }
        if self.customHealthCheckConfig != nil {
            map["customHealthCheckConfig"] = self.customHealthCheckConfig?.toMap()
        }
        if self.customHostAlias != nil {
            map["customHostAlias"] = self.customHostAlias?.toMap()
        }
        if self.customRuntimeConfig != nil {
            map["customRuntimeConfig"] = self.customRuntimeConfig?.toMap()
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.diskSize != nil {
            map["diskSize"] = self.diskSize!
        }
        if self.enableAppMetric != nil {
            map["enableAppMetric"] = self.enableAppMetric!
        }
        if self.environmentVariables != nil {
            map["environmentVariables"] = self.environmentVariables!
        }
        if self.gpuMemorySize != nil {
            map["gpuMemorySize"] = self.gpuMemorySize!
        }
        if self.handler != nil {
            map["handler"] = self.handler!
        }
        if self.httpTriggerConfig != nil {
            map["httpTriggerConfig"] = self.httpTriggerConfig?.toMap()
        }
        if self.imageConfig != nil {
            map["imageConfig"] = self.imageConfig?.toMap()
        }
        if self.initializationTimeout != nil {
            map["initializationTimeout"] = self.initializationTimeout!
        }
        if self.initializer != nil {
            map["initializer"] = self.initializer!
        }
        if self.instanceConcurrency != nil {
            map["instanceConcurrency"] = self.instanceConcurrency!
        }
        if self.instanceLifecycleConfig != nil {
            map["instanceLifecycleConfig"] = self.instanceLifecycleConfig?.toMap()
        }
        if self.instanceSoftConcurrency != nil {
            map["instanceSoftConcurrency"] = self.instanceSoftConcurrency!
        }
        if self.instanceType != nil {
            map["instanceType"] = self.instanceType!
        }
        if self.internetAccess != nil {
            map["internetAccess"] = self.internetAccess!
        }
        if self.layers != nil {
            map["layers"] = self.layers!
        }
        if self.livenessProbe != nil {
            map["livenessProbe"] = self.livenessProbe?.toMap()
        }
        if self.logConfig != nil {
            map["logConfig"] = self.logConfig?.toMap()
        }
        if self.memorySize != nil {
            map["memorySize"] = self.memorySize!
        }
        if self.namespaceID != nil {
            map["namespaceID"] = self.namespaceID!
        }
        if self.nasConfig != nil {
            map["nasConfig"] = self.nasConfig?.toMap()
        }
        if self.ossMountConfig != nil {
            map["ossMountConfig"] = self.ossMountConfig?.toMap()
        }
        if self.programmingLanguage != nil {
            map["programmingLanguage"] = self.programmingLanguage!
        }
        if self.runtime != nil {
            map["runtime"] = self.runtime!
        }
        if self.scaleConfig != nil {
            map["scaleConfig"] = self.scaleConfig?.toMap()
        }
        if self.slsConfig != nil {
            map["slsConfig"] = self.slsConfig?.toMap()
        }
        if self.startupProbe != nil {
            map["startupProbe"] = self.startupProbe?.toMap()
        }
        if self.timeout != nil {
            map["timeout"] = self.timeout!
        }
        if self.tracingConfig != nil {
            map["tracingConfig"] = self.tracingConfig?.toMap()
        }
        if self.vpcConfig != nil {
            map["vpcConfig"] = self.vpcConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["applicationName"] as? String {
            self.applicationName = value
        }
        if let value = dict["args"] as? String {
            self.args = value
        }
        if let value = dict["caPort"] as? Int32 {
            self.caPort = value
        }
        if let value = dict["code"] as? [String: Any?] {
            var model = InputCodeLocation()
            model.fromMap(value)
            self.code = model
        }
        if let value = dict["command"] as? String {
            self.command = value
        }
        if let value = dict["cpu"] as? Double {
            self.cpu = value
        }
        if let value = dict["customDNS"] as? [String: Any?] {
            var model = CustomDNS()
            model.fromMap(value)
            self.customDNS = model
        }
        if let value = dict["customHealthCheckConfig"] as? [String: Any?] {
            var model = CustomHealthCheckConfig()
            model.fromMap(value)
            self.customHealthCheckConfig = model
        }
        if let value = dict["customHostAlias"] as? [String: Any?] {
            var model = CustomHostAlias()
            model.fromMap(value)
            self.customHostAlias = model
        }
        if let value = dict["customRuntimeConfig"] as? [String: Any?] {
            var model = CustomRuntimeConfig()
            model.fromMap(value)
            self.customRuntimeConfig = model
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["diskSize"] as? Int32 {
            self.diskSize = value
        }
        if let value = dict["enableAppMetric"] as? Bool {
            self.enableAppMetric = value
        }
        if let value = dict["environmentVariables"] as? [String: String] {
            self.environmentVariables = value
        }
        if let value = dict["gpuMemorySize"] as? Int32 {
            self.gpuMemorySize = value
        }
        if let value = dict["handler"] as? String {
            self.handler = value
        }
        if let value = dict["httpTriggerConfig"] as? [String: Any?] {
            var model = HTTPTriggerConfig()
            model.fromMap(value)
            self.httpTriggerConfig = model
        }
        if let value = dict["imageConfig"] as? [String: Any?] {
            var model = ImageConfig()
            model.fromMap(value)
            self.imageConfig = model
        }
        if let value = dict["initializationTimeout"] as? Int32 {
            self.initializationTimeout = value
        }
        if let value = dict["initializer"] as? String {
            self.initializer = value
        }
        if let value = dict["instanceConcurrency"] as? Int32 {
            self.instanceConcurrency = value
        }
        if let value = dict["instanceLifecycleConfig"] as? [String: Any?] {
            var model = InstanceLifecycleConfig()
            model.fromMap(value)
            self.instanceLifecycleConfig = model
        }
        if let value = dict["instanceSoftConcurrency"] as? Int32 {
            self.instanceSoftConcurrency = value
        }
        if let value = dict["instanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["internetAccess"] as? Bool {
            self.internetAccess = value
        }
        if let value = dict["layers"] as? [String] {
            self.layers = value
        }
        if let value = dict["livenessProbe"] as? [String: Any?] {
            var model = Probe()
            model.fromMap(value)
            self.livenessProbe = model
        }
        if let value = dict["logConfig"] as? [String: Any?] {
            var model = LogConfig()
            model.fromMap(value)
            self.logConfig = model
        }
        if let value = dict["memorySize"] as? Int32 {
            self.memorySize = value
        }
        if let value = dict["namespaceID"] as? String {
            self.namespaceID = value
        }
        if let value = dict["nasConfig"] as? [String: Any?] {
            var model = NASConfig()
            model.fromMap(value)
            self.nasConfig = model
        }
        if let value = dict["ossMountConfig"] as? [String: Any?] {
            var model = OSSMountConfig()
            model.fromMap(value)
            self.ossMountConfig = model
        }
        if let value = dict["programmingLanguage"] as? String {
            self.programmingLanguage = value
        }
        if let value = dict["runtime"] as? String {
            self.runtime = value
        }
        if let value = dict["scaleConfig"] as? [String: Any?] {
            var model = ScaleConfig()
            model.fromMap(value)
            self.scaleConfig = model
        }
        if let value = dict["slsConfig"] as? [String: Any?] {
            var model = SLSConfig()
            model.fromMap(value)
            self.slsConfig = model
        }
        if let value = dict["startupProbe"] as? [String: Any?] {
            var model = Probe()
            model.fromMap(value)
            self.startupProbe = model
        }
        if let value = dict["timeout"] as? Int32 {
            self.timeout = value
        }
        if let value = dict["tracingConfig"] as? [String: Any?] {
            var model = TracingConfig()
            model.fromMap(value)
            self.tracingConfig = model
        }
        if let value = dict["vpcConfig"] as? [String: Any?] {
            var model = VPCConfig()
            model.fromMap(value)
            self.vpcConfig = model
        }
    }
}

public class CreateCustomDomainInput : Tea.TeaModel {
    public var applicationName: String?

    public var certConfig: CertConfig?

    public var domainName: String?

    public var keepFullPath: Bool?

    public var namespaceID: String?

    public var protocol_: String?

    public var tlsConfig: TLSConfig?

    public var wafConfig: WAFConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.certConfig?.validate()
        try self.tlsConfig?.validate()
        try self.wafConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationName != nil {
            map["applicationName"] = self.applicationName!
        }
        if self.certConfig != nil {
            map["certConfig"] = self.certConfig?.toMap()
        }
        if self.domainName != nil {
            map["domainName"] = self.domainName!
        }
        if self.keepFullPath != nil {
            map["keepFullPath"] = self.keepFullPath!
        }
        if self.namespaceID != nil {
            map["namespaceID"] = self.namespaceID!
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.tlsConfig != nil {
            map["tlsConfig"] = self.tlsConfig?.toMap()
        }
        if self.wafConfig != nil {
            map["wafConfig"] = self.wafConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["applicationName"] as? String {
            self.applicationName = value
        }
        if let value = dict["certConfig"] as? [String: Any?] {
            var model = CertConfig()
            model.fromMap(value)
            self.certConfig = model
        }
        if let value = dict["domainName"] as? String {
            self.domainName = value
        }
        if let value = dict["keepFullPath"] as? Bool {
            self.keepFullPath = value
        }
        if let value = dict["namespaceID"] as? String {
            self.namespaceID = value
        }
        if let value = dict["protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["tlsConfig"] as? [String: Any?] {
            var model = TLSConfig()
            model.fromMap(value)
            self.tlsConfig = model
        }
        if let value = dict["wafConfig"] as? [String: Any?] {
            var model = WAFConfig()
            model.fromMap(value)
            self.wafConfig = model
        }
    }
}

public class CreateSlsIndexRequest : Tea.TeaModel {
    public var logstore: String?

    public var project: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logstore != nil {
            map["logstore"] = self.logstore!
        }
        if self.project != nil {
            map["project"] = self.project!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["logstore"] as? String {
            self.logstore = value
        }
        if let value = dict["project"] as? String {
            self.project = value
        }
    }
}

public class CreateSlsIndexResponse : Tea.TeaModel {
    public var requestId: String?

    public var logStore: String?

    public var project: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.logStore != nil {
            map["logStore"] = self.logStore!
        }
        if self.project != nil {
            map["project"] = self.project!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["logStore"] as? String {
            self.logStore = value
        }
        if let value = dict["project"] as? String {
            self.project = value
        }
    }
}

public class CreateSlsResourceResponse : Tea.TeaModel {
    public var logStore: String?

    public var project: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logStore != nil {
            map["logStore"] = self.logStore!
        }
        if self.project != nil {
            map["project"] = self.project!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["logStore"] as? String {
            self.logStore = value
        }
        if let value = dict["project"] as? String {
            self.project = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateWebApplicationInput : Tea.TeaModel {
    public var applicationName: String?

    public var description_: String?

    public var revisionConfig: RevisionConfig?

    public var webNetworkConfig: WebNetworkConfig?

    public var webScalingConfig: WebScalingConfig?

    public var webTrafficConfig: WebTrafficConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.revisionConfig?.validate()
        try self.webNetworkConfig?.validate()
        try self.webScalingConfig?.validate()
        try self.webTrafficConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationName != nil {
            map["ApplicationName"] = self.applicationName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.revisionConfig != nil {
            map["RevisionConfig"] = self.revisionConfig?.toMap()
        }
        if self.webNetworkConfig != nil {
            map["WebNetworkConfig"] = self.webNetworkConfig?.toMap()
        }
        if self.webScalingConfig != nil {
            map["WebScalingConfig"] = self.webScalingConfig?.toMap()
        }
        if self.webTrafficConfig != nil {
            map["WebTrafficConfig"] = self.webTrafficConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationName"] as? String {
            self.applicationName = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["RevisionConfig"] as? [String: Any?] {
            var model = RevisionConfig()
            model.fromMap(value)
            self.revisionConfig = model
        }
        if let value = dict["WebNetworkConfig"] as? [String: Any?] {
            var model = WebNetworkConfig()
            model.fromMap(value)
            self.webNetworkConfig = model
        }
        if let value = dict["WebScalingConfig"] as? [String: Any?] {
            var model = WebScalingConfig()
            model.fromMap(value)
            self.webScalingConfig = model
        }
        if let value = dict["WebTrafficConfig"] as? [String: Any?] {
            var model = WebTrafficConfig()
            model.fromMap(value)
            self.webTrafficConfig = model
        }
    }
}

public class CreateWebCustomDomainInput : Tea.TeaModel {
    public var defaultForwardingAppName: String?

    public var domainName: String?

    public var protocol_: String?

    public var routeConfig: RouteConfig?

    public var webCertConfig: WebCertConfig?

    public var webTLSConfig: WebTLSConfig?

    public var webWAFConfig: WebWAFConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routeConfig?.validate()
        try self.webCertConfig?.validate()
        try self.webTLSConfig?.validate()
        try self.webWAFConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultForwardingAppName != nil {
            map["DefaultForwardingAppName"] = self.defaultForwardingAppName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.routeConfig != nil {
            map["RouteConfig"] = self.routeConfig?.toMap()
        }
        if self.webCertConfig != nil {
            map["WebCertConfig"] = self.webCertConfig?.toMap()
        }
        if self.webTLSConfig != nil {
            map["WebTLSConfig"] = self.webTLSConfig?.toMap()
        }
        if self.webWAFConfig != nil {
            map["WebWAFConfig"] = self.webWAFConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DefaultForwardingAppName"] as? String {
            self.defaultForwardingAppName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["Protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["RouteConfig"] as? [String: Any?] {
            var model = RouteConfig()
            model.fromMap(value)
            self.routeConfig = model
        }
        if let value = dict["WebCertConfig"] as? [String: Any?] {
            var model = WebCertConfig()
            model.fromMap(value)
            self.webCertConfig = model
        }
        if let value = dict["WebTLSConfig"] as? [String: Any?] {
            var model = WebTLSConfig()
            model.fromMap(value)
            self.webTLSConfig = model
        }
        if let value = dict["WebWAFConfig"] as? [String: Any?] {
            var model = WebWAFConfig()
            model.fromMap(value)
            self.webWAFConfig = model
        }
    }
}

public class CustomDNS : Tea.TeaModel {
    public var dnsOptions: [DNSOption]?

    public var nameServers: [String]?

    public var searches: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dnsOptions != nil {
            var tmp : [Any] = []
            for k in self.dnsOptions! {
                tmp.append(k.toMap())
            }
            map["dnsOptions"] = tmp
        }
        if self.nameServers != nil {
            map["nameServers"] = self.nameServers!
        }
        if self.searches != nil {
            map["searches"] = self.searches!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["dnsOptions"] as? [Any?] {
            var tmp : [DNSOption] = []
            for v in value {
                if v != nil {
                    var model = DNSOption()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dnsOptions = tmp
        }
        if let value = dict["nameServers"] as? [String] {
            self.nameServers = value
        }
        if let value = dict["searches"] as? [String] {
            self.searches = value
        }
    }
}

public class CustomDomain : Tea.TeaModel {
    public var accountId: String?

    public var apiVersion: String?

    public var certConfig: CertConfig?

    public var createdTime: String?

    public var domainName: String?

    public var keepFullPath: Bool?

    public var lastModifiedTime: String?

    public var namespaceID: String?

    public var protocol_: String?

    public var requestId: String?

    public var routeConfig: RouteConfig?

    public var subdomainCount: String?

    public var tlsConfig: TLSConfig?

    public var wafConfig: WAFConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.certConfig?.validate()
        try self.routeConfig?.validate()
        try self.tlsConfig?.validate()
        try self.wafConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["accountId"] = self.accountId!
        }
        if self.apiVersion != nil {
            map["apiVersion"] = self.apiVersion!
        }
        if self.certConfig != nil {
            map["certConfig"] = self.certConfig?.toMap()
        }
        if self.createdTime != nil {
            map["createdTime"] = self.createdTime!
        }
        if self.domainName != nil {
            map["domainName"] = self.domainName!
        }
        if self.keepFullPath != nil {
            map["keepFullPath"] = self.keepFullPath!
        }
        if self.lastModifiedTime != nil {
            map["lastModifiedTime"] = self.lastModifiedTime!
        }
        if self.namespaceID != nil {
            map["namespaceID"] = self.namespaceID!
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.routeConfig != nil {
            map["routeConfig"] = self.routeConfig?.toMap()
        }
        if self.subdomainCount != nil {
            map["subdomainCount"] = self.subdomainCount!
        }
        if self.tlsConfig != nil {
            map["tlsConfig"] = self.tlsConfig?.toMap()
        }
        if self.wafConfig != nil {
            map["wafConfig"] = self.wafConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accountId"] as? String {
            self.accountId = value
        }
        if let value = dict["apiVersion"] as? String {
            self.apiVersion = value
        }
        if let value = dict["certConfig"] as? [String: Any?] {
            var model = CertConfig()
            model.fromMap(value)
            self.certConfig = model
        }
        if let value = dict["createdTime"] as? String {
            self.createdTime = value
        }
        if let value = dict["domainName"] as? String {
            self.domainName = value
        }
        if let value = dict["keepFullPath"] as? Bool {
            self.keepFullPath = value
        }
        if let value = dict["lastModifiedTime"] as? String {
            self.lastModifiedTime = value
        }
        if let value = dict["namespaceID"] as? String {
            self.namespaceID = value
        }
        if let value = dict["protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["routeConfig"] as? [String: Any?] {
            var model = RouteConfig()
            model.fromMap(value)
            self.routeConfig = model
        }
        if let value = dict["subdomainCount"] as? String {
            self.subdomainCount = value
        }
        if let value = dict["tlsConfig"] as? [String: Any?] {
            var model = TLSConfig()
            model.fromMap(value)
            self.tlsConfig = model
        }
        if let value = dict["wafConfig"] as? [String: Any?] {
            var model = WAFConfig()
            model.fromMap(value)
            self.wafConfig = model
        }
    }
}

public class CustomHealthCheckConfig : Tea.TeaModel {
    public var failureThreshold: Int32?

    public var httpGetUrl: String?

    public var initialDelaySeconds: Int32?

    public var periodSeconds: Int32?

    public var successThreshold: Int32?

    public var timeoutSeconds: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failureThreshold != nil {
            map["failureThreshold"] = self.failureThreshold!
        }
        if self.httpGetUrl != nil {
            map["httpGetUrl"] = self.httpGetUrl!
        }
        if self.initialDelaySeconds != nil {
            map["initialDelaySeconds"] = self.initialDelaySeconds!
        }
        if self.periodSeconds != nil {
            map["periodSeconds"] = self.periodSeconds!
        }
        if self.successThreshold != nil {
            map["successThreshold"] = self.successThreshold!
        }
        if self.timeoutSeconds != nil {
            map["timeoutSeconds"] = self.timeoutSeconds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["failureThreshold"] as? Int32 {
            self.failureThreshold = value
        }
        if let value = dict["httpGetUrl"] as? String {
            self.httpGetUrl = value
        }
        if let value = dict["initialDelaySeconds"] as? Int32 {
            self.initialDelaySeconds = value
        }
        if let value = dict["periodSeconds"] as? Int32 {
            self.periodSeconds = value
        }
        if let value = dict["successThreshold"] as? Int32 {
            self.successThreshold = value
        }
        if let value = dict["timeoutSeconds"] as? Int32 {
            self.timeoutSeconds = value
        }
    }
}

public class CustomHostAlias : Tea.TeaModel {
    public var hostAliases: [HostAlias]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hostAliases != nil {
            var tmp : [Any] = []
            for k in self.hostAliases! {
                tmp.append(k.toMap())
            }
            map["hostAliases"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["hostAliases"] as? [Any?] {
            var tmp : [HostAlias] = []
            for v in value {
                if v != nil {
                    var model = HostAlias()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.hostAliases = tmp
        }
    }
}

public class CustomRuntimeConfig : Tea.TeaModel {
    public var args: [String]?

    public var command: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.args != nil {
            map["args"] = self.args!
        }
        if self.command != nil {
            map["command"] = self.command!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["args"] as? [String] {
            self.args = value
        }
        if let value = dict["command"] as? [String] {
            self.command = value
        }
    }
}

public class DNSOption : Tea.TeaModel {
    public var name: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.value != nil {
            map["value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["value"] as? String {
            self.value = value
        }
    }
}

public class DescribeInstanceLogsOutput : Tea.TeaModel {
    public var webLogEntrys: [WebLogEntry]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.webLogEntrys != nil {
            var tmp : [Any] = []
            for k in self.webLogEntrys! {
                tmp.append(k.toMap())
            }
            map["WebLogEntrys"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["WebLogEntrys"] as? [Any?] {
            var tmp : [WebLogEntry] = []
            for v in value {
                if v != nil {
                    var model = WebLogEntry()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.webLogEntrys = tmp
        }
    }
}

public class DescribeWebAppStaticsOutput : Tea.TeaModel {
    public var length: Int32?

    public var webAppStatics: [WebStaticsInfo]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.length != nil {
            map["Length"] = self.length!
        }
        if self.webAppStatics != nil {
            var tmp : [Any] = []
            for k in self.webAppStatics! {
                tmp.append(k.toMap())
            }
            map["WebAppStatics"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Length"] as? Int32 {
            self.length = value
        }
        if let value = dict["WebAppStatics"] as? [Any?] {
            var tmp : [WebStaticsInfo] = []
            for v in value {
                if v != nil {
                    var model = WebStaticsInfo()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.webAppStatics = tmp
        }
    }
}

public class DescribeWebStaticsQueryOutput : Tea.TeaModel {
    public var length: Int32?

    public var webStatics: [WebStaticsInfo]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.length != nil {
            map["Length"] = self.length!
        }
        if self.webStatics != nil {
            var tmp : [Any] = []
            for k in self.webStatics! {
                tmp.append(k.toMap())
            }
            map["WebStatics"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Length"] as? Int32 {
            self.length = value
        }
        if let value = dict["WebStatics"] as? [Any?] {
            var tmp : [WebStaticsInfo] = []
            for v in value {
                if v != nil {
                    var model = WebStaticsInfo()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.webStatics = tmp
        }
    }
}

public class ExecAction : Tea.TeaModel {
    public var command: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.command != nil {
            map["command"] = self.command!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["command"] as? [String] {
            self.command = value
        }
    }
}

public class ExternalErrorSAEWeb : Tea.TeaModel {
    public var code: Int32?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["code"] = self.code!
        }
        if self.errorCode != nil {
            map["errorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.success != nil {
            map["success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["code"] as? Int32 {
            self.code = value
        }
        if let value = dict["errorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["message"] as? String {
            self.message = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["success"] as? Bool {
            self.success = value
        }
    }
}

public class GRPCAction : Tea.TeaModel {
    public var port: Int32?

    public var service: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.port != nil {
            map["port"] = self.port!
        }
        if self.service != nil {
            map["service"] = self.service!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["port"] as? Int32 {
            self.port = value
        }
        if let value = dict["service"] as? String {
            self.service = value
        }
    }
}

public class GetApplicationLogsInput : Tea.TeaModel {
    public var backwardLine: Int64?

    public var endTime: Int64?

    public var forwardLine: Int64?

    public var instanceID: String?

    public var isTail: Bool?

    public var match: String?

    public var message: String?

    public var offset: Int64?

    public var packID: String?

    public var packMeta: String?

    public var startTime: Int64?

    public var timestamp: String?

    public var versionID: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backwardLine != nil {
            map["backwardLine"] = self.backwardLine!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.forwardLine != nil {
            map["forwardLine"] = self.forwardLine!
        }
        if self.instanceID != nil {
            map["instanceID"] = self.instanceID!
        }
        if self.isTail != nil {
            map["isTail"] = self.isTail!
        }
        if self.match != nil {
            map["match"] = self.match!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.offset != nil {
            map["offset"] = self.offset!
        }
        if self.packID != nil {
            map["packID"] = self.packID!
        }
        if self.packMeta != nil {
            map["packMeta"] = self.packMeta!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        if self.versionID != nil {
            map["versionID"] = self.versionID!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["backwardLine"] as? Int64 {
            self.backwardLine = value
        }
        if let value = dict["endTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["forwardLine"] as? Int64 {
            self.forwardLine = value
        }
        if let value = dict["instanceID"] as? String {
            self.instanceID = value
        }
        if let value = dict["isTail"] as? Bool {
            self.isTail = value
        }
        if let value = dict["match"] as? String {
            self.match = value
        }
        if let value = dict["message"] as? String {
            self.message = value
        }
        if let value = dict["offset"] as? Int64 {
            self.offset = value
        }
        if let value = dict["packID"] as? String {
            self.packID = value
        }
        if let value = dict["packMeta"] as? String {
            self.packMeta = value
        }
        if let value = dict["startTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["timestamp"] as? String {
            self.timestamp = value
        }
        if let value = dict["versionID"] as? String {
            self.versionID = value
        }
    }
}

public class GetApplicationLogsOutput : Tea.TeaModel {
    public var logEntrys: [LogEntry]?

    public var nextOffset: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logEntrys != nil {
            var tmp : [Any] = []
            for k in self.logEntrys! {
                tmp.append(k.toMap())
            }
            map["logEntrys"] = tmp
        }
        if self.nextOffset != nil {
            map["nextOffset"] = self.nextOffset!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["logEntrys"] as? [Any?] {
            var tmp : [LogEntry] = []
            for v in value {
                if v != nil {
                    var model = LogEntry()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.logEntrys = tmp
        }
        if let value = dict["nextOffset"] as? Int64 {
            self.nextOffset = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetInstanceLogsInput : Tea.TeaModel {
    public var backwardLine: Int64?

    public var endTime: Int64?

    public var forwardLine: Int64?

    public var isTail: Bool?

    public var match: String?

    public var message: String?

    public var offset: Int64?

    public var packID: String?

    public var packMeta: String?

    public var startTime: Int64?

    public var timestamp: String?

    public var versionID: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backwardLine != nil {
            map["backwardLine"] = self.backwardLine!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.forwardLine != nil {
            map["forwardLine"] = self.forwardLine!
        }
        if self.isTail != nil {
            map["isTail"] = self.isTail!
        }
        if self.match != nil {
            map["match"] = self.match!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.offset != nil {
            map["offset"] = self.offset!
        }
        if self.packID != nil {
            map["packID"] = self.packID!
        }
        if self.packMeta != nil {
            map["packMeta"] = self.packMeta!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        if self.versionID != nil {
            map["versionID"] = self.versionID!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["backwardLine"] as? Int64 {
            self.backwardLine = value
        }
        if let value = dict["endTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["forwardLine"] as? Int64 {
            self.forwardLine = value
        }
        if let value = dict["isTail"] as? Bool {
            self.isTail = value
        }
        if let value = dict["match"] as? String {
            self.match = value
        }
        if let value = dict["message"] as? String {
            self.message = value
        }
        if let value = dict["offset"] as? Int64 {
            self.offset = value
        }
        if let value = dict["packID"] as? String {
            self.packID = value
        }
        if let value = dict["packMeta"] as? String {
            self.packMeta = value
        }
        if let value = dict["startTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["timestamp"] as? String {
            self.timestamp = value
        }
        if let value = dict["versionID"] as? String {
            self.versionID = value
        }
    }
}

public class GetInstanceLogsOutput : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["data"] as? String {
            self.data = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetPerRequestLogsInput : Tea.TeaModel {
    public var endTime: Int64?

    public var errorType: String?

    public var forwardLine: Int64?

    public var instanceID: String?

    public var isColdStart: Bool?

    public var requestID: String?

    public var startTime: Int64?

    public var timestamp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.errorType != nil {
            map["errorType"] = self.errorType!
        }
        if self.forwardLine != nil {
            map["forwardLine"] = self.forwardLine!
        }
        if self.instanceID != nil {
            map["instanceID"] = self.instanceID!
        }
        if self.isColdStart != nil {
            map["isColdStart"] = self.isColdStart!
        }
        if self.requestID != nil {
            map["requestID"] = self.requestID!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["errorType"] as? String {
            self.errorType = value
        }
        if let value = dict["forwardLine"] as? Int64 {
            self.forwardLine = value
        }
        if let value = dict["instanceID"] as? String {
            self.instanceID = value
        }
        if let value = dict["isColdStart"] as? Bool {
            self.isColdStart = value
        }
        if let value = dict["requestID"] as? String {
            self.requestID = value
        }
        if let value = dict["startTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["timestamp"] as? String {
            self.timestamp = value
        }
    }
}

public class GetPerRequestLogsOutput : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["data"] = self.data!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["data"] as? String {
            self.data = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetQuotaOutput : Tea.TeaModel {
    public var requestId: String?

    public var instanceLimit: Int64?

    public var instanceUsed: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.instanceLimit != nil {
            map["instanceLimit"] = self.instanceLimit!
        }
        if self.instanceUsed != nil {
            map["instanceUsed"] = self.instanceUsed!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["instanceLimit"] as? Int64 {
            self.instanceLimit = value
        }
        if let value = dict["instanceUsed"] as? Int64 {
            self.instanceUsed = value
        }
    }
}

public class HTTPGetAction : Tea.TeaModel {
    public var host: String?

    public var httpHeaders: [HTTPHeader]?

    public var path: String?

    public var port: Int32?

    public var scheme: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.httpHeaders != nil {
            var tmp : [Any] = []
            for k in self.httpHeaders! {
                tmp.append(k.toMap())
            }
            map["HttpHeaders"] = tmp
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.scheme != nil {
            map["Scheme"] = self.scheme!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Host"] as? String {
            self.host = value
        }
        if let value = dict["HttpHeaders"] as? [Any?] {
            var tmp : [HTTPHeader] = []
            for v in value {
                if v != nil {
                    var model = HTTPHeader()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.httpHeaders = tmp
        }
        if let value = dict["Path"] as? String {
            self.path = value
        }
        if let value = dict["Port"] as? Int32 {
            self.port = value
        }
        if let value = dict["Scheme"] as? String {
            self.scheme = value
        }
    }
}

public class HTTPHeader : Tea.TeaModel {
    public var name: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.value != nil {
            map["value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["value"] as? String {
            self.value = value
        }
    }
}

public class HTTPTriggerConfig : Tea.TeaModel {
    public var aclConfig: AclConfig?

    public var authConfig: Any?

    public var authType: String?

    public var disableURLInternet: Bool?

    public var safeMode: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.aclConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclConfig != nil {
            map["aclConfig"] = self.aclConfig?.toMap()
        }
        if self.authConfig != nil {
            map["authConfig"] = self.authConfig!
        }
        if self.authType != nil {
            map["authType"] = self.authType!
        }
        if self.disableURLInternet != nil {
            map["disableURLInternet"] = self.disableURLInternet!
        }
        if self.safeMode != nil {
            map["safeMode"] = self.safeMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["aclConfig"] as? [String: Any?] {
            var model = AclConfig()
            model.fromMap(value)
            self.aclConfig = model
        }
        if let value = dict["authConfig"] as? Any {
            self.authConfig = value
        }
        if let value = dict["authType"] as? String {
            self.authType = value
        }
        if let value = dict["disableURLInternet"] as? Bool {
            self.disableURLInternet = value
        }
        if let value = dict["safeMode"] as? Bool {
            self.safeMode = value
        }
    }
}

public class HostAlias : Tea.TeaModel {
    public var hostnames: [String]?

    public var ip: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hostnames != nil {
            map["hostnames"] = self.hostnames!
        }
        if self.ip != nil {
            map["ip"] = self.ip!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["hostnames"] as? [String] {
            self.hostnames = value
        }
        if let value = dict["ip"] as? String {
            self.ip = value
        }
    }
}

public class HttpApiRoute : Tea.TeaModel {
    public class Domains : Tea.TeaModel {
        public var domainId: String?

        public var domainName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DomainId"] as? String {
                self.domainId = value
            }
            if let value = dict["DomainName"] as? String {
                self.domainName = value
            }
        }
    }
    public class Policies : Tea.TeaModel {
        public class Fallback : Tea.TeaModel {
            public class Destinations : Tea.TeaModel {
                public var appId: String?

                public var appName: String?

                public var serviceId: String?

                public var serviceName: String?

                public var servicePort: Int64?

                public var serviceProtocol: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appName != nil {
                        map["AppName"] = self.appName!
                    }
                    if self.serviceId != nil {
                        map["ServiceId"] = self.serviceId!
                    }
                    if self.serviceName != nil {
                        map["ServiceName"] = self.serviceName!
                    }
                    if self.servicePort != nil {
                        map["ServicePort"] = self.servicePort!
                    }
                    if self.serviceProtocol != nil {
                        map["ServiceProtocol"] = self.serviceProtocol!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AppId"] as? String {
                        self.appId = value
                    }
                    if let value = dict["AppName"] as? String {
                        self.appName = value
                    }
                    if let value = dict["ServiceId"] as? String {
                        self.serviceId = value
                    }
                    if let value = dict["ServiceName"] as? String {
                        self.serviceName = value
                    }
                    if let value = dict["ServicePort"] as? Int64 {
                        self.servicePort = value
                    }
                    if let value = dict["ServiceProtocol"] as? String {
                        self.serviceProtocol = value
                    }
                }
            }
            public var destinations: [HttpApiRoute.Policies.Fallback.Destinations]?

            public var enable: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.destinations != nil {
                    var tmp : [Any] = []
                    for k in self.destinations! {
                        tmp.append(k.toMap())
                    }
                    map["Destinations"] = tmp
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Destinations"] as? [Any?] {
                    var tmp : [HttpApiRoute.Policies.Fallback.Destinations] = []
                    for v in value {
                        if v != nil {
                            var model = HttpApiRoute.Policies.Fallback.Destinations()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.destinations = tmp
                }
                if let value = dict["Enable"] as? Bool {
                    self.enable = value
                }
            }
        }
        public class Retry : Tea.TeaModel {
            public var attempts: Int64?

            public var enable: Bool?

            public var httpCodes: [String]?

            public var retryOn: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attempts != nil {
                    map["Attempts"] = self.attempts!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.httpCodes != nil {
                    map["HttpCodes"] = self.httpCodes!
                }
                if self.retryOn != nil {
                    map["RetryOn"] = self.retryOn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Attempts"] as? Int64 {
                    self.attempts = value
                }
                if let value = dict["Enable"] as? Bool {
                    self.enable = value
                }
                if let value = dict["HttpCodes"] as? [String] {
                    self.httpCodes = value
                }
                if let value = dict["RetryOn"] as? [String] {
                    self.retryOn = value
                }
            }
        }
        public class Timeout : Tea.TeaModel {
            public var enable: Bool?

            public var timeUnit: String?

            public var unitNum: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.timeUnit != nil {
                    map["TimeUnit"] = self.timeUnit!
                }
                if self.unitNum != nil {
                    map["UnitNum"] = self.unitNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Enable"] as? Bool {
                    self.enable = value
                }
                if let value = dict["TimeUnit"] as? String {
                    self.timeUnit = value
                }
                if let value = dict["UnitNum"] as? Int64 {
                    self.unitNum = value
                }
            }
        }
        public var fallback: HttpApiRoute.Policies.Fallback?

        public var retry: HttpApiRoute.Policies.Retry?

        public var timeout: HttpApiRoute.Policies.Timeout?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.fallback?.validate()
            try self.retry?.validate()
            try self.timeout?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fallback != nil {
                map["Fallback"] = self.fallback?.toMap()
            }
            if self.retry != nil {
                map["Retry"] = self.retry?.toMap()
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Fallback"] as? [String: Any?] {
                var model = HttpApiRoute.Policies.Fallback()
                model.fromMap(value)
                self.fallback = model
            }
            if let value = dict["Retry"] as? [String: Any?] {
                var model = HttpApiRoute.Policies.Retry()
                model.fromMap(value)
                self.retry = model
            }
            if let value = dict["Timeout"] as? [String: Any?] {
                var model = HttpApiRoute.Policies.Timeout()
                model.fromMap(value)
                self.timeout = model
            }
        }
    }
    public class Predicates : Tea.TeaModel {
        public class HeaderPredicates : Tea.TeaModel {
            public var name: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public class PathPredicates : Tea.TeaModel {
            public var ignoreCase: Bool?

            public var path: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ignoreCase != nil {
                    map["IgnoreCase"] = self.ignoreCase!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IgnoreCase"] as? Bool {
                    self.ignoreCase = value
                }
                if let value = dict["Path"] as? String {
                    self.path = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public class QueryPredicates : Tea.TeaModel {
            public var name: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var headerPredicates: [HttpApiRoute.Predicates.HeaderPredicates]?

        public var methodPredicates: [String]?

        public var pathPredicates: HttpApiRoute.Predicates.PathPredicates?

        public var queryPredicates: [HttpApiRoute.Predicates.QueryPredicates]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.pathPredicates?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.headerPredicates != nil {
                var tmp : [Any] = []
                for k in self.headerPredicates! {
                    tmp.append(k.toMap())
                }
                map["HeaderPredicates"] = tmp
            }
            if self.methodPredicates != nil {
                map["MethodPredicates"] = self.methodPredicates!
            }
            if self.pathPredicates != nil {
                map["PathPredicates"] = self.pathPredicates?.toMap()
            }
            if self.queryPredicates != nil {
                var tmp : [Any] = []
                for k in self.queryPredicates! {
                    tmp.append(k.toMap())
                }
                map["QueryPredicates"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HeaderPredicates"] as? [Any?] {
                var tmp : [HttpApiRoute.Predicates.HeaderPredicates] = []
                for v in value {
                    if v != nil {
                        var model = HttpApiRoute.Predicates.HeaderPredicates()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.headerPredicates = tmp
            }
            if let value = dict["MethodPredicates"] as? [String] {
                self.methodPredicates = value
            }
            if let value = dict["PathPredicates"] as? [String: Any?] {
                var model = HttpApiRoute.Predicates.PathPredicates()
                model.fromMap(value)
                self.pathPredicates = model
            }
            if let value = dict["QueryPredicates"] as? [Any?] {
                var tmp : [HttpApiRoute.Predicates.QueryPredicates] = []
                for v in value {
                    if v != nil {
                        var model = HttpApiRoute.Predicates.QueryPredicates()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.queryPredicates = tmp
            }
        }
    }
    public class Services : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var serviceId: String?

        public var serviceName: String?

        public var servicePort: Int64?

        public var serviceProtocol: String?

        public var serviceWeight: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.servicePort != nil {
                map["ServicePort"] = self.servicePort!
            }
            if self.serviceProtocol != nil {
                map["ServiceProtocol"] = self.serviceProtocol!
            }
            if self.serviceWeight != nil {
                map["ServiceWeight"] = self.serviceWeight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["ServiceId"] as? String {
                self.serviceId = value
            }
            if let value = dict["ServiceName"] as? String {
                self.serviceName = value
            }
            if let value = dict["ServicePort"] as? Int64 {
                self.servicePort = value
            }
            if let value = dict["ServiceProtocol"] as? String {
                self.serviceProtocol = value
            }
            if let value = dict["ServiceWeight"] as? Int64 {
                self.serviceWeight = value
            }
        }
    }
    public var addressType: String?

    public var deployStatus: String?

    public var destinationType: String?

    public var domains: [HttpApiRoute.Domains]?

    public var environmentId: String?

    public var gatewayId: String?

    public var httpApiId: String?

    public var httpApiName: String?

    public var httpApiType: String?

    public var ingressId: Int64?

    public var nacosInstanceId: String?

    public var nacosNamespaceId: String?

    public var name: String?

    public var namespaceId: String?

    public var policies: HttpApiRoute.Policies?

    public var predicates: HttpApiRoute.Predicates?

    public var routeId: String?

    public var services: [HttpApiRoute.Services]?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.policies?.validate()
        try self.predicates?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressType != nil {
            map["AddressType"] = self.addressType!
        }
        if self.deployStatus != nil {
            map["DeployStatus"] = self.deployStatus!
        }
        if self.destinationType != nil {
            map["DestinationType"] = self.destinationType!
        }
        if self.domains != nil {
            var tmp : [Any] = []
            for k in self.domains! {
                tmp.append(k.toMap())
            }
            map["Domains"] = tmp
        }
        if self.environmentId != nil {
            map["EnvironmentId"] = self.environmentId!
        }
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        if self.httpApiId != nil {
            map["HttpApiId"] = self.httpApiId!
        }
        if self.httpApiName != nil {
            map["HttpApiName"] = self.httpApiName!
        }
        if self.httpApiType != nil {
            map["HttpApiType"] = self.httpApiType!
        }
        if self.ingressId != nil {
            map["IngressId"] = self.ingressId!
        }
        if self.nacosInstanceId != nil {
            map["NacosInstanceId"] = self.nacosInstanceId!
        }
        if self.nacosNamespaceId != nil {
            map["NacosNamespaceId"] = self.nacosNamespaceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.policies != nil {
            map["Policies"] = self.policies?.toMap()
        }
        if self.predicates != nil {
            map["Predicates"] = self.predicates?.toMap()
        }
        if self.routeId != nil {
            map["RouteId"] = self.routeId!
        }
        if self.services != nil {
            var tmp : [Any] = []
            for k in self.services! {
                tmp.append(k.toMap())
            }
            map["Services"] = tmp
        }
        if self.sourceType != nil {
            map["SourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressType"] as? String {
            self.addressType = value
        }
        if let value = dict["DeployStatus"] as? String {
            self.deployStatus = value
        }
        if let value = dict["DestinationType"] as? String {
            self.destinationType = value
        }
        if let value = dict["Domains"] as? [Any?] {
            var tmp : [HttpApiRoute.Domains] = []
            for v in value {
                if v != nil {
                    var model = HttpApiRoute.Domains()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.domains = tmp
        }
        if let value = dict["EnvironmentId"] as? String {
            self.environmentId = value
        }
        if let value = dict["GatewayId"] as? String {
            self.gatewayId = value
        }
        if let value = dict["HttpApiId"] as? String {
            self.httpApiId = value
        }
        if let value = dict["HttpApiName"] as? String {
            self.httpApiName = value
        }
        if let value = dict["HttpApiType"] as? String {
            self.httpApiType = value
        }
        if let value = dict["IngressId"] as? Int64 {
            self.ingressId = value
        }
        if let value = dict["NacosInstanceId"] as? String {
            self.nacosInstanceId = value
        }
        if let value = dict["NacosNamespaceId"] as? String {
            self.nacosNamespaceId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["Policies"] as? [String: Any?] {
            var model = HttpApiRoute.Policies()
            model.fromMap(value)
            self.policies = model
        }
        if let value = dict["Predicates"] as? [String: Any?] {
            var model = HttpApiRoute.Predicates()
            model.fromMap(value)
            self.predicates = model
        }
        if let value = dict["RouteId"] as? String {
            self.routeId = value
        }
        if let value = dict["Services"] as? [Any?] {
            var tmp : [HttpApiRoute.Services] = []
            for v in value {
                if v != nil {
                    var model = HttpApiRoute.Services()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.services = tmp
        }
        if let value = dict["SourceType"] as? String {
            self.sourceType = value
        }
    }
}

public class ImageConfig : Tea.TeaModel {
    public var accelerationType: String?

    public var image: String?

    public var instanceID: String?

    public var registryConfig: RegistryConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.registryConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerationType != nil {
            map["accelerationType"] = self.accelerationType!
        }
        if self.image != nil {
            map["image"] = self.image!
        }
        if self.instanceID != nil {
            map["instanceID"] = self.instanceID!
        }
        if self.registryConfig != nil {
            map["registryConfig"] = self.registryConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accelerationType"] as? String {
            self.accelerationType = value
        }
        if let value = dict["image"] as? String {
            self.image = value
        }
        if let value = dict["instanceID"] as? String {
            self.instanceID = value
        }
        if let value = dict["registryConfig"] as? [String: Any?] {
            var model = RegistryConfig()
            model.fromMap(value)
            self.registryConfig = model
        }
    }
}

public class ImageRegistryConfig : Tea.TeaModel {
    public var authConfig: RegistryAuthenticationConfig?

    public var certConfig: RegistryCertificateConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authConfig?.validate()
        try self.certConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authConfig != nil {
            map["AuthConfig"] = self.authConfig?.toMap()
        }
        if self.certConfig != nil {
            map["CertConfig"] = self.certConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AuthConfig"] as? [String: Any?] {
            var model = RegistryAuthenticationConfig()
            model.fromMap(value)
            self.authConfig = model
        }
        if let value = dict["CertConfig"] as? [String: Any?] {
            var model = RegistryCertificateConfig()
            model.fromMap(value)
            self.certConfig = model
        }
    }
}

public class InitContainerConfig : Tea.TeaModel {
    public var command: String?

    public var commandArgs: String?

    public var configMapMountDesc: String?

    public var emptyDirDesc: String?

    public var envs: String?

    public var imageUrl: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.commandArgs != nil {
            map["CommandArgs"] = self.commandArgs!
        }
        if self.configMapMountDesc != nil {
            map["ConfigMapMountDesc"] = self.configMapMountDesc!
        }
        if self.emptyDirDesc != nil {
            map["EmptyDirDesc"] = self.emptyDirDesc!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Command"] as? String {
            self.command = value
        }
        if let value = dict["CommandArgs"] as? String {
            self.commandArgs = value
        }
        if let value = dict["ConfigMapMountDesc"] as? String {
            self.configMapMountDesc = value
        }
        if let value = dict["EmptyDirDesc"] as? String {
            self.emptyDirDesc = value
        }
        if let value = dict["Envs"] as? String {
            self.envs = value
        }
        if let value = dict["ImageUrl"] as? String {
            self.imageUrl = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
    }
}

public class InputCodeLocation : Tea.TeaModel {
    public var ossBucketName: String?

    public var ossObjectName: String?

    public var zipFile: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ossBucketName != nil {
            map["ossBucketName"] = self.ossBucketName!
        }
        if self.ossObjectName != nil {
            map["ossObjectName"] = self.ossObjectName!
        }
        if self.zipFile != nil {
            map["zipFile"] = self.zipFile!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ossBucketName"] as? String {
            self.ossBucketName = value
        }
        if let value = dict["ossObjectName"] as? String {
            self.ossObjectName = value
        }
        if let value = dict["zipFile"] as? String {
            self.zipFile = value
        }
    }
}

public class InstanceExecAuthorizationInput : Tea.TeaModel {
    public var options: InstanceExecAuthorizationInputOptions?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.options?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.options != nil {
            map["options"] = self.options?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["options"] as? [String: Any?] {
            var model = InstanceExecAuthorizationInputOptions()
            model.fromMap(value)
            self.options = model
        }
    }
}

public class InstanceExecAuthorizationInputOptions : Tea.TeaModel {
    public var command: [String]?

    public var stderr: Bool?

    public var stdin: Bool?

    public var stdout: Bool?

    public var tty: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.command != nil {
            map["command"] = self.command!
        }
        if self.stderr != nil {
            map["stderr"] = self.stderr!
        }
        if self.stdin != nil {
            map["stdin"] = self.stdin!
        }
        if self.stdout != nil {
            map["stdout"] = self.stdout!
        }
        if self.tty != nil {
            map["tty"] = self.tty!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["command"] as? [String] {
            self.command = value
        }
        if let value = dict["stderr"] as? Bool {
            self.stderr = value
        }
        if let value = dict["stdin"] as? Bool {
            self.stdin = value
        }
        if let value = dict["stdout"] as? Bool {
            self.stdout = value
        }
        if let value = dict["tty"] as? Bool {
            self.tty = value
        }
    }
}

public class InstanceExecAuthorizationOutput : Tea.TeaModel {
    public var accessKeyId: String?

    public var accountId: String?

    public var authorization: String?

    public var date: String?

    public var endpoint: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessKeyId != nil {
            map["accessKeyId"] = self.accessKeyId!
        }
        if self.accountId != nil {
            map["accountId"] = self.accountId!
        }
        if self.authorization != nil {
            map["authorization"] = self.authorization!
        }
        if self.date != nil {
            map["date"] = self.date!
        }
        if self.endpoint != nil {
            map["endpoint"] = self.endpoint!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["accessKeyId"] as? String {
            self.accessKeyId = value
        }
        if let value = dict["accountId"] as? String {
            self.accountId = value
        }
        if let value = dict["authorization"] as? String {
            self.authorization = value
        }
        if let value = dict["date"] as? String {
            self.date = value
        }
        if let value = dict["endpoint"] as? String {
            self.endpoint = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
    }
}

public class InstanceInfo : Tea.TeaModel {
    public var imageUrl: String?

    public var instanceId: String?

    public var status: String?

    public var versionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageUrl != nil {
            map["imageUrl"] = self.imageUrl!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.versionId != nil {
            map["versionId"] = self.versionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["imageUrl"] as? String {
            self.imageUrl = value
        }
        if let value = dict["instanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["status"] as? String {
            self.status = value
        }
        if let value = dict["versionId"] as? String {
            self.versionId = value
        }
    }
}

public class InstanceLifecycleConfig : Tea.TeaModel {
    public var preFreeze: LifecycleHook?

    public var preStop: LifecycleHook?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.preFreeze?.validate()
        try self.preStop?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.preFreeze != nil {
            map["preFreeze"] = self.preFreeze?.toMap()
        }
        if self.preStop != nil {
            map["preStop"] = self.preStop?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["preFreeze"] as? [String: Any?] {
            var model = LifecycleHook()
            model.fromMap(value)
            self.preFreeze = model
        }
        if let value = dict["preStop"] as? [String: Any?] {
            var model = LifecycleHook()
            model.fromMap(value)
            self.preStop = model
        }
    }
}

public class InstanceMetricInfo : Tea.TeaModel {
    public var applicationID: String?

    public var cpuPercent: Double?

    public var cpuQuotaPercent: Double?

    public var instanceID: String?

    public var memoryLimitMB: Double?

    public var memoryUsageMB: Double?

    public var timestamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationID != nil {
            map["applicationID"] = self.applicationID!
        }
        if self.cpuPercent != nil {
            map["cpuPercent"] = self.cpuPercent!
        }
        if self.cpuQuotaPercent != nil {
            map["cpuQuotaPercent"] = self.cpuQuotaPercent!
        }
        if self.instanceID != nil {
            map["instanceID"] = self.instanceID!
        }
        if self.memoryLimitMB != nil {
            map["memoryLimitMB"] = self.memoryLimitMB!
        }
        if self.memoryUsageMB != nil {
            map["memoryUsageMB"] = self.memoryUsageMB!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["applicationID"] as? String {
            self.applicationID = value
        }
        if let value = dict["cpuPercent"] as? Double {
            self.cpuPercent = value
        }
        if let value = dict["cpuQuotaPercent"] as? Double {
            self.cpuQuotaPercent = value
        }
        if let value = dict["instanceID"] as? String {
            self.instanceID = value
        }
        if let value = dict["memoryLimitMB"] as? Double {
            self.memoryLimitMB = value
        }
        if let value = dict["memoryUsageMB"] as? Double {
            self.memoryUsageMB = value
        }
        if let value = dict["timestamp"] as? Int64 {
            self.timestamp = value
        }
    }
}

public class JaegerConfig : Tea.TeaModel {
    public var endpoint: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpoint != nil {
            map["endpoint"] = self.endpoint!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endpoint"] as? String {
            self.endpoint = value
        }
    }
}

public class LifecycleHook : Tea.TeaModel {
    public var handler: String?

    public var timeout: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.handler != nil {
            map["handler"] = self.handler!
        }
        if self.timeout != nil {
            map["timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["handler"] as? String {
            self.handler = value
        }
        if let value = dict["timeout"] as? Int32 {
            self.timeout = value
        }
    }
}

public class ListApplicationVersionsOutput : Tea.TeaModel {
    public var direction: String?

    public var nextToken: String?

    public var requestId: String?

    public var versions: [Version]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["direction"] = self.direction!
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.versions != nil {
            var tmp : [Any] = []
            for k in self.versions! {
                tmp.append(k.toMap())
            }
            map["versions"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["direction"] as? String {
            self.direction = value
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["versions"] as? [Any?] {
            var tmp : [Version] = []
            for v in value {
                if v != nil {
                    var model = Version()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.versions = tmp
        }
    }
}

public class ListApplicationsOutput : Tea.TeaModel {
    public var applications: [Application]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applications != nil {
            var tmp : [Any] = []
            for k in self.applications! {
                tmp.append(k.toMap())
            }
            map["applications"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["applications"] as? [Any?] {
            var tmp : [Application] = []
            for v in value {
                if v != nil {
                    var model = Application()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.applications = tmp
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListApplicationsWithStatusOutput : Tea.TeaModel {
    public var applications: [ApplicationWithStatus]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applications != nil {
            var tmp : [Any] = []
            for k in self.applications! {
                tmp.append(k.toMap())
            }
            map["applications"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["applications"] as? [Any?] {
            var tmp : [ApplicationWithStatus] = []
            for v in value {
                if v != nil {
                    var model = ApplicationWithStatus()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.applications = tmp
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListCustomDomainOutput : Tea.TeaModel {
    public var customDomains: [CustomDomain]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customDomains != nil {
            var tmp : [Any] = []
            for k in self.customDomains! {
                tmp.append(k.toMap())
            }
            map["customDomains"] = tmp
        }
        if self.nextToken != nil {
            map["nextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["customDomains"] as? [Any?] {
            var tmp : [CustomDomain] = []
            for v in value {
                if v != nil {
                    var model = CustomDomain()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.customDomains = tmp
        }
        if let value = dict["nextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListInstancesMetricsOutput : Tea.TeaModel {
    public var requestId: String?

    public var metricsList: [InstanceMetricInfo]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.metricsList != nil {
            var tmp : [Any] = []
            for k in self.metricsList! {
                tmp.append(k.toMap())
            }
            map["metricsList"] = tmp
        }
        if self.pageNumber != nil {
            map["pageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.totalCount != nil {
            map["totalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["metricsList"] as? [Any?] {
            var tmp : [InstanceMetricInfo] = []
            for v in value {
                if v != nil {
                    var model = InstanceMetricInfo()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.metricsList = tmp
        }
        if let value = dict["pageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["pageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["totalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class ListInstancesOutput : Tea.TeaModel {
    public var currentError: String?

    public var instances: [InstanceInfo]?

    public var requestId: String?

    public var versionStatus: [String: VersionStatus]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentError != nil {
            map["currentError"] = self.currentError!
        }
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["instances"] = tmp
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.versionStatus != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.versionStatus! {
                tmp[k] = v.toMap()
            }
            map["versionStatus"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["currentError"] as? String {
            self.currentError = value
        }
        if let value = dict["instances"] as? [Any?] {
            var tmp : [InstanceInfo] = []
            for v in value {
                if v != nil {
                    var model = InstanceInfo()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instances = tmp
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["versionStatus"] as? [String: Any?] {
            var tmp : [String: VersionStatus] = [:]
            for (k, v) in value {
                if v != nil {
                    var model = VersionStatus()
                    model.fromMap(v as? [String: Any?])
                    tmp[k] = model
                }
            }
            self.versionStatus = tmp
        }
    }
}

public class ListMetricsOutput : Tea.TeaModel {
    public var requestId: String?

    public var metrics: [String: [MetricInfo]]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.metrics != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.metrics! {
                var l1 : [Any] = []
                for k1 in v {
                    l1.append(k1.toMap())
                }
                tmp[k] = l1
            }
            map["metrics"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["metrics"] as? [String: Any?] {
            var tmp : [String: [MetricInfo]] = [:]
            for (k, v) in value {
                var l1 : [MetricInfo] = []
                for v1 in v as! [Any?] {
                    if v1 != nil {
                        var model = MetricInfo()
                        if v1 != nil {
                            model.fromMap(v1 as? [String: Any?])
                        }
                        l1.append(model)
                    }
                }
                tmp[k] = l1
            }
            self.metrics = tmp
        }
    }
}

public class ListStaticsQueryResponse : Tea.TeaModel {
    public var length: Int64?

    public var sort: String?

    public var statics: [StaticsInfo]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.length != nil {
            map["length"] = self.length!
        }
        if self.sort != nil {
            map["sort"] = self.sort!
        }
        if self.statics != nil {
            var tmp : [Any] = []
            for k in self.statics! {
                tmp.append(k.toMap())
            }
            map["statics"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["length"] as? Int64 {
            self.length = value
        }
        if let value = dict["sort"] as? String {
            self.sort = value
        }
        if let value = dict["statics"] as? [Any?] {
            var tmp : [StaticsInfo] = []
            for v in value {
                if v != nil {
                    var model = StaticsInfo()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.statics = tmp
        }
    }
}

public class ListWebApplicationInstancesBody : Tea.TeaModel {
    public var code: Int32?

    public var data: ListWebInstancesOutput?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListWebInstancesOutput()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListWebApplicationRevisionsBody : Tea.TeaModel {
    public var code: Int32?

    public var data: ListWebApplicationRevisionsOutput?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListWebApplicationRevisionsOutput()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListWebApplicationRevisionsOutput : Tea.TeaModel {
    public var nextToken: String?

    public var revisions: [Revision]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.revisions != nil {
            var tmp : [Any] = []
            for k in self.revisions! {
                tmp.append(k.toMap())
            }
            map["Revisions"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Revisions"] as? [Any?] {
            var tmp : [Revision] = []
            for v in value {
                if v != nil {
                    var model = Revision()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.revisions = tmp
        }
    }
}

public class ListWebApplicationsBody : Tea.TeaModel {
    public var code: Int32?

    public var data: ListWebApplicationsOutput?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListWebApplicationsOutput()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListWebApplicationsOutput : Tea.TeaModel {
    public var nextToken: String?

    public var webApplicationWithInstanceCount: [WebApplicationWithInstanceCount]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.webApplicationWithInstanceCount != nil {
            var tmp : [Any] = []
            for k in self.webApplicationWithInstanceCount! {
                tmp.append(k.toMap())
            }
            map["WebApplicationWithInstanceCount"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["WebApplicationWithInstanceCount"] as? [Any?] {
            var tmp : [WebApplicationWithInstanceCount] = []
            for v in value {
                if v != nil {
                    var model = WebApplicationWithInstanceCount()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.webApplicationWithInstanceCount = tmp
        }
    }
}

public class ListWebCustomDomainBody : Tea.TeaModel {
    public var code: Int32?

    public var data: ListWebCustomDomainOutput?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListWebCustomDomainOutput()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListWebCustomDomainOutput : Tea.TeaModel {
    public var nextToken: String?

    public var webCustomDomains: [WebCustomDomain]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.webCustomDomains != nil {
            var tmp : [Any] = []
            for k in self.webCustomDomains! {
                tmp.append(k.toMap())
            }
            map["WebCustomDomains"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["WebCustomDomains"] as? [Any?] {
            var tmp : [WebCustomDomain] = []
            for v in value {
                if v != nil {
                    var model = WebCustomDomain()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.webCustomDomains = tmp
        }
    }
}

public class ListWebInstancesOutput : Tea.TeaModel {
    public var currentError: String?

    public var webInstances: [WebInstanceInfo]?

    public var webVersionStatus: [String: WebVersionStatus]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentError != nil {
            map["CurrentError"] = self.currentError!
        }
        if self.webInstances != nil {
            var tmp : [Any] = []
            for k in self.webInstances! {
                tmp.append(k.toMap())
            }
            map["WebInstances"] = tmp
        }
        if self.webVersionStatus != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.webVersionStatus! {
                tmp[k] = v.toMap()
            }
            map["WebVersionStatus"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CurrentError"] as? String {
            self.currentError = value
        }
        if let value = dict["WebInstances"] as? [Any?] {
            var tmp : [WebInstanceInfo] = []
            for v in value {
                if v != nil {
                    var model = WebInstanceInfo()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.webInstances = tmp
        }
        if let value = dict["WebVersionStatus"] as? [String: Any?] {
            var tmp : [String: WebVersionStatus] = [:]
            for (k, v) in value {
                if v != nil {
                    var model = WebVersionStatus()
                    model.fromMap(v as? [String: Any?])
                    tmp[k] = model
                }
            }
            self.webVersionStatus = tmp
        }
    }
}

public class LogConfig : Tea.TeaModel {
    public var enableInstanceMetrics: Bool?

    public var enableRequestMetrics: Bool?

    public var logBeginRule: String?

    public var logstore: String?

    public var project: String?

    public var pushToUserSLS: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableInstanceMetrics != nil {
            map["enableInstanceMetrics"] = self.enableInstanceMetrics!
        }
        if self.enableRequestMetrics != nil {
            map["enableRequestMetrics"] = self.enableRequestMetrics!
        }
        if self.logBeginRule != nil {
            map["logBeginRule"] = self.logBeginRule!
        }
        if self.logstore != nil {
            map["logstore"] = self.logstore!
        }
        if self.project != nil {
            map["project"] = self.project!
        }
        if self.pushToUserSLS != nil {
            map["pushToUserSLS"] = self.pushToUserSLS!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["enableInstanceMetrics"] as? Bool {
            self.enableInstanceMetrics = value
        }
        if let value = dict["enableRequestMetrics"] as? Bool {
            self.enableRequestMetrics = value
        }
        if let value = dict["logBeginRule"] as? String {
            self.logBeginRule = value
        }
        if let value = dict["logstore"] as? String {
            self.logstore = value
        }
        if let value = dict["project"] as? String {
            self.project = value
        }
        if let value = dict["pushToUserSLS"] as? Bool {
            self.pushToUserSLS = value
        }
    }
}

public class LogEntry : Tea.TeaModel {
    public var instanceID: String?

    public var message: String?

    public var offset: Int64?

    public var packID: String?

    public var packMeta: String?

    public var qualifier: String?

    public var timestamp: Int32?

    public var versionID: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceID != nil {
            map["instanceID"] = self.instanceID!
        }
        if self.message != nil {
            map["message"] = self.message!
        }
        if self.offset != nil {
            map["offset"] = self.offset!
        }
        if self.packID != nil {
            map["packID"] = self.packID!
        }
        if self.packMeta != nil {
            map["packMeta"] = self.packMeta!
        }
        if self.qualifier != nil {
            map["qualifier"] = self.qualifier!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        if self.versionID != nil {
            map["versionID"] = self.versionID!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["instanceID"] as? String {
            self.instanceID = value
        }
        if let value = dict["message"] as? String {
            self.message = value
        }
        if let value = dict["offset"] as? Int64 {
            self.offset = value
        }
        if let value = dict["packID"] as? String {
            self.packID = value
        }
        if let value = dict["packMeta"] as? String {
            self.packMeta = value
        }
        if let value = dict["qualifier"] as? String {
            self.qualifier = value
        }
        if let value = dict["timestamp"] as? Int32 {
            self.timestamp = value
        }
        if let value = dict["versionID"] as? String {
            self.versionID = value
        }
    }
}

public class MetricInfo : Tea.TeaModel {
    public var average: Double?

    public var count: Double?

    public var maximum: Double?

    public var minimum: Double?

    public var sum: Double?

    public var timestamp: Int64?

    public var value: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.average != nil {
            map["Average"] = self.average!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.maximum != nil {
            map["Maximum"] = self.maximum!
        }
        if self.minimum != nil {
            map["Minimum"] = self.minimum!
        }
        if self.sum != nil {
            map["Sum"] = self.sum!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        if self.value != nil {
            map["value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Average"] as? Double {
            self.average = value
        }
        if let value = dict["Count"] as? Double {
            self.count = value
        }
        if let value = dict["Maximum"] as? Double {
            self.maximum = value
        }
        if let value = dict["Minimum"] as? Double {
            self.minimum = value
        }
        if let value = dict["Sum"] as? Double {
            self.sum = value
        }
        if let value = dict["timestamp"] as? Int64 {
            self.timestamp = value
        }
        if let value = dict["value"] as? Double {
            self.value = value
        }
    }
}

public class MetricsCollectConfig : Tea.TeaModel {
    public var enablePushToUserSLS: Bool?

    public var logstoreName: String?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enablePushToUserSLS != nil {
            map["EnablePushToUserSLS"] = self.enablePushToUserSLS!
        }
        if self.logstoreName != nil {
            map["LogstoreName"] = self.logstoreName!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EnablePushToUserSLS"] as? Bool {
            self.enablePushToUserSLS = value
        }
        if let value = dict["LogstoreName"] as? String {
            self.logstoreName = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
    }
}

public class NASConfig : Tea.TeaModel {
    public var mountPoints: [NASMountConfig]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mountPoints != nil {
            var tmp : [Any] = []
            for k in self.mountPoints! {
                tmp.append(k.toMap())
            }
            map["mountPoints"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["mountPoints"] as? [Any?] {
            var tmp : [NASMountConfig] = []
            for v in value {
                if v != nil {
                    var model = NASMountConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.mountPoints = tmp
        }
    }
}

public class NASMountConfig : Tea.TeaModel {
    public var enableTLS: Bool?

    public var mountDir: String?

    public var serverAddr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableTLS != nil {
            map["enableTLS"] = self.enableTLS!
        }
        if self.mountDir != nil {
            map["mountDir"] = self.mountDir!
        }
        if self.serverAddr != nil {
            map["serverAddr"] = self.serverAddr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["enableTLS"] as? Bool {
            self.enableTLS = value
        }
        if let value = dict["mountDir"] as? String {
            self.mountDir = value
        }
        if let value = dict["serverAddr"] as? String {
            self.serverAddr = value
        }
    }
}

public class OSSMountConfig : Tea.TeaModel {
    public var mountPoints: [OSSMountPoint]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mountPoints != nil {
            var tmp : [Any] = []
            for k in self.mountPoints! {
                tmp.append(k.toMap())
            }
            map["mountPoints"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["mountPoints"] as? [Any?] {
            var tmp : [OSSMountPoint] = []
            for v in value {
                if v != nil {
                    var model = OSSMountPoint()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.mountPoints = tmp
        }
    }
}

public class OSSMountPoint : Tea.TeaModel {
    public var bucketName: String?

    public var bucketPath: String?

    public var mountDir: String?

    public var readOnly: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketName != nil {
            map["bucketName"] = self.bucketName!
        }
        if self.bucketPath != nil {
            map["bucketPath"] = self.bucketPath!
        }
        if self.mountDir != nil {
            map["mountDir"] = self.mountDir!
        }
        if self.readOnly != nil {
            map["readOnly"] = self.readOnly!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["bucketName"] as? String {
            self.bucketName = value
        }
        if let value = dict["bucketPath"] as? String {
            self.bucketPath = value
        }
        if let value = dict["mountDir"] as? String {
            self.mountDir = value
        }
        if let value = dict["readOnly"] as? Bool {
            self.readOnly = value
        }
    }
}

public class PathConfig : Tea.TeaModel {
    public var applicationName: String?

    public var path: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationName != nil {
            map["applicationName"] = self.applicationName!
        }
        if self.path != nil {
            map["path"] = self.path!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["applicationName"] as? String {
            self.applicationName = value
        }
        if let value = dict["path"] as? String {
            self.path = value
        }
    }
}

public class PermissionAssistantApi : Tea.TeaModel {
    public var createTime: String?

    public var id: Int64?

    public var name: String?

    public var resourceType: String?

    public var updateTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["createTime"] = self.createTime!
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.resourceType != nil {
            map["resourceType"] = self.resourceType!
        }
        if self.updateTime != nil {
            map["updateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["createTime"] as? String {
            self.createTime = value
        }
        if let value = dict["id"] as? Int64 {
            self.id = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["resourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["updateTime"] as? String {
            self.updateTime = value
        }
    }
}

public class PolicyItem : Tea.TeaModel {
    public var key: String?

    public var operator_: String?

    public var type: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.key != nil {
            map["key"] = self.key!
        }
        if self.operator_ != nil {
            map["operator"] = self.operator_!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        if self.value != nil {
            map["value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["key"] as? String {
            self.key = value
        }
        if let value = dict["operator"] as? String {
            self.operator_ = value
        }
        if let value = dict["type"] as? String {
            self.type = value
        }
        if let value = dict["value"] as? String {
            self.value = value
        }
    }
}

public class PriceEstimateFeature : Tea.TeaModel {
    public var appCount: Int64?

    public var appType: String?

    public var cpuCore: Double?

    public var cpuStrategy: String?

    public var cpuUtilLevel: String?

    public var cpuUtilMetrics: [Double]?

    public var enableCpuIdle: Bool?

    public var envType: String?

    public var ephemeralStorageGiB: Int64?

    public var highLoadInstanceCount: Int64?

    public var highLoadQps: Double?

    public var highLoadSeconds: Int64?

    public var instanceQps: Double?

    public var internetOutboundGiB: Double?

    public var lowLoadInstanceCount: Int64?

    public var lowLoadQps: Double?

    public var lowLoadSeconds: Int64?

    public var maxInstanceCount: Int64?

    public var memoryGiB: Double?

    public var minInstanceCount: Int64?

    public var newSaeVersion: String?

    public var noneLoadInstanceCount: Int64?

    public var noneLoadSeconds: Int64?

    public var regionId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appCount != nil {
            map["AppCount"] = self.appCount!
        }
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.cpuCore != nil {
            map["CpuCore"] = self.cpuCore!
        }
        if self.cpuStrategy != nil {
            map["CpuStrategy"] = self.cpuStrategy!
        }
        if self.cpuUtilLevel != nil {
            map["CpuUtilLevel"] = self.cpuUtilLevel!
        }
        if self.cpuUtilMetrics != nil {
            map["CpuUtilMetrics"] = self.cpuUtilMetrics!
        }
        if self.enableCpuIdle != nil {
            map["EnableCpuIdle"] = self.enableCpuIdle!
        }
        if self.envType != nil {
            map["EnvType"] = self.envType!
        }
        if self.ephemeralStorageGiB != nil {
            map["EphemeralStorageGiB"] = self.ephemeralStorageGiB!
        }
        if self.highLoadInstanceCount != nil {
            map["HighLoadInstanceCount"] = self.highLoadInstanceCount!
        }
        if self.highLoadQps != nil {
            map["HighLoadQps"] = self.highLoadQps!
        }
        if self.highLoadSeconds != nil {
            map["HighLoadSeconds"] = self.highLoadSeconds!
        }
        if self.instanceQps != nil {
            map["InstanceQps"] = self.instanceQps!
        }
        if self.internetOutboundGiB != nil {
            map["InternetOutboundGiB"] = self.internetOutboundGiB!
        }
        if self.lowLoadInstanceCount != nil {
            map["LowLoadInstanceCount"] = self.lowLoadInstanceCount!
        }
        if self.lowLoadQps != nil {
            map["LowLoadQps"] = self.lowLoadQps!
        }
        if self.lowLoadSeconds != nil {
            map["LowLoadSeconds"] = self.lowLoadSeconds!
        }
        if self.maxInstanceCount != nil {
            map["MaxInstanceCount"] = self.maxInstanceCount!
        }
        if self.memoryGiB != nil {
            map["MemoryGiB"] = self.memoryGiB!
        }
        if self.minInstanceCount != nil {
            map["MinInstanceCount"] = self.minInstanceCount!
        }
        if self.newSaeVersion != nil {
            map["NewSaeVersion"] = self.newSaeVersion!
        }
        if self.noneLoadInstanceCount != nil {
            map["NoneLoadInstanceCount"] = self.noneLoadInstanceCount!
        }
        if self.noneLoadSeconds != nil {
            map["NoneLoadSeconds"] = self.noneLoadSeconds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppCount"] as? Int64 {
            self.appCount = value
        }
        if let value = dict["AppType"] as? String {
            self.appType = value
        }
        if let value = dict["CpuCore"] as? Double {
            self.cpuCore = value
        }
        if let value = dict["CpuStrategy"] as? String {
            self.cpuStrategy = value
        }
        if let value = dict["CpuUtilLevel"] as? String {
            self.cpuUtilLevel = value
        }
        if let value = dict["CpuUtilMetrics"] as? [Double] {
            self.cpuUtilMetrics = value
        }
        if let value = dict["EnableCpuIdle"] as? Bool {
            self.enableCpuIdle = value
        }
        if let value = dict["EnvType"] as? String {
            self.envType = value
        }
        if let value = dict["EphemeralStorageGiB"] as? Int64 {
            self.ephemeralStorageGiB = value
        }
        if let value = dict["HighLoadInstanceCount"] as? Int64 {
            self.highLoadInstanceCount = value
        }
        if let value = dict["HighLoadQps"] as? Double {
            self.highLoadQps = value
        }
        if let value = dict["HighLoadSeconds"] as? Int64 {
            self.highLoadSeconds = value
        }
        if let value = dict["InstanceQps"] as? Double {
            self.instanceQps = value
        }
        if let value = dict["InternetOutboundGiB"] as? Double {
            self.internetOutboundGiB = value
        }
        if let value = dict["LowLoadInstanceCount"] as? Int64 {
            self.lowLoadInstanceCount = value
        }
        if let value = dict["LowLoadQps"] as? Double {
            self.lowLoadQps = value
        }
        if let value = dict["LowLoadSeconds"] as? Int64 {
            self.lowLoadSeconds = value
        }
        if let value = dict["MaxInstanceCount"] as? Int64 {
            self.maxInstanceCount = value
        }
        if let value = dict["MemoryGiB"] as? Double {
            self.memoryGiB = value
        }
        if let value = dict["MinInstanceCount"] as? Int64 {
            self.minInstanceCount = value
        }
        if let value = dict["NewSaeVersion"] as? String {
            self.newSaeVersion = value
        }
        if let value = dict["NoneLoadInstanceCount"] as? Int64 {
            self.noneLoadInstanceCount = value
        }
        if let value = dict["NoneLoadSeconds"] as? Int64 {
            self.noneLoadSeconds = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class PriceEstimateOutput : Tea.TeaModel {
    public class Apps : Tea.TeaModel {
        public class Usages : Tea.TeaModel {
            public var amount: Double?

            public var id: String?

            public var unit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["Amount"] = self.amount!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.unit != nil {
                    map["Unit"] = self.unit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Amount"] as? Double {
                    self.amount = value
                }
                if let value = dict["Id"] as? String {
                    self.id = value
                }
                if let value = dict["Unit"] as? String {
                    self.unit = value
                }
            }
        }
        public var feature: PriceEstimateFeature?

        public var id: Int64?

        public var usages: [PriceEstimateOutput.Apps.Usages]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.feature?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.feature != nil {
                map["Feature"] = self.feature?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.usages != nil {
                var tmp : [Any] = []
                for k in self.usages! {
                    tmp.append(k.toMap())
                }
                map["Usages"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Feature"] as? [String: Any?] {
                var model = PriceEstimateFeature()
                model.fromMap(value)
                self.feature = model
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["Usages"] as? [Any?] {
                var tmp : [PriceEstimateOutput.Apps.Usages] = []
                for v in value {
                    if v != nil {
                        var model = PriceEstimateOutput.Apps.Usages()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.usages = tmp
            }
        }
    }
    public class Items : Tea.TeaModel {
        public class Steps : Tea.TeaModel {
            public var begin: Int64?

            public var end: Int64?

            public var price: Double?

            public var regionIds: [String]?

            public var unit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.begin != nil {
                    map["Begin"] = self.begin!
                }
                if self.end != nil {
                    map["End"] = self.end!
                }
                if self.price != nil {
                    map["Price"] = self.price!
                }
                if self.regionIds != nil {
                    map["RegionIds"] = self.regionIds!
                }
                if self.unit != nil {
                    map["Unit"] = self.unit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Begin"] as? Int64 {
                    self.begin = value
                }
                if let value = dict["End"] as? Int64 {
                    self.end = value
                }
                if let value = dict["Price"] as? Double {
                    self.price = value
                }
                if let value = dict["RegionIds"] as? [String] {
                    self.regionIds = value
                }
                if let value = dict["Unit"] as? String {
                    self.unit = value
                }
            }
        }
        public var amount: Double?

        public var count: Int64?

        public var id: String?

        public var price: Double?

        public var steps: [PriceEstimateOutput.Items.Steps]?

        public var type: String?

        public var unit: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.amount != nil {
                map["Amount"] = self.amount!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.price != nil {
                map["Price"] = self.price!
            }
            if self.steps != nil {
                var tmp : [Any] = []
                for k in self.steps! {
                    tmp.append(k.toMap())
                }
                map["Steps"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.unit != nil {
                map["Unit"] = self.unit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Amount"] as? Double {
                self.amount = value
            }
            if let value = dict["Count"] as? Int64 {
                self.count = value
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["Price"] as? Double {
                self.price = value
            }
            if let value = dict["Steps"] as? [Any?] {
                var tmp : [PriceEstimateOutput.Items.Steps] = []
                for v in value {
                    if v != nil {
                        var model = PriceEstimateOutput.Items.Steps()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.steps = tmp
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["Unit"] as? String {
                self.unit = value
            }
        }
    }
    public class PostPayItems : Tea.TeaModel {
        public class Steps : Tea.TeaModel {
            public var begin: Int64?

            public var end: Int64?

            public var price: Double?

            public var regionIds: [String]?

            public var unit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.begin != nil {
                    map["Begin"] = self.begin!
                }
                if self.end != nil {
                    map["End"] = self.end!
                }
                if self.price != nil {
                    map["Price"] = self.price!
                }
                if self.regionIds != nil {
                    map["RegionIds"] = self.regionIds!
                }
                if self.unit != nil {
                    map["Unit"] = self.unit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Begin"] as? Int64 {
                    self.begin = value
                }
                if let value = dict["End"] as? Int64 {
                    self.end = value
                }
                if let value = dict["Price"] as? Double {
                    self.price = value
                }
                if let value = dict["RegionIds"] as? [String] {
                    self.regionIds = value
                }
                if let value = dict["Unit"] as? String {
                    self.unit = value
                }
            }
        }
        public var amount: Double?

        public var count: Int64?

        public var id: String?

        public var price: Double?

        public var steps: [PriceEstimateOutput.PostPayItems.Steps]?

        public var type: String?

        public var unit: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.amount != nil {
                map["Amount"] = self.amount!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.price != nil {
                map["Price"] = self.price!
            }
            if self.steps != nil {
                var tmp : [Any] = []
                for k in self.steps! {
                    tmp.append(k.toMap())
                }
                map["Steps"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.unit != nil {
                map["Unit"] = self.unit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Amount"] as? Double {
                self.amount = value
            }
            if let value = dict["Count"] as? Int64 {
                self.count = value
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["Price"] as? Double {
                self.price = value
            }
            if let value = dict["Steps"] as? [Any?] {
                var tmp : [PriceEstimateOutput.PostPayItems.Steps] = []
                for v in value {
                    if v != nil {
                        var model = PriceEstimateOutput.PostPayItems.Steps()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.steps = tmp
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["Unit"] as? String {
                self.unit = value
            }
        }
    }
    public var apps: [PriceEstimateOutput.Apps]?

    public var items: [PriceEstimateOutput.Items]?

    public var postPayItems: [PriceEstimateOutput.PostPayItems]?

    public var postPayTotalPrice: Double?

    public var totalPrice: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apps != nil {
            var tmp : [Any] = []
            for k in self.apps! {
                tmp.append(k.toMap())
            }
            map["Apps"] = tmp
        }
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.postPayItems != nil {
            var tmp : [Any] = []
            for k in self.postPayItems! {
                tmp.append(k.toMap())
            }
            map["PostPayItems"] = tmp
        }
        if self.postPayTotalPrice != nil {
            map["PostPayTotalPrice"] = self.postPayTotalPrice!
        }
        if self.totalPrice != nil {
            map["TotalPrice"] = self.totalPrice!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Apps"] as? [Any?] {
            var tmp : [PriceEstimateOutput.Apps] = []
            for v in value {
                if v != nil {
                    var model = PriceEstimateOutput.Apps()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.apps = tmp
        }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [PriceEstimateOutput.Items] = []
            for v in value {
                if v != nil {
                    var model = PriceEstimateOutput.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["PostPayItems"] as? [Any?] {
            var tmp : [PriceEstimateOutput.PostPayItems] = []
            for v in value {
                if v != nil {
                    var model = PriceEstimateOutput.PostPayItems()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.postPayItems = tmp
        }
        if let value = dict["PostPayTotalPrice"] as? Double {
            self.postPayTotalPrice = value
        }
        if let value = dict["TotalPrice"] as? Double {
            self.totalPrice = value
        }
    }
}

public class Probe : Tea.TeaModel {
    public class ProbeHandler : Tea.TeaModel {
        public class HttpGet : Tea.TeaModel {
            public class HttpHeaders : Tea.TeaModel {
                public var name: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                    if let value = dict["value"] as? String {
                        self.value = value
                    }
                }
            }
            public var httpHeaders: [Probe.ProbeHandler.HttpGet.HttpHeaders]?

            public var path: String?

            public var port: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.httpHeaders != nil {
                    var tmp : [Any] = []
                    for k in self.httpHeaders! {
                        tmp.append(k.toMap())
                    }
                    map["httpHeaders"] = tmp
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                if self.port != nil {
                    map["port"] = self.port!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["httpHeaders"] as? [Any?] {
                    var tmp : [Probe.ProbeHandler.HttpGet.HttpHeaders] = []
                    for v in value {
                        if v != nil {
                            var model = Probe.ProbeHandler.HttpGet.HttpHeaders()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.httpHeaders = tmp
                }
                if let value = dict["path"] as? String {
                    self.path = value
                }
                if let value = dict["port"] as? Int32 {
                    self.port = value
                }
            }
        }
        public class TcpSocket : Tea.TeaModel {
            public var port: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["port"] = self.port!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["port"] as? Int32 {
                    self.port = value
                }
            }
        }
        public var httpGet: Probe.ProbeHandler.HttpGet?

        public var tcpSocket: Probe.ProbeHandler.TcpSocket?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.httpGet?.validate()
            try self.tcpSocket?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.httpGet != nil {
                map["httpGet"] = self.httpGet?.toMap()
            }
            if self.tcpSocket != nil {
                map["tcpSocket"] = self.tcpSocket?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["httpGet"] as? [String: Any?] {
                var model = Probe.ProbeHandler.HttpGet()
                model.fromMap(value)
                self.httpGet = model
            }
            if let value = dict["tcpSocket"] as? [String: Any?] {
                var model = Probe.ProbeHandler.TcpSocket()
                model.fromMap(value)
                self.tcpSocket = model
            }
        }
    }
    public var failureThreshold: Int32?

    public var initialDelaySeconds: Int32?

    public var periodSeconds: Int32?

    public var probeHandler: Probe.ProbeHandler?

    public var timeoutSeconds: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.probeHandler?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failureThreshold != nil {
            map["failureThreshold"] = self.failureThreshold!
        }
        if self.initialDelaySeconds != nil {
            map["initialDelaySeconds"] = self.initialDelaySeconds!
        }
        if self.periodSeconds != nil {
            map["periodSeconds"] = self.periodSeconds!
        }
        if self.probeHandler != nil {
            map["probeHandler"] = self.probeHandler?.toMap()
        }
        if self.timeoutSeconds != nil {
            map["timeoutSeconds"] = self.timeoutSeconds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["failureThreshold"] as? Int32 {
            self.failureThreshold = value
        }
        if let value = dict["initialDelaySeconds"] as? Int32 {
            self.initialDelaySeconds = value
        }
        if let value = dict["periodSeconds"] as? Int32 {
            self.periodSeconds = value
        }
        if let value = dict["probeHandler"] as? [String: Any?] {
            var model = Probe.ProbeHandler()
            model.fromMap(value)
            self.probeHandler = model
        }
        if let value = dict["timeoutSeconds"] as? Int32 {
            self.timeoutSeconds = value
        }
    }
}

public class ProbeHandler : Tea.TeaModel {
    public var httpGet: HTTPGetAction?

    public var tcpSocket: TCPSocketAction?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.httpGet?.validate()
        try self.tcpSocket?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.httpGet != nil {
            map["HttpGet"] = self.httpGet?.toMap()
        }
        if self.tcpSocket != nil {
            map["TcpSocket"] = self.tcpSocket?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["HttpGet"] as? [String: Any?] {
            var model = HTTPGetAction()
            model.fromMap(value)
            self.httpGet = model
        }
        if let value = dict["TcpSocket"] as? [String: Any?] {
            var model = TCPSocketAction()
            model.fromMap(value)
            self.tcpSocket = model
        }
    }
}

public class PublishApplicationVersionInput : Tea.TeaModel {
    public var description_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
    }
}

public class PublishWebApplicationRevisionInput : Tea.TeaModel {
    public var containers: [Container]?

    public var description_: String?

    public var enableArmsMetrics: Bool?

    public var takeEffect: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.containers != nil {
            var tmp : [Any] = []
            for k in self.containers! {
                tmp.append(k.toMap())
            }
            map["Containers"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableArmsMetrics != nil {
            map["EnableArmsMetrics"] = self.enableArmsMetrics!
        }
        if self.takeEffect != nil {
            map["TakeEffect"] = self.takeEffect!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Containers"] as? [Any?] {
            var tmp : [Container] = []
            for v in value {
                if v != nil {
                    var model = Container()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.containers = tmp
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnableArmsMetrics"] as? Bool {
            self.enableArmsMetrics = value
        }
        if let value = dict["TakeEffect"] as? Bool {
            self.takeEffect = value
        }
    }
}

public class RegistryAuthConfig : Tea.TeaModel {
    public var password: String?

    public var role: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.password != nil {
            map["password"] = self.password!
        }
        if self.role != nil {
            map["role"] = self.role!
        }
        if self.userName != nil {
            map["userName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["password"] as? String {
            self.password = value
        }
        if let value = dict["role"] as? String {
            self.role = value
        }
        if let value = dict["userName"] as? String {
            self.userName = value
        }
    }
}

public class RegistryAuthenticationConfig : Tea.TeaModel {
    public var password: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["UserName"] as? String {
            self.userName = value
        }
    }
}

public class RegistryCertConfig : Tea.TeaModel {
    public var insecure: Bool?

    public var rootCaCertBase64: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.insecure != nil {
            map["insecure"] = self.insecure!
        }
        if self.rootCaCertBase64 != nil {
            map["rootCaCertBase64"] = self.rootCaCertBase64!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["insecure"] as? Bool {
            self.insecure = value
        }
        if let value = dict["rootCaCertBase64"] as? String {
            self.rootCaCertBase64 = value
        }
    }
}

public class RegistryCertificateConfig : Tea.TeaModel {
    public var certBase64: String?

    public var insecure: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certBase64 != nil {
            map["CertBase64"] = self.certBase64!
        }
        if self.insecure != nil {
            map["Insecure"] = self.insecure!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CertBase64"] as? String {
            self.certBase64 = value
        }
        if let value = dict["Insecure"] as? Bool {
            self.insecure = value
        }
    }
}

public class RegistryConfig : Tea.TeaModel {
    public var authConfig: RegistryAuthConfig?

    public var certConfig: RegistryCertConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authConfig?.validate()
        try self.certConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authConfig != nil {
            map["authConfig"] = self.authConfig?.toMap()
        }
        if self.certConfig != nil {
            map["certConfig"] = self.certConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["authConfig"] as? [String: Any?] {
            var model = RegistryAuthConfig()
            model.fromMap(value)
            self.authConfig = model
        }
        if let value = dict["certConfig"] as? [String: Any?] {
            var model = RegistryCertConfig()
            model.fromMap(value)
            self.certConfig = model
        }
    }
}

public class Revision : Tea.TeaModel {
    public var createdTime: String?

    public var description_: String?

    public var revisionConfig: RevisionConfig?

    public var revisionId: String?

    public var weight: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.revisionConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.revisionConfig != nil {
            map["RevisionConfig"] = self.revisionConfig?.toMap()
        }
        if self.revisionId != nil {
            map["RevisionId"] = self.revisionId!
        }
        if self.weight != nil {
            map["Weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreatedTime"] as? String {
            self.createdTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["RevisionConfig"] as? [String: Any?] {
            var model = RevisionConfig()
            model.fromMap(value)
            self.revisionConfig = model
        }
        if let value = dict["RevisionId"] as? String {
            self.revisionId = value
        }
        if let value = dict["Weight"] as? Double {
            self.weight = value
        }
    }
}

public class RevisionConfig : Tea.TeaModel {
    public var containers: [Container]?

    public var enableArmsMetrics: Bool?

    public var webNetworkConfig: WebNetworkConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.webNetworkConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.containers != nil {
            var tmp : [Any] = []
            for k in self.containers! {
                tmp.append(k.toMap())
            }
            map["Containers"] = tmp
        }
        if self.enableArmsMetrics != nil {
            map["EnableArmsMetrics"] = self.enableArmsMetrics!
        }
        if self.webNetworkConfig != nil {
            map["WebNetworkConfig"] = self.webNetworkConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Containers"] as? [Any?] {
            var tmp : [Container] = []
            for v in value {
                if v != nil {
                    var model = Container()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.containers = tmp
        }
        if let value = dict["EnableArmsMetrics"] as? Bool {
            self.enableArmsMetrics = value
        }
        if let value = dict["WebNetworkConfig"] as? [String: Any?] {
            var model = WebNetworkConfig()
            model.fromMap(value)
            self.webNetworkConfig = model
        }
    }
}

public class RouteConfig : Tea.TeaModel {
    public var routes: [PathConfig]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.routes != nil {
            var tmp : [Any] = []
            for k in self.routes! {
                tmp.append(k.toMap())
            }
            map["routes"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["routes"] as? [Any?] {
            var tmp : [PathConfig] = []
            for v in value {
                if v != nil {
                    var model = PathConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.routes = tmp
        }
    }
}

public class RoutePolicy : Tea.TeaModel {
    public var condition: String?

    public var policyItems: [PolicyItem]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.condition != nil {
            map["condition"] = self.condition!
        }
        if self.policyItems != nil {
            var tmp : [Any] = []
            for k in self.policyItems! {
                tmp.append(k.toMap())
            }
            map["policyItems"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["condition"] as? String {
            self.condition = value
        }
        if let value = dict["policyItems"] as? [Any?] {
            var tmp : [PolicyItem] = []
            for v in value {
                if v != nil {
                    var model = PolicyItem()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.policyItems = tmp
        }
    }
}

public class SLSCollectConfig : Tea.TeaModel {
    public var logPath: String?

    public var logType: String?

    public var logstoreName: String?

    public var logtailName: String?

    public var machineGroup: String?

    public var projectName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logPath != nil {
            map["LogPath"] = self.logPath!
        }
        if self.logType != nil {
            map["LogType"] = self.logType!
        }
        if self.logstoreName != nil {
            map["LogstoreName"] = self.logstoreName!
        }
        if self.logtailName != nil {
            map["LogtailName"] = self.logtailName!
        }
        if self.machineGroup != nil {
            map["MachineGroup"] = self.machineGroup!
        }
        if self.projectName != nil {
            map["ProjectName"] = self.projectName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["LogPath"] as? String {
            self.logPath = value
        }
        if let value = dict["LogType"] as? String {
            self.logType = value
        }
        if let value = dict["LogstoreName"] as? String {
            self.logstoreName = value
        }
        if let value = dict["LogtailName"] as? String {
            self.logtailName = value
        }
        if let value = dict["MachineGroup"] as? String {
            self.machineGroup = value
        }
        if let value = dict["ProjectName"] as? String {
            self.projectName = value
        }
    }
}

public class SLSCollectConfigs : Tea.TeaModel {
    public var collectConfigs: [SLSCollectConfig]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collectConfigs != nil {
            var tmp : [Any] = []
            for k in self.collectConfigs! {
                tmp.append(k.toMap())
            }
            map["CollectConfigs"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CollectConfigs"] as? [Any?] {
            var tmp : [SLSCollectConfig] = []
            for v in value {
                if v != nil {
                    var model = SLSCollectConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.collectConfigs = tmp
        }
    }
}

public class SLSConfig : Tea.TeaModel {
    public class CollectConfigs : Tea.TeaModel {
        public var logPath: String?

        public var logType: String?

        public var logstoreName: String?

        public var logtailName: String?

        public var projectName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logPath != nil {
                map["logPath"] = self.logPath!
            }
            if self.logType != nil {
                map["logType"] = self.logType!
            }
            if self.logstoreName != nil {
                map["logstoreName"] = self.logstoreName!
            }
            if self.logtailName != nil {
                map["logtailName"] = self.logtailName!
            }
            if self.projectName != nil {
                map["projectName"] = self.projectName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["logPath"] as? String {
                self.logPath = value
            }
            if let value = dict["logType"] as? String {
                self.logType = value
            }
            if let value = dict["logstoreName"] as? String {
                self.logstoreName = value
            }
            if let value = dict["logtailName"] as? String {
                self.logtailName = value
            }
            if let value = dict["projectName"] as? String {
                self.projectName = value
            }
        }
    }
    public var collectConfigs: [SLSConfig.CollectConfigs]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collectConfigs != nil {
            var tmp : [Any] = []
            for k in self.collectConfigs! {
                tmp.append(k.toMap())
            }
            map["collectConfigs"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["collectConfigs"] as? [Any?] {
            var tmp : [SLSConfig.CollectConfigs] = []
            for v in value {
                if v != nil {
                    var model = SLSConfig.CollectConfigs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.collectConfigs = tmp
        }
    }
}

public class ScaleConfig : Tea.TeaModel {
    public var alwaysAllocateCPU: Bool?

    public var maximumInstanceCount: Int64?

    public var minimumInstanceCount: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alwaysAllocateCPU != nil {
            map["alwaysAllocateCPU"] = self.alwaysAllocateCPU!
        }
        if self.maximumInstanceCount != nil {
            map["maximumInstanceCount"] = self.maximumInstanceCount!
        }
        if self.minimumInstanceCount != nil {
            map["minimumInstanceCount"] = self.minimumInstanceCount!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["alwaysAllocateCPU"] as? Bool {
            self.alwaysAllocateCPU = value
        }
        if let value = dict["maximumInstanceCount"] as? Int64 {
            self.maximumInstanceCount = value
        }
        if let value = dict["minimumInstanceCount"] as? Int64 {
            self.minimumInstanceCount = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
    }
}

public class SidecarContainerConfig : Tea.TeaModel {
    public var acrInstanceId: String?

    public var command: String?

    public var commandArgs: String?

    public var configMapMountDesc: String?

    public var cpu: Int32?

    public var emptyDirDesc: String?

    public var envs: String?

    public var imageUrl: String?

    public var memory: Int32?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acrInstanceId != nil {
            map["AcrInstanceId"] = self.acrInstanceId!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.commandArgs != nil {
            map["CommandArgs"] = self.commandArgs!
        }
        if self.configMapMountDesc != nil {
            map["ConfigMapMountDesc"] = self.configMapMountDesc!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.emptyDirDesc != nil {
            map["EmptyDirDesc"] = self.emptyDirDesc!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcrInstanceId"] as? String {
            self.acrInstanceId = value
        }
        if let value = dict["Command"] as? String {
            self.command = value
        }
        if let value = dict["CommandArgs"] as? String {
            self.commandArgs = value
        }
        if let value = dict["ConfigMapMountDesc"] as? String {
            self.configMapMountDesc = value
        }
        if let value = dict["Cpu"] as? Int32 {
            self.cpu = value
        }
        if let value = dict["EmptyDirDesc"] as? String {
            self.emptyDirDesc = value
        }
        if let value = dict["Envs"] as? String {
            self.envs = value
        }
        if let value = dict["ImageUrl"] as? String {
            self.imageUrl = value
        }
        if let value = dict["Memory"] as? Int32 {
            self.memory = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
    }
}

public class SourceCodeAccount : Tea.TeaModel {
    public class Organizations : Tea.TeaModel {
        public var avatarUrl: String?

        public var id: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarUrl != nil {
                map["AvatarUrl"] = self.avatarUrl!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AvatarUrl"] as? String {
                self.avatarUrl = value
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
        }
    }
    public var avatarUrl: String?

    public var id: String?

    public var name: String?

    public var organizations: [SourceCodeAccount.Organizations]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avatarUrl != nil {
            map["AvatarUrl"] = self.avatarUrl!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.organizations != nil {
            var tmp : [Any] = []
            for k in self.organizations! {
                tmp.append(k.toMap())
            }
            map["Organizations"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AvatarUrl"] as? String {
            self.avatarUrl = value
        }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Organizations"] as? [Any?] {
            var tmp : [SourceCodeAccount.Organizations] = []
            for v in value {
                if v != nil {
                    var model = SourceCodeAccount.Organizations()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.organizations = tmp
        }
    }
}

public class SourceCodeRepo : Tea.TeaModel {
    public var fullName: String?

    public var id: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fullName != nil {
            map["FullName"] = self.fullName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FullName"] as? String {
            self.fullName = value
        }
        if let value = dict["Id"] as? String {
            self.id = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
    }
}

public class SourceCodeRepoBranch : Tea.TeaModel {
    public var commitId: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commitId != nil {
            map["CommitId"] = self.commitId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CommitId"] as? String {
            self.commitId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
    }
}

public class StartupProbe : Tea.TeaModel {
    public var failureThreshold: Int32?

    public var initialDelaySeconds: Int32?

    public var periodSeconds: Int32?

    public var probeHandler: ProbeHandler?

    public var timeoutSeconds: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.probeHandler?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failureThreshold != nil {
            map["FailureThreshold"] = self.failureThreshold!
        }
        if self.initialDelaySeconds != nil {
            map["InitialDelaySeconds"] = self.initialDelaySeconds!
        }
        if self.periodSeconds != nil {
            map["PeriodSeconds"] = self.periodSeconds!
        }
        if self.probeHandler != nil {
            map["ProbeHandler"] = self.probeHandler?.toMap()
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FailureThreshold"] as? Int32 {
            self.failureThreshold = value
        }
        if let value = dict["InitialDelaySeconds"] as? Int32 {
            self.initialDelaySeconds = value
        }
        if let value = dict["PeriodSeconds"] as? Int32 {
            self.periodSeconds = value
        }
        if let value = dict["ProbeHandler"] as? [String: Any?] {
            var model = ProbeHandler()
            model.fromMap(value)
            self.probeHandler = model
        }
        if let value = dict["TimeoutSeconds"] as? Int32 {
            self.timeoutSeconds = value
        }
    }
}

public class StaticsInfo : Tea.TeaModel {
    public var activeCPUUsage: Int64?

    public var cost: Double?

    public var diskUsage: Int64?

    public var functionName: String?

    public var gpuUsage: Int64?

    public var idleCPUUsage: Int64?

    public var instanceTrafficOut: Int64?

    public var invocations: Int64?

    public var invokeCDNOut: Int64?

    public var invokeInternetOut: Int64?

    public var memoryUsage: Int64?

    public var region: String?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activeCPUUsage != nil {
            map["activeCPUUsage"] = self.activeCPUUsage!
        }
        if self.cost != nil {
            map["cost"] = self.cost!
        }
        if self.diskUsage != nil {
            map["diskUsage"] = self.diskUsage!
        }
        if self.functionName != nil {
            map["functionName"] = self.functionName!
        }
        if self.gpuUsage != nil {
            map["gpuUsage"] = self.gpuUsage!
        }
        if self.idleCPUUsage != nil {
            map["idleCPUUsage"] = self.idleCPUUsage!
        }
        if self.instanceTrafficOut != nil {
            map["instanceTrafficOut"] = self.instanceTrafficOut!
        }
        if self.invocations != nil {
            map["invocations"] = self.invocations!
        }
        if self.invokeCDNOut != nil {
            map["invokeCDNOut"] = self.invokeCDNOut!
        }
        if self.invokeInternetOut != nil {
            map["invokeInternetOut"] = self.invokeInternetOut!
        }
        if self.memoryUsage != nil {
            map["memoryUsage"] = self.memoryUsage!
        }
        if self.region != nil {
            map["region"] = self.region!
        }
        if self.serviceName != nil {
            map["serviceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["activeCPUUsage"] as? Int64 {
            self.activeCPUUsage = value
        }
        if let value = dict["cost"] as? Double {
            self.cost = value
        }
        if let value = dict["diskUsage"] as? Int64 {
            self.diskUsage = value
        }
        if let value = dict["functionName"] as? String {
            self.functionName = value
        }
        if let value = dict["gpuUsage"] as? Int64 {
            self.gpuUsage = value
        }
        if let value = dict["idleCPUUsage"] as? Int64 {
            self.idleCPUUsage = value
        }
        if let value = dict["instanceTrafficOut"] as? Int64 {
            self.instanceTrafficOut = value
        }
        if let value = dict["invocations"] as? Int64 {
            self.invocations = value
        }
        if let value = dict["invokeCDNOut"] as? Int64 {
            self.invokeCDNOut = value
        }
        if let value = dict["invokeInternetOut"] as? Int64 {
            self.invokeInternetOut = value
        }
        if let value = dict["memoryUsage"] as? Int64 {
            self.memoryUsage = value
        }
        if let value = dict["region"] as? String {
            self.region = value
        }
        if let value = dict["serviceName"] as? String {
            self.serviceName = value
        }
    }
}

public class Submenu : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var defaultSelected: Bool?

        public var itemDesc: String?

        public var itemType: String?

        public var relatingItems: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultSelected != nil {
                map["DefaultSelected"] = self.defaultSelected!
            }
            if self.itemDesc != nil {
                map["ItemDesc"] = self.itemDesc!
            }
            if self.itemType != nil {
                map["ItemType"] = self.itemType!
            }
            if self.relatingItems != nil {
                map["RelatingItems"] = self.relatingItems!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DefaultSelected"] as? Bool {
                self.defaultSelected = value
            }
            if let value = dict["ItemDesc"] as? String {
                self.itemDesc = value
            }
            if let value = dict["ItemType"] as? String {
                self.itemType = value
            }
            if let value = dict["RelatingItems"] as? [String] {
                self.relatingItems = value
            }
        }
    }
    public var items: [Submenu.Items]?

    public var submenuDesc: String?

    public var submenuType: String?

    public var submenus: [Submenu]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.submenuDesc != nil {
            map["SubmenuDesc"] = self.submenuDesc!
        }
        if self.submenuType != nil {
            map["SubmenuType"] = self.submenuType!
        }
        if self.submenus != nil {
            var tmp : [Any] = []
            for k in self.submenus! {
                tmp.append(k.toMap())
            }
            map["Submenus"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [Submenu.Items] = []
            for v in value {
                if v != nil {
                    var model = Submenu.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["SubmenuDesc"] as? String {
            self.submenuDesc = value
        }
        if let value = dict["SubmenuType"] as? String {
            self.submenuType = value
        }
        if let value = dict["Submenus"] as? [Any?] {
            var tmp : [Submenu] = []
            for v in value {
                if v != nil {
                    var model = Submenu()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.submenus = tmp
        }
    }
}

public class TCPSocketAction : Tea.TeaModel {
    public var host: String?

    public var port: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.host != nil {
            map["Host"] = self.host!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Host"] as? String {
            self.host = value
        }
        if let value = dict["Port"] as? Int32 {
            self.port = value
        }
    }
}

public class TLSConfig : Tea.TeaModel {
    public var cipherSuites: [String]?

    public var maxVersion: String?

    public var minVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cipherSuites != nil {
            map["cipherSuites"] = self.cipherSuites!
        }
        if self.maxVersion != nil {
            map["maxVersion"] = self.maxVersion!
        }
        if self.minVersion != nil {
            map["minVersion"] = self.minVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["cipherSuites"] as? [String] {
            self.cipherSuites = value
        }
        if let value = dict["maxVersion"] as? String {
            self.maxVersion = value
        }
        if let value = dict["minVersion"] as? String {
            self.minVersion = value
        }
    }
}

public class TomcatConfig : Tea.TeaModel {
    public var contextPath: String?

    public var maxThreads: Int32?

    public var port: Int32?

    public var uriEncoding: String?

    public var useBodyEncodingForUri: Bool?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contextPath != nil {
            map["ContextPath"] = self.contextPath!
        }
        if self.maxThreads != nil {
            map["MaxThreads"] = self.maxThreads!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.uriEncoding != nil {
            map["UriEncoding"] = self.uriEncoding!
        }
        if self.useBodyEncodingForUri != nil {
            map["UseBodyEncodingForUri"] = self.useBodyEncodingForUri!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ContextPath"] as? String {
            self.contextPath = value
        }
        if let value = dict["MaxThreads"] as? Int32 {
            self.maxThreads = value
        }
        if let value = dict["Port"] as? Int32 {
            self.port = value
        }
        if let value = dict["UriEncoding"] as? String {
            self.uriEncoding = value
        }
        if let value = dict["UseBodyEncodingForUri"] as? Bool {
            self.useBodyEncodingForUri = value
        }
        if let value = dict["Version"] as? String {
            self.version = value
        }
    }
}

public class TracingConfig : Tea.TeaModel {
    public var jaegerConfig: JaegerConfig?

    public var params: Any?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jaegerConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jaegerConfig != nil {
            map["jaegerConfig"] = self.jaegerConfig?.toMap()
        }
        if self.params != nil {
            map["params"] = self.params!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["jaegerConfig"] as? [String: Any?] {
            var model = JaegerConfig()
            model.fromMap(value)
            self.jaegerConfig = model
        }
        if let value = dict["params"] as? Any {
            self.params = value
        }
        if let value = dict["type"] as? String {
            self.type = value
        }
    }
}

public class TrafficConfig : Tea.TeaModel {
    public var additionalVersionWeight: [String: Double]?

    public var createdTime: String?

    public var lastModifiedTime: String?

    public var requestId: String?

    public var resolvePolicy: String?

    public var routePolicy: RoutePolicy?

    public var versionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routePolicy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionalVersionWeight != nil {
            map["additionalVersionWeight"] = self.additionalVersionWeight!
        }
        if self.createdTime != nil {
            map["createdTime"] = self.createdTime!
        }
        if self.lastModifiedTime != nil {
            map["lastModifiedTime"] = self.lastModifiedTime!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.resolvePolicy != nil {
            map["resolvePolicy"] = self.resolvePolicy!
        }
        if self.routePolicy != nil {
            map["routePolicy"] = self.routePolicy?.toMap()
        }
        if self.versionId != nil {
            map["versionId"] = self.versionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["additionalVersionWeight"] as? [String: Double] {
            self.additionalVersionWeight = value
        }
        if let value = dict["createdTime"] as? String {
            self.createdTime = value
        }
        if let value = dict["lastModifiedTime"] as? String {
            self.lastModifiedTime = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["resolvePolicy"] as? String {
            self.resolvePolicy = value
        }
        if let value = dict["routePolicy"] as? [String: Any?] {
            var model = RoutePolicy()
            model.fromMap(value)
            self.routePolicy = model
        }
        if let value = dict["versionId"] as? String {
            self.versionId = value
        }
    }
}

public class UpdateApplicationInput : Tea.TeaModel {
    public var args: String?

    public var caPort: Int32?

    public var code: InputCodeLocation?

    public var command: String?

    public var cpu: Double?

    public var customDNS: CustomDNS?

    public var customHealthCheckConfig: CustomHealthCheckConfig?

    public var customHostAlias: CustomHostAlias?

    public var customRuntimeConfig: CustomRuntimeConfig?

    public var description_: String?

    public var diskSize: Int32?

    public var effectiveImmediately: Bool?

    public var enableAppMetric: Bool?

    public var environmentVariables: [String: String]?

    public var gpuMemorySize: Int32?

    public var handler: String?

    public var httpTriggerConfig: HTTPTriggerConfig?

    public var imageConfig: ImageConfig?

    public var initializationTimeout: Int32?

    public var initializer: String?

    public var instanceConcurrency: Int32?

    public var instanceLifecycleConfig: InstanceLifecycleConfig?

    public var instanceSoftConcurrency: Int32?

    public var instanceType: String?

    public var internetAccess: Bool?

    public var layers: [String]?

    public var livenessProbe: Probe?

    public var logConfig: LogConfig?

    public var memorySize: Int32?

    public var namespaceID: String?

    public var nasConfig: NASConfig?

    public var ossMountConfig: OSSMountConfig?

    public var programmingLanguage: String?

    public var runtime: String?

    public var scaleConfig: ScaleConfig?

    public var slsConfig: SLSConfig?

    public var startupProbe: Probe?

    public var timeout: Int32?

    public var tracingConfig: TracingConfig?

    public var vpcConfig: VPCConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.code?.validate()
        try self.customDNS?.validate()
        try self.customHealthCheckConfig?.validate()
        try self.customHostAlias?.validate()
        try self.customRuntimeConfig?.validate()
        try self.httpTriggerConfig?.validate()
        try self.imageConfig?.validate()
        try self.instanceLifecycleConfig?.validate()
        try self.livenessProbe?.validate()
        try self.logConfig?.validate()
        try self.nasConfig?.validate()
        try self.ossMountConfig?.validate()
        try self.scaleConfig?.validate()
        try self.slsConfig?.validate()
        try self.startupProbe?.validate()
        try self.tracingConfig?.validate()
        try self.vpcConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.args != nil {
            map["args"] = self.args!
        }
        if self.caPort != nil {
            map["caPort"] = self.caPort!
        }
        if self.code != nil {
            map["code"] = self.code?.toMap()
        }
        if self.command != nil {
            map["command"] = self.command!
        }
        if self.cpu != nil {
            map["cpu"] = self.cpu!
        }
        if self.customDNS != nil {
            map["customDNS"] = self.customDNS?.toMap()
        }
        if self.customHealthCheckConfig != nil {
            map["customHealthCheckConfig"] = self.customHealthCheckConfig?.toMap()
        }
        if self.customHostAlias != nil {
            map["customHostAlias"] = self.customHostAlias?.toMap()
        }
        if self.customRuntimeConfig != nil {
            map["customRuntimeConfig"] = self.customRuntimeConfig?.toMap()
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.diskSize != nil {
            map["diskSize"] = self.diskSize!
        }
        if self.effectiveImmediately != nil {
            map["effectiveImmediately"] = self.effectiveImmediately!
        }
        if self.enableAppMetric != nil {
            map["enableAppMetric"] = self.enableAppMetric!
        }
        if self.environmentVariables != nil {
            map["environmentVariables"] = self.environmentVariables!
        }
        if self.gpuMemorySize != nil {
            map["gpuMemorySize"] = self.gpuMemorySize!
        }
        if self.handler != nil {
            map["handler"] = self.handler!
        }
        if self.httpTriggerConfig != nil {
            map["httpTriggerConfig"] = self.httpTriggerConfig?.toMap()
        }
        if self.imageConfig != nil {
            map["imageConfig"] = self.imageConfig?.toMap()
        }
        if self.initializationTimeout != nil {
            map["initializationTimeout"] = self.initializationTimeout!
        }
        if self.initializer != nil {
            map["initializer"] = self.initializer!
        }
        if self.instanceConcurrency != nil {
            map["instanceConcurrency"] = self.instanceConcurrency!
        }
        if self.instanceLifecycleConfig != nil {
            map["instanceLifecycleConfig"] = self.instanceLifecycleConfig?.toMap()
        }
        if self.instanceSoftConcurrency != nil {
            map["instanceSoftConcurrency"] = self.instanceSoftConcurrency!
        }
        if self.instanceType != nil {
            map["instanceType"] = self.instanceType!
        }
        if self.internetAccess != nil {
            map["internetAccess"] = self.internetAccess!
        }
        if self.layers != nil {
            map["layers"] = self.layers!
        }
        if self.livenessProbe != nil {
            map["livenessProbe"] = self.livenessProbe?.toMap()
        }
        if self.logConfig != nil {
            map["logConfig"] = self.logConfig?.toMap()
        }
        if self.memorySize != nil {
            map["memorySize"] = self.memorySize!
        }
        if self.namespaceID != nil {
            map["namespaceID"] = self.namespaceID!
        }
        if self.nasConfig != nil {
            map["nasConfig"] = self.nasConfig?.toMap()
        }
        if self.ossMountConfig != nil {
            map["ossMountConfig"] = self.ossMountConfig?.toMap()
        }
        if self.programmingLanguage != nil {
            map["programmingLanguage"] = self.programmingLanguage!
        }
        if self.runtime != nil {
            map["runtime"] = self.runtime!
        }
        if self.scaleConfig != nil {
            map["scaleConfig"] = self.scaleConfig?.toMap()
        }
        if self.slsConfig != nil {
            map["slsConfig"] = self.slsConfig?.toMap()
        }
        if self.startupProbe != nil {
            map["startupProbe"] = self.startupProbe?.toMap()
        }
        if self.timeout != nil {
            map["timeout"] = self.timeout!
        }
        if self.tracingConfig != nil {
            map["tracingConfig"] = self.tracingConfig?.toMap()
        }
        if self.vpcConfig != nil {
            map["vpcConfig"] = self.vpcConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["args"] as? String {
            self.args = value
        }
        if let value = dict["caPort"] as? Int32 {
            self.caPort = value
        }
        if let value = dict["code"] as? [String: Any?] {
            var model = InputCodeLocation()
            model.fromMap(value)
            self.code = model
        }
        if let value = dict["command"] as? String {
            self.command = value
        }
        if let value = dict["cpu"] as? Double {
            self.cpu = value
        }
        if let value = dict["customDNS"] as? [String: Any?] {
            var model = CustomDNS()
            model.fromMap(value)
            self.customDNS = model
        }
        if let value = dict["customHealthCheckConfig"] as? [String: Any?] {
            var model = CustomHealthCheckConfig()
            model.fromMap(value)
            self.customHealthCheckConfig = model
        }
        if let value = dict["customHostAlias"] as? [String: Any?] {
            var model = CustomHostAlias()
            model.fromMap(value)
            self.customHostAlias = model
        }
        if let value = dict["customRuntimeConfig"] as? [String: Any?] {
            var model = CustomRuntimeConfig()
            model.fromMap(value)
            self.customRuntimeConfig = model
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["diskSize"] as? Int32 {
            self.diskSize = value
        }
        if let value = dict["effectiveImmediately"] as? Bool {
            self.effectiveImmediately = value
        }
        if let value = dict["enableAppMetric"] as? Bool {
            self.enableAppMetric = value
        }
        if let value = dict["environmentVariables"] as? [String: String] {
            self.environmentVariables = value
        }
        if let value = dict["gpuMemorySize"] as? Int32 {
            self.gpuMemorySize = value
        }
        if let value = dict["handler"] as? String {
            self.handler = value
        }
        if let value = dict["httpTriggerConfig"] as? [String: Any?] {
            var model = HTTPTriggerConfig()
            model.fromMap(value)
            self.httpTriggerConfig = model
        }
        if let value = dict["imageConfig"] as? [String: Any?] {
            var model = ImageConfig()
            model.fromMap(value)
            self.imageConfig = model
        }
        if let value = dict["initializationTimeout"] as? Int32 {
            self.initializationTimeout = value
        }
        if let value = dict["initializer"] as? String {
            self.initializer = value
        }
        if let value = dict["instanceConcurrency"] as? Int32 {
            self.instanceConcurrency = value
        }
        if let value = dict["instanceLifecycleConfig"] as? [String: Any?] {
            var model = InstanceLifecycleConfig()
            model.fromMap(value)
            self.instanceLifecycleConfig = model
        }
        if let value = dict["instanceSoftConcurrency"] as? Int32 {
            self.instanceSoftConcurrency = value
        }
        if let value = dict["instanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["internetAccess"] as? Bool {
            self.internetAccess = value
        }
        if let value = dict["layers"] as? [String] {
            self.layers = value
        }
        if let value = dict["livenessProbe"] as? [String: Any?] {
            var model = Probe()
            model.fromMap(value)
            self.livenessProbe = model
        }
        if let value = dict["logConfig"] as? [String: Any?] {
            var model = LogConfig()
            model.fromMap(value)
            self.logConfig = model
        }
        if let value = dict["memorySize"] as? Int32 {
            self.memorySize = value
        }
        if let value = dict["namespaceID"] as? String {
            self.namespaceID = value
        }
        if let value = dict["nasConfig"] as? [String: Any?] {
            var model = NASConfig()
            model.fromMap(value)
            self.nasConfig = model
        }
        if let value = dict["ossMountConfig"] as? [String: Any?] {
            var model = OSSMountConfig()
            model.fromMap(value)
            self.ossMountConfig = model
        }
        if let value = dict["programmingLanguage"] as? String {
            self.programmingLanguage = value
        }
        if let value = dict["runtime"] as? String {
            self.runtime = value
        }
        if let value = dict["scaleConfig"] as? [String: Any?] {
            var model = ScaleConfig()
            model.fromMap(value)
            self.scaleConfig = model
        }
        if let value = dict["slsConfig"] as? [String: Any?] {
            var model = SLSConfig()
            model.fromMap(value)
            self.slsConfig = model
        }
        if let value = dict["startupProbe"] as? [String: Any?] {
            var model = Probe()
            model.fromMap(value)
            self.startupProbe = model
        }
        if let value = dict["timeout"] as? Int32 {
            self.timeout = value
        }
        if let value = dict["tracingConfig"] as? [String: Any?] {
            var model = TracingConfig()
            model.fromMap(value)
            self.tracingConfig = model
        }
        if let value = dict["vpcConfig"] as? [String: Any?] {
            var model = VPCConfig()
            model.fromMap(value)
            self.vpcConfig = model
        }
    }
}

public class UpdateApplicationScaleConfigInput : Tea.TeaModel {
    public var alwaysAllocateCPU: Bool?

    public var maximumInstanceCount: Int64?

    public var minimumInstanceCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alwaysAllocateCPU != nil {
            map["alwaysAllocateCPU"] = self.alwaysAllocateCPU!
        }
        if self.maximumInstanceCount != nil {
            map["maximumInstanceCount"] = self.maximumInstanceCount!
        }
        if self.minimumInstanceCount != nil {
            map["minimumInstanceCount"] = self.minimumInstanceCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["alwaysAllocateCPU"] as? Bool {
            self.alwaysAllocateCPU = value
        }
        if let value = dict["maximumInstanceCount"] as? Int64 {
            self.maximumInstanceCount = value
        }
        if let value = dict["minimumInstanceCount"] as? Int64 {
            self.minimumInstanceCount = value
        }
    }
}

public class UpdateApplicationTrafficConfigInput : Tea.TeaModel {
    public var additionalVersionWeight: [String: Double]?

    public var resolvePolicy: String?

    public var routePolicy: RoutePolicy?

    public var versionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routePolicy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionalVersionWeight != nil {
            map["additionalVersionWeight"] = self.additionalVersionWeight!
        }
        if self.resolvePolicy != nil {
            map["resolvePolicy"] = self.resolvePolicy!
        }
        if self.routePolicy != nil {
            map["routePolicy"] = self.routePolicy?.toMap()
        }
        if self.versionId != nil {
            map["versionId"] = self.versionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["additionalVersionWeight"] as? [String: Double] {
            self.additionalVersionWeight = value
        }
        if let value = dict["resolvePolicy"] as? String {
            self.resolvePolicy = value
        }
        if let value = dict["routePolicy"] as? [String: Any?] {
            var model = RoutePolicy()
            model.fromMap(value)
            self.routePolicy = model
        }
        if let value = dict["versionId"] as? String {
            self.versionId = value
        }
    }
}

public class UpdateAttributesInput : Tea.TeaModel {
    public var description_: String?

    public var httpTriggerConfig: HTTPTriggerConfig?

    public var versionID: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.httpTriggerConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.httpTriggerConfig != nil {
            map["httpTriggerConfig"] = self.httpTriggerConfig?.toMap()
        }
        if self.versionID != nil {
            map["versionID"] = self.versionID!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["httpTriggerConfig"] as? [String: Any?] {
            var model = HTTPTriggerConfig()
            model.fromMap(value)
            self.httpTriggerConfig = model
        }
        if let value = dict["versionID"] as? String {
            self.versionID = value
        }
    }
}

public class UpdateCustomDomainInput : Tea.TeaModel {
    public var applicationID: String?

    public var applicationName: String?

    public var certConfig: CertConfig?

    public var keepFullPath: Bool?

    public var namespaceID: String?

    public var protocol_: String?

    public var tlsConfig: TLSConfig?

    public var wafConfig: WAFConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.certConfig?.validate()
        try self.tlsConfig?.validate()
        try self.wafConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationID != nil {
            map["applicationID"] = self.applicationID!
        }
        if self.applicationName != nil {
            map["applicationName"] = self.applicationName!
        }
        if self.certConfig != nil {
            map["certConfig"] = self.certConfig?.toMap()
        }
        if self.keepFullPath != nil {
            map["keepFullPath"] = self.keepFullPath!
        }
        if self.namespaceID != nil {
            map["namespaceID"] = self.namespaceID!
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.tlsConfig != nil {
            map["tlsConfig"] = self.tlsConfig?.toMap()
        }
        if self.wafConfig != nil {
            map["wafConfig"] = self.wafConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["applicationID"] as? String {
            self.applicationID = value
        }
        if let value = dict["applicationName"] as? String {
            self.applicationName = value
        }
        if let value = dict["certConfig"] as? [String: Any?] {
            var model = CertConfig()
            model.fromMap(value)
            self.certConfig = model
        }
        if let value = dict["keepFullPath"] as? Bool {
            self.keepFullPath = value
        }
        if let value = dict["namespaceID"] as? String {
            self.namespaceID = value
        }
        if let value = dict["protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["tlsConfig"] as? [String: Any?] {
            var model = TLSConfig()
            model.fromMap(value)
            self.tlsConfig = model
        }
        if let value = dict["wafConfig"] as? [String: Any?] {
            var model = WAFConfig()
            model.fromMap(value)
            self.wafConfig = model
        }
    }
}

public class UpdateWebApplicationInput : Tea.TeaModel {
    public var description_: String?

    public var webNetworkConfig: WebNetworkConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.webNetworkConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.webNetworkConfig != nil {
            map["WebNetworkConfig"] = self.webNetworkConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["WebNetworkConfig"] as? [String: Any?] {
            var model = WebNetworkConfig()
            model.fromMap(value)
            self.webNetworkConfig = model
        }
    }
}

public class UpdateWebApplicationScalingConfigInput : Tea.TeaModel {
    public var maximumInstanceCount: Int64?

    public var minimumInstanceCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maximumInstanceCount != nil {
            map["MaximumInstanceCount"] = self.maximumInstanceCount!
        }
        if self.minimumInstanceCount != nil {
            map["MinimumInstanceCount"] = self.minimumInstanceCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaximumInstanceCount"] as? Int64 {
            self.maximumInstanceCount = value
        }
        if let value = dict["MinimumInstanceCount"] as? Int64 {
            self.minimumInstanceCount = value
        }
    }
}

public class UpdateWebApplicationTrafficConfigInput : Tea.TeaModel {
    public var authType: String?

    public var disableURLInternet: Bool?

    public var revisionsTrafficWeight: [String: Double]?

    public var webAclConfig: WebAclConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.webAclConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.disableURLInternet != nil {
            map["DisableURLInternet"] = self.disableURLInternet!
        }
        if self.revisionsTrafficWeight != nil {
            map["RevisionsTrafficWeight"] = self.revisionsTrafficWeight!
        }
        if self.webAclConfig != nil {
            map["WebAclConfig"] = self.webAclConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AuthType"] as? String {
            self.authType = value
        }
        if let value = dict["DisableURLInternet"] as? Bool {
            self.disableURLInternet = value
        }
        if let value = dict["RevisionsTrafficWeight"] as? [String: Double] {
            self.revisionsTrafficWeight = value
        }
        if let value = dict["WebAclConfig"] as? [String: Any?] {
            var model = WebAclConfig()
            model.fromMap(value)
            self.webAclConfig = model
        }
    }
}

public class UpdateWebCustomDomainInput : Tea.TeaModel {
    public var defaultForwardingAppName: String?

    public var protocol_: String?

    public var routeConfig: RouteConfig?

    public var webCertConfig: WebCertConfig?

    public var webTLSConfig: WebTLSConfig?

    public var webWAFConfig: WebWAFConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routeConfig?.validate()
        try self.webCertConfig?.validate()
        try self.webTLSConfig?.validate()
        try self.webWAFConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultForwardingAppName != nil {
            map["DefaultForwardingAppName"] = self.defaultForwardingAppName!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.routeConfig != nil {
            map["RouteConfig"] = self.routeConfig?.toMap()
        }
        if self.webCertConfig != nil {
            map["WebCertConfig"] = self.webCertConfig?.toMap()
        }
        if self.webTLSConfig != nil {
            map["WebTLSConfig"] = self.webTLSConfig?.toMap()
        }
        if self.webWAFConfig != nil {
            map["WebWAFConfig"] = self.webWAFConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DefaultForwardingAppName"] as? String {
            self.defaultForwardingAppName = value
        }
        if let value = dict["Protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["RouteConfig"] as? [String: Any?] {
            var model = RouteConfig()
            model.fromMap(value)
            self.routeConfig = model
        }
        if let value = dict["WebCertConfig"] as? [String: Any?] {
            var model = WebCertConfig()
            model.fromMap(value)
            self.webCertConfig = model
        }
        if let value = dict["WebTLSConfig"] as? [String: Any?] {
            var model = WebTLSConfig()
            model.fromMap(value)
            self.webTLSConfig = model
        }
        if let value = dict["WebWAFConfig"] as? [String: Any?] {
            var model = WebWAFConfig()
            model.fromMap(value)
            self.webWAFConfig = model
        }
    }
}

public class VPCConfig : Tea.TeaModel {
    public var anytunnelViaENI: Bool?

    public var role: String?

    public var securityGroupId: String?

    public var vSwitchIds: [String]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.anytunnelViaENI != nil {
            map["anytunnelViaENI"] = self.anytunnelViaENI!
        }
        if self.role != nil {
            map["role"] = self.role!
        }
        if self.securityGroupId != nil {
            map["securityGroupId"] = self.securityGroupId!
        }
        if self.vSwitchIds != nil {
            map["vSwitchIds"] = self.vSwitchIds!
        }
        if self.vpcId != nil {
            map["vpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["anytunnelViaENI"] as? Bool {
            self.anytunnelViaENI = value
        }
        if let value = dict["role"] as? String {
            self.role = value
        }
        if let value = dict["securityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["vSwitchIds"] as? [String] {
            self.vSwitchIds = value
        }
        if let value = dict["vpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class Version : Tea.TeaModel {
    public var createdTime: String?

    public var description_: String?

    public var image: String?

    public var lastModifiedTime: String?

    public var requestId: String?

    public var versionId: String?

    public var weight: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createdTime != nil {
            map["createdTime"] = self.createdTime!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.image != nil {
            map["image"] = self.image!
        }
        if self.lastModifiedTime != nil {
            map["lastModifiedTime"] = self.lastModifiedTime!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.versionId != nil {
            map["versionId"] = self.versionId!
        }
        if self.weight != nil {
            map["weight"] = self.weight!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["createdTime"] as? String {
            self.createdTime = value
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["image"] as? String {
            self.image = value
        }
        if let value = dict["lastModifiedTime"] as? String {
            self.lastModifiedTime = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["versionId"] as? String {
            self.versionId = value
        }
        if let value = dict["weight"] as? Double {
            self.weight = value
        }
    }
}

public class VersionStatus : Tea.TeaModel {
    public var errorMessage: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorMessage != nil {
            map["errorMessage"] = self.errorMessage!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["errorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["status"] as? String {
            self.status = value
        }
    }
}

public class WAFConfig : Tea.TeaModel {
    public var enableWAF: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableWAF != nil {
            map["enableWAF"] = self.enableWAF!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["enableWAF"] as? Bool {
            self.enableWAF = value
        }
    }
}

public class WebAclConfig : Tea.TeaModel {
    public var webAclEntries: [WebAclEntryConfig]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.webAclEntries != nil {
            var tmp : [Any] = []
            for k in self.webAclEntries! {
                tmp.append(k.toMap())
            }
            map["WebAclEntries"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["WebAclEntries"] as? [Any?] {
            var tmp : [WebAclEntryConfig] = []
            for v in value {
                if v != nil {
                    var model = WebAclEntryConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.webAclEntries = tmp
        }
    }
}

public class WebAclEntryConfig : Tea.TeaModel {
    public var entry: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.entry != nil {
            map["Entry"] = self.entry!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Entry"] as? String {
            self.entry = value
        }
    }
}

public class WebApplication : Tea.TeaModel {
    public var applicationId: String?

    public var applicationName: String?

    public var createdTime: String?

    public var description_: String?

    public var internetURL: String?

    public var intranetURL: String?

    public var lastModifiedTime: String?

    public var namespaceId: String?

    public var revisionConfig: RevisionConfig?

    public var vpcId: String?

    public var webScalingConfig: WebScalingConfig?

    public var webTrafficConfig: WebTrafficConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.revisionConfig?.validate()
        try self.webScalingConfig?.validate()
        try self.webTrafficConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.applicationName != nil {
            map["ApplicationName"] = self.applicationName!
        }
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.internetURL != nil {
            map["InternetURL"] = self.internetURL!
        }
        if self.intranetURL != nil {
            map["IntranetURL"] = self.intranetURL!
        }
        if self.lastModifiedTime != nil {
            map["LastModifiedTime"] = self.lastModifiedTime!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.revisionConfig != nil {
            map["RevisionConfig"] = self.revisionConfig?.toMap()
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.webScalingConfig != nil {
            map["WebScalingConfig"] = self.webScalingConfig?.toMap()
        }
        if self.webTrafficConfig != nil {
            map["WebTrafficConfig"] = self.webTrafficConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["ApplicationName"] as? String {
            self.applicationName = value
        }
        if let value = dict["CreatedTime"] as? String {
            self.createdTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["InternetURL"] as? String {
            self.internetURL = value
        }
        if let value = dict["IntranetURL"] as? String {
            self.intranetURL = value
        }
        if let value = dict["LastModifiedTime"] as? String {
            self.lastModifiedTime = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["RevisionConfig"] as? [String: Any?] {
            var model = RevisionConfig()
            model.fromMap(value)
            self.revisionConfig = model
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["WebScalingConfig"] as? [String: Any?] {
            var model = WebScalingConfig()
            model.fromMap(value)
            self.webScalingConfig = model
        }
        if let value = dict["WebTrafficConfig"] as? [String: Any?] {
            var model = WebTrafficConfig()
            model.fromMap(value)
            self.webTrafficConfig = model
        }
    }
}

public class WebApplicationBody : Tea.TeaModel {
    public var code: Int32?

    public var data: WebApplication?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = WebApplication()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class WebApplicationInstanceLogsBody : Tea.TeaModel {
    public var code: Int32?

    public var data: DescribeInstanceLogsOutput?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeInstanceLogsOutput()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class WebApplicationResourceStaticsBody : Tea.TeaModel {
    public var code: Int32?

    public var data: DescribeWebAppStaticsOutput?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeWebAppStaticsOutput()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class WebApplicationRevisionBody : Tea.TeaModel {
    public var code: Int32?

    public var data: Revision?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = Revision()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class WebApplicationScalingConfigBody : Tea.TeaModel {
    public var code: Int32?

    public var data: WebScalingConfig?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = WebScalingConfig()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class WebApplicationStatus : Tea.TeaModel {
    public var instanceCount: Int64?

    public var webScalingConfig: WebScalingConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.webScalingConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceCount != nil {
            map["InstanceCount"] = self.instanceCount!
        }
        if self.webScalingConfig != nil {
            map["WebScalingConfig"] = self.webScalingConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceCount"] as? Int64 {
            self.instanceCount = value
        }
        if let value = dict["WebScalingConfig"] as? [String: Any?] {
            var model = WebScalingConfig()
            model.fromMap(value)
            self.webScalingConfig = model
        }
    }
}

public class WebApplicationTrafficConfigBody : Tea.TeaModel {
    public var code: Int32?

    public var data: WebTrafficConfig?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = WebTrafficConfig()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class WebApplicationWithInstanceCount : Tea.TeaModel {
    public var instanceCount: Int64?

    public var webApplication: WebApplication?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.webApplication?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceCount != nil {
            map["InstanceCount"] = self.instanceCount!
        }
        if self.webApplication != nil {
            map["WebApplication"] = self.webApplication?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceCount"] as? Int64 {
            self.instanceCount = value
        }
        if let value = dict["WebApplication"] as? [String: Any?] {
            var model = WebApplication()
            model.fromMap(value)
            self.webApplication = model
        }
    }
}

public class WebApplicationWithStatus : Tea.TeaModel {
    public var status: WebApplicationStatus?

    public var webApplication: WebApplication?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.status?.validate()
        try self.webApplication?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.status != nil {
            map["Status"] = self.status?.toMap()
        }
        if self.webApplication != nil {
            map["WebApplication"] = self.webApplication?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Status"] as? [String: Any?] {
            var model = WebApplicationStatus()
            model.fromMap(value)
            self.status = model
        }
        if let value = dict["WebApplication"] as? [String: Any?] {
            var model = WebApplication()
            model.fromMap(value)
            self.webApplication = model
        }
    }
}

public class WebCertConfig : Tea.TeaModel {
    public var certName: String?

    public var certificate: String?

    public var privateKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certName != nil {
            map["CertName"] = self.certName!
        }
        if self.certificate != nil {
            map["Certificate"] = self.certificate!
        }
        if self.privateKey != nil {
            map["PrivateKey"] = self.privateKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CertName"] as? String {
            self.certName = value
        }
        if let value = dict["Certificate"] as? String {
            self.certificate = value
        }
        if let value = dict["PrivateKey"] as? String {
            self.privateKey = value
        }
    }
}

public class WebCustomDomain : Tea.TeaModel {
    public var createdTime: String?

    public var defaultForwardingAppName: String?

    public var domainName: String?

    public var lastModifiedTime: String?

    public var namespaceId: String?

    public var protocol_: String?

    public var routeConfig: RouteConfig?

    public var webCertConfig: WebCertConfig?

    public var webTLSConfig: WebTLSConfig?

    public var webWAFConfig: WebWAFConfig?

    public var accountId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routeConfig?.validate()
        try self.webCertConfig?.validate()
        try self.webTLSConfig?.validate()
        try self.webWAFConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.defaultForwardingAppName != nil {
            map["DefaultForwardingAppName"] = self.defaultForwardingAppName!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.lastModifiedTime != nil {
            map["LastModifiedTime"] = self.lastModifiedTime!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.routeConfig != nil {
            map["RouteConfig"] = self.routeConfig?.toMap()
        }
        if self.webCertConfig != nil {
            map["WebCertConfig"] = self.webCertConfig?.toMap()
        }
        if self.webTLSConfig != nil {
            map["WebTLSConfig"] = self.webTLSConfig?.toMap()
        }
        if self.webWAFConfig != nil {
            map["WebWAFConfig"] = self.webWAFConfig?.toMap()
        }
        if self.accountId != nil {
            map["accountId"] = self.accountId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreatedTime"] as? String {
            self.createdTime = value
        }
        if let value = dict["DefaultForwardingAppName"] as? String {
            self.defaultForwardingAppName = value
        }
        if let value = dict["DomainName"] as? String {
            self.domainName = value
        }
        if let value = dict["LastModifiedTime"] as? String {
            self.lastModifiedTime = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["Protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["RouteConfig"] as? [String: Any?] {
            var model = RouteConfig()
            model.fromMap(value)
            self.routeConfig = model
        }
        if let value = dict["WebCertConfig"] as? [String: Any?] {
            var model = WebCertConfig()
            model.fromMap(value)
            self.webCertConfig = model
        }
        if let value = dict["WebTLSConfig"] as? [String: Any?] {
            var model = WebTLSConfig()
            model.fromMap(value)
            self.webTLSConfig = model
        }
        if let value = dict["WebWAFConfig"] as? [String: Any?] {
            var model = WebWAFConfig()
            model.fromMap(value)
            self.webWAFConfig = model
        }
        if let value = dict["accountId"] as? String {
            self.accountId = value
        }
    }
}

public class WebCustomDomainBody : Tea.TeaModel {
    public var code: Int32?

    public var data: WebCustomDomain?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = WebCustomDomain()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class WebInstanceInfo : Tea.TeaModel {
    public var imageUrl: String?

    public var instanceId: String?

    public var status: String?

    public var versionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.versionId != nil {
            map["VersionId"] = self.versionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ImageUrl"] as? String {
            self.imageUrl = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["VersionId"] as? String {
            self.versionId = value
        }
    }
}

public class WebLogEntry : Tea.TeaModel {
    public var message: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Message"] as? String {
            self.message = value
        }
    }
}

public class WebNASConfig : Tea.TeaModel {
    public var mountPoints: [WebNASMountPoint]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mountPoints != nil {
            var tmp : [Any] = []
            for k in self.mountPoints! {
                tmp.append(k.toMap())
            }
            map["MountPoints"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MountPoints"] as? [Any?] {
            var tmp : [WebNASMountPoint] = []
            for v in value {
                if v != nil {
                    var model = WebNASMountPoint()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.mountPoints = tmp
        }
    }
}

public class WebNASMountPoint : Tea.TeaModel {
    public var mountDir: String?

    public var nasAddr: String?

    public var nasPath: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mountDir != nil {
            map["MountDir"] = self.mountDir!
        }
        if self.nasAddr != nil {
            map["NasAddr"] = self.nasAddr!
        }
        if self.nasPath != nil {
            map["NasPath"] = self.nasPath!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MountDir"] as? String {
            self.mountDir = value
        }
        if let value = dict["NasAddr"] as? String {
            self.nasAddr = value
        }
        if let value = dict["NasPath"] as? String {
            self.nasPath = value
        }
    }
}

public class WebNetworkConfig : Tea.TeaModel {
    public var internetAccess: Bool?

    public var securityGroupId: String?

    public var vSwitchIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.internetAccess != nil {
            map["InternetAccess"] = self.internetAccess!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InternetAccess"] as? Bool {
            self.internetAccess = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["VSwitchIds"] as? [String] {
            self.vSwitchIds = value
        }
    }
}

public class WebOSSConfig : Tea.TeaModel {
    public var mountPoints: [WebOSSMountPoint]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.mountPoints != nil {
            var tmp : [Any] = []
            for k in self.mountPoints! {
                tmp.append(k.toMap())
            }
            map["MountPoints"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MountPoints"] as? [Any?] {
            var tmp : [WebOSSMountPoint] = []
            for v in value {
                if v != nil {
                    var model = WebOSSMountPoint()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.mountPoints = tmp
        }
    }
}

public class WebOSSMountPoint : Tea.TeaModel {
    public var bucketName: String?

    public var bucketPath: String?

    public var mountDir: String?

    public var readOnly: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bucketName != nil {
            map["BucketName"] = self.bucketName!
        }
        if self.bucketPath != nil {
            map["BucketPath"] = self.bucketPath!
        }
        if self.mountDir != nil {
            map["MountDir"] = self.mountDir!
        }
        if self.readOnly != nil {
            map["ReadOnly"] = self.readOnly!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BucketName"] as? String {
            self.bucketName = value
        }
        if let value = dict["BucketPath"] as? String {
            self.bucketPath = value
        }
        if let value = dict["MountDir"] as? String {
            self.mountDir = value
        }
        if let value = dict["ReadOnly"] as? Bool {
            self.readOnly = value
        }
    }
}

public class WebScalingConfig : Tea.TeaModel {
    public var maximumInstanceCount: Int64?

    public var minimumInstanceCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maximumInstanceCount != nil {
            map["MaximumInstanceCount"] = self.maximumInstanceCount!
        }
        if self.minimumInstanceCount != nil {
            map["MinimumInstanceCount"] = self.minimumInstanceCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MaximumInstanceCount"] as? Int64 {
            self.maximumInstanceCount = value
        }
        if let value = dict["MinimumInstanceCount"] as? Int64 {
            self.minimumInstanceCount = value
        }
    }
}

public class WebStaticsInfo : Tea.TeaModel {
    public var cpuUsage: Int64?

    public var internetTrafficOut: Int64?

    public var invocations: Int64?

    public var memoryUsage: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpuUsage != nil {
            map["CpuUsage"] = self.cpuUsage!
        }
        if self.internetTrafficOut != nil {
            map["InternetTrafficOut"] = self.internetTrafficOut!
        }
        if self.invocations != nil {
            map["Invocations"] = self.invocations!
        }
        if self.memoryUsage != nil {
            map["MemoryUsage"] = self.memoryUsage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CpuUsage"] as? Int64 {
            self.cpuUsage = value
        }
        if let value = dict["InternetTrafficOut"] as? Int64 {
            self.internetTrafficOut = value
        }
        if let value = dict["Invocations"] as? Int64 {
            self.invocations = value
        }
        if let value = dict["MemoryUsage"] as? Int64 {
            self.memoryUsage = value
        }
    }
}

public class WebTLSConfig : Tea.TeaModel {
    public var cipherSuites: [String]?

    public var maxVersion: String?

    public var minVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cipherSuites != nil {
            map["CipherSuites"] = self.cipherSuites!
        }
        if self.maxVersion != nil {
            map["MaxVersion"] = self.maxVersion!
        }
        if self.minVersion != nil {
            map["MinVersion"] = self.minVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CipherSuites"] as? [String] {
            self.cipherSuites = value
        }
        if let value = dict["MaxVersion"] as? String {
            self.maxVersion = value
        }
        if let value = dict["MinVersion"] as? String {
            self.minVersion = value
        }
    }
}

public class WebTrafficConfig : Tea.TeaModel {
    public var authType: String?

    public var disableInternetURL: Bool?

    public var revisionsTrafficWeight: [String: Double]?

    public var webAclConfig: WebAclConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.webAclConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authType != nil {
            map["AuthType"] = self.authType!
        }
        if self.disableInternetURL != nil {
            map["DisableInternetURL"] = self.disableInternetURL!
        }
        if self.revisionsTrafficWeight != nil {
            map["RevisionsTrafficWeight"] = self.revisionsTrafficWeight!
        }
        if self.webAclConfig != nil {
            map["WebAclConfig"] = self.webAclConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AuthType"] as? String {
            self.authType = value
        }
        if let value = dict["DisableInternetURL"] as? Bool {
            self.disableInternetURL = value
        }
        if let value = dict["RevisionsTrafficWeight"] as? [String: Double] {
            self.revisionsTrafficWeight = value
        }
        if let value = dict["WebAclConfig"] as? [String: Any?] {
            var model = WebAclConfig()
            model.fromMap(value)
            self.webAclConfig = model
        }
    }
}

public class WebVersionStatus : Tea.TeaModel {
    public var errorMessage: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.errorMessage != nil {
            map["ErrorMessage"] = self.errorMessage!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ErrorMessage"] as? String {
            self.errorMessage = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class WebWAFConfig : Tea.TeaModel {
    public var enableWAF: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableWAF != nil {
            map["EnableWAF"] = self.enableWAF!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EnableWAF"] as? Bool {
            self.enableWAF = value
        }
    }
}

public class DataInstancesValue : Tea.TeaModel {
    public var dnsName: String?

    public var listeners: [String: DataInstancesValueListenersValue]?

    public var createdBySae: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dnsName != nil {
            map["DnsName"] = self.dnsName!
        }
        if self.listeners != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.listeners! {
                tmp[k] = v.toMap()
            }
            map["Listeners"] = tmp
        }
        if self.createdBySae != nil {
            map["CreatedBySae"] = self.createdBySae!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DnsName"] as? String {
            self.dnsName = value
        }
        if let value = dict["Listeners"] as? [String: Any?] {
            var tmp : [String: DataInstancesValueListenersValue] = [:]
            for (k, v) in value {
                if v != nil {
                    var model = DataInstancesValueListenersValue()
                    model.fromMap(v as? [String: Any?])
                    tmp[k] = model
                }
            }
            self.listeners = tmp
        }
        if let value = dict["CreatedBySae"] as? Bool {
            self.createdBySae = value
        }
    }
}

public class DataInstancesValueListenersValue : Tea.TeaModel {
    public var protocol_: String?

    public var port: Int32?

    public var status: String?

    public var targetPort: Int32?

    public var certIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.targetPort != nil {
            map["TargetPort"] = self.targetPort!
        }
        if self.certIds != nil {
            map["CertIds"] = self.certIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["Port"] as? Int32 {
            self.port = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["TargetPort"] as? Int32 {
            self.targetPort = value
        }
        if let value = dict["CertIds"] as? String {
            self.certIds = value
        }
    }
}

public class AbortAndRollbackChangeOrderRequest : Tea.TeaModel {
    public var changeOrderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
    }
}

public class AbortAndRollbackChangeOrderResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: AbortAndRollbackChangeOrderResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = AbortAndRollbackChangeOrderResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class AbortAndRollbackChangeOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AbortAndRollbackChangeOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AbortAndRollbackChangeOrderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AbortChangeOrderRequest : Tea.TeaModel {
    public var changeOrderId: String?

    public var rollback: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        if self.rollback != nil {
            map["Rollback"] = self.rollback!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
        if let value = dict["Rollback"] as? Bool {
            self.rollback = value
        }
    }
}

public class AbortChangeOrderResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: AbortChangeOrderResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = AbortChangeOrderResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class AbortChangeOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AbortChangeOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AbortChangeOrderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class BatchRestartApplicationsRequest : Tea.TeaModel {
    public var appIds: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppIds"] as? String {
            self.appIds = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class BatchRestartApplicationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: BatchRestartApplicationsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = BatchRestartApplicationsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class BatchRestartApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchRestartApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = BatchRestartApplicationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class BatchStartApplicationsRequest : Tea.TeaModel {
    public var appIds: String?

    public var namespaceId: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppIds"] as? String {
            self.appIds = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["Version"] as? String {
            self.version = value
        }
    }
}

public class BatchStartApplicationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: BatchStartApplicationsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = BatchStartApplicationsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class BatchStartApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchStartApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = BatchStartApplicationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class BatchStopApplicationsRequest : Tea.TeaModel {
    public var appIds: String?

    public var namespaceId: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.version != nil {
            map["Version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppIds"] as? String {
            self.appIds = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["Version"] as? String {
            self.version = value
        }
    }
}

public class BatchStopApplicationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: BatchStopApplicationsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = BatchStopApplicationsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class BatchStopApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchStopApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = BatchStopApplicationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class BindNlbRequest : Tea.TeaModel {
    public var addressType: String?

    public var appId: String?

    public var listeners: String?

    public var nlbId: String?

    public var zoneMappings: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressType != nil {
            map["AddressType"] = self.addressType!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.listeners != nil {
            map["Listeners"] = self.listeners!
        }
        if self.nlbId != nil {
            map["NlbId"] = self.nlbId!
        }
        if self.zoneMappings != nil {
            map["ZoneMappings"] = self.zoneMappings!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressType"] as? String {
            self.addressType = value
        }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Listeners"] as? String {
            self.listeners = value
        }
        if let value = dict["NlbId"] as? String {
            self.nlbId = value
        }
        if let value = dict["ZoneMappings"] as? String {
            self.zoneMappings = value
        }
    }
}

public class BindNlbResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: BindNlbResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = BindNlbResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class BindNlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindNlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = BindNlbResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class BindSlbRequest : Tea.TeaModel {
    public var appId: String?

    public var internet: String?

    public var internetSlbChargeType: String?

    public var internetSlbId: String?

    public var intranet: String?

    public var intranetSlbChargeType: String?

    public var intranetSlbId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.internet != nil {
            map["Internet"] = self.internet!
        }
        if self.internetSlbChargeType != nil {
            map["InternetSlbChargeType"] = self.internetSlbChargeType!
        }
        if self.internetSlbId != nil {
            map["InternetSlbId"] = self.internetSlbId!
        }
        if self.intranet != nil {
            map["Intranet"] = self.intranet!
        }
        if self.intranetSlbChargeType != nil {
            map["IntranetSlbChargeType"] = self.intranetSlbChargeType!
        }
        if self.intranetSlbId != nil {
            map["IntranetSlbId"] = self.intranetSlbId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Internet"] as? String {
            self.internet = value
        }
        if let value = dict["InternetSlbChargeType"] as? String {
            self.internetSlbChargeType = value
        }
        if let value = dict["InternetSlbId"] as? String {
            self.internetSlbId = value
        }
        if let value = dict["Intranet"] as? String {
            self.intranet = value
        }
        if let value = dict["IntranetSlbChargeType"] as? String {
            self.intranetSlbChargeType = value
        }
        if let value = dict["IntranetSlbId"] as? String {
            self.intranetSlbId = value
        }
    }
}

public class BindSlbResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: BindSlbResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = BindSlbResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class BindSlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindSlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = BindSlbResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ConfirmPipelineBatchRequest : Tea.TeaModel {
    public var confirm: Bool?

    public var pipelineId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.confirm != nil {
            map["Confirm"] = self.confirm!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Confirm"] as? Bool {
            self.confirm = value
        }
        if let value = dict["PipelineId"] as? String {
            self.pipelineId = value
        }
    }
}

public class ConfirmPipelineBatchResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var pipelineId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PipelineId"] as? String {
                self.pipelineId = value
            }
        }
    }
    public var code: String?

    public var data: ConfirmPipelineBatchResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ConfirmPipelineBatchResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class ConfirmPipelineBatchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfirmPipelineBatchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ConfirmPipelineBatchResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateApplicationRequest : Tea.TeaModel {
    public var acrAssumeRoleArn: String?

    public var acrInstanceId: String?

    public var appDescription: String?

    public var appName: String?

    public var appSource: String?

    public var associateEip: Bool?

    public var autoConfig: Bool?

    public var baseAppId: String?

    public var command: String?

    public var commandArgs: String?

    public var configMapMountDesc: String?

    public var cpu: Int32?

    public var customHostAlias: String?

    public var customImageNetworkType: String?

    public var deploy: Bool?

    public var diskSize: Int32?

    public var dotnet: String?

    public var edasContainerVersion: String?

    public var emptyDirDesc: String?

    public var enableCpuBurst: Bool?

    public var enableEbpf: String?

    public var enableNewArms: Bool?

    public var enablePrometheus: Bool?

    public var enableSidecarResourceIsolated: Bool?

    public var envs: String?

    public var gpuConfig: String?

    public var headlessPvtzDiscoverySvc: String?

    public var html: String?

    public var imagePullSecrets: String?

    public var imageUrl: String?

    public var initContainersConfig: [InitContainerConfig]?

    public var isStateful: Bool?

    public var jarStartArgs: String?

    public var jarStartOptions: String?

    public var jdk: String?

    public var kafkaConfigs: String?

    public var liveness: String?

    public var memory: Int32?

    public var microRegistration: String?

    public var microRegistrationConfig: String?

    public var microserviceEngineConfig: String?

    public var mountDesc: String?

    public var mountHost: String?

    public var namespaceId: String?

    public var nasConfigs: String?

    public var nasId: String?

    public var newSaeVersion: String?

    public var oidcRoleName: String?

    public var ossAkId: String?

    public var ossAkSecret: String?

    public var ossMountDescs: String?

    public var packageType: String?

    public var packageUrl: String?

    public var packageVersion: String?

    public var php: String?

    public var phpArmsConfigLocation: String?

    public var phpConfig: String?

    public var phpConfigLocation: String?

    public var postStart: String?

    public var preStop: String?

    public var programmingLanguage: String?

    public var pvtzDiscoverySvc: String?

    public var python: String?

    public var pythonModules: String?

    public var readiness: String?

    public var replicas: Int32?

    public var resourceType: String?

    public var saeVersion: String?

    public var secretMountDesc: String?

    public var securityGroupId: String?

    public var serviceTags: String?

    public var sidecarContainersConfig: [SidecarContainerConfig]?

    public var slsConfigs: String?

    public var startupProbe: String?

    public var terminationGracePeriodSeconds: Int32?

    public var timezone: String?

    public var tomcatConfig: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public var warStartOptions: String?

    public var webContainer: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acrAssumeRoleArn != nil {
            map["AcrAssumeRoleArn"] = self.acrAssumeRoleArn!
        }
        if self.acrInstanceId != nil {
            map["AcrInstanceId"] = self.acrInstanceId!
        }
        if self.appDescription != nil {
            map["AppDescription"] = self.appDescription!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.appSource != nil {
            map["AppSource"] = self.appSource!
        }
        if self.associateEip != nil {
            map["AssociateEip"] = self.associateEip!
        }
        if self.autoConfig != nil {
            map["AutoConfig"] = self.autoConfig!
        }
        if self.baseAppId != nil {
            map["BaseAppId"] = self.baseAppId!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.commandArgs != nil {
            map["CommandArgs"] = self.commandArgs!
        }
        if self.configMapMountDesc != nil {
            map["ConfigMapMountDesc"] = self.configMapMountDesc!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.customHostAlias != nil {
            map["CustomHostAlias"] = self.customHostAlias!
        }
        if self.customImageNetworkType != nil {
            map["CustomImageNetworkType"] = self.customImageNetworkType!
        }
        if self.deploy != nil {
            map["Deploy"] = self.deploy!
        }
        if self.diskSize != nil {
            map["DiskSize"] = self.diskSize!
        }
        if self.dotnet != nil {
            map["Dotnet"] = self.dotnet!
        }
        if self.edasContainerVersion != nil {
            map["EdasContainerVersion"] = self.edasContainerVersion!
        }
        if self.emptyDirDesc != nil {
            map["EmptyDirDesc"] = self.emptyDirDesc!
        }
        if self.enableCpuBurst != nil {
            map["EnableCpuBurst"] = self.enableCpuBurst!
        }
        if self.enableEbpf != nil {
            map["EnableEbpf"] = self.enableEbpf!
        }
        if self.enableNewArms != nil {
            map["EnableNewArms"] = self.enableNewArms!
        }
        if self.enablePrometheus != nil {
            map["EnablePrometheus"] = self.enablePrometheus!
        }
        if self.enableSidecarResourceIsolated != nil {
            map["EnableSidecarResourceIsolated"] = self.enableSidecarResourceIsolated!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.gpuConfig != nil {
            map["GpuConfig"] = self.gpuConfig!
        }
        if self.headlessPvtzDiscoverySvc != nil {
            map["HeadlessPvtzDiscoverySvc"] = self.headlessPvtzDiscoverySvc!
        }
        if self.html != nil {
            map["Html"] = self.html!
        }
        if self.imagePullSecrets != nil {
            map["ImagePullSecrets"] = self.imagePullSecrets!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.initContainersConfig != nil {
            var tmp : [Any] = []
            for k in self.initContainersConfig! {
                tmp.append(k.toMap())
            }
            map["InitContainersConfig"] = tmp
        }
        if self.isStateful != nil {
            map["IsStateful"] = self.isStateful!
        }
        if self.jarStartArgs != nil {
            map["JarStartArgs"] = self.jarStartArgs!
        }
        if self.jarStartOptions != nil {
            map["JarStartOptions"] = self.jarStartOptions!
        }
        if self.jdk != nil {
            map["Jdk"] = self.jdk!
        }
        if self.kafkaConfigs != nil {
            map["KafkaConfigs"] = self.kafkaConfigs!
        }
        if self.liveness != nil {
            map["Liveness"] = self.liveness!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.microRegistration != nil {
            map["MicroRegistration"] = self.microRegistration!
        }
        if self.microRegistrationConfig != nil {
            map["MicroRegistrationConfig"] = self.microRegistrationConfig!
        }
        if self.microserviceEngineConfig != nil {
            map["MicroserviceEngineConfig"] = self.microserviceEngineConfig!
        }
        if self.mountDesc != nil {
            map["MountDesc"] = self.mountDesc!
        }
        if self.mountHost != nil {
            map["MountHost"] = self.mountHost!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.nasConfigs != nil {
            map["NasConfigs"] = self.nasConfigs!
        }
        if self.nasId != nil {
            map["NasId"] = self.nasId!
        }
        if self.newSaeVersion != nil {
            map["NewSaeVersion"] = self.newSaeVersion!
        }
        if self.oidcRoleName != nil {
            map["OidcRoleName"] = self.oidcRoleName!
        }
        if self.ossAkId != nil {
            map["OssAkId"] = self.ossAkId!
        }
        if self.ossAkSecret != nil {
            map["OssAkSecret"] = self.ossAkSecret!
        }
        if self.ossMountDescs != nil {
            map["OssMountDescs"] = self.ossMountDescs!
        }
        if self.packageType != nil {
            map["PackageType"] = self.packageType!
        }
        if self.packageUrl != nil {
            map["PackageUrl"] = self.packageUrl!
        }
        if self.packageVersion != nil {
            map["PackageVersion"] = self.packageVersion!
        }
        if self.php != nil {
            map["Php"] = self.php!
        }
        if self.phpArmsConfigLocation != nil {
            map["PhpArmsConfigLocation"] = self.phpArmsConfigLocation!
        }
        if self.phpConfig != nil {
            map["PhpConfig"] = self.phpConfig!
        }
        if self.phpConfigLocation != nil {
            map["PhpConfigLocation"] = self.phpConfigLocation!
        }
        if self.postStart != nil {
            map["PostStart"] = self.postStart!
        }
        if self.preStop != nil {
            map["PreStop"] = self.preStop!
        }
        if self.programmingLanguage != nil {
            map["ProgrammingLanguage"] = self.programmingLanguage!
        }
        if self.pvtzDiscoverySvc != nil {
            map["PvtzDiscoverySvc"] = self.pvtzDiscoverySvc!
        }
        if self.python != nil {
            map["Python"] = self.python!
        }
        if self.pythonModules != nil {
            map["PythonModules"] = self.pythonModules!
        }
        if self.readiness != nil {
            map["Readiness"] = self.readiness!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.saeVersion != nil {
            map["SaeVersion"] = self.saeVersion!
        }
        if self.secretMountDesc != nil {
            map["SecretMountDesc"] = self.secretMountDesc!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.serviceTags != nil {
            map["ServiceTags"] = self.serviceTags!
        }
        if self.sidecarContainersConfig != nil {
            var tmp : [Any] = []
            for k in self.sidecarContainersConfig! {
                tmp.append(k.toMap())
            }
            map["SidecarContainersConfig"] = tmp
        }
        if self.slsConfigs != nil {
            map["SlsConfigs"] = self.slsConfigs!
        }
        if self.startupProbe != nil {
            map["StartupProbe"] = self.startupProbe!
        }
        if self.terminationGracePeriodSeconds != nil {
            map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
        }
        if self.timezone != nil {
            map["Timezone"] = self.timezone!
        }
        if self.tomcatConfig != nil {
            map["TomcatConfig"] = self.tomcatConfig!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.warStartOptions != nil {
            map["WarStartOptions"] = self.warStartOptions!
        }
        if self.webContainer != nil {
            map["WebContainer"] = self.webContainer!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcrAssumeRoleArn"] as? String {
            self.acrAssumeRoleArn = value
        }
        if let value = dict["AcrInstanceId"] as? String {
            self.acrInstanceId = value
        }
        if let value = dict["AppDescription"] as? String {
            self.appDescription = value
        }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["AppSource"] as? String {
            self.appSource = value
        }
        if let value = dict["AssociateEip"] as? Bool {
            self.associateEip = value
        }
        if let value = dict["AutoConfig"] as? Bool {
            self.autoConfig = value
        }
        if let value = dict["BaseAppId"] as? String {
            self.baseAppId = value
        }
        if let value = dict["Command"] as? String {
            self.command = value
        }
        if let value = dict["CommandArgs"] as? String {
            self.commandArgs = value
        }
        if let value = dict["ConfigMapMountDesc"] as? String {
            self.configMapMountDesc = value
        }
        if let value = dict["Cpu"] as? Int32 {
            self.cpu = value
        }
        if let value = dict["CustomHostAlias"] as? String {
            self.customHostAlias = value
        }
        if let value = dict["CustomImageNetworkType"] as? String {
            self.customImageNetworkType = value
        }
        if let value = dict["Deploy"] as? Bool {
            self.deploy = value
        }
        if let value = dict["DiskSize"] as? Int32 {
            self.diskSize = value
        }
        if let value = dict["Dotnet"] as? String {
            self.dotnet = value
        }
        if let value = dict["EdasContainerVersion"] as? String {
            self.edasContainerVersion = value
        }
        if let value = dict["EmptyDirDesc"] as? String {
            self.emptyDirDesc = value
        }
        if let value = dict["EnableCpuBurst"] as? Bool {
            self.enableCpuBurst = value
        }
        if let value = dict["EnableEbpf"] as? String {
            self.enableEbpf = value
        }
        if let value = dict["EnableNewArms"] as? Bool {
            self.enableNewArms = value
        }
        if let value = dict["EnablePrometheus"] as? Bool {
            self.enablePrometheus = value
        }
        if let value = dict["EnableSidecarResourceIsolated"] as? Bool {
            self.enableSidecarResourceIsolated = value
        }
        if let value = dict["Envs"] as? String {
            self.envs = value
        }
        if let value = dict["GpuConfig"] as? String {
            self.gpuConfig = value
        }
        if let value = dict["HeadlessPvtzDiscoverySvc"] as? String {
            self.headlessPvtzDiscoverySvc = value
        }
        if let value = dict["Html"] as? String {
            self.html = value
        }
        if let value = dict["ImagePullSecrets"] as? String {
            self.imagePullSecrets = value
        }
        if let value = dict["ImageUrl"] as? String {
            self.imageUrl = value
        }
        if let value = dict["InitContainersConfig"] as? [Any?] {
            var tmp : [InitContainerConfig] = []
            for v in value {
                if v != nil {
                    var model = InitContainerConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.initContainersConfig = tmp
        }
        if let value = dict["IsStateful"] as? Bool {
            self.isStateful = value
        }
        if let value = dict["JarStartArgs"] as? String {
            self.jarStartArgs = value
        }
        if let value = dict["JarStartOptions"] as? String {
            self.jarStartOptions = value
        }
        if let value = dict["Jdk"] as? String {
            self.jdk = value
        }
        if let value = dict["KafkaConfigs"] as? String {
            self.kafkaConfigs = value
        }
        if let value = dict["Liveness"] as? String {
            self.liveness = value
        }
        if let value = dict["Memory"] as? Int32 {
            self.memory = value
        }
        if let value = dict["MicroRegistration"] as? String {
            self.microRegistration = value
        }
        if let value = dict["MicroRegistrationConfig"] as? String {
            self.microRegistrationConfig = value
        }
        if let value = dict["MicroserviceEngineConfig"] as? String {
            self.microserviceEngineConfig = value
        }
        if let value = dict["MountDesc"] as? String {
            self.mountDesc = value
        }
        if let value = dict["MountHost"] as? String {
            self.mountHost = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["NasConfigs"] as? String {
            self.nasConfigs = value
        }
        if let value = dict["NasId"] as? String {
            self.nasId = value
        }
        if let value = dict["NewSaeVersion"] as? String {
            self.newSaeVersion = value
        }
        if let value = dict["OidcRoleName"] as? String {
            self.oidcRoleName = value
        }
        if let value = dict["OssAkId"] as? String {
            self.ossAkId = value
        }
        if let value = dict["OssAkSecret"] as? String {
            self.ossAkSecret = value
        }
        if let value = dict["OssMountDescs"] as? String {
            self.ossMountDescs = value
        }
        if let value = dict["PackageType"] as? String {
            self.packageType = value
        }
        if let value = dict["PackageUrl"] as? String {
            self.packageUrl = value
        }
        if let value = dict["PackageVersion"] as? String {
            self.packageVersion = value
        }
        if let value = dict["Php"] as? String {
            self.php = value
        }
        if let value = dict["PhpArmsConfigLocation"] as? String {
            self.phpArmsConfigLocation = value
        }
        if let value = dict["PhpConfig"] as? String {
            self.phpConfig = value
        }
        if let value = dict["PhpConfigLocation"] as? String {
            self.phpConfigLocation = value
        }
        if let value = dict["PostStart"] as? String {
            self.postStart = value
        }
        if let value = dict["PreStop"] as? String {
            self.preStop = value
        }
        if let value = dict["ProgrammingLanguage"] as? String {
            self.programmingLanguage = value
        }
        if let value = dict["PvtzDiscoverySvc"] as? String {
            self.pvtzDiscoverySvc = value
        }
        if let value = dict["Python"] as? String {
            self.python = value
        }
        if let value = dict["PythonModules"] as? String {
            self.pythonModules = value
        }
        if let value = dict["Readiness"] as? String {
            self.readiness = value
        }
        if let value = dict["Replicas"] as? Int32 {
            self.replicas = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["SaeVersion"] as? String {
            self.saeVersion = value
        }
        if let value = dict["SecretMountDesc"] as? String {
            self.secretMountDesc = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["ServiceTags"] as? String {
            self.serviceTags = value
        }
        if let value = dict["SidecarContainersConfig"] as? [Any?] {
            var tmp : [SidecarContainerConfig] = []
            for v in value {
                if v != nil {
                    var model = SidecarContainerConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.sidecarContainersConfig = tmp
        }
        if let value = dict["SlsConfigs"] as? String {
            self.slsConfigs = value
        }
        if let value = dict["StartupProbe"] as? String {
            self.startupProbe = value
        }
        if let value = dict["TerminationGracePeriodSeconds"] as? Int32 {
            self.terminationGracePeriodSeconds = value
        }
        if let value = dict["Timezone"] as? String {
            self.timezone = value
        }
        if let value = dict["TomcatConfig"] as? String {
            self.tomcatConfig = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["WarStartOptions"] as? String {
            self.warStartOptions = value
        }
        if let value = dict["WebContainer"] as? String {
            self.webContainer = value
        }
    }
}

public class CreateApplicationShrinkRequest : Tea.TeaModel {
    public var acrAssumeRoleArn: String?

    public var acrInstanceId: String?

    public var appDescription: String?

    public var appName: String?

    public var appSource: String?

    public var associateEip: Bool?

    public var autoConfig: Bool?

    public var baseAppId: String?

    public var command: String?

    public var commandArgs: String?

    public var configMapMountDesc: String?

    public var cpu: Int32?

    public var customHostAlias: String?

    public var customImageNetworkType: String?

    public var deploy: Bool?

    public var diskSize: Int32?

    public var dotnet: String?

    public var edasContainerVersion: String?

    public var emptyDirDesc: String?

    public var enableCpuBurst: Bool?

    public var enableEbpf: String?

    public var enableNewArms: Bool?

    public var enablePrometheus: Bool?

    public var enableSidecarResourceIsolated: Bool?

    public var envs: String?

    public var gpuConfig: String?

    public var headlessPvtzDiscoverySvc: String?

    public var html: String?

    public var imagePullSecrets: String?

    public var imageUrl: String?

    public var initContainersConfigShrink: String?

    public var isStateful: Bool?

    public var jarStartArgs: String?

    public var jarStartOptions: String?

    public var jdk: String?

    public var kafkaConfigs: String?

    public var liveness: String?

    public var memory: Int32?

    public var microRegistration: String?

    public var microRegistrationConfig: String?

    public var microserviceEngineConfig: String?

    public var mountDesc: String?

    public var mountHost: String?

    public var namespaceId: String?

    public var nasConfigs: String?

    public var nasId: String?

    public var newSaeVersion: String?

    public var oidcRoleName: String?

    public var ossAkId: String?

    public var ossAkSecret: String?

    public var ossMountDescs: String?

    public var packageType: String?

    public var packageUrl: String?

    public var packageVersion: String?

    public var php: String?

    public var phpArmsConfigLocation: String?

    public var phpConfig: String?

    public var phpConfigLocation: String?

    public var postStart: String?

    public var preStop: String?

    public var programmingLanguage: String?

    public var pvtzDiscoverySvc: String?

    public var python: String?

    public var pythonModules: String?

    public var readiness: String?

    public var replicas: Int32?

    public var resourceType: String?

    public var saeVersion: String?

    public var secretMountDesc: String?

    public var securityGroupId: String?

    public var serviceTags: String?

    public var sidecarContainersConfigShrink: String?

    public var slsConfigs: String?

    public var startupProbe: String?

    public var terminationGracePeriodSeconds: Int32?

    public var timezone: String?

    public var tomcatConfig: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public var warStartOptions: String?

    public var webContainer: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acrAssumeRoleArn != nil {
            map["AcrAssumeRoleArn"] = self.acrAssumeRoleArn!
        }
        if self.acrInstanceId != nil {
            map["AcrInstanceId"] = self.acrInstanceId!
        }
        if self.appDescription != nil {
            map["AppDescription"] = self.appDescription!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.appSource != nil {
            map["AppSource"] = self.appSource!
        }
        if self.associateEip != nil {
            map["AssociateEip"] = self.associateEip!
        }
        if self.autoConfig != nil {
            map["AutoConfig"] = self.autoConfig!
        }
        if self.baseAppId != nil {
            map["BaseAppId"] = self.baseAppId!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.commandArgs != nil {
            map["CommandArgs"] = self.commandArgs!
        }
        if self.configMapMountDesc != nil {
            map["ConfigMapMountDesc"] = self.configMapMountDesc!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.customHostAlias != nil {
            map["CustomHostAlias"] = self.customHostAlias!
        }
        if self.customImageNetworkType != nil {
            map["CustomImageNetworkType"] = self.customImageNetworkType!
        }
        if self.deploy != nil {
            map["Deploy"] = self.deploy!
        }
        if self.diskSize != nil {
            map["DiskSize"] = self.diskSize!
        }
        if self.dotnet != nil {
            map["Dotnet"] = self.dotnet!
        }
        if self.edasContainerVersion != nil {
            map["EdasContainerVersion"] = self.edasContainerVersion!
        }
        if self.emptyDirDesc != nil {
            map["EmptyDirDesc"] = self.emptyDirDesc!
        }
        if self.enableCpuBurst != nil {
            map["EnableCpuBurst"] = self.enableCpuBurst!
        }
        if self.enableEbpf != nil {
            map["EnableEbpf"] = self.enableEbpf!
        }
        if self.enableNewArms != nil {
            map["EnableNewArms"] = self.enableNewArms!
        }
        if self.enablePrometheus != nil {
            map["EnablePrometheus"] = self.enablePrometheus!
        }
        if self.enableSidecarResourceIsolated != nil {
            map["EnableSidecarResourceIsolated"] = self.enableSidecarResourceIsolated!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.gpuConfig != nil {
            map["GpuConfig"] = self.gpuConfig!
        }
        if self.headlessPvtzDiscoverySvc != nil {
            map["HeadlessPvtzDiscoverySvc"] = self.headlessPvtzDiscoverySvc!
        }
        if self.html != nil {
            map["Html"] = self.html!
        }
        if self.imagePullSecrets != nil {
            map["ImagePullSecrets"] = self.imagePullSecrets!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.initContainersConfigShrink != nil {
            map["InitContainersConfig"] = self.initContainersConfigShrink!
        }
        if self.isStateful != nil {
            map["IsStateful"] = self.isStateful!
        }
        if self.jarStartArgs != nil {
            map["JarStartArgs"] = self.jarStartArgs!
        }
        if self.jarStartOptions != nil {
            map["JarStartOptions"] = self.jarStartOptions!
        }
        if self.jdk != nil {
            map["Jdk"] = self.jdk!
        }
        if self.kafkaConfigs != nil {
            map["KafkaConfigs"] = self.kafkaConfigs!
        }
        if self.liveness != nil {
            map["Liveness"] = self.liveness!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.microRegistration != nil {
            map["MicroRegistration"] = self.microRegistration!
        }
        if self.microRegistrationConfig != nil {
            map["MicroRegistrationConfig"] = self.microRegistrationConfig!
        }
        if self.microserviceEngineConfig != nil {
            map["MicroserviceEngineConfig"] = self.microserviceEngineConfig!
        }
        if self.mountDesc != nil {
            map["MountDesc"] = self.mountDesc!
        }
        if self.mountHost != nil {
            map["MountHost"] = self.mountHost!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.nasConfigs != nil {
            map["NasConfigs"] = self.nasConfigs!
        }
        if self.nasId != nil {
            map["NasId"] = self.nasId!
        }
        if self.newSaeVersion != nil {
            map["NewSaeVersion"] = self.newSaeVersion!
        }
        if self.oidcRoleName != nil {
            map["OidcRoleName"] = self.oidcRoleName!
        }
        if self.ossAkId != nil {
            map["OssAkId"] = self.ossAkId!
        }
        if self.ossAkSecret != nil {
            map["OssAkSecret"] = self.ossAkSecret!
        }
        if self.ossMountDescs != nil {
            map["OssMountDescs"] = self.ossMountDescs!
        }
        if self.packageType != nil {
            map["PackageType"] = self.packageType!
        }
        if self.packageUrl != nil {
            map["PackageUrl"] = self.packageUrl!
        }
        if self.packageVersion != nil {
            map["PackageVersion"] = self.packageVersion!
        }
        if self.php != nil {
            map["Php"] = self.php!
        }
        if self.phpArmsConfigLocation != nil {
            map["PhpArmsConfigLocation"] = self.phpArmsConfigLocation!
        }
        if self.phpConfig != nil {
            map["PhpConfig"] = self.phpConfig!
        }
        if self.phpConfigLocation != nil {
            map["PhpConfigLocation"] = self.phpConfigLocation!
        }
        if self.postStart != nil {
            map["PostStart"] = self.postStart!
        }
        if self.preStop != nil {
            map["PreStop"] = self.preStop!
        }
        if self.programmingLanguage != nil {
            map["ProgrammingLanguage"] = self.programmingLanguage!
        }
        if self.pvtzDiscoverySvc != nil {
            map["PvtzDiscoverySvc"] = self.pvtzDiscoverySvc!
        }
        if self.python != nil {
            map["Python"] = self.python!
        }
        if self.pythonModules != nil {
            map["PythonModules"] = self.pythonModules!
        }
        if self.readiness != nil {
            map["Readiness"] = self.readiness!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.saeVersion != nil {
            map["SaeVersion"] = self.saeVersion!
        }
        if self.secretMountDesc != nil {
            map["SecretMountDesc"] = self.secretMountDesc!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.serviceTags != nil {
            map["ServiceTags"] = self.serviceTags!
        }
        if self.sidecarContainersConfigShrink != nil {
            map["SidecarContainersConfig"] = self.sidecarContainersConfigShrink!
        }
        if self.slsConfigs != nil {
            map["SlsConfigs"] = self.slsConfigs!
        }
        if self.startupProbe != nil {
            map["StartupProbe"] = self.startupProbe!
        }
        if self.terminationGracePeriodSeconds != nil {
            map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
        }
        if self.timezone != nil {
            map["Timezone"] = self.timezone!
        }
        if self.tomcatConfig != nil {
            map["TomcatConfig"] = self.tomcatConfig!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.warStartOptions != nil {
            map["WarStartOptions"] = self.warStartOptions!
        }
        if self.webContainer != nil {
            map["WebContainer"] = self.webContainer!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcrAssumeRoleArn"] as? String {
            self.acrAssumeRoleArn = value
        }
        if let value = dict["AcrInstanceId"] as? String {
            self.acrInstanceId = value
        }
        if let value = dict["AppDescription"] as? String {
            self.appDescription = value
        }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["AppSource"] as? String {
            self.appSource = value
        }
        if let value = dict["AssociateEip"] as? Bool {
            self.associateEip = value
        }
        if let value = dict["AutoConfig"] as? Bool {
            self.autoConfig = value
        }
        if let value = dict["BaseAppId"] as? String {
            self.baseAppId = value
        }
        if let value = dict["Command"] as? String {
            self.command = value
        }
        if let value = dict["CommandArgs"] as? String {
            self.commandArgs = value
        }
        if let value = dict["ConfigMapMountDesc"] as? String {
            self.configMapMountDesc = value
        }
        if let value = dict["Cpu"] as? Int32 {
            self.cpu = value
        }
        if let value = dict["CustomHostAlias"] as? String {
            self.customHostAlias = value
        }
        if let value = dict["CustomImageNetworkType"] as? String {
            self.customImageNetworkType = value
        }
        if let value = dict["Deploy"] as? Bool {
            self.deploy = value
        }
        if let value = dict["DiskSize"] as? Int32 {
            self.diskSize = value
        }
        if let value = dict["Dotnet"] as? String {
            self.dotnet = value
        }
        if let value = dict["EdasContainerVersion"] as? String {
            self.edasContainerVersion = value
        }
        if let value = dict["EmptyDirDesc"] as? String {
            self.emptyDirDesc = value
        }
        if let value = dict["EnableCpuBurst"] as? Bool {
            self.enableCpuBurst = value
        }
        if let value = dict["EnableEbpf"] as? String {
            self.enableEbpf = value
        }
        if let value = dict["EnableNewArms"] as? Bool {
            self.enableNewArms = value
        }
        if let value = dict["EnablePrometheus"] as? Bool {
            self.enablePrometheus = value
        }
        if let value = dict["EnableSidecarResourceIsolated"] as? Bool {
            self.enableSidecarResourceIsolated = value
        }
        if let value = dict["Envs"] as? String {
            self.envs = value
        }
        if let value = dict["GpuConfig"] as? String {
            self.gpuConfig = value
        }
        if let value = dict["HeadlessPvtzDiscoverySvc"] as? String {
            self.headlessPvtzDiscoverySvc = value
        }
        if let value = dict["Html"] as? String {
            self.html = value
        }
        if let value = dict["ImagePullSecrets"] as? String {
            self.imagePullSecrets = value
        }
        if let value = dict["ImageUrl"] as? String {
            self.imageUrl = value
        }
        if let value = dict["InitContainersConfig"] as? String {
            self.initContainersConfigShrink = value
        }
        if let value = dict["IsStateful"] as? Bool {
            self.isStateful = value
        }
        if let value = dict["JarStartArgs"] as? String {
            self.jarStartArgs = value
        }
        if let value = dict["JarStartOptions"] as? String {
            self.jarStartOptions = value
        }
        if let value = dict["Jdk"] as? String {
            self.jdk = value
        }
        if let value = dict["KafkaConfigs"] as? String {
            self.kafkaConfigs = value
        }
        if let value = dict["Liveness"] as? String {
            self.liveness = value
        }
        if let value = dict["Memory"] as? Int32 {
            self.memory = value
        }
        if let value = dict["MicroRegistration"] as? String {
            self.microRegistration = value
        }
        if let value = dict["MicroRegistrationConfig"] as? String {
            self.microRegistrationConfig = value
        }
        if let value = dict["MicroserviceEngineConfig"] as? String {
            self.microserviceEngineConfig = value
        }
        if let value = dict["MountDesc"] as? String {
            self.mountDesc = value
        }
        if let value = dict["MountHost"] as? String {
            self.mountHost = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["NasConfigs"] as? String {
            self.nasConfigs = value
        }
        if let value = dict["NasId"] as? String {
            self.nasId = value
        }
        if let value = dict["NewSaeVersion"] as? String {
            self.newSaeVersion = value
        }
        if let value = dict["OidcRoleName"] as? String {
            self.oidcRoleName = value
        }
        if let value = dict["OssAkId"] as? String {
            self.ossAkId = value
        }
        if let value = dict["OssAkSecret"] as? String {
            self.ossAkSecret = value
        }
        if let value = dict["OssMountDescs"] as? String {
            self.ossMountDescs = value
        }
        if let value = dict["PackageType"] as? String {
            self.packageType = value
        }
        if let value = dict["PackageUrl"] as? String {
            self.packageUrl = value
        }
        if let value = dict["PackageVersion"] as? String {
            self.packageVersion = value
        }
        if let value = dict["Php"] as? String {
            self.php = value
        }
        if let value = dict["PhpArmsConfigLocation"] as? String {
            self.phpArmsConfigLocation = value
        }
        if let value = dict["PhpConfig"] as? String {
            self.phpConfig = value
        }
        if let value = dict["PhpConfigLocation"] as? String {
            self.phpConfigLocation = value
        }
        if let value = dict["PostStart"] as? String {
            self.postStart = value
        }
        if let value = dict["PreStop"] as? String {
            self.preStop = value
        }
        if let value = dict["ProgrammingLanguage"] as? String {
            self.programmingLanguage = value
        }
        if let value = dict["PvtzDiscoverySvc"] as? String {
            self.pvtzDiscoverySvc = value
        }
        if let value = dict["Python"] as? String {
            self.python = value
        }
        if let value = dict["PythonModules"] as? String {
            self.pythonModules = value
        }
        if let value = dict["Readiness"] as? String {
            self.readiness = value
        }
        if let value = dict["Replicas"] as? Int32 {
            self.replicas = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["SaeVersion"] as? String {
            self.saeVersion = value
        }
        if let value = dict["SecretMountDesc"] as? String {
            self.secretMountDesc = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["ServiceTags"] as? String {
            self.serviceTags = value
        }
        if let value = dict["SidecarContainersConfig"] as? String {
            self.sidecarContainersConfigShrink = value
        }
        if let value = dict["SlsConfigs"] as? String {
            self.slsConfigs = value
        }
        if let value = dict["StartupProbe"] as? String {
            self.startupProbe = value
        }
        if let value = dict["TerminationGracePeriodSeconds"] as? Int32 {
            self.terminationGracePeriodSeconds = value
        }
        if let value = dict["Timezone"] as? String {
            self.timezone = value
        }
        if let value = dict["TomcatConfig"] as? String {
            self.tomcatConfig = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["WarStartOptions"] as? String {
            self.warStartOptions = value
        }
        if let value = dict["WebContainer"] as? String {
            self.webContainer = value
        }
    }
}

public class CreateApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: CreateApplicationResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateApplicationResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class CreateApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var enableIdle: Bool?

    public var minReadyInstanceRatio: Int32?

    public var minReadyInstances: Int32?

    public var scalingRuleEnable: Bool?

    public var scalingRuleMetric: String?

    public var scalingRuleName: String?

    public var scalingRuleTimer: String?

    public var scalingRuleType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.enableIdle != nil {
            map["EnableIdle"] = self.enableIdle!
        }
        if self.minReadyInstanceRatio != nil {
            map["MinReadyInstanceRatio"] = self.minReadyInstanceRatio!
        }
        if self.minReadyInstances != nil {
            map["MinReadyInstances"] = self.minReadyInstances!
        }
        if self.scalingRuleEnable != nil {
            map["ScalingRuleEnable"] = self.scalingRuleEnable!
        }
        if self.scalingRuleMetric != nil {
            map["ScalingRuleMetric"] = self.scalingRuleMetric!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        if self.scalingRuleTimer != nil {
            map["ScalingRuleTimer"] = self.scalingRuleTimer!
        }
        if self.scalingRuleType != nil {
            map["ScalingRuleType"] = self.scalingRuleType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["EnableIdle"] as? Bool {
            self.enableIdle = value
        }
        if let value = dict["MinReadyInstanceRatio"] as? Int32 {
            self.minReadyInstanceRatio = value
        }
        if let value = dict["MinReadyInstances"] as? Int32 {
            self.minReadyInstances = value
        }
        if let value = dict["ScalingRuleEnable"] as? Bool {
            self.scalingRuleEnable = value
        }
        if let value = dict["ScalingRuleMetric"] as? String {
            self.scalingRuleMetric = value
        }
        if let value = dict["ScalingRuleName"] as? String {
            self.scalingRuleName = value
        }
        if let value = dict["ScalingRuleTimer"] as? String {
            self.scalingRuleTimer = value
        }
        if let value = dict["ScalingRuleType"] as? String {
            self.scalingRuleType = value
        }
    }
}

public class CreateApplicationScalingRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Metric : Tea.TeaModel {
            public class Metrics : Tea.TeaModel {
                public var metricTargetAverageUtilization: Int32?

                public var metricType: String?

                public var slbId: String?

                public var slbLogstore: String?

                public var slbProject: String?

                public var vport: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricTargetAverageUtilization != nil {
                        map["MetricTargetAverageUtilization"] = self.metricTargetAverageUtilization!
                    }
                    if self.metricType != nil {
                        map["MetricType"] = self.metricType!
                    }
                    if self.slbId != nil {
                        map["SlbId"] = self.slbId!
                    }
                    if self.slbLogstore != nil {
                        map["SlbLogstore"] = self.slbLogstore!
                    }
                    if self.slbProject != nil {
                        map["SlbProject"] = self.slbProject!
                    }
                    if self.vport != nil {
                        map["Vport"] = self.vport!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MetricTargetAverageUtilization"] as? Int32 {
                        self.metricTargetAverageUtilization = value
                    }
                    if let value = dict["MetricType"] as? String {
                        self.metricType = value
                    }
                    if let value = dict["SlbId"] as? String {
                        self.slbId = value
                    }
                    if let value = dict["SlbLogstore"] as? String {
                        self.slbLogstore = value
                    }
                    if let value = dict["SlbProject"] as? String {
                        self.slbProject = value
                    }
                    if let value = dict["Vport"] as? String {
                        self.vport = value
                    }
                }
            }
            public var maxReplicas: Int32?

            public var metrics: [CreateApplicationScalingRuleResponseBody.Data.Metric.Metrics]?

            public var minReplicas: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.metrics != nil {
                    var tmp : [Any] = []
                    for k in self.metrics! {
                        tmp.append(k.toMap())
                    }
                    map["Metrics"] = tmp
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MaxReplicas"] as? Int32 {
                    self.maxReplicas = value
                }
                if let value = dict["Metrics"] as? [Any?] {
                    var tmp : [CreateApplicationScalingRuleResponseBody.Data.Metric.Metrics] = []
                    for v in value {
                        if v != nil {
                            var model = CreateApplicationScalingRuleResponseBody.Data.Metric.Metrics()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.metrics = tmp
                }
                if let value = dict["MinReplicas"] as? Int32 {
                    self.minReplicas = value
                }
            }
        }
        public class Timer : Tea.TeaModel {
            public class Schedules : Tea.TeaModel {
                public var atTime: String?

                public var maxReplicas: Int32?

                public var minReplicas: Int32?

                public var targetReplicas: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.atTime != nil {
                        map["AtTime"] = self.atTime!
                    }
                    if self.maxReplicas != nil {
                        map["MaxReplicas"] = self.maxReplicas!
                    }
                    if self.minReplicas != nil {
                        map["MinReplicas"] = self.minReplicas!
                    }
                    if self.targetReplicas != nil {
                        map["TargetReplicas"] = self.targetReplicas!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AtTime"] as? String {
                        self.atTime = value
                    }
                    if let value = dict["MaxReplicas"] as? Int32 {
                        self.maxReplicas = value
                    }
                    if let value = dict["MinReplicas"] as? Int32 {
                        self.minReplicas = value
                    }
                    if let value = dict["TargetReplicas"] as? Int32 {
                        self.targetReplicas = value
                    }
                }
            }
            public var beginDate: String?

            public var endDate: String?

            public var period: String?

            public var schedules: [CreateApplicationScalingRuleResponseBody.Data.Timer.Schedules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.beginDate != nil {
                    map["BeginDate"] = self.beginDate!
                }
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.schedules != nil {
                    var tmp : [Any] = []
                    for k in self.schedules! {
                        tmp.append(k.toMap())
                    }
                    map["Schedules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BeginDate"] as? String {
                    self.beginDate = value
                }
                if let value = dict["EndDate"] as? String {
                    self.endDate = value
                }
                if let value = dict["Period"] as? String {
                    self.period = value
                }
                if let value = dict["Schedules"] as? [Any?] {
                    var tmp : [CreateApplicationScalingRuleResponseBody.Data.Timer.Schedules] = []
                    for v in value {
                        if v != nil {
                            var model = CreateApplicationScalingRuleResponseBody.Data.Timer.Schedules()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.schedules = tmp
                }
            }
        }
        public var appId: String?

        public var createTime: Int64?

        public var enableIdle: Bool?

        public var lastDisableTime: Int64?

        public var metric: CreateApplicationScalingRuleResponseBody.Data.Metric?

        public var scaleRuleEnabled: Bool?

        public var scaleRuleName: String?

        public var scaleRuleType: String?

        public var timer: CreateApplicationScalingRuleResponseBody.Data.Timer?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metric?.validate()
            try self.timer?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.enableIdle != nil {
                map["EnableIdle"] = self.enableIdle!
            }
            if self.lastDisableTime != nil {
                map["LastDisableTime"] = self.lastDisableTime!
            }
            if self.metric != nil {
                map["Metric"] = self.metric?.toMap()
            }
            if self.scaleRuleEnabled != nil {
                map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
            }
            if self.scaleRuleName != nil {
                map["ScaleRuleName"] = self.scaleRuleName!
            }
            if self.scaleRuleType != nil {
                map["ScaleRuleType"] = self.scaleRuleType!
            }
            if self.timer != nil {
                map["Timer"] = self.timer?.toMap()
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["EnableIdle"] as? Bool {
                self.enableIdle = value
            }
            if let value = dict["LastDisableTime"] as? Int64 {
                self.lastDisableTime = value
            }
            if let value = dict["Metric"] as? [String: Any?] {
                var model = CreateApplicationScalingRuleResponseBody.Data.Metric()
                model.fromMap(value)
                self.metric = model
            }
            if let value = dict["ScaleRuleEnabled"] as? Bool {
                self.scaleRuleEnabled = value
            }
            if let value = dict["ScaleRuleName"] as? String {
                self.scaleRuleName = value
            }
            if let value = dict["ScaleRuleType"] as? String {
                self.scaleRuleType = value
            }
            if let value = dict["Timer"] as? [String: Any?] {
                var model = CreateApplicationScalingRuleResponseBody.Data.Timer()
                model.fromMap(value)
                self.timer = model
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var code: String?

    public var data: CreateApplicationScalingRuleResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateApplicationScalingRuleResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class CreateApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateApplicationScalingRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateConfigMapRequest : Tea.TeaModel {
    public var data: String?

    public var description_: String?

    public var name: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class CreateConfigMapResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configMapId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configMapId != nil {
                map["ConfigMapId"] = self.configMapId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigMapId"] as? Int64 {
                self.configMapId = value
            }
        }
    }
    public var code: String?

    public var data: CreateConfigMapResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateConfigMapResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class CreateConfigMapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateConfigMapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateConfigMapResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateGreyTagRouteRequest : Tea.TeaModel {
    public var albRules: String?

    public var appId: String?

    public var description_: String?

    public var dubboRules: String?

    public var name: String?

    public var scRules: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.albRules != nil {
            map["AlbRules"] = self.albRules!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dubboRules != nil {
            map["DubboRules"] = self.dubboRules!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.scRules != nil {
            map["ScRules"] = self.scRules!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlbRules"] as? String {
            self.albRules = value
        }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DubboRules"] as? String {
            self.dubboRules = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ScRules"] as? String {
            self.scRules = value
        }
    }
}

public class CreateGreyTagRouteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var greyTagRouteId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.greyTagRouteId != nil {
                map["GreyTagRouteId"] = self.greyTagRouteId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GreyTagRouteId"] as? Int64 {
                self.greyTagRouteId = value
            }
        }
    }
    public var code: String?

    public var data: CreateGreyTagRouteResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateGreyTagRouteResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class CreateGreyTagRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateGreyTagRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateGreyTagRouteResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateIngressRequest : Tea.TeaModel {
    public var addressType: String?

    public var certId: String?

    public var certIds: String?

    public var corsConfig: String?

    public var defaultRule: String?

    public var description_: String?

    public var enableXForwardedFor: Bool?

    public var enableXForwardedForClientSrcPort: Bool?

    public var enableXForwardedForProto: Bool?

    public var enableXForwardedForSlbId: Bool?

    public var enableXForwardedForSlbPort: Bool?

    public var idleTimeout: Int32?

    public var listenerPort: Int32?

    public var listenerProtocol: String?

    public var loadBalanceType: String?

    public var loadBalancerEdition: String?

    public var namespaceId: String?

    public var requestTimeout: Int32?

    public var rules: String?

    public var securityPolicyId: String?

    public var slbId: String?

    public var zoneMappings: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressType != nil {
            map["AddressType"] = self.addressType!
        }
        if self.certId != nil {
            map["CertId"] = self.certId!
        }
        if self.certIds != nil {
            map["CertIds"] = self.certIds!
        }
        if self.corsConfig != nil {
            map["CorsConfig"] = self.corsConfig!
        }
        if self.defaultRule != nil {
            map["DefaultRule"] = self.defaultRule!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableXForwardedFor != nil {
            map["EnableXForwardedFor"] = self.enableXForwardedFor!
        }
        if self.enableXForwardedForClientSrcPort != nil {
            map["EnableXForwardedForClientSrcPort"] = self.enableXForwardedForClientSrcPort!
        }
        if self.enableXForwardedForProto != nil {
            map["EnableXForwardedForProto"] = self.enableXForwardedForProto!
        }
        if self.enableXForwardedForSlbId != nil {
            map["EnableXForwardedForSlbId"] = self.enableXForwardedForSlbId!
        }
        if self.enableXForwardedForSlbPort != nil {
            map["EnableXForwardedForSlbPort"] = self.enableXForwardedForSlbPort!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.listenerProtocol != nil {
            map["ListenerProtocol"] = self.listenerProtocol!
        }
        if self.loadBalanceType != nil {
            map["LoadBalanceType"] = self.loadBalanceType!
        }
        if self.loadBalancerEdition != nil {
            map["LoadBalancerEdition"] = self.loadBalancerEdition!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.rules != nil {
            map["Rules"] = self.rules!
        }
        if self.securityPolicyId != nil {
            map["SecurityPolicyId"] = self.securityPolicyId!
        }
        if self.slbId != nil {
            map["SlbId"] = self.slbId!
        }
        if self.zoneMappings != nil {
            map["ZoneMappings"] = self.zoneMappings!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AddressType"] as? String {
            self.addressType = value
        }
        if let value = dict["CertId"] as? String {
            self.certId = value
        }
        if let value = dict["CertIds"] as? String {
            self.certIds = value
        }
        if let value = dict["CorsConfig"] as? String {
            self.corsConfig = value
        }
        if let value = dict["DefaultRule"] as? String {
            self.defaultRule = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnableXForwardedFor"] as? Bool {
            self.enableXForwardedFor = value
        }
        if let value = dict["EnableXForwardedForClientSrcPort"] as? Bool {
            self.enableXForwardedForClientSrcPort = value
        }
        if let value = dict["EnableXForwardedForProto"] as? Bool {
            self.enableXForwardedForProto = value
        }
        if let value = dict["EnableXForwardedForSlbId"] as? Bool {
            self.enableXForwardedForSlbId = value
        }
        if let value = dict["EnableXForwardedForSlbPort"] as? Bool {
            self.enableXForwardedForSlbPort = value
        }
        if let value = dict["IdleTimeout"] as? Int32 {
            self.idleTimeout = value
        }
        if let value = dict["ListenerPort"] as? Int32 {
            self.listenerPort = value
        }
        if let value = dict["ListenerProtocol"] as? String {
            self.listenerProtocol = value
        }
        if let value = dict["LoadBalanceType"] as? String {
            self.loadBalanceType = value
        }
        if let value = dict["LoadBalancerEdition"] as? String {
            self.loadBalancerEdition = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["RequestTimeout"] as? Int32 {
            self.requestTimeout = value
        }
        if let value = dict["Rules"] as? String {
            self.rules = value
        }
        if let value = dict["SecurityPolicyId"] as? String {
            self.securityPolicyId = value
        }
        if let value = dict["SlbId"] as? String {
            self.slbId = value
        }
        if let value = dict["ZoneMappings"] as? String {
            self.zoneMappings = value
        }
    }
}

public class CreateIngressResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var ingressId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ingressId != nil {
                map["IngressId"] = self.ingressId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IngressId"] as? Int64 {
                self.ingressId = value
            }
        }
    }
    public var code: String?

    public var data: CreateIngressResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateIngressResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class CreateIngressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIngressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateIngressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateJobRequest : Tea.TeaModel {
    public var acrAssumeRoleArn: String?

    public var acrInstanceId: String?

    public var appDescription: String?

    public var appName: String?

    public var autoConfig: Bool?

    public var backoffLimit: Int64?

    public var bestEffortType: String?

    public var command: String?

    public var commandArgs: String?

    public var concurrencyPolicy: String?

    public var configMapMountDesc: String?

    public var cpu: Int32?

    public var customHostAlias: String?

    public var edasContainerVersion: String?

    public var enableImageAccl: Bool?

    public var envs: String?

    public var imagePullSecrets: String?

    public var imageUrl: String?

    public var jarStartArgs: String?

    public var jarStartOptions: String?

    public var jdk: String?

    public var memory: Int32?

    public var mountDesc: String?

    public var mountHost: String?

    public var namespaceId: String?

    public var nasConfigs: String?

    public var nasId: String?

    public var ossAkId: String?

    public var ossAkSecret: String?

    public var ossMountDescs: String?

    public var packageType: String?

    public var packageUrl: String?

    public var packageVersion: String?

    public var phpConfig: String?

    public var phpConfigLocation: String?

    public var postStart: String?

    public var preStop: String?

    public var programmingLanguage: String?

    public var python: String?

    public var pythonModules: String?

    public var refAppId: String?

    public var replicas: Int32?

    public var securityGroupId: String?

    public var slice: Bool?

    public var sliceEnvs: String?

    public var slsConfigs: String?

    public var terminationGracePeriodSeconds: Int32?

    public var timeout: Int64?

    public var timezone: String?

    public var tomcatConfig: String?

    public var triggerConfig: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public var warStartOptions: String?

    public var webContainer: String?

    public var workload: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acrAssumeRoleArn != nil {
            map["AcrAssumeRoleArn"] = self.acrAssumeRoleArn!
        }
        if self.acrInstanceId != nil {
            map["AcrInstanceId"] = self.acrInstanceId!
        }
        if self.appDescription != nil {
            map["AppDescription"] = self.appDescription!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.autoConfig != nil {
            map["AutoConfig"] = self.autoConfig!
        }
        if self.backoffLimit != nil {
            map["BackoffLimit"] = self.backoffLimit!
        }
        if self.bestEffortType != nil {
            map["BestEffortType"] = self.bestEffortType!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.commandArgs != nil {
            map["CommandArgs"] = self.commandArgs!
        }
        if self.concurrencyPolicy != nil {
            map["ConcurrencyPolicy"] = self.concurrencyPolicy!
        }
        if self.configMapMountDesc != nil {
            map["ConfigMapMountDesc"] = self.configMapMountDesc!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.customHostAlias != nil {
            map["CustomHostAlias"] = self.customHostAlias!
        }
        if self.edasContainerVersion != nil {
            map["EdasContainerVersion"] = self.edasContainerVersion!
        }
        if self.enableImageAccl != nil {
            map["EnableImageAccl"] = self.enableImageAccl!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.imagePullSecrets != nil {
            map["ImagePullSecrets"] = self.imagePullSecrets!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.jarStartArgs != nil {
            map["JarStartArgs"] = self.jarStartArgs!
        }
        if self.jarStartOptions != nil {
            map["JarStartOptions"] = self.jarStartOptions!
        }
        if self.jdk != nil {
            map["Jdk"] = self.jdk!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.mountDesc != nil {
            map["MountDesc"] = self.mountDesc!
        }
        if self.mountHost != nil {
            map["MountHost"] = self.mountHost!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.nasConfigs != nil {
            map["NasConfigs"] = self.nasConfigs!
        }
        if self.nasId != nil {
            map["NasId"] = self.nasId!
        }
        if self.ossAkId != nil {
            map["OssAkId"] = self.ossAkId!
        }
        if self.ossAkSecret != nil {
            map["OssAkSecret"] = self.ossAkSecret!
        }
        if self.ossMountDescs != nil {
            map["OssMountDescs"] = self.ossMountDescs!
        }
        if self.packageType != nil {
            map["PackageType"] = self.packageType!
        }
        if self.packageUrl != nil {
            map["PackageUrl"] = self.packageUrl!
        }
        if self.packageVersion != nil {
            map["PackageVersion"] = self.packageVersion!
        }
        if self.phpConfig != nil {
            map["PhpConfig"] = self.phpConfig!
        }
        if self.phpConfigLocation != nil {
            map["PhpConfigLocation"] = self.phpConfigLocation!
        }
        if self.postStart != nil {
            map["PostStart"] = self.postStart!
        }
        if self.preStop != nil {
            map["PreStop"] = self.preStop!
        }
        if self.programmingLanguage != nil {
            map["ProgrammingLanguage"] = self.programmingLanguage!
        }
        if self.python != nil {
            map["Python"] = self.python!
        }
        if self.pythonModules != nil {
            map["PythonModules"] = self.pythonModules!
        }
        if self.refAppId != nil {
            map["RefAppId"] = self.refAppId!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.slice != nil {
            map["Slice"] = self.slice!
        }
        if self.sliceEnvs != nil {
            map["SliceEnvs"] = self.sliceEnvs!
        }
        if self.slsConfigs != nil {
            map["SlsConfigs"] = self.slsConfigs!
        }
        if self.terminationGracePeriodSeconds != nil {
            map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.timezone != nil {
            map["Timezone"] = self.timezone!
        }
        if self.tomcatConfig != nil {
            map["TomcatConfig"] = self.tomcatConfig!
        }
        if self.triggerConfig != nil {
            map["TriggerConfig"] = self.triggerConfig!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.warStartOptions != nil {
            map["WarStartOptions"] = self.warStartOptions!
        }
        if self.webContainer != nil {
            map["WebContainer"] = self.webContainer!
        }
        if self.workload != nil {
            map["Workload"] = self.workload!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcrAssumeRoleArn"] as? String {
            self.acrAssumeRoleArn = value
        }
        if let value = dict["AcrInstanceId"] as? String {
            self.acrInstanceId = value
        }
        if let value = dict["AppDescription"] as? String {
            self.appDescription = value
        }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["AutoConfig"] as? Bool {
            self.autoConfig = value
        }
        if let value = dict["BackoffLimit"] as? Int64 {
            self.backoffLimit = value
        }
        if let value = dict["BestEffortType"] as? String {
            self.bestEffortType = value
        }
        if let value = dict["Command"] as? String {
            self.command = value
        }
        if let value = dict["CommandArgs"] as? String {
            self.commandArgs = value
        }
        if let value = dict["ConcurrencyPolicy"] as? String {
            self.concurrencyPolicy = value
        }
        if let value = dict["ConfigMapMountDesc"] as? String {
            self.configMapMountDesc = value
        }
        if let value = dict["Cpu"] as? Int32 {
            self.cpu = value
        }
        if let value = dict["CustomHostAlias"] as? String {
            self.customHostAlias = value
        }
        if let value = dict["EdasContainerVersion"] as? String {
            self.edasContainerVersion = value
        }
        if let value = dict["EnableImageAccl"] as? Bool {
            self.enableImageAccl = value
        }
        if let value = dict["Envs"] as? String {
            self.envs = value
        }
        if let value = dict["ImagePullSecrets"] as? String {
            self.imagePullSecrets = value
        }
        if let value = dict["ImageUrl"] as? String {
            self.imageUrl = value
        }
        if let value = dict["JarStartArgs"] as? String {
            self.jarStartArgs = value
        }
        if let value = dict["JarStartOptions"] as? String {
            self.jarStartOptions = value
        }
        if let value = dict["Jdk"] as? String {
            self.jdk = value
        }
        if let value = dict["Memory"] as? Int32 {
            self.memory = value
        }
        if let value = dict["MountDesc"] as? String {
            self.mountDesc = value
        }
        if let value = dict["MountHost"] as? String {
            self.mountHost = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["NasConfigs"] as? String {
            self.nasConfigs = value
        }
        if let value = dict["NasId"] as? String {
            self.nasId = value
        }
        if let value = dict["OssAkId"] as? String {
            self.ossAkId = value
        }
        if let value = dict["OssAkSecret"] as? String {
            self.ossAkSecret = value
        }
        if let value = dict["OssMountDescs"] as? String {
            self.ossMountDescs = value
        }
        if let value = dict["PackageType"] as? String {
            self.packageType = value
        }
        if let value = dict["PackageUrl"] as? String {
            self.packageUrl = value
        }
        if let value = dict["PackageVersion"] as? String {
            self.packageVersion = value
        }
        if let value = dict["PhpConfig"] as? String {
            self.phpConfig = value
        }
        if let value = dict["PhpConfigLocation"] as? String {
            self.phpConfigLocation = value
        }
        if let value = dict["PostStart"] as? String {
            self.postStart = value
        }
        if let value = dict["PreStop"] as? String {
            self.preStop = value
        }
        if let value = dict["ProgrammingLanguage"] as? String {
            self.programmingLanguage = value
        }
        if let value = dict["Python"] as? String {
            self.python = value
        }
        if let value = dict["PythonModules"] as? String {
            self.pythonModules = value
        }
        if let value = dict["RefAppId"] as? String {
            self.refAppId = value
        }
        if let value = dict["Replicas"] as? Int32 {
            self.replicas = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["Slice"] as? Bool {
            self.slice = value
        }
        if let value = dict["SliceEnvs"] as? String {
            self.sliceEnvs = value
        }
        if let value = dict["SlsConfigs"] as? String {
            self.slsConfigs = value
        }
        if let value = dict["TerminationGracePeriodSeconds"] as? Int32 {
            self.terminationGracePeriodSeconds = value
        }
        if let value = dict["Timeout"] as? Int64 {
            self.timeout = value
        }
        if let value = dict["Timezone"] as? String {
            self.timezone = value
        }
        if let value = dict["TomcatConfig"] as? String {
            self.tomcatConfig = value
        }
        if let value = dict["TriggerConfig"] as? String {
            self.triggerConfig = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["WarStartOptions"] as? String {
            self.warStartOptions = value
        }
        if let value = dict["WebContainer"] as? String {
            self.webContainer = value
        }
        if let value = dict["Workload"] as? String {
            self.workload = value
        }
    }
}

public class CreateJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: CreateJobResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateJobResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class CreateJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateNamespaceRequest : Tea.TeaModel {
    public var enableMicroRegistration: Bool?

    public var nameSpaceShortId: String?

    public var namespaceDescription: String?

    public var namespaceId: String?

    public var namespaceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableMicroRegistration != nil {
            map["EnableMicroRegistration"] = self.enableMicroRegistration!
        }
        if self.nameSpaceShortId != nil {
            map["NameSpaceShortId"] = self.nameSpaceShortId!
        }
        if self.namespaceDescription != nil {
            map["NamespaceDescription"] = self.namespaceDescription!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.namespaceName != nil {
            map["NamespaceName"] = self.namespaceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EnableMicroRegistration"] as? Bool {
            self.enableMicroRegistration = value
        }
        if let value = dict["NameSpaceShortId"] as? String {
            self.nameSpaceShortId = value
        }
        if let value = dict["NamespaceDescription"] as? String {
            self.namespaceDescription = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["NamespaceName"] as? String {
            self.namespaceName = value
        }
    }
}

public class CreateNamespaceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var enableMicroRegistration: Bool?

        public var nameSpaceShortId: String?

        public var namespaceDescription: String?

        public var namespaceId: String?

        public var namespaceName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableMicroRegistration != nil {
                map["EnableMicroRegistration"] = self.enableMicroRegistration!
            }
            if self.nameSpaceShortId != nil {
                map["NameSpaceShortId"] = self.nameSpaceShortId!
            }
            if self.namespaceDescription != nil {
                map["NamespaceDescription"] = self.namespaceDescription!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.namespaceName != nil {
                map["NamespaceName"] = self.namespaceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EnableMicroRegistration"] as? Bool {
                self.enableMicroRegistration = value
            }
            if let value = dict["NameSpaceShortId"] as? String {
                self.nameSpaceShortId = value
            }
            if let value = dict["NamespaceDescription"] as? String {
                self.namespaceDescription = value
            }
            if let value = dict["NamespaceId"] as? String {
                self.namespaceId = value
            }
            if let value = dict["NamespaceName"] as? String {
                self.namespaceName = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
        }
    }
    public var code: String?

    public var data: CreateNamespaceResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateNamespaceResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class CreateNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateNamespaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateOrUpdateSwimmingLaneRequest : Tea.TeaModel {
    public class AppEntryRule : Tea.TeaModel {
        public class Conditions : Tea.TeaModel {
            public var condition: String?

            public var name: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["Condition"] = self.condition!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Condition"] as? String {
                    self.condition = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var conditionJoiner: String?

        public var conditions: [CreateOrUpdateSwimmingLaneRequest.AppEntryRule.Conditions]?

        public var independentPercentageEnable: Bool?

        public var paths: [String]?

        public var percentage: Int32?

        public var percentageByPath: [String: Int32]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conditionJoiner != nil {
                map["ConditionJoiner"] = self.conditionJoiner!
            }
            if self.conditions != nil {
                var tmp : [Any] = []
                for k in self.conditions! {
                    tmp.append(k.toMap())
                }
                map["Conditions"] = tmp
            }
            if self.independentPercentageEnable != nil {
                map["IndependentPercentageEnable"] = self.independentPercentageEnable!
            }
            if self.paths != nil {
                map["Paths"] = self.paths!
            }
            if self.percentage != nil {
                map["Percentage"] = self.percentage!
            }
            if self.percentageByPath != nil {
                map["PercentageByPath"] = self.percentageByPath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConditionJoiner"] as? String {
                self.conditionJoiner = value
            }
            if let value = dict["Conditions"] as? [Any?] {
                var tmp : [CreateOrUpdateSwimmingLaneRequest.AppEntryRule.Conditions] = []
                for v in value {
                    if v != nil {
                        var model = CreateOrUpdateSwimmingLaneRequest.AppEntryRule.Conditions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.conditions = tmp
            }
            if let value = dict["IndependentPercentageEnable"] as? Bool {
                self.independentPercentageEnable = value
            }
            if let value = dict["Paths"] as? [String] {
                self.paths = value
            }
            if let value = dict["Percentage"] as? Int32 {
                self.percentage = value
            }
            if let value = dict["PercentageByPath"] as? [String: Int32] {
                self.percentageByPath = value
            }
        }
    }
    public class MseGatewayEntryRule : Tea.TeaModel {
        public class Conditions : Tea.TeaModel {
            public var condition: String?

            public var name: String?

            public var type: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["Condition"] = self.condition!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Condition"] as? String {
                    self.condition = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var conditionJoiner: String?

        public var conditions: [CreateOrUpdateSwimmingLaneRequest.MseGatewayEntryRule.Conditions]?

        public var independentPercentageEnable: Bool?

        public var percentage: Int32?

        public var percentageByRoute: [String: Int32]?

        public var routeIds: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conditionJoiner != nil {
                map["ConditionJoiner"] = self.conditionJoiner!
            }
            if self.conditions != nil {
                var tmp : [Any] = []
                for k in self.conditions! {
                    tmp.append(k.toMap())
                }
                map["Conditions"] = tmp
            }
            if self.independentPercentageEnable != nil {
                map["IndependentPercentageEnable"] = self.independentPercentageEnable!
            }
            if self.percentage != nil {
                map["Percentage"] = self.percentage!
            }
            if self.percentageByRoute != nil {
                map["PercentageByRoute"] = self.percentageByRoute!
            }
            if self.routeIds != nil {
                map["RouteIds"] = self.routeIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConditionJoiner"] as? String {
                self.conditionJoiner = value
            }
            if let value = dict["Conditions"] as? [Any?] {
                var tmp : [CreateOrUpdateSwimmingLaneRequest.MseGatewayEntryRule.Conditions] = []
                for v in value {
                    if v != nil {
                        var model = CreateOrUpdateSwimmingLaneRequest.MseGatewayEntryRule.Conditions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.conditions = tmp
            }
            if let value = dict["IndependentPercentageEnable"] as? Bool {
                self.independentPercentageEnable = value
            }
            if let value = dict["Percentage"] as? Int32 {
                self.percentage = value
            }
            if let value = dict["PercentageByRoute"] as? [String: Int32] {
                self.percentageByRoute = value
            }
            if let value = dict["RouteIds"] as? [Int64] {
                self.routeIds = value
            }
        }
    }
    public var appEntryRule: CreateOrUpdateSwimmingLaneRequest.AppEntryRule?

    public var canaryModel: Int32?

    public var enable: Bool?

    public var groupId: Int64?

    public var laneId: Int64?

    public var laneName: String?

    public var laneTag: String?

    public var mseGatewayEntryRule: CreateOrUpdateSwimmingLaneRequest.MseGatewayEntryRule?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.appEntryRule?.validate()
        try self.mseGatewayEntryRule?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appEntryRule != nil {
            map["AppEntryRule"] = self.appEntryRule?.toMap()
        }
        if self.canaryModel != nil {
            map["CanaryModel"] = self.canaryModel!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.laneId != nil {
            map["LaneId"] = self.laneId!
        }
        if self.laneName != nil {
            map["LaneName"] = self.laneName!
        }
        if self.laneTag != nil {
            map["LaneTag"] = self.laneTag!
        }
        if self.mseGatewayEntryRule != nil {
            map["MseGatewayEntryRule"] = self.mseGatewayEntryRule?.toMap()
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppEntryRule"] as? [String: Any?] {
            var model = CreateOrUpdateSwimmingLaneRequest.AppEntryRule()
            model.fromMap(value)
            self.appEntryRule = model
        }
        if let value = dict["CanaryModel"] as? Int32 {
            self.canaryModel = value
        }
        if let value = dict["Enable"] as? Bool {
            self.enable = value
        }
        if let value = dict["GroupId"] as? Int64 {
            self.groupId = value
        }
        if let value = dict["LaneId"] as? Int64 {
            self.laneId = value
        }
        if let value = dict["LaneName"] as? String {
            self.laneName = value
        }
        if let value = dict["LaneTag"] as? String {
            self.laneTag = value
        }
        if let value = dict["MseGatewayEntryRule"] as? [String: Any?] {
            var model = CreateOrUpdateSwimmingLaneRequest.MseGatewayEntryRule()
            model.fromMap(value)
            self.mseGatewayEntryRule = model
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class CreateOrUpdateSwimmingLaneShrinkRequest : Tea.TeaModel {
    public var appEntryRuleShrink: String?

    public var canaryModel: Int32?

    public var enable: Bool?

    public var groupId: Int64?

    public var laneId: Int64?

    public var laneName: String?

    public var laneTag: String?

    public var mseGatewayEntryRuleShrink: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appEntryRuleShrink != nil {
            map["AppEntryRule"] = self.appEntryRuleShrink!
        }
        if self.canaryModel != nil {
            map["CanaryModel"] = self.canaryModel!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.laneId != nil {
            map["LaneId"] = self.laneId!
        }
        if self.laneName != nil {
            map["LaneName"] = self.laneName!
        }
        if self.laneTag != nil {
            map["LaneTag"] = self.laneTag!
        }
        if self.mseGatewayEntryRuleShrink != nil {
            map["MseGatewayEntryRule"] = self.mseGatewayEntryRuleShrink!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppEntryRule"] as? String {
            self.appEntryRuleShrink = value
        }
        if let value = dict["CanaryModel"] as? Int32 {
            self.canaryModel = value
        }
        if let value = dict["Enable"] as? Bool {
            self.enable = value
        }
        if let value = dict["GroupId"] as? Int64 {
            self.groupId = value
        }
        if let value = dict["LaneId"] as? Int64 {
            self.laneId = value
        }
        if let value = dict["LaneName"] as? String {
            self.laneName = value
        }
        if let value = dict["LaneTag"] as? String {
            self.laneTag = value
        }
        if let value = dict["MseGatewayEntryRule"] as? String {
            self.mseGatewayEntryRuleShrink = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class CreateOrUpdateSwimmingLaneResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var laneId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.laneId != nil {
                map["LaneId"] = self.laneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LaneId"] as? Int64 {
                self.laneId = value
            }
        }
    }
    public var code: String?

    public var data: CreateOrUpdateSwimmingLaneResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateOrUpdateSwimmingLaneResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class CreateOrUpdateSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateOrUpdateSwimmingLaneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateOrUpdateSwimmingLaneGroupRequest : Tea.TeaModel {
    public var appIds: [String]?

    public var entryAppId: String?

    public var entryAppType: String?

    public var groupId: Int64?

    public var groupName: String?

    public var namespaceId: String?

    public var swimVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.entryAppId != nil {
            map["EntryAppId"] = self.entryAppId!
        }
        if self.entryAppType != nil {
            map["EntryAppType"] = self.entryAppType!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.swimVersion != nil {
            map["SwimVersion"] = self.swimVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppIds"] as? [String] {
            self.appIds = value
        }
        if let value = dict["EntryAppId"] as? String {
            self.entryAppId = value
        }
        if let value = dict["EntryAppType"] as? String {
            self.entryAppType = value
        }
        if let value = dict["GroupId"] as? Int64 {
            self.groupId = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["SwimVersion"] as? String {
            self.swimVersion = value
        }
    }
}

public class CreateOrUpdateSwimmingLaneGroupShrinkRequest : Tea.TeaModel {
    public var appIdsShrink: String?

    public var entryAppId: String?

    public var entryAppType: String?

    public var groupId: Int64?

    public var groupName: String?

    public var namespaceId: String?

    public var swimVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIdsShrink != nil {
            map["AppIds"] = self.appIdsShrink!
        }
        if self.entryAppId != nil {
            map["EntryAppId"] = self.entryAppId!
        }
        if self.entryAppType != nil {
            map["EntryAppType"] = self.entryAppType!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.swimVersion != nil {
            map["SwimVersion"] = self.swimVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppIds"] as? String {
            self.appIdsShrink = value
        }
        if let value = dict["EntryAppId"] as? String {
            self.entryAppId = value
        }
        if let value = dict["EntryAppType"] as? String {
            self.entryAppType = value
        }
        if let value = dict["GroupId"] as? Int64 {
            self.groupId = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["SwimVersion"] as? String {
            self.swimVersion = value
        }
    }
}

public class CreateOrUpdateSwimmingLaneGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var groupId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GroupId"] as? Int64 {
                self.groupId = value
            }
        }
    }
    public var code: String?

    public var data: CreateOrUpdateSwimmingLaneGroupResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateOrUpdateSwimmingLaneGroupResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class CreateOrUpdateSwimmingLaneGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrUpdateSwimmingLaneGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateOrUpdateSwimmingLaneGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateSecretRequest : Tea.TeaModel {
    public class SecretData : Tea.TeaModel {
        public var secretData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.secretData != nil {
                map["SecretData"] = self.secretData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SecretData"] as? String {
                self.secretData = value
            }
        }
    }
    public var namespaceId: String?

    public var secretData: CreateSecretRequest.SecretData?

    public var secretName: String?

    public var secretType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.secretData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.secretData != nil {
            map["SecretData"] = self.secretData?.toMap()
        }
        if self.secretName != nil {
            map["SecretName"] = self.secretName!
        }
        if self.secretType != nil {
            map["SecretType"] = self.secretType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["SecretData"] as? [String: Any?] {
            var model = CreateSecretRequest.SecretData()
            model.fromMap(value)
            self.secretData = model
        }
        if let value = dict["SecretName"] as? String {
            self.secretName = value
        }
        if let value = dict["SecretType"] as? String {
            self.secretType = value
        }
    }
}

public class CreateSecretShrinkRequest : Tea.TeaModel {
    public var namespaceId: String?

    public var secretDataShrink: String?

    public var secretName: String?

    public var secretType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.secretDataShrink != nil {
            map["SecretData"] = self.secretDataShrink!
        }
        if self.secretName != nil {
            map["SecretName"] = self.secretName!
        }
        if self.secretType != nil {
            map["SecretType"] = self.secretType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["SecretData"] as? String {
            self.secretDataShrink = value
        }
        if let value = dict["SecretName"] as? String {
            self.secretName = value
        }
        if let value = dict["SecretType"] as? String {
            self.secretType = value
        }
    }
}

public class CreateSecretResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var secretId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.secretId != nil {
                map["SecretId"] = self.secretId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SecretId"] as? Int64 {
                self.secretId = value
            }
        }
    }
    public var code: String?

    public var data: CreateSecretResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateSecretResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class CreateSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateSecretResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateWebApplicationRequest : Tea.TeaModel {
    public var namespaceId: String?

    public var body: CreateWebApplicationInput?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateWebApplicationInput()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateWebApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WebApplicationBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WebApplicationBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateWebCustomDomainRequest : Tea.TeaModel {
    public var namespaceId: String?

    public var body: CreateWebCustomDomainInput?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateWebCustomDomainInput()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateWebCustomDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WebCustomDomainBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WebCustomDomainBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class DeleteApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: DeleteApplicationResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DeleteApplicationResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DeleteApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var scalingRuleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ScalingRuleName"] as? String {
            self.scalingRuleName = value
        }
    }
}

public class DeleteApplicationScalingRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DeleteApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteApplicationScalingRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteConfigMapRequest : Tea.TeaModel {
    public var configMapId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configMapId != nil {
            map["ConfigMapId"] = self.configMapId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigMapId"] as? Int64 {
            self.configMapId = value
        }
    }
}

public class DeleteConfigMapResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configMapId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configMapId != nil {
                map["ConfigMapId"] = self.configMapId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigMapId"] as? Int64 {
                self.configMapId = value
            }
        }
    }
    public var code: String?

    public var data: DeleteConfigMapResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DeleteConfigMapResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DeleteConfigMapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteConfigMapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteConfigMapResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteGreyTagRouteRequest : Tea.TeaModel {
    public var greyTagRouteId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.greyTagRouteId != nil {
            map["GreyTagRouteId"] = self.greyTagRouteId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GreyTagRouteId"] as? Int64 {
            self.greyTagRouteId = value
        }
    }
}

public class DeleteGreyTagRouteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var greyTagRouteId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.greyTagRouteId != nil {
                map["GreyTagRouteId"] = self.greyTagRouteId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GreyTagRouteId"] as? Int64 {
                self.greyTagRouteId = value
            }
        }
    }
    public var code: String?

    public var data: DeleteGreyTagRouteResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DeleteGreyTagRouteResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DeleteGreyTagRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGreyTagRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteGreyTagRouteResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteHistoryJobRequest : Tea.TeaModel {
    public var appId: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
    }
}

public class DeleteHistoryJobResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DeleteHistoryJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHistoryJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteHistoryJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteIngressRequest : Tea.TeaModel {
    public var ingressId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ingressId != nil {
            map["IngressId"] = self.ingressId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IngressId"] as? Int64 {
            self.ingressId = value
        }
    }
}

public class DeleteIngressResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var ingressId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ingressId != nil {
                map["IngressId"] = self.ingressId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IngressId"] as? Int64 {
                self.ingressId = value
            }
        }
    }
    public var code: String?

    public var data: DeleteIngressResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DeleteIngressResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DeleteIngressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIngressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteIngressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteInstancesRequest : Tea.TeaModel {
    public var appId: String?

    public var instanceIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
    }
}

public class DeleteInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: DeleteInstancesResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DeleteInstancesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DeleteInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteJobRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class DeleteJobResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DeleteJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteNamespaceRequest : Tea.TeaModel {
    public var nameSpaceShortId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nameSpaceShortId != nil {
            map["NameSpaceShortId"] = self.nameSpaceShortId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NameSpaceShortId"] as? String {
            self.nameSpaceShortId = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class DeleteNamespaceResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DeleteNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteNamespaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteSecretRequest : Tea.TeaModel {
    public var namespaceId: String?

    public var secretId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.secretId != nil {
            map["SecretId"] = self.secretId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["SecretId"] as? Int64 {
            self.secretId = value
        }
    }
}

public class DeleteSecretResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var secretId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.secretId != nil {
                map["SecretId"] = self.secretId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SecretId"] as? Int64 {
                self.secretId = value
            }
        }
    }
    public var code: String?

    public var data: DeleteSecretResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DeleteSecretResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DeleteSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteSecretResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteSwimmingLaneGroupRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? Int64 {
            self.groupId = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class DeleteSwimmingLaneGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DeleteSwimmingLaneGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSwimmingLaneGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteSwimmingLaneGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteWebApplicationRequest : Tea.TeaModel {
    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class DeleteWebApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WebApplicationBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WebApplicationBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteWebApplicationRevisionRequest : Tea.TeaModel {
    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class DeleteWebApplicationRevisionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WebApplicationRevisionBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WebApplicationRevisionBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteWebCustomDomainRequest : Tea.TeaModel {
    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class DeleteWebCustomDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WebCustomDomainBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WebCustomDomainBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeployApplicationRequest : Tea.TeaModel {
    public var acrAssumeRoleArn: String?

    public var acrInstanceId: String?

    public var albIngressReadinessGate: String?

    public var appId: String?

    public var associateEip: Bool?

    public var autoEnableApplicationScalingRule: Bool?

    public var batchWaitTime: Int32?

    public var changeOrderDesc: String?

    public var command: String?

    public var commandArgs: String?

    public var configMapMountDesc: String?

    public var cpu: Int32?

    public var customHostAlias: String?

    public var customImageNetworkType: String?

    public var deploy: String?

    public var dotnet: String?

    public var edasContainerVersion: String?

    public var emptyDirDesc: String?

    public var enableAhas: String?

    public var enableCpuBurst: Bool?

    public var enableGreyTagRoute: Bool?

    public var enableNewArms: Bool?

    public var enablePrometheus: Bool?

    public var enableSidecarResourceIsolated: Bool?

    public var envs: String?

    public var gpuConfig: String?

    public var html: String?

    public var imagePullSecrets: String?

    public var imageUrl: String?

    public var initContainersConfig: [InitContainerConfig]?

    public var jarStartArgs: String?

    public var jarStartOptions: String?

    public var jdk: String?

    public var kafkaConfigs: String?

    public var liveness: String?

    public var memory: Int32?

    public var microRegistration: String?

    public var microRegistrationConfig: String?

    public var microserviceEngineConfig: String?

    public var minReadyInstanceRatio: Int32?

    public var minReadyInstances: Int32?

    public var mountDesc: String?

    public var mountHost: String?

    public var nasConfigs: String?

    public var nasId: String?

    public var newSaeVersion: String?

    public var oidcRoleName: String?

    public var ossAkId: String?

    public var ossAkSecret: String?

    public var ossMountDescs: String?

    public var packageType: String?

    public var packageUrl: String?

    public var packageVersion: String?

    public var php: String?

    public var phpArmsConfigLocation: String?

    public var phpConfig: String?

    public var phpConfigLocation: String?

    public var postStart: String?

    public var preStop: String?

    public var pvtzDiscoverySvc: String?

    public var python: String?

    public var pythonModules: String?

    public var readiness: String?

    public var replicas: Int32?

    public var secretMountDesc: String?

    public var securityGroupId: String?

    public var serviceTags: String?

    public var sidecarContainersConfig: [SidecarContainerConfig]?

    public var slsConfigs: String?

    public var startupProbe: String?

    public var swimlanePvtzDiscoverySvc: String?

    public var terminationGracePeriodSeconds: Int32?

    public var timezone: String?

    public var tomcatConfig: String?

    public var updateStrategy: String?

    public var vSwitchId: String?

    public var warStartOptions: String?

    public var webContainer: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acrAssumeRoleArn != nil {
            map["AcrAssumeRoleArn"] = self.acrAssumeRoleArn!
        }
        if self.acrInstanceId != nil {
            map["AcrInstanceId"] = self.acrInstanceId!
        }
        if self.albIngressReadinessGate != nil {
            map["AlbIngressReadinessGate"] = self.albIngressReadinessGate!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.associateEip != nil {
            map["AssociateEip"] = self.associateEip!
        }
        if self.autoEnableApplicationScalingRule != nil {
            map["AutoEnableApplicationScalingRule"] = self.autoEnableApplicationScalingRule!
        }
        if self.batchWaitTime != nil {
            map["BatchWaitTime"] = self.batchWaitTime!
        }
        if self.changeOrderDesc != nil {
            map["ChangeOrderDesc"] = self.changeOrderDesc!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.commandArgs != nil {
            map["CommandArgs"] = self.commandArgs!
        }
        if self.configMapMountDesc != nil {
            map["ConfigMapMountDesc"] = self.configMapMountDesc!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.customHostAlias != nil {
            map["CustomHostAlias"] = self.customHostAlias!
        }
        if self.customImageNetworkType != nil {
            map["CustomImageNetworkType"] = self.customImageNetworkType!
        }
        if self.deploy != nil {
            map["Deploy"] = self.deploy!
        }
        if self.dotnet != nil {
            map["Dotnet"] = self.dotnet!
        }
        if self.edasContainerVersion != nil {
            map["EdasContainerVersion"] = self.edasContainerVersion!
        }
        if self.emptyDirDesc != nil {
            map["EmptyDirDesc"] = self.emptyDirDesc!
        }
        if self.enableAhas != nil {
            map["EnableAhas"] = self.enableAhas!
        }
        if self.enableCpuBurst != nil {
            map["EnableCpuBurst"] = self.enableCpuBurst!
        }
        if self.enableGreyTagRoute != nil {
            map["EnableGreyTagRoute"] = self.enableGreyTagRoute!
        }
        if self.enableNewArms != nil {
            map["EnableNewArms"] = self.enableNewArms!
        }
        if self.enablePrometheus != nil {
            map["EnablePrometheus"] = self.enablePrometheus!
        }
        if self.enableSidecarResourceIsolated != nil {
            map["EnableSidecarResourceIsolated"] = self.enableSidecarResourceIsolated!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.gpuConfig != nil {
            map["GpuConfig"] = self.gpuConfig!
        }
        if self.html != nil {
            map["Html"] = self.html!
        }
        if self.imagePullSecrets != nil {
            map["ImagePullSecrets"] = self.imagePullSecrets!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.initContainersConfig != nil {
            var tmp : [Any] = []
            for k in self.initContainersConfig! {
                tmp.append(k.toMap())
            }
            map["InitContainersConfig"] = tmp
        }
        if self.jarStartArgs != nil {
            map["JarStartArgs"] = self.jarStartArgs!
        }
        if self.jarStartOptions != nil {
            map["JarStartOptions"] = self.jarStartOptions!
        }
        if self.jdk != nil {
            map["Jdk"] = self.jdk!
        }
        if self.kafkaConfigs != nil {
            map["KafkaConfigs"] = self.kafkaConfigs!
        }
        if self.liveness != nil {
            map["Liveness"] = self.liveness!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.microRegistration != nil {
            map["MicroRegistration"] = self.microRegistration!
        }
        if self.microRegistrationConfig != nil {
            map["MicroRegistrationConfig"] = self.microRegistrationConfig!
        }
        if self.microserviceEngineConfig != nil {
            map["MicroserviceEngineConfig"] = self.microserviceEngineConfig!
        }
        if self.minReadyInstanceRatio != nil {
            map["MinReadyInstanceRatio"] = self.minReadyInstanceRatio!
        }
        if self.minReadyInstances != nil {
            map["MinReadyInstances"] = self.minReadyInstances!
        }
        if self.mountDesc != nil {
            map["MountDesc"] = self.mountDesc!
        }
        if self.mountHost != nil {
            map["MountHost"] = self.mountHost!
        }
        if self.nasConfigs != nil {
            map["NasConfigs"] = self.nasConfigs!
        }
        if self.nasId != nil {
            map["NasId"] = self.nasId!
        }
        if self.newSaeVersion != nil {
            map["NewSaeVersion"] = self.newSaeVersion!
        }
        if self.oidcRoleName != nil {
            map["OidcRoleName"] = self.oidcRoleName!
        }
        if self.ossAkId != nil {
            map["OssAkId"] = self.ossAkId!
        }
        if self.ossAkSecret != nil {
            map["OssAkSecret"] = self.ossAkSecret!
        }
        if self.ossMountDescs != nil {
            map["OssMountDescs"] = self.ossMountDescs!
        }
        if self.packageType != nil {
            map["PackageType"] = self.packageType!
        }
        if self.packageUrl != nil {
            map["PackageUrl"] = self.packageUrl!
        }
        if self.packageVersion != nil {
            map["PackageVersion"] = self.packageVersion!
        }
        if self.php != nil {
            map["Php"] = self.php!
        }
        if self.phpArmsConfigLocation != nil {
            map["PhpArmsConfigLocation"] = self.phpArmsConfigLocation!
        }
        if self.phpConfig != nil {
            map["PhpConfig"] = self.phpConfig!
        }
        if self.phpConfigLocation != nil {
            map["PhpConfigLocation"] = self.phpConfigLocation!
        }
        if self.postStart != nil {
            map["PostStart"] = self.postStart!
        }
        if self.preStop != nil {
            map["PreStop"] = self.preStop!
        }
        if self.pvtzDiscoverySvc != nil {
            map["PvtzDiscoverySvc"] = self.pvtzDiscoverySvc!
        }
        if self.python != nil {
            map["Python"] = self.python!
        }
        if self.pythonModules != nil {
            map["PythonModules"] = self.pythonModules!
        }
        if self.readiness != nil {
            map["Readiness"] = self.readiness!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.secretMountDesc != nil {
            map["SecretMountDesc"] = self.secretMountDesc!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.serviceTags != nil {
            map["ServiceTags"] = self.serviceTags!
        }
        if self.sidecarContainersConfig != nil {
            var tmp : [Any] = []
            for k in self.sidecarContainersConfig! {
                tmp.append(k.toMap())
            }
            map["SidecarContainersConfig"] = tmp
        }
        if self.slsConfigs != nil {
            map["SlsConfigs"] = self.slsConfigs!
        }
        if self.startupProbe != nil {
            map["StartupProbe"] = self.startupProbe!
        }
        if self.swimlanePvtzDiscoverySvc != nil {
            map["SwimlanePvtzDiscoverySvc"] = self.swimlanePvtzDiscoverySvc!
        }
        if self.terminationGracePeriodSeconds != nil {
            map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
        }
        if self.timezone != nil {
            map["Timezone"] = self.timezone!
        }
        if self.tomcatConfig != nil {
            map["TomcatConfig"] = self.tomcatConfig!
        }
        if self.updateStrategy != nil {
            map["UpdateStrategy"] = self.updateStrategy!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.warStartOptions != nil {
            map["WarStartOptions"] = self.warStartOptions!
        }
        if self.webContainer != nil {
            map["WebContainer"] = self.webContainer!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcrAssumeRoleArn"] as? String {
            self.acrAssumeRoleArn = value
        }
        if let value = dict["AcrInstanceId"] as? String {
            self.acrInstanceId = value
        }
        if let value = dict["AlbIngressReadinessGate"] as? String {
            self.albIngressReadinessGate = value
        }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AssociateEip"] as? Bool {
            self.associateEip = value
        }
        if let value = dict["AutoEnableApplicationScalingRule"] as? Bool {
            self.autoEnableApplicationScalingRule = value
        }
        if let value = dict["BatchWaitTime"] as? Int32 {
            self.batchWaitTime = value
        }
        if let value = dict["ChangeOrderDesc"] as? String {
            self.changeOrderDesc = value
        }
        if let value = dict["Command"] as? String {
            self.command = value
        }
        if let value = dict["CommandArgs"] as? String {
            self.commandArgs = value
        }
        if let value = dict["ConfigMapMountDesc"] as? String {
            self.configMapMountDesc = value
        }
        if let value = dict["Cpu"] as? Int32 {
            self.cpu = value
        }
        if let value = dict["CustomHostAlias"] as? String {
            self.customHostAlias = value
        }
        if let value = dict["CustomImageNetworkType"] as? String {
            self.customImageNetworkType = value
        }
        if let value = dict["Deploy"] as? String {
            self.deploy = value
        }
        if let value = dict["Dotnet"] as? String {
            self.dotnet = value
        }
        if let value = dict["EdasContainerVersion"] as? String {
            self.edasContainerVersion = value
        }
        if let value = dict["EmptyDirDesc"] as? String {
            self.emptyDirDesc = value
        }
        if let value = dict["EnableAhas"] as? String {
            self.enableAhas = value
        }
        if let value = dict["EnableCpuBurst"] as? Bool {
            self.enableCpuBurst = value
        }
        if let value = dict["EnableGreyTagRoute"] as? Bool {
            self.enableGreyTagRoute = value
        }
        if let value = dict["EnableNewArms"] as? Bool {
            self.enableNewArms = value
        }
        if let value = dict["EnablePrometheus"] as? Bool {
            self.enablePrometheus = value
        }
        if let value = dict["EnableSidecarResourceIsolated"] as? Bool {
            self.enableSidecarResourceIsolated = value
        }
        if let value = dict["Envs"] as? String {
            self.envs = value
        }
        if let value = dict["GpuConfig"] as? String {
            self.gpuConfig = value
        }
        if let value = dict["Html"] as? String {
            self.html = value
        }
        if let value = dict["ImagePullSecrets"] as? String {
            self.imagePullSecrets = value
        }
        if let value = dict["ImageUrl"] as? String {
            self.imageUrl = value
        }
        if let value = dict["InitContainersConfig"] as? [Any?] {
            var tmp : [InitContainerConfig] = []
            for v in value {
                if v != nil {
                    var model = InitContainerConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.initContainersConfig = tmp
        }
        if let value = dict["JarStartArgs"] as? String {
            self.jarStartArgs = value
        }
        if let value = dict["JarStartOptions"] as? String {
            self.jarStartOptions = value
        }
        if let value = dict["Jdk"] as? String {
            self.jdk = value
        }
        if let value = dict["KafkaConfigs"] as? String {
            self.kafkaConfigs = value
        }
        if let value = dict["Liveness"] as? String {
            self.liveness = value
        }
        if let value = dict["Memory"] as? Int32 {
            self.memory = value
        }
        if let value = dict["MicroRegistration"] as? String {
            self.microRegistration = value
        }
        if let value = dict["MicroRegistrationConfig"] as? String {
            self.microRegistrationConfig = value
        }
        if let value = dict["MicroserviceEngineConfig"] as? String {
            self.microserviceEngineConfig = value
        }
        if let value = dict["MinReadyInstanceRatio"] as? Int32 {
            self.minReadyInstanceRatio = value
        }
        if let value = dict["MinReadyInstances"] as? Int32 {
            self.minReadyInstances = value
        }
        if let value = dict["MountDesc"] as? String {
            self.mountDesc = value
        }
        if let value = dict["MountHost"] as? String {
            self.mountHost = value
        }
        if let value = dict["NasConfigs"] as? String {
            self.nasConfigs = value
        }
        if let value = dict["NasId"] as? String {
            self.nasId = value
        }
        if let value = dict["NewSaeVersion"] as? String {
            self.newSaeVersion = value
        }
        if let value = dict["OidcRoleName"] as? String {
            self.oidcRoleName = value
        }
        if let value = dict["OssAkId"] as? String {
            self.ossAkId = value
        }
        if let value = dict["OssAkSecret"] as? String {
            self.ossAkSecret = value
        }
        if let value = dict["OssMountDescs"] as? String {
            self.ossMountDescs = value
        }
        if let value = dict["PackageType"] as? String {
            self.packageType = value
        }
        if let value = dict["PackageUrl"] as? String {
            self.packageUrl = value
        }
        if let value = dict["PackageVersion"] as? String {
            self.packageVersion = value
        }
        if let value = dict["Php"] as? String {
            self.php = value
        }
        if let value = dict["PhpArmsConfigLocation"] as? String {
            self.phpArmsConfigLocation = value
        }
        if let value = dict["PhpConfig"] as? String {
            self.phpConfig = value
        }
        if let value = dict["PhpConfigLocation"] as? String {
            self.phpConfigLocation = value
        }
        if let value = dict["PostStart"] as? String {
            self.postStart = value
        }
        if let value = dict["PreStop"] as? String {
            self.preStop = value
        }
        if let value = dict["PvtzDiscoverySvc"] as? String {
            self.pvtzDiscoverySvc = value
        }
        if let value = dict["Python"] as? String {
            self.python = value
        }
        if let value = dict["PythonModules"] as? String {
            self.pythonModules = value
        }
        if let value = dict["Readiness"] as? String {
            self.readiness = value
        }
        if let value = dict["Replicas"] as? Int32 {
            self.replicas = value
        }
        if let value = dict["SecretMountDesc"] as? String {
            self.secretMountDesc = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["ServiceTags"] as? String {
            self.serviceTags = value
        }
        if let value = dict["SidecarContainersConfig"] as? [Any?] {
            var tmp : [SidecarContainerConfig] = []
            for v in value {
                if v != nil {
                    var model = SidecarContainerConfig()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.sidecarContainersConfig = tmp
        }
        if let value = dict["SlsConfigs"] as? String {
            self.slsConfigs = value
        }
        if let value = dict["StartupProbe"] as? String {
            self.startupProbe = value
        }
        if let value = dict["SwimlanePvtzDiscoverySvc"] as? String {
            self.swimlanePvtzDiscoverySvc = value
        }
        if let value = dict["TerminationGracePeriodSeconds"] as? Int32 {
            self.terminationGracePeriodSeconds = value
        }
        if let value = dict["Timezone"] as? String {
            self.timezone = value
        }
        if let value = dict["TomcatConfig"] as? String {
            self.tomcatConfig = value
        }
        if let value = dict["UpdateStrategy"] as? String {
            self.updateStrategy = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["WarStartOptions"] as? String {
            self.warStartOptions = value
        }
        if let value = dict["WebContainer"] as? String {
            self.webContainer = value
        }
    }
}

public class DeployApplicationShrinkRequest : Tea.TeaModel {
    public var acrAssumeRoleArn: String?

    public var acrInstanceId: String?

    public var albIngressReadinessGate: String?

    public var appId: String?

    public var associateEip: Bool?

    public var autoEnableApplicationScalingRule: Bool?

    public var batchWaitTime: Int32?

    public var changeOrderDesc: String?

    public var command: String?

    public var commandArgs: String?

    public var configMapMountDesc: String?

    public var cpu: Int32?

    public var customHostAlias: String?

    public var customImageNetworkType: String?

    public var deploy: String?

    public var dotnet: String?

    public var edasContainerVersion: String?

    public var emptyDirDesc: String?

    public var enableAhas: String?

    public var enableCpuBurst: Bool?

    public var enableGreyTagRoute: Bool?

    public var enableNewArms: Bool?

    public var enablePrometheus: Bool?

    public var enableSidecarResourceIsolated: Bool?

    public var envs: String?

    public var gpuConfig: String?

    public var html: String?

    public var imagePullSecrets: String?

    public var imageUrl: String?

    public var initContainersConfigShrink: String?

    public var jarStartArgs: String?

    public var jarStartOptions: String?

    public var jdk: String?

    public var kafkaConfigs: String?

    public var liveness: String?

    public var memory: Int32?

    public var microRegistration: String?

    public var microRegistrationConfig: String?

    public var microserviceEngineConfig: String?

    public var minReadyInstanceRatio: Int32?

    public var minReadyInstances: Int32?

    public var mountDesc: String?

    public var mountHost: String?

    public var nasConfigs: String?

    public var nasId: String?

    public var newSaeVersion: String?

    public var oidcRoleName: String?

    public var ossAkId: String?

    public var ossAkSecret: String?

    public var ossMountDescs: String?

    public var packageType: String?

    public var packageUrl: String?

    public var packageVersion: String?

    public var php: String?

    public var phpArmsConfigLocation: String?

    public var phpConfig: String?

    public var phpConfigLocation: String?

    public var postStart: String?

    public var preStop: String?

    public var pvtzDiscoverySvc: String?

    public var python: String?

    public var pythonModules: String?

    public var readiness: String?

    public var replicas: Int32?

    public var secretMountDesc: String?

    public var securityGroupId: String?

    public var serviceTags: String?

    public var sidecarContainersConfigShrink: String?

    public var slsConfigs: String?

    public var startupProbe: String?

    public var swimlanePvtzDiscoverySvc: String?

    public var terminationGracePeriodSeconds: Int32?

    public var timezone: String?

    public var tomcatConfig: String?

    public var updateStrategy: String?

    public var vSwitchId: String?

    public var warStartOptions: String?

    public var webContainer: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acrAssumeRoleArn != nil {
            map["AcrAssumeRoleArn"] = self.acrAssumeRoleArn!
        }
        if self.acrInstanceId != nil {
            map["AcrInstanceId"] = self.acrInstanceId!
        }
        if self.albIngressReadinessGate != nil {
            map["AlbIngressReadinessGate"] = self.albIngressReadinessGate!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.associateEip != nil {
            map["AssociateEip"] = self.associateEip!
        }
        if self.autoEnableApplicationScalingRule != nil {
            map["AutoEnableApplicationScalingRule"] = self.autoEnableApplicationScalingRule!
        }
        if self.batchWaitTime != nil {
            map["BatchWaitTime"] = self.batchWaitTime!
        }
        if self.changeOrderDesc != nil {
            map["ChangeOrderDesc"] = self.changeOrderDesc!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.commandArgs != nil {
            map["CommandArgs"] = self.commandArgs!
        }
        if self.configMapMountDesc != nil {
            map["ConfigMapMountDesc"] = self.configMapMountDesc!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.customHostAlias != nil {
            map["CustomHostAlias"] = self.customHostAlias!
        }
        if self.customImageNetworkType != nil {
            map["CustomImageNetworkType"] = self.customImageNetworkType!
        }
        if self.deploy != nil {
            map["Deploy"] = self.deploy!
        }
        if self.dotnet != nil {
            map["Dotnet"] = self.dotnet!
        }
        if self.edasContainerVersion != nil {
            map["EdasContainerVersion"] = self.edasContainerVersion!
        }
        if self.emptyDirDesc != nil {
            map["EmptyDirDesc"] = self.emptyDirDesc!
        }
        if self.enableAhas != nil {
            map["EnableAhas"] = self.enableAhas!
        }
        if self.enableCpuBurst != nil {
            map["EnableCpuBurst"] = self.enableCpuBurst!
        }
        if self.enableGreyTagRoute != nil {
            map["EnableGreyTagRoute"] = self.enableGreyTagRoute!
        }
        if self.enableNewArms != nil {
            map["EnableNewArms"] = self.enableNewArms!
        }
        if self.enablePrometheus != nil {
            map["EnablePrometheus"] = self.enablePrometheus!
        }
        if self.enableSidecarResourceIsolated != nil {
            map["EnableSidecarResourceIsolated"] = self.enableSidecarResourceIsolated!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.gpuConfig != nil {
            map["GpuConfig"] = self.gpuConfig!
        }
        if self.html != nil {
            map["Html"] = self.html!
        }
        if self.imagePullSecrets != nil {
            map["ImagePullSecrets"] = self.imagePullSecrets!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.initContainersConfigShrink != nil {
            map["InitContainersConfig"] = self.initContainersConfigShrink!
        }
        if self.jarStartArgs != nil {
            map["JarStartArgs"] = self.jarStartArgs!
        }
        if self.jarStartOptions != nil {
            map["JarStartOptions"] = self.jarStartOptions!
        }
        if self.jdk != nil {
            map["Jdk"] = self.jdk!
        }
        if self.kafkaConfigs != nil {
            map["KafkaConfigs"] = self.kafkaConfigs!
        }
        if self.liveness != nil {
            map["Liveness"] = self.liveness!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.microRegistration != nil {
            map["MicroRegistration"] = self.microRegistration!
        }
        if self.microRegistrationConfig != nil {
            map["MicroRegistrationConfig"] = self.microRegistrationConfig!
        }
        if self.microserviceEngineConfig != nil {
            map["MicroserviceEngineConfig"] = self.microserviceEngineConfig!
        }
        if self.minReadyInstanceRatio != nil {
            map["MinReadyInstanceRatio"] = self.minReadyInstanceRatio!
        }
        if self.minReadyInstances != nil {
            map["MinReadyInstances"] = self.minReadyInstances!
        }
        if self.mountDesc != nil {
            map["MountDesc"] = self.mountDesc!
        }
        if self.mountHost != nil {
            map["MountHost"] = self.mountHost!
        }
        if self.nasConfigs != nil {
            map["NasConfigs"] = self.nasConfigs!
        }
        if self.nasId != nil {
            map["NasId"] = self.nasId!
        }
        if self.newSaeVersion != nil {
            map["NewSaeVersion"] = self.newSaeVersion!
        }
        if self.oidcRoleName != nil {
            map["OidcRoleName"] = self.oidcRoleName!
        }
        if self.ossAkId != nil {
            map["OssAkId"] = self.ossAkId!
        }
        if self.ossAkSecret != nil {
            map["OssAkSecret"] = self.ossAkSecret!
        }
        if self.ossMountDescs != nil {
            map["OssMountDescs"] = self.ossMountDescs!
        }
        if self.packageType != nil {
            map["PackageType"] = self.packageType!
        }
        if self.packageUrl != nil {
            map["PackageUrl"] = self.packageUrl!
        }
        if self.packageVersion != nil {
            map["PackageVersion"] = self.packageVersion!
        }
        if self.php != nil {
            map["Php"] = self.php!
        }
        if self.phpArmsConfigLocation != nil {
            map["PhpArmsConfigLocation"] = self.phpArmsConfigLocation!
        }
        if self.phpConfig != nil {
            map["PhpConfig"] = self.phpConfig!
        }
        if self.phpConfigLocation != nil {
            map["PhpConfigLocation"] = self.phpConfigLocation!
        }
        if self.postStart != nil {
            map["PostStart"] = self.postStart!
        }
        if self.preStop != nil {
            map["PreStop"] = self.preStop!
        }
        if self.pvtzDiscoverySvc != nil {
            map["PvtzDiscoverySvc"] = self.pvtzDiscoverySvc!
        }
        if self.python != nil {
            map["Python"] = self.python!
        }
        if self.pythonModules != nil {
            map["PythonModules"] = self.pythonModules!
        }
        if self.readiness != nil {
            map["Readiness"] = self.readiness!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.secretMountDesc != nil {
            map["SecretMountDesc"] = self.secretMountDesc!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.serviceTags != nil {
            map["ServiceTags"] = self.serviceTags!
        }
        if self.sidecarContainersConfigShrink != nil {
            map["SidecarContainersConfig"] = self.sidecarContainersConfigShrink!
        }
        if self.slsConfigs != nil {
            map["SlsConfigs"] = self.slsConfigs!
        }
        if self.startupProbe != nil {
            map["StartupProbe"] = self.startupProbe!
        }
        if self.swimlanePvtzDiscoverySvc != nil {
            map["SwimlanePvtzDiscoverySvc"] = self.swimlanePvtzDiscoverySvc!
        }
        if self.terminationGracePeriodSeconds != nil {
            map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
        }
        if self.timezone != nil {
            map["Timezone"] = self.timezone!
        }
        if self.tomcatConfig != nil {
            map["TomcatConfig"] = self.tomcatConfig!
        }
        if self.updateStrategy != nil {
            map["UpdateStrategy"] = self.updateStrategy!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.warStartOptions != nil {
            map["WarStartOptions"] = self.warStartOptions!
        }
        if self.webContainer != nil {
            map["WebContainer"] = self.webContainer!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcrAssumeRoleArn"] as? String {
            self.acrAssumeRoleArn = value
        }
        if let value = dict["AcrInstanceId"] as? String {
            self.acrInstanceId = value
        }
        if let value = dict["AlbIngressReadinessGate"] as? String {
            self.albIngressReadinessGate = value
        }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AssociateEip"] as? Bool {
            self.associateEip = value
        }
        if let value = dict["AutoEnableApplicationScalingRule"] as? Bool {
            self.autoEnableApplicationScalingRule = value
        }
        if let value = dict["BatchWaitTime"] as? Int32 {
            self.batchWaitTime = value
        }
        if let value = dict["ChangeOrderDesc"] as? String {
            self.changeOrderDesc = value
        }
        if let value = dict["Command"] as? String {
            self.command = value
        }
        if let value = dict["CommandArgs"] as? String {
            self.commandArgs = value
        }
        if let value = dict["ConfigMapMountDesc"] as? String {
            self.configMapMountDesc = value
        }
        if let value = dict["Cpu"] as? Int32 {
            self.cpu = value
        }
        if let value = dict["CustomHostAlias"] as? String {
            self.customHostAlias = value
        }
        if let value = dict["CustomImageNetworkType"] as? String {
            self.customImageNetworkType = value
        }
        if let value = dict["Deploy"] as? String {
            self.deploy = value
        }
        if let value = dict["Dotnet"] as? String {
            self.dotnet = value
        }
        if let value = dict["EdasContainerVersion"] as? String {
            self.edasContainerVersion = value
        }
        if let value = dict["EmptyDirDesc"] as? String {
            self.emptyDirDesc = value
        }
        if let value = dict["EnableAhas"] as? String {
            self.enableAhas = value
        }
        if let value = dict["EnableCpuBurst"] as? Bool {
            self.enableCpuBurst = value
        }
        if let value = dict["EnableGreyTagRoute"] as? Bool {
            self.enableGreyTagRoute = value
        }
        if let value = dict["EnableNewArms"] as? Bool {
            self.enableNewArms = value
        }
        if let value = dict["EnablePrometheus"] as? Bool {
            self.enablePrometheus = value
        }
        if let value = dict["EnableSidecarResourceIsolated"] as? Bool {
            self.enableSidecarResourceIsolated = value
        }
        if let value = dict["Envs"] as? String {
            self.envs = value
        }
        if let value = dict["GpuConfig"] as? String {
            self.gpuConfig = value
        }
        if let value = dict["Html"] as? String {
            self.html = value
        }
        if let value = dict["ImagePullSecrets"] as? String {
            self.imagePullSecrets = value
        }
        if let value = dict["ImageUrl"] as? String {
            self.imageUrl = value
        }
        if let value = dict["InitContainersConfig"] as? String {
            self.initContainersConfigShrink = value
        }
        if let value = dict["JarStartArgs"] as? String {
            self.jarStartArgs = value
        }
        if let value = dict["JarStartOptions"] as? String {
            self.jarStartOptions = value
        }
        if let value = dict["Jdk"] as? String {
            self.jdk = value
        }
        if let value = dict["KafkaConfigs"] as? String {
            self.kafkaConfigs = value
        }
        if let value = dict["Liveness"] as? String {
            self.liveness = value
        }
        if let value = dict["Memory"] as? Int32 {
            self.memory = value
        }
        if let value = dict["MicroRegistration"] as? String {
            self.microRegistration = value
        }
        if let value = dict["MicroRegistrationConfig"] as? String {
            self.microRegistrationConfig = value
        }
        if let value = dict["MicroserviceEngineConfig"] as? String {
            self.microserviceEngineConfig = value
        }
        if let value = dict["MinReadyInstanceRatio"] as? Int32 {
            self.minReadyInstanceRatio = value
        }
        if let value = dict["MinReadyInstances"] as? Int32 {
            self.minReadyInstances = value
        }
        if let value = dict["MountDesc"] as? String {
            self.mountDesc = value
        }
        if let value = dict["MountHost"] as? String {
            self.mountHost = value
        }
        if let value = dict["NasConfigs"] as? String {
            self.nasConfigs = value
        }
        if let value = dict["NasId"] as? String {
            self.nasId = value
        }
        if let value = dict["NewSaeVersion"] as? String {
            self.newSaeVersion = value
        }
        if let value = dict["OidcRoleName"] as? String {
            self.oidcRoleName = value
        }
        if let value = dict["OssAkId"] as? String {
            self.ossAkId = value
        }
        if let value = dict["OssAkSecret"] as? String {
            self.ossAkSecret = value
        }
        if let value = dict["OssMountDescs"] as? String {
            self.ossMountDescs = value
        }
        if let value = dict["PackageType"] as? String {
            self.packageType = value
        }
        if let value = dict["PackageUrl"] as? String {
            self.packageUrl = value
        }
        if let value = dict["PackageVersion"] as? String {
            self.packageVersion = value
        }
        if let value = dict["Php"] as? String {
            self.php = value
        }
        if let value = dict["PhpArmsConfigLocation"] as? String {
            self.phpArmsConfigLocation = value
        }
        if let value = dict["PhpConfig"] as? String {
            self.phpConfig = value
        }
        if let value = dict["PhpConfigLocation"] as? String {
            self.phpConfigLocation = value
        }
        if let value = dict["PostStart"] as? String {
            self.postStart = value
        }
        if let value = dict["PreStop"] as? String {
            self.preStop = value
        }
        if let value = dict["PvtzDiscoverySvc"] as? String {
            self.pvtzDiscoverySvc = value
        }
        if let value = dict["Python"] as? String {
            self.python = value
        }
        if let value = dict["PythonModules"] as? String {
            self.pythonModules = value
        }
        if let value = dict["Readiness"] as? String {
            self.readiness = value
        }
        if let value = dict["Replicas"] as? Int32 {
            self.replicas = value
        }
        if let value = dict["SecretMountDesc"] as? String {
            self.secretMountDesc = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
        if let value = dict["ServiceTags"] as? String {
            self.serviceTags = value
        }
        if let value = dict["SidecarContainersConfig"] as? String {
            self.sidecarContainersConfigShrink = value
        }
        if let value = dict["SlsConfigs"] as? String {
            self.slsConfigs = value
        }
        if let value = dict["StartupProbe"] as? String {
            self.startupProbe = value
        }
        if let value = dict["SwimlanePvtzDiscoverySvc"] as? String {
            self.swimlanePvtzDiscoverySvc = value
        }
        if let value = dict["TerminationGracePeriodSeconds"] as? Int32 {
            self.terminationGracePeriodSeconds = value
        }
        if let value = dict["Timezone"] as? String {
            self.timezone = value
        }
        if let value = dict["TomcatConfig"] as? String {
            self.tomcatConfig = value
        }
        if let value = dict["UpdateStrategy"] as? String {
            self.updateStrategy = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["WarStartOptions"] as? String {
            self.warStartOptions = value
        }
        if let value = dict["WebContainer"] as? String {
            self.webContainer = value
        }
    }
}

public class DeployApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var changeOrderId: String?

        public var isNeedApproval: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            if self.isNeedApproval != nil {
                map["IsNeedApproval"] = self.isNeedApproval!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
            if let value = dict["IsNeedApproval"] as? Bool {
                self.isNeedApproval = value
            }
        }
    }
    public var code: String?

    public var data: DeployApplicationResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DeployApplicationResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DeployApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeployApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeployApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAppServiceDetailRequest : Tea.TeaModel {
    public var appId: String?

    public var nacosInstanceId: String?

    public var nacosNamespaceId: String?

    public var serviceGroup: String?

    public var serviceName: String?

    public var serviceType: String?

    public var serviceVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.nacosInstanceId != nil {
            map["NacosInstanceId"] = self.nacosInstanceId!
        }
        if self.nacosNamespaceId != nil {
            map["NacosNamespaceId"] = self.nacosNamespaceId!
        }
        if self.serviceGroup != nil {
            map["ServiceGroup"] = self.serviceGroup!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        if self.serviceVersion != nil {
            map["ServiceVersion"] = self.serviceVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["NacosInstanceId"] as? String {
            self.nacosInstanceId = value
        }
        if let value = dict["NacosNamespaceId"] as? String {
            self.nacosNamespaceId = value
        }
        if let value = dict["ServiceGroup"] as? String {
            self.serviceGroup = value
        }
        if let value = dict["ServiceName"] as? String {
            self.serviceName = value
        }
        if let value = dict["ServiceType"] as? String {
            self.serviceType = value
        }
        if let value = dict["ServiceVersion"] as? String {
            self.serviceVersion = value
        }
    }
}

public class DescribeAppServiceDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Methods : Tea.TeaModel {
            public class ParameterDefinitions : Tea.TeaModel {
                public var description_: String?

                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var methodController: String?

            public var name: String?

            public var nameDetail: String?

            public var parameterDefinitions: [DescribeAppServiceDetailResponseBody.Data.Methods.ParameterDefinitions]?

            public var parameterDetails: [String]?

            public var parameterTypes: [String]?

            public var paths: [String]?

            public var requestMethods: [String]?

            public var returnDetails: String?

            public var returnType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.methodController != nil {
                    map["MethodController"] = self.methodController!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nameDetail != nil {
                    map["NameDetail"] = self.nameDetail!
                }
                if self.parameterDefinitions != nil {
                    var tmp : [Any] = []
                    for k in self.parameterDefinitions! {
                        tmp.append(k.toMap())
                    }
                    map["ParameterDefinitions"] = tmp
                }
                if self.parameterDetails != nil {
                    map["ParameterDetails"] = self.parameterDetails!
                }
                if self.parameterTypes != nil {
                    map["ParameterTypes"] = self.parameterTypes!
                }
                if self.paths != nil {
                    map["Paths"] = self.paths!
                }
                if self.requestMethods != nil {
                    map["RequestMethods"] = self.requestMethods!
                }
                if self.returnDetails != nil {
                    map["ReturnDetails"] = self.returnDetails!
                }
                if self.returnType != nil {
                    map["ReturnType"] = self.returnType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MethodController"] as? String {
                    self.methodController = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["NameDetail"] as? String {
                    self.nameDetail = value
                }
                if let value = dict["ParameterDefinitions"] as? [Any?] {
                    var tmp : [DescribeAppServiceDetailResponseBody.Data.Methods.ParameterDefinitions] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeAppServiceDetailResponseBody.Data.Methods.ParameterDefinitions()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.parameterDefinitions = tmp
                }
                if let value = dict["ParameterDetails"] as? [String] {
                    self.parameterDetails = value
                }
                if let value = dict["ParameterTypes"] as? [String] {
                    self.parameterTypes = value
                }
                if let value = dict["Paths"] as? [String] {
                    self.paths = value
                }
                if let value = dict["RequestMethods"] as? [String] {
                    self.requestMethods = value
                }
                if let value = dict["ReturnDetails"] as? String {
                    self.returnDetails = value
                }
                if let value = dict["ReturnType"] as? String {
                    self.returnType = value
                }
            }
        }
        public var dubboApplicationName: String?

        public var edasAppName: String?

        public var group: String?

        public var metadata: [String: Any]?

        public var methods: [DescribeAppServiceDetailResponseBody.Data.Methods]?

        public var serviceName: String?

        public var servicePorts: [Int64]?

        public var serviceProtocol: String?

        public var serviceTags: [String]?

        public var serviceType: String?

        public var springApplicationName: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dubboApplicationName != nil {
                map["DubboApplicationName"] = self.dubboApplicationName!
            }
            if self.edasAppName != nil {
                map["EdasAppName"] = self.edasAppName!
            }
            if self.group != nil {
                map["Group"] = self.group!
            }
            if self.metadata != nil {
                map["Metadata"] = self.metadata!
            }
            if self.methods != nil {
                var tmp : [Any] = []
                for k in self.methods! {
                    tmp.append(k.toMap())
                }
                map["Methods"] = tmp
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.servicePorts != nil {
                map["ServicePorts"] = self.servicePorts!
            }
            if self.serviceProtocol != nil {
                map["ServiceProtocol"] = self.serviceProtocol!
            }
            if self.serviceTags != nil {
                map["ServiceTags"] = self.serviceTags!
            }
            if self.serviceType != nil {
                map["ServiceType"] = self.serviceType!
            }
            if self.springApplicationName != nil {
                map["SpringApplicationName"] = self.springApplicationName!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DubboApplicationName"] as? String {
                self.dubboApplicationName = value
            }
            if let value = dict["EdasAppName"] as? String {
                self.edasAppName = value
            }
            if let value = dict["Group"] as? String {
                self.group = value
            }
            if let value = dict["Metadata"] as? [String: Any] {
                self.metadata = value
            }
            if let value = dict["Methods"] as? [Any?] {
                var tmp : [DescribeAppServiceDetailResponseBody.Data.Methods] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAppServiceDetailResponseBody.Data.Methods()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.methods = tmp
            }
            if let value = dict["ServiceName"] as? String {
                self.serviceName = value
            }
            if let value = dict["ServicePorts"] as? [Int64] {
                self.servicePorts = value
            }
            if let value = dict["ServiceProtocol"] as? String {
                self.serviceProtocol = value
            }
            if let value = dict["ServiceTags"] as? [String] {
                self.serviceTags = value
            }
            if let value = dict["ServiceType"] as? String {
                self.serviceType = value
            }
            if let value = dict["SpringApplicationName"] as? String {
                self.springApplicationName = value
            }
            if let value = dict["Version"] as? String {
                self.version = value
            }
        }
    }
    public var code: String?

    public var data: DescribeAppServiceDetailResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeAppServiceDetailResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeAppServiceDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAppServiceDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAppServiceDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApplicationConfigRequest : Tea.TeaModel {
    public var appId: String?

    public var versionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.versionId != nil {
            map["VersionId"] = self.versionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["VersionId"] as? String {
            self.versionId = value
        }
    }
}

public class DescribeApplicationConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ConfigMapMountDesc : Tea.TeaModel {
            public var configMapId: Int64?

            public var configMapName: String?

            public var key: String?

            public var mountPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configMapId != nil {
                    map["ConfigMapId"] = self.configMapId!
                }
                if self.configMapName != nil {
                    map["ConfigMapName"] = self.configMapName!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigMapId"] as? Int64 {
                    self.configMapId = value
                }
                if let value = dict["ConfigMapName"] as? String {
                    self.configMapName = value
                }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["MountPath"] as? String {
                    self.mountPath = value
                }
            }
        }
        public class EmptyDirDesc : Tea.TeaModel {
            public var mountPath: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MountPath"] as? String {
                    self.mountPath = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public class InitContainersConfig : Tea.TeaModel {
            public class ConfigMapMountDesc : Tea.TeaModel {
                public var configMapId: Int64?

                public var configMapName: String?

                public var key: String?

                public var mountPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.configMapId != nil {
                        map["ConfigMapId"] = self.configMapId!
                    }
                    if self.configMapName != nil {
                        map["ConfigMapName"] = self.configMapName!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.mountPath != nil {
                        map["MountPath"] = self.mountPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ConfigMapId"] as? Int64 {
                        self.configMapId = value
                    }
                    if let value = dict["ConfigMapName"] as? String {
                        self.configMapName = value
                    }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["MountPath"] as? String {
                        self.mountPath = value
                    }
                }
            }
            public class EmptyDirDesc : Tea.TeaModel {
                public var mountPath: String?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mountPath != nil {
                        map["MountPath"] = self.mountPath!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MountPath"] as? String {
                        self.mountPath = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                }
            }
            public var command: String?

            public var commandArgs: String?

            public var configMapMountDesc: [DescribeApplicationConfigResponseBody.Data.InitContainersConfig.ConfigMapMountDesc]?

            public var emptyDirDesc: [DescribeApplicationConfigResponseBody.Data.InitContainersConfig.EmptyDirDesc]?

            public var envs: String?

            public var imageUrl: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.command != nil {
                    map["Command"] = self.command!
                }
                if self.commandArgs != nil {
                    map["CommandArgs"] = self.commandArgs!
                }
                if self.configMapMountDesc != nil {
                    var tmp : [Any] = []
                    for k in self.configMapMountDesc! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigMapMountDesc"] = tmp
                }
                if self.emptyDirDesc != nil {
                    var tmp : [Any] = []
                    for k in self.emptyDirDesc! {
                        tmp.append(k.toMap())
                    }
                    map["EmptyDirDesc"] = tmp
                }
                if self.envs != nil {
                    map["Envs"] = self.envs!
                }
                if self.imageUrl != nil {
                    map["ImageUrl"] = self.imageUrl!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Command"] as? String {
                    self.command = value
                }
                if let value = dict["CommandArgs"] as? String {
                    self.commandArgs = value
                }
                if let value = dict["ConfigMapMountDesc"] as? [Any?] {
                    var tmp : [DescribeApplicationConfigResponseBody.Data.InitContainersConfig.ConfigMapMountDesc] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeApplicationConfigResponseBody.Data.InitContainersConfig.ConfigMapMountDesc()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.configMapMountDesc = tmp
                }
                if let value = dict["EmptyDirDesc"] as? [Any?] {
                    var tmp : [DescribeApplicationConfigResponseBody.Data.InitContainersConfig.EmptyDirDesc] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeApplicationConfigResponseBody.Data.InitContainersConfig.EmptyDirDesc()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.emptyDirDesc = tmp
                }
                if let value = dict["Envs"] as? String {
                    self.envs = value
                }
                if let value = dict["ImageUrl"] as? String {
                    self.imageUrl = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public class MountDesc : Tea.TeaModel {
            public var mountPath: String?

            public var nasPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.nasPath != nil {
                    map["NasPath"] = self.nasPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MountPath"] as? String {
                    self.mountPath = value
                }
                if let value = dict["NasPath"] as? String {
                    self.nasPath = value
                }
            }
        }
        public class OssMountDescs : Tea.TeaModel {
            public var bucketName: String?

            public var bucketPath: String?

            public var mountPath: String?

            public var readOnly: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucketName != nil {
                    map["bucketName"] = self.bucketName!
                }
                if self.bucketPath != nil {
                    map["bucketPath"] = self.bucketPath!
                }
                if self.mountPath != nil {
                    map["mountPath"] = self.mountPath!
                }
                if self.readOnly != nil {
                    map["readOnly"] = self.readOnly!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["bucketName"] as? String {
                    self.bucketName = value
                }
                if let value = dict["bucketPath"] as? String {
                    self.bucketPath = value
                }
                if let value = dict["mountPath"] as? String {
                    self.mountPath = value
                }
                if let value = dict["readOnly"] as? Bool {
                    self.readOnly = value
                }
            }
        }
        public class SecretMountDesc : Tea.TeaModel {
            public var key: String?

            public var mountPath: String?

            public var secretId: Int64?

            public var secretName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.secretId != nil {
                    map["SecretId"] = self.secretId!
                }
                if self.secretName != nil {
                    map["SecretName"] = self.secretName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["MountPath"] as? String {
                    self.mountPath = value
                }
                if let value = dict["SecretId"] as? Int64 {
                    self.secretId = value
                }
                if let value = dict["SecretName"] as? String {
                    self.secretName = value
                }
            }
        }
        public class SidecarContainersConfig : Tea.TeaModel {
            public class ConfigMapMountDesc : Tea.TeaModel {
                public var configMapId: Int64?

                public var configMapName: String?

                public var key: String?

                public var mountPath: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.configMapId != nil {
                        map["ConfigMapId"] = self.configMapId!
                    }
                    if self.configMapName != nil {
                        map["ConfigMapName"] = self.configMapName!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.mountPath != nil {
                        map["MountPath"] = self.mountPath!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ConfigMapId"] as? Int64 {
                        self.configMapId = value
                    }
                    if let value = dict["ConfigMapName"] as? String {
                        self.configMapName = value
                    }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["MountPath"] as? String {
                        self.mountPath = value
                    }
                }
            }
            public class EmptyDirDesc : Tea.TeaModel {
                public var mountPath: String?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mountPath != nil {
                        map["MountPath"] = self.mountPath!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MountPath"] as? String {
                        self.mountPath = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                }
            }
            public var acrInstanceId: String?

            public var command: String?

            public var commandArgs: String?

            public var configMapMountDesc: [DescribeApplicationConfigResponseBody.Data.SidecarContainersConfig.ConfigMapMountDesc]?

            public var cpu: Int32?

            public var emptyDirDesc: [DescribeApplicationConfigResponseBody.Data.SidecarContainersConfig.EmptyDirDesc]?

            public var envs: String?

            public var imageUrl: String?

            public var memory: Int32?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.acrInstanceId != nil {
                    map["AcrInstanceId"] = self.acrInstanceId!
                }
                if self.command != nil {
                    map["Command"] = self.command!
                }
                if self.commandArgs != nil {
                    map["CommandArgs"] = self.commandArgs!
                }
                if self.configMapMountDesc != nil {
                    var tmp : [Any] = []
                    for k in self.configMapMountDesc! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigMapMountDesc"] = tmp
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.emptyDirDesc != nil {
                    var tmp : [Any] = []
                    for k in self.emptyDirDesc! {
                        tmp.append(k.toMap())
                    }
                    map["EmptyDirDesc"] = tmp
                }
                if self.envs != nil {
                    map["Envs"] = self.envs!
                }
                if self.imageUrl != nil {
                    map["ImageUrl"] = self.imageUrl!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AcrInstanceId"] as? String {
                    self.acrInstanceId = value
                }
                if let value = dict["Command"] as? String {
                    self.command = value
                }
                if let value = dict["CommandArgs"] as? String {
                    self.commandArgs = value
                }
                if let value = dict["ConfigMapMountDesc"] as? [Any?] {
                    var tmp : [DescribeApplicationConfigResponseBody.Data.SidecarContainersConfig.ConfigMapMountDesc] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeApplicationConfigResponseBody.Data.SidecarContainersConfig.ConfigMapMountDesc()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.configMapMountDesc = tmp
                }
                if let value = dict["Cpu"] as? Int32 {
                    self.cpu = value
                }
                if let value = dict["EmptyDirDesc"] as? [Any?] {
                    var tmp : [DescribeApplicationConfigResponseBody.Data.SidecarContainersConfig.EmptyDirDesc] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeApplicationConfigResponseBody.Data.SidecarContainersConfig.EmptyDirDesc()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.emptyDirDesc = tmp
                }
                if let value = dict["Envs"] as? String {
                    self.envs = value
                }
                if let value = dict["ImageUrl"] as? String {
                    self.imageUrl = value
                }
                if let value = dict["Memory"] as? Int32 {
                    self.memory = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var acrAssumeRoleArn: String?

        public var acrInstanceId: String?

        public var albIngressReadinessGate: String?

        public var appDescription: String?

        public var appId: String?

        public var appName: String?

        public var appSource: String?

        public var associateEip: Bool?

        public var baseAppId: String?

        public var batchWaitTime: Int32?

        public var clusterId: String?

        public var cmsServiceId: String?

        public var command: String?

        public var commandArgs: String?

        public var configMapMountDesc: [DescribeApplicationConfigResponseBody.Data.ConfigMapMountDesc]?

        public var cpu: Int32?

        public var customHostAlias: String?

        public var customImageNetworkType: String?

        public var deploymentName: String?

        public var diskSize: Int32?

        public var dotnet: String?

        public var edasContainerVersion: String?

        public var emptyDirDesc: [DescribeApplicationConfigResponseBody.Data.EmptyDirDesc]?

        public var enableAhas: String?

        public var enableCpuBurst: String?

        public var enableGreyTagRoute: Bool?

        public var enableIdle: Bool?

        public var enableNewArms: Bool?

        public var enablePrometheus: Bool?

        public var envs: String?

        public var gpuCount: String?

        public var gpuType: String?

        public var headlessPvtzDiscovery: String?

        public var html: String?

        public var imagePullSecrets: String?

        public var imageUrl: String?

        public var initContainersConfig: [DescribeApplicationConfigResponseBody.Data.InitContainersConfig]?

        public var isStateful: Bool?

        public var jarStartArgs: String?

        public var jarStartOptions: String?

        public var jdk: String?

        public var kafkaConfigs: String?

        public var liveness: String?

        public var memory: Int32?

        public var microRegistration: String?

        public var microRegistrationConfig: String?

        public var microserviceEngineConfig: String?

        public var minReadyInstanceRatio: Int32?

        public var minReadyInstances: Int32?

        public var mountDesc: [DescribeApplicationConfigResponseBody.Data.MountDesc]?

        public var mountHost: String?

        public var mseApplicationId: String?

        public var mseApplicationName: String?

        public var namespaceId: String?

        public var nasConfigs: String?

        public var nasId: String?

        public var newSaeVersion: String?

        public var oidcRoleName: String?

        public var ossAkId: String?

        public var ossAkSecret: String?

        public var ossMountDescs: [DescribeApplicationConfigResponseBody.Data.OssMountDescs]?

        public var packageType: String?

        public var packageUrl: String?

        public var packageVersion: String?

        public var php: String?

        public var phpArmsConfigLocation: String?

        public var phpConfig: String?

        public var phpConfigLocation: String?

        public var postStart: String?

        public var preStop: String?

        public var programmingLanguage: String?

        public var pvtzDiscovery: String?

        public var python: String?

        public var pythonModules: String?

        public var readiness: String?

        public var regionId: String?

        public var replicas: Int32?

        public var resourceType: String?

        public var secretMountDesc: [DescribeApplicationConfigResponseBody.Data.SecretMountDesc]?

        public var securityGroupId: String?

        public var serviceTags: [String: String]?

        public var sidecarContainersConfig: [DescribeApplicationConfigResponseBody.Data.SidecarContainersConfig]?

        public var slsConfigs: String?

        public var startupProbe: String?

        public var swimlanePvtzDiscovery: String?

        public var tags: [DescribeApplicationConfigResponseBody.Data.Tags]?

        public var terminationGracePeriodSeconds: Int32?

        public var timezone: String?

        public var tomcatConfig: String?

        public var updateStrategy: String?

        public var vSwitchId: String?

        public var vpcId: String?

        public var warStartOptions: String?

        public var webContainer: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acrAssumeRoleArn != nil {
                map["AcrAssumeRoleArn"] = self.acrAssumeRoleArn!
            }
            if self.acrInstanceId != nil {
                map["AcrInstanceId"] = self.acrInstanceId!
            }
            if self.albIngressReadinessGate != nil {
                map["AlbIngressReadinessGate"] = self.albIngressReadinessGate!
            }
            if self.appDescription != nil {
                map["AppDescription"] = self.appDescription!
            }
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.appSource != nil {
                map["AppSource"] = self.appSource!
            }
            if self.associateEip != nil {
                map["AssociateEip"] = self.associateEip!
            }
            if self.baseAppId != nil {
                map["BaseAppId"] = self.baseAppId!
            }
            if self.batchWaitTime != nil {
                map["BatchWaitTime"] = self.batchWaitTime!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.cmsServiceId != nil {
                map["CmsServiceId"] = self.cmsServiceId!
            }
            if self.command != nil {
                map["Command"] = self.command!
            }
            if self.commandArgs != nil {
                map["CommandArgs"] = self.commandArgs!
            }
            if self.configMapMountDesc != nil {
                var tmp : [Any] = []
                for k in self.configMapMountDesc! {
                    tmp.append(k.toMap())
                }
                map["ConfigMapMountDesc"] = tmp
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.customHostAlias != nil {
                map["CustomHostAlias"] = self.customHostAlias!
            }
            if self.customImageNetworkType != nil {
                map["CustomImageNetworkType"] = self.customImageNetworkType!
            }
            if self.deploymentName != nil {
                map["DeploymentName"] = self.deploymentName!
            }
            if self.diskSize != nil {
                map["DiskSize"] = self.diskSize!
            }
            if self.dotnet != nil {
                map["Dotnet"] = self.dotnet!
            }
            if self.edasContainerVersion != nil {
                map["EdasContainerVersion"] = self.edasContainerVersion!
            }
            if self.emptyDirDesc != nil {
                var tmp : [Any] = []
                for k in self.emptyDirDesc! {
                    tmp.append(k.toMap())
                }
                map["EmptyDirDesc"] = tmp
            }
            if self.enableAhas != nil {
                map["EnableAhas"] = self.enableAhas!
            }
            if self.enableCpuBurst != nil {
                map["EnableCpuBurst"] = self.enableCpuBurst!
            }
            if self.enableGreyTagRoute != nil {
                map["EnableGreyTagRoute"] = self.enableGreyTagRoute!
            }
            if self.enableIdle != nil {
                map["EnableIdle"] = self.enableIdle!
            }
            if self.enableNewArms != nil {
                map["EnableNewArms"] = self.enableNewArms!
            }
            if self.enablePrometheus != nil {
                map["EnablePrometheus"] = self.enablePrometheus!
            }
            if self.envs != nil {
                map["Envs"] = self.envs!
            }
            if self.gpuCount != nil {
                map["GpuCount"] = self.gpuCount!
            }
            if self.gpuType != nil {
                map["GpuType"] = self.gpuType!
            }
            if self.headlessPvtzDiscovery != nil {
                map["HeadlessPvtzDiscovery"] = self.headlessPvtzDiscovery!
            }
            if self.html != nil {
                map["Html"] = self.html!
            }
            if self.imagePullSecrets != nil {
                map["ImagePullSecrets"] = self.imagePullSecrets!
            }
            if self.imageUrl != nil {
                map["ImageUrl"] = self.imageUrl!
            }
            if self.initContainersConfig != nil {
                var tmp : [Any] = []
                for k in self.initContainersConfig! {
                    tmp.append(k.toMap())
                }
                map["InitContainersConfig"] = tmp
            }
            if self.isStateful != nil {
                map["IsStateful"] = self.isStateful!
            }
            if self.jarStartArgs != nil {
                map["JarStartArgs"] = self.jarStartArgs!
            }
            if self.jarStartOptions != nil {
                map["JarStartOptions"] = self.jarStartOptions!
            }
            if self.jdk != nil {
                map["Jdk"] = self.jdk!
            }
            if self.kafkaConfigs != nil {
                map["KafkaConfigs"] = self.kafkaConfigs!
            }
            if self.liveness != nil {
                map["Liveness"] = self.liveness!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.microRegistration != nil {
                map["MicroRegistration"] = self.microRegistration!
            }
            if self.microRegistrationConfig != nil {
                map["MicroRegistrationConfig"] = self.microRegistrationConfig!
            }
            if self.microserviceEngineConfig != nil {
                map["MicroserviceEngineConfig"] = self.microserviceEngineConfig!
            }
            if self.minReadyInstanceRatio != nil {
                map["MinReadyInstanceRatio"] = self.minReadyInstanceRatio!
            }
            if self.minReadyInstances != nil {
                map["MinReadyInstances"] = self.minReadyInstances!
            }
            if self.mountDesc != nil {
                var tmp : [Any] = []
                for k in self.mountDesc! {
                    tmp.append(k.toMap())
                }
                map["MountDesc"] = tmp
            }
            if self.mountHost != nil {
                map["MountHost"] = self.mountHost!
            }
            if self.mseApplicationId != nil {
                map["MseApplicationId"] = self.mseApplicationId!
            }
            if self.mseApplicationName != nil {
                map["MseApplicationName"] = self.mseApplicationName!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.nasConfigs != nil {
                map["NasConfigs"] = self.nasConfigs!
            }
            if self.nasId != nil {
                map["NasId"] = self.nasId!
            }
            if self.newSaeVersion != nil {
                map["NewSaeVersion"] = self.newSaeVersion!
            }
            if self.oidcRoleName != nil {
                map["OidcRoleName"] = self.oidcRoleName!
            }
            if self.ossAkId != nil {
                map["OssAkId"] = self.ossAkId!
            }
            if self.ossAkSecret != nil {
                map["OssAkSecret"] = self.ossAkSecret!
            }
            if self.ossMountDescs != nil {
                var tmp : [Any] = []
                for k in self.ossMountDescs! {
                    tmp.append(k.toMap())
                }
                map["OssMountDescs"] = tmp
            }
            if self.packageType != nil {
                map["PackageType"] = self.packageType!
            }
            if self.packageUrl != nil {
                map["PackageUrl"] = self.packageUrl!
            }
            if self.packageVersion != nil {
                map["PackageVersion"] = self.packageVersion!
            }
            if self.php != nil {
                map["Php"] = self.php!
            }
            if self.phpArmsConfigLocation != nil {
                map["PhpArmsConfigLocation"] = self.phpArmsConfigLocation!
            }
            if self.phpConfig != nil {
                map["PhpConfig"] = self.phpConfig!
            }
            if self.phpConfigLocation != nil {
                map["PhpConfigLocation"] = self.phpConfigLocation!
            }
            if self.postStart != nil {
                map["PostStart"] = self.postStart!
            }
            if self.preStop != nil {
                map["PreStop"] = self.preStop!
            }
            if self.programmingLanguage != nil {
                map["ProgrammingLanguage"] = self.programmingLanguage!
            }
            if self.pvtzDiscovery != nil {
                map["PvtzDiscovery"] = self.pvtzDiscovery!
            }
            if self.python != nil {
                map["Python"] = self.python!
            }
            if self.pythonModules != nil {
                map["PythonModules"] = self.pythonModules!
            }
            if self.readiness != nil {
                map["Readiness"] = self.readiness!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.replicas != nil {
                map["Replicas"] = self.replicas!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.secretMountDesc != nil {
                var tmp : [Any] = []
                for k in self.secretMountDesc! {
                    tmp.append(k.toMap())
                }
                map["SecretMountDesc"] = tmp
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.serviceTags != nil {
                map["ServiceTags"] = self.serviceTags!
            }
            if self.sidecarContainersConfig != nil {
                var tmp : [Any] = []
                for k in self.sidecarContainersConfig! {
                    tmp.append(k.toMap())
                }
                map["SidecarContainersConfig"] = tmp
            }
            if self.slsConfigs != nil {
                map["SlsConfigs"] = self.slsConfigs!
            }
            if self.startupProbe != nil {
                map["StartupProbe"] = self.startupProbe!
            }
            if self.swimlanePvtzDiscovery != nil {
                map["SwimlanePvtzDiscovery"] = self.swimlanePvtzDiscovery!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.terminationGracePeriodSeconds != nil {
                map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
            }
            if self.timezone != nil {
                map["Timezone"] = self.timezone!
            }
            if self.tomcatConfig != nil {
                map["TomcatConfig"] = self.tomcatConfig!
            }
            if self.updateStrategy != nil {
                map["UpdateStrategy"] = self.updateStrategy!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.warStartOptions != nil {
                map["WarStartOptions"] = self.warStartOptions!
            }
            if self.webContainer != nil {
                map["WebContainer"] = self.webContainer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AcrAssumeRoleArn"] as? String {
                self.acrAssumeRoleArn = value
            }
            if let value = dict["AcrInstanceId"] as? String {
                self.acrInstanceId = value
            }
            if let value = dict["AlbIngressReadinessGate"] as? String {
                self.albIngressReadinessGate = value
            }
            if let value = dict["AppDescription"] as? String {
                self.appDescription = value
            }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["AppSource"] as? String {
                self.appSource = value
            }
            if let value = dict["AssociateEip"] as? Bool {
                self.associateEip = value
            }
            if let value = dict["BaseAppId"] as? String {
                self.baseAppId = value
            }
            if let value = dict["BatchWaitTime"] as? Int32 {
                self.batchWaitTime = value
            }
            if let value = dict["ClusterId"] as? String {
                self.clusterId = value
            }
            if let value = dict["CmsServiceId"] as? String {
                self.cmsServiceId = value
            }
            if let value = dict["Command"] as? String {
                self.command = value
            }
            if let value = dict["CommandArgs"] as? String {
                self.commandArgs = value
            }
            if let value = dict["ConfigMapMountDesc"] as? [Any?] {
                var tmp : [DescribeApplicationConfigResponseBody.Data.ConfigMapMountDesc] = []
                for v in value {
                    if v != nil {
                        var model = DescribeApplicationConfigResponseBody.Data.ConfigMapMountDesc()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configMapMountDesc = tmp
            }
            if let value = dict["Cpu"] as? Int32 {
                self.cpu = value
            }
            if let value = dict["CustomHostAlias"] as? String {
                self.customHostAlias = value
            }
            if let value = dict["CustomImageNetworkType"] as? String {
                self.customImageNetworkType = value
            }
            if let value = dict["DeploymentName"] as? String {
                self.deploymentName = value
            }
            if let value = dict["DiskSize"] as? Int32 {
                self.diskSize = value
            }
            if let value = dict["Dotnet"] as? String {
                self.dotnet = value
            }
            if let value = dict["EdasContainerVersion"] as? String {
                self.edasContainerVersion = value
            }
            if let value = dict["EmptyDirDesc"] as? [Any?] {
                var tmp : [DescribeApplicationConfigResponseBody.Data.EmptyDirDesc] = []
                for v in value {
                    if v != nil {
                        var model = DescribeApplicationConfigResponseBody.Data.EmptyDirDesc()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.emptyDirDesc = tmp
            }
            if let value = dict["EnableAhas"] as? String {
                self.enableAhas = value
            }
            if let value = dict["EnableCpuBurst"] as? String {
                self.enableCpuBurst = value
            }
            if let value = dict["EnableGreyTagRoute"] as? Bool {
                self.enableGreyTagRoute = value
            }
            if let value = dict["EnableIdle"] as? Bool {
                self.enableIdle = value
            }
            if let value = dict["EnableNewArms"] as? Bool {
                self.enableNewArms = value
            }
            if let value = dict["EnablePrometheus"] as? Bool {
                self.enablePrometheus = value
            }
            if let value = dict["Envs"] as? String {
                self.envs = value
            }
            if let value = dict["GpuCount"] as? String {
                self.gpuCount = value
            }
            if let value = dict["GpuType"] as? String {
                self.gpuType = value
            }
            if let value = dict["HeadlessPvtzDiscovery"] as? String {
                self.headlessPvtzDiscovery = value
            }
            if let value = dict["Html"] as? String {
                self.html = value
            }
            if let value = dict["ImagePullSecrets"] as? String {
                self.imagePullSecrets = value
            }
            if let value = dict["ImageUrl"] as? String {
                self.imageUrl = value
            }
            if let value = dict["InitContainersConfig"] as? [Any?] {
                var tmp : [DescribeApplicationConfigResponseBody.Data.InitContainersConfig] = []
                for v in value {
                    if v != nil {
                        var model = DescribeApplicationConfigResponseBody.Data.InitContainersConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.initContainersConfig = tmp
            }
            if let value = dict["IsStateful"] as? Bool {
                self.isStateful = value
            }
            if let value = dict["JarStartArgs"] as? String {
                self.jarStartArgs = value
            }
            if let value = dict["JarStartOptions"] as? String {
                self.jarStartOptions = value
            }
            if let value = dict["Jdk"] as? String {
                self.jdk = value
            }
            if let value = dict["KafkaConfigs"] as? String {
                self.kafkaConfigs = value
            }
            if let value = dict["Liveness"] as? String {
                self.liveness = value
            }
            if let value = dict["Memory"] as? Int32 {
                self.memory = value
            }
            if let value = dict["MicroRegistration"] as? String {
                self.microRegistration = value
            }
            if let value = dict["MicroRegistrationConfig"] as? String {
                self.microRegistrationConfig = value
            }
            if let value = dict["MicroserviceEngineConfig"] as? String {
                self.microserviceEngineConfig = value
            }
            if let value = dict["MinReadyInstanceRatio"] as? Int32 {
                self.minReadyInstanceRatio = value
            }
            if let value = dict["MinReadyInstances"] as? Int32 {
                self.minReadyInstances = value
            }
            if let value = dict["MountDesc"] as? [Any?] {
                var tmp : [DescribeApplicationConfigResponseBody.Data.MountDesc] = []
                for v in value {
                    if v != nil {
                        var model = DescribeApplicationConfigResponseBody.Data.MountDesc()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.mountDesc = tmp
            }
            if let value = dict["MountHost"] as? String {
                self.mountHost = value
            }
            if let value = dict["MseApplicationId"] as? String {
                self.mseApplicationId = value
            }
            if let value = dict["MseApplicationName"] as? String {
                self.mseApplicationName = value
            }
            if let value = dict["NamespaceId"] as? String {
                self.namespaceId = value
            }
            if let value = dict["NasConfigs"] as? String {
                self.nasConfigs = value
            }
            if let value = dict["NasId"] as? String {
                self.nasId = value
            }
            if let value = dict["NewSaeVersion"] as? String {
                self.newSaeVersion = value
            }
            if let value = dict["OidcRoleName"] as? String {
                self.oidcRoleName = value
            }
            if let value = dict["OssAkId"] as? String {
                self.ossAkId = value
            }
            if let value = dict["OssAkSecret"] as? String {
                self.ossAkSecret = value
            }
            if let value = dict["OssMountDescs"] as? [Any?] {
                var tmp : [DescribeApplicationConfigResponseBody.Data.OssMountDescs] = []
                for v in value {
                    if v != nil {
                        var model = DescribeApplicationConfigResponseBody.Data.OssMountDescs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ossMountDescs = tmp
            }
            if let value = dict["PackageType"] as? String {
                self.packageType = value
            }
            if let value = dict["PackageUrl"] as? String {
                self.packageUrl = value
            }
            if let value = dict["PackageVersion"] as? String {
                self.packageVersion = value
            }
            if let value = dict["Php"] as? String {
                self.php = value
            }
            if let value = dict["PhpArmsConfigLocation"] as? String {
                self.phpArmsConfigLocation = value
            }
            if let value = dict["PhpConfig"] as? String {
                self.phpConfig = value
            }
            if let value = dict["PhpConfigLocation"] as? String {
                self.phpConfigLocation = value
            }
            if let value = dict["PostStart"] as? String {
                self.postStart = value
            }
            if let value = dict["PreStop"] as? String {
                self.preStop = value
            }
            if let value = dict["ProgrammingLanguage"] as? String {
                self.programmingLanguage = value
            }
            if let value = dict["PvtzDiscovery"] as? String {
                self.pvtzDiscovery = value
            }
            if let value = dict["Python"] as? String {
                self.python = value
            }
            if let value = dict["PythonModules"] as? String {
                self.pythonModules = value
            }
            if let value = dict["Readiness"] as? String {
                self.readiness = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["Replicas"] as? Int32 {
                self.replicas = value
            }
            if let value = dict["ResourceType"] as? String {
                self.resourceType = value
            }
            if let value = dict["SecretMountDesc"] as? [Any?] {
                var tmp : [DescribeApplicationConfigResponseBody.Data.SecretMountDesc] = []
                for v in value {
                    if v != nil {
                        var model = DescribeApplicationConfigResponseBody.Data.SecretMountDesc()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.secretMountDesc = tmp
            }
            if let value = dict["SecurityGroupId"] as? String {
                self.securityGroupId = value
            }
            if let value = dict["ServiceTags"] as? [String: String] {
                self.serviceTags = value
            }
            if let value = dict["SidecarContainersConfig"] as? [Any?] {
                var tmp : [DescribeApplicationConfigResponseBody.Data.SidecarContainersConfig] = []
                for v in value {
                    if v != nil {
                        var model = DescribeApplicationConfigResponseBody.Data.SidecarContainersConfig()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.sidecarContainersConfig = tmp
            }
            if let value = dict["SlsConfigs"] as? String {
                self.slsConfigs = value
            }
            if let value = dict["StartupProbe"] as? String {
                self.startupProbe = value
            }
            if let value = dict["SwimlanePvtzDiscovery"] as? String {
                self.swimlanePvtzDiscovery = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [DescribeApplicationConfigResponseBody.Data.Tags] = []
                for v in value {
                    if v != nil {
                        var model = DescribeApplicationConfigResponseBody.Data.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["TerminationGracePeriodSeconds"] as? Int32 {
                self.terminationGracePeriodSeconds = value
            }
            if let value = dict["Timezone"] as? String {
                self.timezone = value
            }
            if let value = dict["TomcatConfig"] as? String {
                self.tomcatConfig = value
            }
            if let value = dict["UpdateStrategy"] as? String {
                self.updateStrategy = value
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
            if let value = dict["WarStartOptions"] as? String {
                self.warStartOptions = value
            }
            if let value = dict["WebContainer"] as? String {
                self.webContainer = value
            }
        }
    }
    public var code: String?

    public var data: DescribeApplicationConfigResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeApplicationConfigResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeApplicationConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApplicationConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApplicationGroupsRequest : Tea.TeaModel {
    public var appId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["CurrentPage"] as? Int32 {
            self.currentPage = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class DescribeApplicationGroupsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var edasContainerVersion: String?

        public var groupId: String?

        public var groupName: String?

        public var groupType: Int32?

        public var imageUrl: String?

        public var jdk: String?

        public var packageType: String?

        public var packageUrl: String?

        public var packageVersion: String?

        public var packageVersionId: String?

        public var replicas: Int32?

        public var runningInstances: Int32?

        public var webContainer: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.edasContainerVersion != nil {
                map["EdasContainerVersion"] = self.edasContainerVersion!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.groupType != nil {
                map["GroupType"] = self.groupType!
            }
            if self.imageUrl != nil {
                map["ImageUrl"] = self.imageUrl!
            }
            if self.jdk != nil {
                map["Jdk"] = self.jdk!
            }
            if self.packageType != nil {
                map["PackageType"] = self.packageType!
            }
            if self.packageUrl != nil {
                map["PackageUrl"] = self.packageUrl!
            }
            if self.packageVersion != nil {
                map["PackageVersion"] = self.packageVersion!
            }
            if self.packageVersionId != nil {
                map["PackageVersionId"] = self.packageVersionId!
            }
            if self.replicas != nil {
                map["Replicas"] = self.replicas!
            }
            if self.runningInstances != nil {
                map["RunningInstances"] = self.runningInstances!
            }
            if self.webContainer != nil {
                map["WebContainer"] = self.webContainer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EdasContainerVersion"] as? String {
                self.edasContainerVersion = value
            }
            if let value = dict["GroupId"] as? String {
                self.groupId = value
            }
            if let value = dict["GroupName"] as? String {
                self.groupName = value
            }
            if let value = dict["GroupType"] as? Int32 {
                self.groupType = value
            }
            if let value = dict["ImageUrl"] as? String {
                self.imageUrl = value
            }
            if let value = dict["Jdk"] as? String {
                self.jdk = value
            }
            if let value = dict["PackageType"] as? String {
                self.packageType = value
            }
            if let value = dict["PackageUrl"] as? String {
                self.packageUrl = value
            }
            if let value = dict["PackageVersion"] as? String {
                self.packageVersion = value
            }
            if let value = dict["PackageVersionId"] as? String {
                self.packageVersionId = value
            }
            if let value = dict["Replicas"] as? Int32 {
                self.replicas = value
            }
            if let value = dict["RunningInstances"] as? Int32 {
                self.runningInstances = value
            }
            if let value = dict["WebContainer"] as? String {
                self.webContainer = value
            }
        }
    }
    public var code: String?

    public var data: [DescribeApplicationGroupsResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DescribeApplicationGroupsResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DescribeApplicationGroupsResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeApplicationGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApplicationGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApplicationImageRequest : Tea.TeaModel {
    public var appId: String?

    public var imageUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ImageUrl"] as? String {
            self.imageUrl = value
        }
    }
}

public class DescribeApplicationImageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var crUrl: String?

        public var logo: String?

        public var regionId: String?

        public var repoName: String?

        public var repoNamespace: String?

        public var repoOriginType: String?

        public var repoTag: String?

        public var repoType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.crUrl != nil {
                map["CrUrl"] = self.crUrl!
            }
            if self.logo != nil {
                map["Logo"] = self.logo!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.repoName != nil {
                map["RepoName"] = self.repoName!
            }
            if self.repoNamespace != nil {
                map["RepoNamespace"] = self.repoNamespace!
            }
            if self.repoOriginType != nil {
                map["RepoOriginType"] = self.repoOriginType!
            }
            if self.repoTag != nil {
                map["RepoTag"] = self.repoTag!
            }
            if self.repoType != nil {
                map["RepoType"] = self.repoType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CrUrl"] as? String {
                self.crUrl = value
            }
            if let value = dict["Logo"] as? String {
                self.logo = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["RepoName"] as? String {
                self.repoName = value
            }
            if let value = dict["RepoNamespace"] as? String {
                self.repoNamespace = value
            }
            if let value = dict["RepoOriginType"] as? String {
                self.repoOriginType = value
            }
            if let value = dict["RepoTag"] as? String {
                self.repoTag = value
            }
            if let value = dict["RepoType"] as? String {
                self.repoType = value
            }
        }
    }
    public var code: String?

    public var data: DescribeApplicationImageResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeApplicationImageResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeApplicationImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApplicationImageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApplicationInstancesRequest : Tea.TeaModel {
    public var appId: String?

    public var currentPage: Int32?

    public var groupId: String?

    public var instanceId: String?

    public var pageSize: Int32?

    public var pipelineId: String?

    public var reverse: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        if self.reverse != nil {
            map["Reverse"] = self.reverse!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["CurrentPage"] as? Int32 {
            self.currentPage = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PipelineId"] as? String {
            self.pipelineId = value
        }
        if let value = dict["Reverse"] as? Bool {
            self.reverse = value
        }
    }
}

public class DescribeApplicationInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Instances : Tea.TeaModel {
            public class SidecarContainersStatus : Tea.TeaModel {
                public var containerId: String?

                public var containerStatus: String?

                public var imageUrl: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.containerId != nil {
                        map["ContainerId"] = self.containerId!
                    }
                    if self.containerStatus != nil {
                        map["ContainerStatus"] = self.containerStatus!
                    }
                    if self.imageUrl != nil {
                        map["ImageUrl"] = self.imageUrl!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ContainerId"] as? String {
                        self.containerId = value
                    }
                    if let value = dict["ContainerStatus"] as? String {
                        self.containerStatus = value
                    }
                    if let value = dict["ImageUrl"] as? String {
                        self.imageUrl = value
                    }
                }
            }
            public var createTimeStamp: Int64?

            public var debugStatus: Bool?

            public var eip: String?

            public var finishTimeStamp: Int64?

            public var groupId: String?

            public var imageUrl: String?

            public var instanceContainerIp: String?

            public var instanceContainerRestarts: Int64?

            public var instanceContainerStatus: String?

            public var instanceHealthStatus: String?

            public var instanceId: String?

            public var mainContainerStatus: String?

            public var packageVersion: String?

            public var sidecarContainersStatus: [DescribeApplicationInstancesResponseBody.Data.Instances.SidecarContainersStatus]?

            public var timestamp: Int64?

            public var unhealthyMessage: String?

            public var vSwitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTimeStamp != nil {
                    map["CreateTimeStamp"] = self.createTimeStamp!
                }
                if self.debugStatus != nil {
                    map["DebugStatus"] = self.debugStatus!
                }
                if self.eip != nil {
                    map["Eip"] = self.eip!
                }
                if self.finishTimeStamp != nil {
                    map["FinishTimeStamp"] = self.finishTimeStamp!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.imageUrl != nil {
                    map["ImageUrl"] = self.imageUrl!
                }
                if self.instanceContainerIp != nil {
                    map["InstanceContainerIp"] = self.instanceContainerIp!
                }
                if self.instanceContainerRestarts != nil {
                    map["InstanceContainerRestarts"] = self.instanceContainerRestarts!
                }
                if self.instanceContainerStatus != nil {
                    map["InstanceContainerStatus"] = self.instanceContainerStatus!
                }
                if self.instanceHealthStatus != nil {
                    map["InstanceHealthStatus"] = self.instanceHealthStatus!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.mainContainerStatus != nil {
                    map["MainContainerStatus"] = self.mainContainerStatus!
                }
                if self.packageVersion != nil {
                    map["PackageVersion"] = self.packageVersion!
                }
                if self.sidecarContainersStatus != nil {
                    var tmp : [Any] = []
                    for k in self.sidecarContainersStatus! {
                        tmp.append(k.toMap())
                    }
                    map["SidecarContainersStatus"] = tmp
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.unhealthyMessage != nil {
                    map["UnhealthyMessage"] = self.unhealthyMessage!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTimeStamp"] as? Int64 {
                    self.createTimeStamp = value
                }
                if let value = dict["DebugStatus"] as? Bool {
                    self.debugStatus = value
                }
                if let value = dict["Eip"] as? String {
                    self.eip = value
                }
                if let value = dict["FinishTimeStamp"] as? Int64 {
                    self.finishTimeStamp = value
                }
                if let value = dict["GroupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["ImageUrl"] as? String {
                    self.imageUrl = value
                }
                if let value = dict["InstanceContainerIp"] as? String {
                    self.instanceContainerIp = value
                }
                if let value = dict["InstanceContainerRestarts"] as? Int64 {
                    self.instanceContainerRestarts = value
                }
                if let value = dict["InstanceContainerStatus"] as? String {
                    self.instanceContainerStatus = value
                }
                if let value = dict["InstanceHealthStatus"] as? String {
                    self.instanceHealthStatus = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["MainContainerStatus"] as? String {
                    self.mainContainerStatus = value
                }
                if let value = dict["PackageVersion"] as? String {
                    self.packageVersion = value
                }
                if let value = dict["SidecarContainersStatus"] as? [Any?] {
                    var tmp : [DescribeApplicationInstancesResponseBody.Data.Instances.SidecarContainersStatus] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeApplicationInstancesResponseBody.Data.Instances.SidecarContainersStatus()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.sidecarContainersStatus = tmp
                }
                if let value = dict["Timestamp"] as? Int64 {
                    self.timestamp = value
                }
                if let value = dict["UnhealthyMessage"] as? String {
                    self.unhealthyMessage = value
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
            }
        }
        public var currentPage: Int32?

        public var instances: [DescribeApplicationInstancesResponseBody.Data.Instances]?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.instances != nil {
                var tmp : [Any] = []
                for k in self.instances! {
                    tmp.append(k.toMap())
                }
                map["Instances"] = tmp
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CurrentPage"] as? Int32 {
                self.currentPage = value
            }
            if let value = dict["Instances"] as? [Any?] {
                var tmp : [DescribeApplicationInstancesResponseBody.Data.Instances] = []
                for v in value {
                    if v != nil {
                        var model = DescribeApplicationInstancesResponseBody.Data.Instances()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.instances = tmp
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalSize"] as? Int32 {
                self.totalSize = value
            }
        }
    }
    public var code: String?

    public var data: DescribeApplicationInstancesResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeApplicationInstancesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeApplicationInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApplicationInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApplicationMseServiceRequest : Tea.TeaModel {
    public var appId: String?

    public var enableAhas: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.enableAhas != nil {
            map["EnableAhas"] = self.enableAhas!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["EnableAhas"] as? Bool {
            self.enableAhas = value
        }
    }
}

public class DescribeApplicationMseServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var mseAppId: String?

        public var mseAppName: String?

        public var mseAppNameSpace: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mseAppId != nil {
                map["MseAppId"] = self.mseAppId!
            }
            if self.mseAppName != nil {
                map["MseAppName"] = self.mseAppName!
            }
            if self.mseAppNameSpace != nil {
                map["MseAppNameSpace"] = self.mseAppNameSpace!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MseAppId"] as? String {
                self.mseAppId = value
            }
            if let value = dict["MseAppName"] as? String {
                self.mseAppName = value
            }
            if let value = dict["MseAppNameSpace"] as? String {
                self.mseAppNameSpace = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var code: String?

    public var data: DescribeApplicationMseServiceResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeApplicationMseServiceResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeApplicationMseServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationMseServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApplicationMseServiceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApplicationNlbsRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class DescribeApplicationNlbsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var instances: [String: DataInstancesValue]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instances != nil {
                var tmp : [String: Any] = [:]
                for (k, v) in self.instances! {
                    tmp[k] = v.toMap()
                }
                map["Instances"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Instances"] as? [String: Any?] {
                var tmp : [String: DataInstancesValue] = [:]
                for (k, v) in value {
                    if v != nil {
                        var model = DataInstancesValue()
                        model.fromMap(v as? [String: Any?])
                        tmp[k] = model
                    }
                }
                self.instances = tmp
            }
        }
    }
    public var code: String?

    public var data: DescribeApplicationNlbsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeApplicationNlbsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeApplicationNlbsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationNlbsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApplicationNlbsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var scalingRuleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ScalingRuleName"] as? String {
            self.scalingRuleName = value
        }
    }
}

public class DescribeApplicationScalingRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Metric : Tea.TeaModel {
            public class Metrics : Tea.TeaModel {
                public var metricTargetAverageUtilization: Int32?

                public var metricType: String?

                public var slbId: String?

                public var slbLogstore: String?

                public var slbProject: String?

                public var vport: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricTargetAverageUtilization != nil {
                        map["MetricTargetAverageUtilization"] = self.metricTargetAverageUtilization!
                    }
                    if self.metricType != nil {
                        map["MetricType"] = self.metricType!
                    }
                    if self.slbId != nil {
                        map["SlbId"] = self.slbId!
                    }
                    if self.slbLogstore != nil {
                        map["SlbLogstore"] = self.slbLogstore!
                    }
                    if self.slbProject != nil {
                        map["SlbProject"] = self.slbProject!
                    }
                    if self.vport != nil {
                        map["Vport"] = self.vport!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MetricTargetAverageUtilization"] as? Int32 {
                        self.metricTargetAverageUtilization = value
                    }
                    if let value = dict["MetricType"] as? String {
                        self.metricType = value
                    }
                    if let value = dict["SlbId"] as? String {
                        self.slbId = value
                    }
                    if let value = dict["SlbLogstore"] as? String {
                        self.slbLogstore = value
                    }
                    if let value = dict["SlbProject"] as? String {
                        self.slbProject = value
                    }
                    if let value = dict["Vport"] as? String {
                        self.vport = value
                    }
                }
            }
            public class MetricsStatus : Tea.TeaModel {
                public class CurrentMetrics : Tea.TeaModel {
                    public var currentValue: Int64?

                    public var name: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.currentValue != nil {
                            map["CurrentValue"] = self.currentValue!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["CurrentValue"] as? Int64 {
                            self.currentValue = value
                        }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                        if let value = dict["Type"] as? String {
                            self.type = value
                        }
                    }
                }
                public class NextScaleMetrics : Tea.TeaModel {
                    public var name: String?

                    public var nextScaleInAverageUtilization: Int32?

                    public var nextScaleOutAverageUtilization: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.nextScaleInAverageUtilization != nil {
                            map["NextScaleInAverageUtilization"] = self.nextScaleInAverageUtilization!
                        }
                        if self.nextScaleOutAverageUtilization != nil {
                            map["NextScaleOutAverageUtilization"] = self.nextScaleOutAverageUtilization!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Name"] as? String {
                            self.name = value
                        }
                        if let value = dict["NextScaleInAverageUtilization"] as? Int32 {
                            self.nextScaleInAverageUtilization = value
                        }
                        if let value = dict["NextScaleOutAverageUtilization"] as? Int32 {
                            self.nextScaleOutAverageUtilization = value
                        }
                    }
                }
                public var currentMetrics: [DescribeApplicationScalingRuleResponseBody.Data.Metric.MetricsStatus.CurrentMetrics]?

                public var currentReplicas: Int64?

                public var desiredReplicas: Int64?

                public var lastScaleTime: String?

                public var nextScaleMetrics: [DescribeApplicationScalingRuleResponseBody.Data.Metric.MetricsStatus.NextScaleMetrics]?

                public var nextScaleTimePeriod: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.currentMetrics != nil {
                        var tmp : [Any] = []
                        for k in self.currentMetrics! {
                            tmp.append(k.toMap())
                        }
                        map["CurrentMetrics"] = tmp
                    }
                    if self.currentReplicas != nil {
                        map["CurrentReplicas"] = self.currentReplicas!
                    }
                    if self.desiredReplicas != nil {
                        map["DesiredReplicas"] = self.desiredReplicas!
                    }
                    if self.lastScaleTime != nil {
                        map["LastScaleTime"] = self.lastScaleTime!
                    }
                    if self.nextScaleMetrics != nil {
                        var tmp : [Any] = []
                        for k in self.nextScaleMetrics! {
                            tmp.append(k.toMap())
                        }
                        map["NextScaleMetrics"] = tmp
                    }
                    if self.nextScaleTimePeriod != nil {
                        map["NextScaleTimePeriod"] = self.nextScaleTimePeriod!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["CurrentMetrics"] as? [Any?] {
                        var tmp : [DescribeApplicationScalingRuleResponseBody.Data.Metric.MetricsStatus.CurrentMetrics] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeApplicationScalingRuleResponseBody.Data.Metric.MetricsStatus.CurrentMetrics()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.currentMetrics = tmp
                    }
                    if let value = dict["CurrentReplicas"] as? Int64 {
                        self.currentReplicas = value
                    }
                    if let value = dict["DesiredReplicas"] as? Int64 {
                        self.desiredReplicas = value
                    }
                    if let value = dict["LastScaleTime"] as? String {
                        self.lastScaleTime = value
                    }
                    if let value = dict["NextScaleMetrics"] as? [Any?] {
                        var tmp : [DescribeApplicationScalingRuleResponseBody.Data.Metric.MetricsStatus.NextScaleMetrics] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeApplicationScalingRuleResponseBody.Data.Metric.MetricsStatus.NextScaleMetrics()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.nextScaleMetrics = tmp
                    }
                    if let value = dict["NextScaleTimePeriod"] as? Int32 {
                        self.nextScaleTimePeriod = value
                    }
                }
            }
            public class ScaleDownRules : Tea.TeaModel {
                public var disabled: Bool?

                public var stabilizationWindowSeconds: Int64?

                public var step: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.disabled != nil {
                        map["Disabled"] = self.disabled!
                    }
                    if self.stabilizationWindowSeconds != nil {
                        map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                    }
                    if self.step != nil {
                        map["Step"] = self.step!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Disabled"] as? Bool {
                        self.disabled = value
                    }
                    if let value = dict["StabilizationWindowSeconds"] as? Int64 {
                        self.stabilizationWindowSeconds = value
                    }
                    if let value = dict["Step"] as? Int64 {
                        self.step = value
                    }
                }
            }
            public class ScaleUpRules : Tea.TeaModel {
                public var disabled: Bool?

                public var stabilizationWindowSeconds: Int64?

                public var step: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.disabled != nil {
                        map["Disabled"] = self.disabled!
                    }
                    if self.stabilizationWindowSeconds != nil {
                        map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                    }
                    if self.step != nil {
                        map["Step"] = self.step!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Disabled"] as? Bool {
                        self.disabled = value
                    }
                    if let value = dict["StabilizationWindowSeconds"] as? Int64 {
                        self.stabilizationWindowSeconds = value
                    }
                    if let value = dict["Step"] as? Int64 {
                        self.step = value
                    }
                }
            }
            public var maxReplicas: Int32?

            public var metrics: [DescribeApplicationScalingRuleResponseBody.Data.Metric.Metrics]?

            public var metricsStatus: DescribeApplicationScalingRuleResponseBody.Data.Metric.MetricsStatus?

            public var minReplicas: Int32?

            public var scaleDownRules: DescribeApplicationScalingRuleResponseBody.Data.Metric.ScaleDownRules?

            public var scaleUpRules: DescribeApplicationScalingRuleResponseBody.Data.Metric.ScaleUpRules?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.metricsStatus?.validate()
                try self.scaleDownRules?.validate()
                try self.scaleUpRules?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.metrics != nil {
                    var tmp : [Any] = []
                    for k in self.metrics! {
                        tmp.append(k.toMap())
                    }
                    map["Metrics"] = tmp
                }
                if self.metricsStatus != nil {
                    map["MetricsStatus"] = self.metricsStatus?.toMap()
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                if self.scaleDownRules != nil {
                    map["ScaleDownRules"] = self.scaleDownRules?.toMap()
                }
                if self.scaleUpRules != nil {
                    map["ScaleUpRules"] = self.scaleUpRules?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MaxReplicas"] as? Int32 {
                    self.maxReplicas = value
                }
                if let value = dict["Metrics"] as? [Any?] {
                    var tmp : [DescribeApplicationScalingRuleResponseBody.Data.Metric.Metrics] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeApplicationScalingRuleResponseBody.Data.Metric.Metrics()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.metrics = tmp
                }
                if let value = dict["MetricsStatus"] as? [String: Any?] {
                    var model = DescribeApplicationScalingRuleResponseBody.Data.Metric.MetricsStatus()
                    model.fromMap(value)
                    self.metricsStatus = model
                }
                if let value = dict["MinReplicas"] as? Int32 {
                    self.minReplicas = value
                }
                if let value = dict["ScaleDownRules"] as? [String: Any?] {
                    var model = DescribeApplicationScalingRuleResponseBody.Data.Metric.ScaleDownRules()
                    model.fromMap(value)
                    self.scaleDownRules = model
                }
                if let value = dict["ScaleUpRules"] as? [String: Any?] {
                    var model = DescribeApplicationScalingRuleResponseBody.Data.Metric.ScaleUpRules()
                    model.fromMap(value)
                    self.scaleUpRules = model
                }
            }
        }
        public class Timer : Tea.TeaModel {
            public class Schedules : Tea.TeaModel {
                public var atTime: String?

                public var maxReplicas: Int32?

                public var minReplicas: Int32?

                public var targetReplicas: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.atTime != nil {
                        map["AtTime"] = self.atTime!
                    }
                    if self.maxReplicas != nil {
                        map["MaxReplicas"] = self.maxReplicas!
                    }
                    if self.minReplicas != nil {
                        map["MinReplicas"] = self.minReplicas!
                    }
                    if self.targetReplicas != nil {
                        map["TargetReplicas"] = self.targetReplicas!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AtTime"] as? String {
                        self.atTime = value
                    }
                    if let value = dict["MaxReplicas"] as? Int32 {
                        self.maxReplicas = value
                    }
                    if let value = dict["MinReplicas"] as? Int32 {
                        self.minReplicas = value
                    }
                    if let value = dict["TargetReplicas"] as? Int32 {
                        self.targetReplicas = value
                    }
                }
            }
            public var beginDate: String?

            public var endDate: String?

            public var period: String?

            public var schedules: [DescribeApplicationScalingRuleResponseBody.Data.Timer.Schedules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.beginDate != nil {
                    map["BeginDate"] = self.beginDate!
                }
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.schedules != nil {
                    var tmp : [Any] = []
                    for k in self.schedules! {
                        tmp.append(k.toMap())
                    }
                    map["Schedules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BeginDate"] as? String {
                    self.beginDate = value
                }
                if let value = dict["EndDate"] as? String {
                    self.endDate = value
                }
                if let value = dict["Period"] as? String {
                    self.period = value
                }
                if let value = dict["Schedules"] as? [Any?] {
                    var tmp : [DescribeApplicationScalingRuleResponseBody.Data.Timer.Schedules] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeApplicationScalingRuleResponseBody.Data.Timer.Schedules()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.schedules = tmp
                }
            }
        }
        public var appId: String?

        public var createTime: Int64?

        public var lastDisableTime: Int64?

        public var metric: DescribeApplicationScalingRuleResponseBody.Data.Metric?

        public var minReadyInstanceRatio: Int32?

        public var minReadyInstances: Int32?

        public var scaleRuleEnabled: Bool?

        public var scaleRuleName: String?

        public var scaleRuleType: String?

        public var timer: DescribeApplicationScalingRuleResponseBody.Data.Timer?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metric?.validate()
            try self.timer?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.lastDisableTime != nil {
                map["LastDisableTime"] = self.lastDisableTime!
            }
            if self.metric != nil {
                map["Metric"] = self.metric?.toMap()
            }
            if self.minReadyInstanceRatio != nil {
                map["MinReadyInstanceRatio"] = self.minReadyInstanceRatio!
            }
            if self.minReadyInstances != nil {
                map["MinReadyInstances"] = self.minReadyInstances!
            }
            if self.scaleRuleEnabled != nil {
                map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
            }
            if self.scaleRuleName != nil {
                map["ScaleRuleName"] = self.scaleRuleName!
            }
            if self.scaleRuleType != nil {
                map["ScaleRuleType"] = self.scaleRuleType!
            }
            if self.timer != nil {
                map["Timer"] = self.timer?.toMap()
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["LastDisableTime"] as? Int64 {
                self.lastDisableTime = value
            }
            if let value = dict["Metric"] as? [String: Any?] {
                var model = DescribeApplicationScalingRuleResponseBody.Data.Metric()
                model.fromMap(value)
                self.metric = model
            }
            if let value = dict["MinReadyInstanceRatio"] as? Int32 {
                self.minReadyInstanceRatio = value
            }
            if let value = dict["MinReadyInstances"] as? Int32 {
                self.minReadyInstances = value
            }
            if let value = dict["ScaleRuleEnabled"] as? Bool {
                self.scaleRuleEnabled = value
            }
            if let value = dict["ScaleRuleName"] as? String {
                self.scaleRuleName = value
            }
            if let value = dict["ScaleRuleType"] as? String {
                self.scaleRuleType = value
            }
            if let value = dict["Timer"] as? [String: Any?] {
                var model = DescribeApplicationScalingRuleResponseBody.Data.Timer()
                model.fromMap(value)
                self.timer = model
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var code: String?

    public var data: DescribeApplicationScalingRuleResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeApplicationScalingRuleResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApplicationScalingRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApplicationScalingRulesRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class DescribeApplicationScalingRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ApplicationScalingRules : Tea.TeaModel {
            public class Metric : Tea.TeaModel {
                public class Metrics : Tea.TeaModel {
                    public var metricTargetAverageUtilization: Int32?

                    public var metricType: String?

                    public var slbId: String?

                    public var slbLogstore: String?

                    public var slbProject: String?

                    public var vport: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.metricTargetAverageUtilization != nil {
                            map["MetricTargetAverageUtilization"] = self.metricTargetAverageUtilization!
                        }
                        if self.metricType != nil {
                            map["MetricType"] = self.metricType!
                        }
                        if self.slbId != nil {
                            map["SlbId"] = self.slbId!
                        }
                        if self.slbLogstore != nil {
                            map["SlbLogstore"] = self.slbLogstore!
                        }
                        if self.slbProject != nil {
                            map["SlbProject"] = self.slbProject!
                        }
                        if self.vport != nil {
                            map["Vport"] = self.vport!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["MetricTargetAverageUtilization"] as? Int32 {
                            self.metricTargetAverageUtilization = value
                        }
                        if let value = dict["MetricType"] as? String {
                            self.metricType = value
                        }
                        if let value = dict["SlbId"] as? String {
                            self.slbId = value
                        }
                        if let value = dict["SlbLogstore"] as? String {
                            self.slbLogstore = value
                        }
                        if let value = dict["SlbProject"] as? String {
                            self.slbProject = value
                        }
                        if let value = dict["Vport"] as? String {
                            self.vport = value
                        }
                    }
                }
                public class MetricsStatus : Tea.TeaModel {
                    public class CurrentMetrics : Tea.TeaModel {
                        public var currentValue: Int64?

                        public var name: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.currentValue != nil {
                                map["CurrentValue"] = self.currentValue!
                            }
                            if self.name != nil {
                                map["Name"] = self.name!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["CurrentValue"] as? Int64 {
                                self.currentValue = value
                            }
                            if let value = dict["Name"] as? String {
                                self.name = value
                            }
                            if let value = dict["Type"] as? String {
                                self.type = value
                            }
                        }
                    }
                    public class NextScaleMetrics : Tea.TeaModel {
                        public var name: String?

                        public var nextScaleInAverageUtilization: Int32?

                        public var nextScaleOutAverageUtilization: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.name != nil {
                                map["Name"] = self.name!
                            }
                            if self.nextScaleInAverageUtilization != nil {
                                map["NextScaleInAverageUtilization"] = self.nextScaleInAverageUtilization!
                            }
                            if self.nextScaleOutAverageUtilization != nil {
                                map["NextScaleOutAverageUtilization"] = self.nextScaleOutAverageUtilization!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Name"] as? String {
                                self.name = value
                            }
                            if let value = dict["NextScaleInAverageUtilization"] as? Int32 {
                                self.nextScaleInAverageUtilization = value
                            }
                            if let value = dict["NextScaleOutAverageUtilization"] as? Int32 {
                                self.nextScaleOutAverageUtilization = value
                            }
                        }
                    }
                    public var currentMetrics: [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.MetricsStatus.CurrentMetrics]?

                    public var currentReplicas: Int64?

                    public var desiredReplicas: Int64?

                    public var lastScaleTime: String?

                    public var maxReplicas: Int64?

                    public var minReplicas: Int64?

                    public var nextScaleMetrics: [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.MetricsStatus.NextScaleMetrics]?

                    public var nextScaleTimePeriod: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.currentMetrics != nil {
                            var tmp : [Any] = []
                            for k in self.currentMetrics! {
                                tmp.append(k.toMap())
                            }
                            map["CurrentMetrics"] = tmp
                        }
                        if self.currentReplicas != nil {
                            map["CurrentReplicas"] = self.currentReplicas!
                        }
                        if self.desiredReplicas != nil {
                            map["DesiredReplicas"] = self.desiredReplicas!
                        }
                        if self.lastScaleTime != nil {
                            map["LastScaleTime"] = self.lastScaleTime!
                        }
                        if self.maxReplicas != nil {
                            map["MaxReplicas"] = self.maxReplicas!
                        }
                        if self.minReplicas != nil {
                            map["MinReplicas"] = self.minReplicas!
                        }
                        if self.nextScaleMetrics != nil {
                            var tmp : [Any] = []
                            for k in self.nextScaleMetrics! {
                                tmp.append(k.toMap())
                            }
                            map["NextScaleMetrics"] = tmp
                        }
                        if self.nextScaleTimePeriod != nil {
                            map["NextScaleTimePeriod"] = self.nextScaleTimePeriod!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["CurrentMetrics"] as? [Any?] {
                            var tmp : [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.MetricsStatus.CurrentMetrics] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.MetricsStatus.CurrentMetrics()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.currentMetrics = tmp
                        }
                        if let value = dict["CurrentReplicas"] as? Int64 {
                            self.currentReplicas = value
                        }
                        if let value = dict["DesiredReplicas"] as? Int64 {
                            self.desiredReplicas = value
                        }
                        if let value = dict["LastScaleTime"] as? String {
                            self.lastScaleTime = value
                        }
                        if let value = dict["MaxReplicas"] as? Int64 {
                            self.maxReplicas = value
                        }
                        if let value = dict["MinReplicas"] as? Int64 {
                            self.minReplicas = value
                        }
                        if let value = dict["NextScaleMetrics"] as? [Any?] {
                            var tmp : [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.MetricsStatus.NextScaleMetrics] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.MetricsStatus.NextScaleMetrics()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.nextScaleMetrics = tmp
                        }
                        if let value = dict["NextScaleTimePeriod"] as? Int32 {
                            self.nextScaleTimePeriod = value
                        }
                    }
                }
                public class PrometheusMetrics : Tea.TeaModel {
                    public var prometheusQuery: String?

                    public var targetMetricValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.prometheusQuery != nil {
                            map["PrometheusQuery"] = self.prometheusQuery!
                        }
                        if self.targetMetricValue != nil {
                            map["TargetMetricValue"] = self.targetMetricValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["PrometheusQuery"] as? String {
                            self.prometheusQuery = value
                        }
                        if let value = dict["TargetMetricValue"] as? String {
                            self.targetMetricValue = value
                        }
                    }
                }
                public class ScaleDownRules : Tea.TeaModel {
                    public var disabled: Bool?

                    public var stabilizationWindowSeconds: Int64?

                    public var step: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.disabled != nil {
                            map["Disabled"] = self.disabled!
                        }
                        if self.stabilizationWindowSeconds != nil {
                            map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                        }
                        if self.step != nil {
                            map["Step"] = self.step!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Disabled"] as? Bool {
                            self.disabled = value
                        }
                        if let value = dict["StabilizationWindowSeconds"] as? Int64 {
                            self.stabilizationWindowSeconds = value
                        }
                        if let value = dict["Step"] as? Int64 {
                            self.step = value
                        }
                    }
                }
                public class ScaleUpRules : Tea.TeaModel {
                    public var disabled: Bool?

                    public var stabilizationWindowSeconds: Int64?

                    public var step: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.disabled != nil {
                            map["Disabled"] = self.disabled!
                        }
                        if self.stabilizationWindowSeconds != nil {
                            map["StabilizationWindowSeconds"] = self.stabilizationWindowSeconds!
                        }
                        if self.step != nil {
                            map["Step"] = self.step!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Disabled"] as? Bool {
                            self.disabled = value
                        }
                        if let value = dict["StabilizationWindowSeconds"] as? Int64 {
                            self.stabilizationWindowSeconds = value
                        }
                        if let value = dict["Step"] as? Int64 {
                            self.step = value
                        }
                    }
                }
                public var maxReplicas: Int32?

                public var metricSource: String?

                public var metrics: [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.Metrics]?

                public var metricsStatus: DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.MetricsStatus?

                public var minReplicas: Int32?

                public var prometheusMetrics: [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.PrometheusMetrics]?

                public var prometheusToken: String?

                public var prometheusUrl: String?

                public var scaleDownRules: DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.ScaleDownRules?

                public var scaleUpRules: DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.ScaleUpRules?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.metricsStatus?.validate()
                    try self.scaleDownRules?.validate()
                    try self.scaleUpRules?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxReplicas != nil {
                        map["MaxReplicas"] = self.maxReplicas!
                    }
                    if self.metricSource != nil {
                        map["MetricSource"] = self.metricSource!
                    }
                    if self.metrics != nil {
                        var tmp : [Any] = []
                        for k in self.metrics! {
                            tmp.append(k.toMap())
                        }
                        map["Metrics"] = tmp
                    }
                    if self.metricsStatus != nil {
                        map["MetricsStatus"] = self.metricsStatus?.toMap()
                    }
                    if self.minReplicas != nil {
                        map["MinReplicas"] = self.minReplicas!
                    }
                    if self.prometheusMetrics != nil {
                        var tmp : [Any] = []
                        for k in self.prometheusMetrics! {
                            tmp.append(k.toMap())
                        }
                        map["PrometheusMetrics"] = tmp
                    }
                    if self.prometheusToken != nil {
                        map["PrometheusToken"] = self.prometheusToken!
                    }
                    if self.prometheusUrl != nil {
                        map["PrometheusUrl"] = self.prometheusUrl!
                    }
                    if self.scaleDownRules != nil {
                        map["ScaleDownRules"] = self.scaleDownRules?.toMap()
                    }
                    if self.scaleUpRules != nil {
                        map["ScaleUpRules"] = self.scaleUpRules?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MaxReplicas"] as? Int32 {
                        self.maxReplicas = value
                    }
                    if let value = dict["MetricSource"] as? String {
                        self.metricSource = value
                    }
                    if let value = dict["Metrics"] as? [Any?] {
                        var tmp : [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.Metrics] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.Metrics()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.metrics = tmp
                    }
                    if let value = dict["MetricsStatus"] as? [String: Any?] {
                        var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.MetricsStatus()
                        model.fromMap(value)
                        self.metricsStatus = model
                    }
                    if let value = dict["MinReplicas"] as? Int32 {
                        self.minReplicas = value
                    }
                    if let value = dict["PrometheusMetrics"] as? [Any?] {
                        var tmp : [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.PrometheusMetrics] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.PrometheusMetrics()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.prometheusMetrics = tmp
                    }
                    if let value = dict["PrometheusToken"] as? String {
                        self.prometheusToken = value
                    }
                    if let value = dict["PrometheusUrl"] as? String {
                        self.prometheusUrl = value
                    }
                    if let value = dict["ScaleDownRules"] as? [String: Any?] {
                        var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.ScaleDownRules()
                        model.fromMap(value)
                        self.scaleDownRules = model
                    }
                    if let value = dict["ScaleUpRules"] as? [String: Any?] {
                        var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric.ScaleUpRules()
                        model.fromMap(value)
                        self.scaleUpRules = model
                    }
                }
            }
            public class Timer : Tea.TeaModel {
                public class Schedules : Tea.TeaModel {
                    public var atTime: String?

                    public var maxReplicas: Int64?

                    public var minReplicas: Int64?

                    public var targetReplicas: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.atTime != nil {
                            map["AtTime"] = self.atTime!
                        }
                        if self.maxReplicas != nil {
                            map["MaxReplicas"] = self.maxReplicas!
                        }
                        if self.minReplicas != nil {
                            map["MinReplicas"] = self.minReplicas!
                        }
                        if self.targetReplicas != nil {
                            map["TargetReplicas"] = self.targetReplicas!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AtTime"] as? String {
                            self.atTime = value
                        }
                        if let value = dict["MaxReplicas"] as? Int64 {
                            self.maxReplicas = value
                        }
                        if let value = dict["MinReplicas"] as? Int64 {
                            self.minReplicas = value
                        }
                        if let value = dict["TargetReplicas"] as? Int32 {
                            self.targetReplicas = value
                        }
                    }
                }
                public var beginDate: String?

                public var endDate: String?

                public var period: String?

                public var schedules: [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Timer.Schedules]?

                public var timeZone: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.beginDate != nil {
                        map["BeginDate"] = self.beginDate!
                    }
                    if self.endDate != nil {
                        map["EndDate"] = self.endDate!
                    }
                    if self.period != nil {
                        map["Period"] = self.period!
                    }
                    if self.schedules != nil {
                        var tmp : [Any] = []
                        for k in self.schedules! {
                            tmp.append(k.toMap())
                        }
                        map["Schedules"] = tmp
                    }
                    if self.timeZone != nil {
                        map["TimeZone"] = self.timeZone!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["BeginDate"] as? String {
                        self.beginDate = value
                    }
                    if let value = dict["EndDate"] as? String {
                        self.endDate = value
                    }
                    if let value = dict["Period"] as? String {
                        self.period = value
                    }
                    if let value = dict["Schedules"] as? [Any?] {
                        var tmp : [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Timer.Schedules] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Timer.Schedules()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.schedules = tmp
                    }
                    if let value = dict["TimeZone"] as? String {
                        self.timeZone = value
                    }
                }
            }
            public var appId: String?

            public var createTime: Int64?

            public var lastDisableTime: Int64?

            public var metric: DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric?

            public var minReadyInstanceRatio: Int32?

            public var minReadyInstances: Int32?

            public var scaleRuleEnabled: Bool?

            public var scaleRuleName: String?

            public var scaleRuleType: String?

            public var timer: DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Timer?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.metric?.validate()
                try self.timer?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.lastDisableTime != nil {
                    map["LastDisableTime"] = self.lastDisableTime!
                }
                if self.metric != nil {
                    map["Metric"] = self.metric?.toMap()
                }
                if self.minReadyInstanceRatio != nil {
                    map["MinReadyInstanceRatio"] = self.minReadyInstanceRatio!
                }
                if self.minReadyInstances != nil {
                    map["MinReadyInstances"] = self.minReadyInstances!
                }
                if self.scaleRuleEnabled != nil {
                    map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
                }
                if self.scaleRuleName != nil {
                    map["ScaleRuleName"] = self.scaleRuleName!
                }
                if self.scaleRuleType != nil {
                    map["ScaleRuleType"] = self.scaleRuleType!
                }
                if self.timer != nil {
                    map["Timer"] = self.timer?.toMap()
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["LastDisableTime"] as? Int64 {
                    self.lastDisableTime = value
                }
                if let value = dict["Metric"] as? [String: Any?] {
                    var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Metric()
                    model.fromMap(value)
                    self.metric = model
                }
                if let value = dict["MinReadyInstanceRatio"] as? Int32 {
                    self.minReadyInstanceRatio = value
                }
                if let value = dict["MinReadyInstances"] as? Int32 {
                    self.minReadyInstances = value
                }
                if let value = dict["ScaleRuleEnabled"] as? Bool {
                    self.scaleRuleEnabled = value
                }
                if let value = dict["ScaleRuleName"] as? String {
                    self.scaleRuleName = value
                }
                if let value = dict["ScaleRuleType"] as? String {
                    self.scaleRuleType = value
                }
                if let value = dict["Timer"] as? [String: Any?] {
                    var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules.Timer()
                    model.fromMap(value)
                    self.timer = model
                }
                if let value = dict["UpdateTime"] as? Int64 {
                    self.updateTime = value
                }
            }
        }
        public var applicationScalingRules: [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules]?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationScalingRules != nil {
                var tmp : [Any] = []
                for k in self.applicationScalingRules! {
                    tmp.append(k.toMap())
                }
                map["ApplicationScalingRules"] = tmp
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApplicationScalingRules"] as? [Any?] {
                var tmp : [DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules] = []
                for v in value {
                    if v != nil {
                        var model = DescribeApplicationScalingRulesResponseBody.Data.ApplicationScalingRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.applicationScalingRules = tmp
            }
            if let value = dict["CurrentPage"] as? Int32 {
                self.currentPage = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalSize"] as? Int32 {
                self.totalSize = value
            }
        }
    }
    public var code: String?

    public var data: DescribeApplicationScalingRulesResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeApplicationScalingRulesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeApplicationScalingRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationScalingRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApplicationScalingRulesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApplicationSlbsRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class DescribeApplicationSlbsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Internet : Tea.TeaModel {
            public var cookie: String?

            public var cookieTimeout: Int32?

            public var createTime: Int64?

            public var httpsCaCertId: String?

            public var httpsCertId: String?

            public var port: Int32?

            public var protocol_: String?

            public var stickySession: Bool?

            public var stickySessionType: String?

            public var targetPort: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cookie != nil {
                    map["Cookie"] = self.cookie!
                }
                if self.cookieTimeout != nil {
                    map["CookieTimeout"] = self.cookieTimeout!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.httpsCaCertId != nil {
                    map["HttpsCaCertId"] = self.httpsCaCertId!
                }
                if self.httpsCertId != nil {
                    map["HttpsCertId"] = self.httpsCertId!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.stickySession != nil {
                    map["StickySession"] = self.stickySession!
                }
                if self.stickySessionType != nil {
                    map["StickySessionType"] = self.stickySessionType!
                }
                if self.targetPort != nil {
                    map["TargetPort"] = self.targetPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cookie"] as? String {
                    self.cookie = value
                }
                if let value = dict["CookieTimeout"] as? Int32 {
                    self.cookieTimeout = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["HttpsCaCertId"] as? String {
                    self.httpsCaCertId = value
                }
                if let value = dict["HttpsCertId"] as? String {
                    self.httpsCertId = value
                }
                if let value = dict["Port"] as? Int32 {
                    self.port = value
                }
                if let value = dict["Protocol"] as? String {
                    self.protocol_ = value
                }
                if let value = dict["StickySession"] as? Bool {
                    self.stickySession = value
                }
                if let value = dict["StickySessionType"] as? String {
                    self.stickySessionType = value
                }
                if let value = dict["TargetPort"] as? Int32 {
                    self.targetPort = value
                }
            }
        }
        public class Intranet : Tea.TeaModel {
            public var cookie: String?

            public var cookieTimeout: Int32?

            public var createTime: Int64?

            public var httpsCaCertId: String?

            public var httpsCertId: String?

            public var port: Int32?

            public var protocol_: String?

            public var stickySession: Bool?

            public var stickySessionType: String?

            public var targetPort: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cookie != nil {
                    map["Cookie"] = self.cookie!
                }
                if self.cookieTimeout != nil {
                    map["CookieTimeout"] = self.cookieTimeout!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.httpsCaCertId != nil {
                    map["HttpsCaCertId"] = self.httpsCaCertId!
                }
                if self.httpsCertId != nil {
                    map["HttpsCertId"] = self.httpsCertId!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.stickySession != nil {
                    map["StickySession"] = self.stickySession!
                }
                if self.stickySessionType != nil {
                    map["StickySessionType"] = self.stickySessionType!
                }
                if self.targetPort != nil {
                    map["TargetPort"] = self.targetPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cookie"] as? String {
                    self.cookie = value
                }
                if let value = dict["CookieTimeout"] as? Int32 {
                    self.cookieTimeout = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["HttpsCaCertId"] as? String {
                    self.httpsCaCertId = value
                }
                if let value = dict["HttpsCertId"] as? String {
                    self.httpsCertId = value
                }
                if let value = dict["Port"] as? Int32 {
                    self.port = value
                }
                if let value = dict["Protocol"] as? String {
                    self.protocol_ = value
                }
                if let value = dict["StickySession"] as? Bool {
                    self.stickySession = value
                }
                if let value = dict["StickySessionType"] as? String {
                    self.stickySessionType = value
                }
                if let value = dict["TargetPort"] as? Int32 {
                    self.targetPort = value
                }
            }
        }
        public var appId: String?

        public var appName: String?

        public var clusterId: String?

        public var internet: [DescribeApplicationSlbsResponseBody.Data.Internet]?

        public var internetIp: String?

        public var internetSlbChargeType: String?

        public var internetSlbExpired: Bool?

        public var internetSlbId: String?

        public var intranet: [DescribeApplicationSlbsResponseBody.Data.Intranet]?

        public var intranetIp: String?

        public var intranetSlbChargeType: String?

        public var intranetSlbExpired: Bool?

        public var intranetSlbId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.internet != nil {
                var tmp : [Any] = []
                for k in self.internet! {
                    tmp.append(k.toMap())
                }
                map["Internet"] = tmp
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.internetSlbChargeType != nil {
                map["InternetSlbChargeType"] = self.internetSlbChargeType!
            }
            if self.internetSlbExpired != nil {
                map["InternetSlbExpired"] = self.internetSlbExpired!
            }
            if self.internetSlbId != nil {
                map["InternetSlbId"] = self.internetSlbId!
            }
            if self.intranet != nil {
                var tmp : [Any] = []
                for k in self.intranet! {
                    tmp.append(k.toMap())
                }
                map["Intranet"] = tmp
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.intranetSlbChargeType != nil {
                map["IntranetSlbChargeType"] = self.intranetSlbChargeType!
            }
            if self.intranetSlbExpired != nil {
                map["IntranetSlbExpired"] = self.intranetSlbExpired!
            }
            if self.intranetSlbId != nil {
                map["IntranetSlbId"] = self.intranetSlbId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["ClusterId"] as? String {
                self.clusterId = value
            }
            if let value = dict["Internet"] as? [Any?] {
                var tmp : [DescribeApplicationSlbsResponseBody.Data.Internet] = []
                for v in value {
                    if v != nil {
                        var model = DescribeApplicationSlbsResponseBody.Data.Internet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.internet = tmp
            }
            if let value = dict["InternetIp"] as? String {
                self.internetIp = value
            }
            if let value = dict["InternetSlbChargeType"] as? String {
                self.internetSlbChargeType = value
            }
            if let value = dict["InternetSlbExpired"] as? Bool {
                self.internetSlbExpired = value
            }
            if let value = dict["InternetSlbId"] as? String {
                self.internetSlbId = value
            }
            if let value = dict["Intranet"] as? [Any?] {
                var tmp : [DescribeApplicationSlbsResponseBody.Data.Intranet] = []
                for v in value {
                    if v != nil {
                        var model = DescribeApplicationSlbsResponseBody.Data.Intranet()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.intranet = tmp
            }
            if let value = dict["IntranetIp"] as? String {
                self.intranetIp = value
            }
            if let value = dict["IntranetSlbChargeType"] as? String {
                self.intranetSlbChargeType = value
            }
            if let value = dict["IntranetSlbExpired"] as? Bool {
                self.intranetSlbExpired = value
            }
            if let value = dict["IntranetSlbId"] as? String {
                self.intranetSlbId = value
            }
        }
    }
    public var code: String?

    public var data: DescribeApplicationSlbsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeApplicationSlbsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeApplicationSlbsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationSlbsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApplicationSlbsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApplicationStatusRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class DescribeApplicationStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var armsAdvancedEnabled: String?

        public var armsApmInfo: String?

        public var createTime: String?

        public var currentStatus: String?

        public var enableAgent: Bool?

        public var fileSizeLimit: Int64?

        public var lastChangeOrderId: String?

        public var lastChangeOrderRunning: Bool?

        public var lastChangeOrderStatus: String?

        public var runningInstances: Int32?

        public var subStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.armsAdvancedEnabled != nil {
                map["ArmsAdvancedEnabled"] = self.armsAdvancedEnabled!
            }
            if self.armsApmInfo != nil {
                map["ArmsApmInfo"] = self.armsApmInfo!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.currentStatus != nil {
                map["CurrentStatus"] = self.currentStatus!
            }
            if self.enableAgent != nil {
                map["EnableAgent"] = self.enableAgent!
            }
            if self.fileSizeLimit != nil {
                map["FileSizeLimit"] = self.fileSizeLimit!
            }
            if self.lastChangeOrderId != nil {
                map["LastChangeOrderId"] = self.lastChangeOrderId!
            }
            if self.lastChangeOrderRunning != nil {
                map["LastChangeOrderRunning"] = self.lastChangeOrderRunning!
            }
            if self.lastChangeOrderStatus != nil {
                map["LastChangeOrderStatus"] = self.lastChangeOrderStatus!
            }
            if self.runningInstances != nil {
                map["RunningInstances"] = self.runningInstances!
            }
            if self.subStatus != nil {
                map["SubStatus"] = self.subStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["ArmsAdvancedEnabled"] as? String {
                self.armsAdvancedEnabled = value
            }
            if let value = dict["ArmsApmInfo"] as? String {
                self.armsApmInfo = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["CurrentStatus"] as? String {
                self.currentStatus = value
            }
            if let value = dict["EnableAgent"] as? Bool {
                self.enableAgent = value
            }
            if let value = dict["FileSizeLimit"] as? Int64 {
                self.fileSizeLimit = value
            }
            if let value = dict["LastChangeOrderId"] as? String {
                self.lastChangeOrderId = value
            }
            if let value = dict["LastChangeOrderRunning"] as? Bool {
                self.lastChangeOrderRunning = value
            }
            if let value = dict["LastChangeOrderStatus"] as? String {
                self.lastChangeOrderStatus = value
            }
            if let value = dict["RunningInstances"] as? Int32 {
                self.runningInstances = value
            }
            if let value = dict["SubStatus"] as? String {
                self.subStatus = value
            }
        }
    }
    public var code: String?

    public var data: DescribeApplicationStatusResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeApplicationStatusResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeApplicationStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApplicationStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeChangeOrderRequest : Tea.TeaModel {
    public var changeOrderId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.changeOrderId != nil {
            map["ChangeOrderId"] = self.changeOrderId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ChangeOrderId"] as? String {
            self.changeOrderId = value
        }
    }
}

public class DescribeChangeOrderResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Pipelines : Tea.TeaModel {
            public var batchType: Int32?

            public var parallelCount: Int32?

            public var pipelineId: String?

            public var pipelineName: String?

            public var startTime: Int64?

            public var status: Int32?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.batchType != nil {
                    map["BatchType"] = self.batchType!
                }
                if self.parallelCount != nil {
                    map["ParallelCount"] = self.parallelCount!
                }
                if self.pipelineId != nil {
                    map["PipelineId"] = self.pipelineId!
                }
                if self.pipelineName != nil {
                    map["PipelineName"] = self.pipelineName!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BatchType"] as? Int32 {
                    self.batchType = value
                }
                if let value = dict["ParallelCount"] as? Int32 {
                    self.parallelCount = value
                }
                if let value = dict["PipelineId"] as? String {
                    self.pipelineId = value
                }
                if let value = dict["PipelineName"] as? String {
                    self.pipelineName = value
                }
                if let value = dict["StartTime"] as? Int64 {
                    self.startTime = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
                if let value = dict["UpdateTime"] as? Int64 {
                    self.updateTime = value
                }
            }
        }
        public var appId: String?

        public var appName: String?

        public var applicationEnableGreyTagRoute: Bool?

        public var applicationUpdateStrategy: String?

        public var approvalId: String?

        public var auto: Bool?

        public var batchCount: Int32?

        public var batchType: String?

        public var batchWaitTime: Int32?

        public var changeOrderId: String?

        public var coType: String?

        public var coTypeCode: String?

        public var createTime: String?

        public var currentPipelineId: String?

        public var description_: String?

        public var errorMessage: String?

        public var pipelines: [DescribeChangeOrderResponseBody.Data.Pipelines]?

        public var status: Int32?

        public var subStatus: Int32?

        public var supportRollback: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.applicationEnableGreyTagRoute != nil {
                map["ApplicationEnableGreyTagRoute"] = self.applicationEnableGreyTagRoute!
            }
            if self.applicationUpdateStrategy != nil {
                map["ApplicationUpdateStrategy"] = self.applicationUpdateStrategy!
            }
            if self.approvalId != nil {
                map["ApprovalId"] = self.approvalId!
            }
            if self.auto != nil {
                map["Auto"] = self.auto!
            }
            if self.batchCount != nil {
                map["BatchCount"] = self.batchCount!
            }
            if self.batchType != nil {
                map["BatchType"] = self.batchType!
            }
            if self.batchWaitTime != nil {
                map["BatchWaitTime"] = self.batchWaitTime!
            }
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            if self.coType != nil {
                map["CoType"] = self.coType!
            }
            if self.coTypeCode != nil {
                map["CoTypeCode"] = self.coTypeCode!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.currentPipelineId != nil {
                map["CurrentPipelineId"] = self.currentPipelineId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.pipelines != nil {
                var tmp : [Any] = []
                for k in self.pipelines! {
                    tmp.append(k.toMap())
                }
                map["Pipelines"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subStatus != nil {
                map["SubStatus"] = self.subStatus!
            }
            if self.supportRollback != nil {
                map["SupportRollback"] = self.supportRollback!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["ApplicationEnableGreyTagRoute"] as? Bool {
                self.applicationEnableGreyTagRoute = value
            }
            if let value = dict["ApplicationUpdateStrategy"] as? String {
                self.applicationUpdateStrategy = value
            }
            if let value = dict["ApprovalId"] as? String {
                self.approvalId = value
            }
            if let value = dict["Auto"] as? Bool {
                self.auto = value
            }
            if let value = dict["BatchCount"] as? Int32 {
                self.batchCount = value
            }
            if let value = dict["BatchType"] as? String {
                self.batchType = value
            }
            if let value = dict["BatchWaitTime"] as? Int32 {
                self.batchWaitTime = value
            }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
            if let value = dict["CoType"] as? String {
                self.coType = value
            }
            if let value = dict["CoTypeCode"] as? String {
                self.coTypeCode = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["CurrentPipelineId"] as? String {
                self.currentPipelineId = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["ErrorMessage"] as? String {
                self.errorMessage = value
            }
            if let value = dict["Pipelines"] as? [Any?] {
                var tmp : [DescribeChangeOrderResponseBody.Data.Pipelines] = []
                for v in value {
                    if v != nil {
                        var model = DescribeChangeOrderResponseBody.Data.Pipelines()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.pipelines = tmp
            }
            if let value = dict["Status"] as? Int32 {
                self.status = value
            }
            if let value = dict["SubStatus"] as? Int32 {
                self.subStatus = value
            }
            if let value = dict["SupportRollback"] as? Bool {
                self.supportRollback = value
            }
        }
    }
    public var code: String?

    public var data: DescribeChangeOrderResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeChangeOrderResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeChangeOrderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeChangeOrderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeChangeOrderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeComponentsRequest : Tea.TeaModel {
    public var appId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DescribeComponentsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var componentDescription: String?

        public var componentKey: String?

        public var expired: Bool?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.componentDescription != nil {
                map["ComponentDescription"] = self.componentDescription!
            }
            if self.componentKey != nil {
                map["ComponentKey"] = self.componentKey!
            }
            if self.expired != nil {
                map["Expired"] = self.expired!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ComponentDescription"] as? String {
                self.componentDescription = value
            }
            if let value = dict["ComponentKey"] as? String {
                self.componentKey = value
            }
            if let value = dict["Expired"] as? Bool {
                self.expired = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var code: String?

    public var data: [DescribeComponentsResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DescribeComponentsResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DescribeComponentsResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeComponentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeComponentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeComponentsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeConfigMapRequest : Tea.TeaModel {
    public var configMapId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configMapId != nil {
            map["ConfigMapId"] = self.configMapId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigMapId"] as? Int64 {
            self.configMapId = value
        }
    }
}

public class DescribeConfigMapResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RelateApps : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
            }
        }
        public var configMapId: Int64?

        public var createTime: Int64?

        public var data: [String: Any]?

        public var description_: String?

        public var name: String?

        public var namespaceId: String?

        public var relateApps: [DescribeConfigMapResponseBody.Data.RelateApps]?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configMapId != nil {
                map["ConfigMapId"] = self.configMapId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.relateApps != nil {
                var tmp : [Any] = []
                for k in self.relateApps! {
                    tmp.append(k.toMap())
                }
                map["RelateApps"] = tmp
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigMapId"] as? Int64 {
                self.configMapId = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Data"] as? [String: Any] {
                self.data = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["NamespaceId"] as? String {
                self.namespaceId = value
            }
            if let value = dict["RelateApps"] as? [Any?] {
                var tmp : [DescribeConfigMapResponseBody.Data.RelateApps] = []
                for v in value {
                    if v != nil {
                        var model = DescribeConfigMapResponseBody.Data.RelateApps()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.relateApps = tmp
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var code: String?

    public var data: DescribeConfigMapResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeConfigMapResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeConfigMapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConfigMapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeConfigMapResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeConfigurationPriceRequest : Tea.TeaModel {
    public var bestEffortType: String?

    public var cpu: Int32?

    public var memory: Int32?

    public var newSaeVersion: String?

    public var resourceType: String?

    public var workload: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bestEffortType != nil {
            map["BestEffortType"] = self.bestEffortType!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.newSaeVersion != nil {
            map["NewSaeVersion"] = self.newSaeVersion!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.workload != nil {
            map["Workload"] = self.workload!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BestEffortType"] as? String {
            self.bestEffortType = value
        }
        if let value = dict["Cpu"] as? Int32 {
            self.cpu = value
        }
        if let value = dict["Memory"] as? Int32 {
            self.memory = value
        }
        if let value = dict["NewSaeVersion"] as? String {
            self.newSaeVersion = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Workload"] as? String {
            self.workload = value
        }
    }
}

public class DescribeConfigurationPriceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class BagUsage : Tea.TeaModel {
            public var cpu: Double?

            public var cu: Double?

            public var mem: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.cu != nil {
                    map["Cu"] = self.cu!
                }
                if self.mem != nil {
                    map["Mem"] = self.mem!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cpu"] as? Double {
                    self.cpu = value
                }
                if let value = dict["Cu"] as? Double {
                    self.cu = value
                }
                if let value = dict["Mem"] as? Double {
                    self.mem = value
                }
            }
        }
        public class CpuMemPrice : Tea.TeaModel {
            public class Order : Tea.TeaModel {
                public var discountAmount: Double?

                public var originalAmount: Double?

                public var ruleIds: [String]?

                public var tradeAmount: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.discountAmount != nil {
                        map["DiscountAmount"] = self.discountAmount!
                    }
                    if self.originalAmount != nil {
                        map["OriginalAmount"] = self.originalAmount!
                    }
                    if self.ruleIds != nil {
                        map["RuleIds"] = self.ruleIds!
                    }
                    if self.tradeAmount != nil {
                        map["TradeAmount"] = self.tradeAmount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DiscountAmount"] as? Double {
                        self.discountAmount = value
                    }
                    if let value = dict["OriginalAmount"] as? Double {
                        self.originalAmount = value
                    }
                    if let value = dict["RuleIds"] as? [String] {
                        self.ruleIds = value
                    }
                    if let value = dict["TradeAmount"] as? Double {
                        self.tradeAmount = value
                    }
                }
            }
            public class Rules : Tea.TeaModel {
                public var name: String?

                public var ruleDescId: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.ruleDescId != nil {
                        map["RuleDescId"] = self.ruleDescId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["RuleDescId"] as? Double {
                        self.ruleDescId = value
                    }
                }
            }
            public var order: DescribeConfigurationPriceResponseBody.Data.CpuMemPrice.Order?

            public var rules: [DescribeConfigurationPriceResponseBody.Data.CpuMemPrice.Rules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.order?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.order != nil {
                    map["Order"] = self.order?.toMap()
                }
                if self.rules != nil {
                    var tmp : [Any] = []
                    for k in self.rules! {
                        tmp.append(k.toMap())
                    }
                    map["Rules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Order"] as? [String: Any?] {
                    var model = DescribeConfigurationPriceResponseBody.Data.CpuMemPrice.Order()
                    model.fromMap(value)
                    self.order = model
                }
                if let value = dict["Rules"] as? [Any?] {
                    var tmp : [DescribeConfigurationPriceResponseBody.Data.CpuMemPrice.Rules] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeConfigurationPriceResponseBody.Data.CpuMemPrice.Rules()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.rules = tmp
                }
            }
        }
        public class Order : Tea.TeaModel {
            public var discountAmount: Double?

            public var originalAmount: Double?

            public var ruleIds: [String]?

            public var tradeAmount: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.discountAmount != nil {
                    map["DiscountAmount"] = self.discountAmount!
                }
                if self.originalAmount != nil {
                    map["OriginalAmount"] = self.originalAmount!
                }
                if self.ruleIds != nil {
                    map["RuleIds"] = self.ruleIds!
                }
                if self.tradeAmount != nil {
                    map["TradeAmount"] = self.tradeAmount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DiscountAmount"] as? Double {
                    self.discountAmount = value
                }
                if let value = dict["OriginalAmount"] as? Double {
                    self.originalAmount = value
                }
                if let value = dict["RuleIds"] as? [String] {
                    self.ruleIds = value
                }
                if let value = dict["TradeAmount"] as? Double {
                    self.tradeAmount = value
                }
            }
        }
        public class RequestPrice : Tea.TeaModel {
            public class Order : Tea.TeaModel {
                public var discountAmount: Double?

                public var originalAmount: Double?

                public var ruleIds: [String]?

                public var tradeAmount: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.discountAmount != nil {
                        map["DiscountAmount"] = self.discountAmount!
                    }
                    if self.originalAmount != nil {
                        map["OriginalAmount"] = self.originalAmount!
                    }
                    if self.ruleIds != nil {
                        map["RuleIds"] = self.ruleIds!
                    }
                    if self.tradeAmount != nil {
                        map["TradeAmount"] = self.tradeAmount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DiscountAmount"] as? Double {
                        self.discountAmount = value
                    }
                    if let value = dict["OriginalAmount"] as? Double {
                        self.originalAmount = value
                    }
                    if let value = dict["RuleIds"] as? [String] {
                        self.ruleIds = value
                    }
                    if let value = dict["TradeAmount"] as? Double {
                        self.tradeAmount = value
                    }
                }
            }
            public class Rules : Tea.TeaModel {
                public var name: String?

                public var ruleDescId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.ruleDescId != nil {
                        map["RuleDescId"] = self.ruleDescId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["RuleDescId"] as? Int64 {
                        self.ruleDescId = value
                    }
                }
            }
            public var order: DescribeConfigurationPriceResponseBody.Data.RequestPrice.Order?

            public var rules: [DescribeConfigurationPriceResponseBody.Data.RequestPrice.Rules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.order?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.order != nil {
                    map["Order"] = self.order?.toMap()
                }
                if self.rules != nil {
                    var tmp : [Any] = []
                    for k in self.rules! {
                        tmp.append(k.toMap())
                    }
                    map["Rules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Order"] as? [String: Any?] {
                    var model = DescribeConfigurationPriceResponseBody.Data.RequestPrice.Order()
                    model.fromMap(value)
                    self.order = model
                }
                if let value = dict["Rules"] as? [Any?] {
                    var tmp : [DescribeConfigurationPriceResponseBody.Data.RequestPrice.Rules] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeConfigurationPriceResponseBody.Data.RequestPrice.Rules()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.rules = tmp
                }
            }
        }
        public class Rules : Tea.TeaModel {
            public var name: String?

            public var ruleDescId: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ruleDescId != nil {
                    map["RuleDescId"] = self.ruleDescId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["RuleDescId"] as? Int64 {
                    self.ruleDescId = value
                }
            }
        }
        public class TrafficPrice : Tea.TeaModel {
            public class Order : Tea.TeaModel {
                public var discountAmount: Double?

                public var originalAmount: Double?

                public var ruleIds: [String]?

                public var tradeAmount: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.discountAmount != nil {
                        map["DiscountAmount"] = self.discountAmount!
                    }
                    if self.originalAmount != nil {
                        map["OriginalAmount"] = self.originalAmount!
                    }
                    if self.ruleIds != nil {
                        map["RuleIds"] = self.ruleIds!
                    }
                    if self.tradeAmount != nil {
                        map["TradeAmount"] = self.tradeAmount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DiscountAmount"] as? Double {
                        self.discountAmount = value
                    }
                    if let value = dict["OriginalAmount"] as? Double {
                        self.originalAmount = value
                    }
                    if let value = dict["RuleIds"] as? [String] {
                        self.ruleIds = value
                    }
                    if let value = dict["TradeAmount"] as? Double {
                        self.tradeAmount = value
                    }
                }
            }
            public class Rules : Tea.TeaModel {
                public var name: String?

                public var ruleDescId: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.ruleDescId != nil {
                        map["RuleDescId"] = self.ruleDescId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["RuleDescId"] as? Double {
                        self.ruleDescId = value
                    }
                }
            }
            public var order: DescribeConfigurationPriceResponseBody.Data.TrafficPrice.Order?

            public var rules: [DescribeConfigurationPriceResponseBody.Data.TrafficPrice.Rules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.order?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.order != nil {
                    map["Order"] = self.order?.toMap()
                }
                if self.rules != nil {
                    var tmp : [Any] = []
                    for k in self.rules! {
                        tmp.append(k.toMap())
                    }
                    map["Rules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Order"] as? [String: Any?] {
                    var model = DescribeConfigurationPriceResponseBody.Data.TrafficPrice.Order()
                    model.fromMap(value)
                    self.order = model
                }
                if let value = dict["Rules"] as? [Any?] {
                    var tmp : [DescribeConfigurationPriceResponseBody.Data.TrafficPrice.Rules] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeConfigurationPriceResponseBody.Data.TrafficPrice.Rules()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.rules = tmp
                }
            }
        }
        public var bagUsage: DescribeConfigurationPriceResponseBody.Data.BagUsage?

        public var cpuMemPrice: DescribeConfigurationPriceResponseBody.Data.CpuMemPrice?

        public var order: DescribeConfigurationPriceResponseBody.Data.Order?

        public var requestPrice: DescribeConfigurationPriceResponseBody.Data.RequestPrice?

        public var rules: [DescribeConfigurationPriceResponseBody.Data.Rules]?

        public var trafficPrice: DescribeConfigurationPriceResponseBody.Data.TrafficPrice?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.bagUsage?.validate()
            try self.cpuMemPrice?.validate()
            try self.order?.validate()
            try self.requestPrice?.validate()
            try self.trafficPrice?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bagUsage != nil {
                map["BagUsage"] = self.bagUsage?.toMap()
            }
            if self.cpuMemPrice != nil {
                map["CpuMemPrice"] = self.cpuMemPrice?.toMap()
            }
            if self.order != nil {
                map["Order"] = self.order?.toMap()
            }
            if self.requestPrice != nil {
                map["RequestPrice"] = self.requestPrice?.toMap()
            }
            if self.rules != nil {
                var tmp : [Any] = []
                for k in self.rules! {
                    tmp.append(k.toMap())
                }
                map["Rules"] = tmp
            }
            if self.trafficPrice != nil {
                map["TrafficPrice"] = self.trafficPrice?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BagUsage"] as? [String: Any?] {
                var model = DescribeConfigurationPriceResponseBody.Data.BagUsage()
                model.fromMap(value)
                self.bagUsage = model
            }
            if let value = dict["CpuMemPrice"] as? [String: Any?] {
                var model = DescribeConfigurationPriceResponseBody.Data.CpuMemPrice()
                model.fromMap(value)
                self.cpuMemPrice = model
            }
            if let value = dict["Order"] as? [String: Any?] {
                var model = DescribeConfigurationPriceResponseBody.Data.Order()
                model.fromMap(value)
                self.order = model
            }
            if let value = dict["RequestPrice"] as? [String: Any?] {
                var model = DescribeConfigurationPriceResponseBody.Data.RequestPrice()
                model.fromMap(value)
                self.requestPrice = model
            }
            if let value = dict["Rules"] as? [Any?] {
                var tmp : [DescribeConfigurationPriceResponseBody.Data.Rules] = []
                for v in value {
                    if v != nil {
                        var model = DescribeConfigurationPriceResponseBody.Data.Rules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.rules = tmp
            }
            if let value = dict["TrafficPrice"] as? [String: Any?] {
                var model = DescribeConfigurationPriceResponseBody.Data.TrafficPrice()
                model.fromMap(value)
                self.trafficPrice = model
            }
        }
    }
    public var code: String?

    public var data: DescribeConfigurationPriceResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeConfigurationPriceResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeConfigurationPriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConfigurationPriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeConfigurationPriceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeEdasContainersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var disabled: Bool?

        public var edasContainerVersion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disabled != nil {
                map["Disabled"] = self.disabled!
            }
            if self.edasContainerVersion != nil {
                map["EdasContainerVersion"] = self.edasContainerVersion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Disabled"] as? Bool {
                self.disabled = value
            }
            if let value = dict["EdasContainerVersion"] as? String {
                self.edasContainerVersion = value
            }
        }
    }
    public var code: String?

    public var data: [DescribeEdasContainersResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DescribeEdasContainersResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DescribeEdasContainersResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeEdasContainersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEdasContainersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeEdasContainersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeGreyTagRouteRequest : Tea.TeaModel {
    public var greyTagRouteId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.greyTagRouteId != nil {
            map["GreyTagRouteId"] = self.greyTagRouteId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GreyTagRouteId"] as? Int64 {
            self.greyTagRouteId = value
        }
    }
}

public class DescribeGreyTagRouteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AlbRules : Tea.TeaModel {
            public class Items : Tea.TeaModel {
                public var cond: String?

                public var expr: String?

                public var index: Int32?

                public var name: String?

                public var operator_: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cond != nil {
                        map["cond"] = self.cond!
                    }
                    if self.expr != nil {
                        map["expr"] = self.expr!
                    }
                    if self.index != nil {
                        map["index"] = self.index!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.operator_ != nil {
                        map["operator"] = self.operator_!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["cond"] as? String {
                        self.cond = value
                    }
                    if let value = dict["expr"] as? String {
                        self.expr = value
                    }
                    if let value = dict["index"] as? Int32 {
                        self.index = value
                    }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                    if let value = dict["operator"] as? String {
                        self.operator_ = value
                    }
                    if let value = dict["type"] as? String {
                        self.type = value
                    }
                    if let value = dict["value"] as? String {
                        self.value = value
                    }
                }
            }
            public var condition: String?

            public var ingressId: String?

            public var items: [DescribeGreyTagRouteResponseBody.Data.AlbRules.Items]?

            public var serviceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["condition"] = self.condition!
                }
                if self.ingressId != nil {
                    map["ingressId"] = self.ingressId!
                }
                if self.items != nil {
                    var tmp : [Any] = []
                    for k in self.items! {
                        tmp.append(k.toMap())
                    }
                    map["items"] = tmp
                }
                if self.serviceId != nil {
                    map["serviceId"] = self.serviceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["condition"] as? String {
                    self.condition = value
                }
                if let value = dict["ingressId"] as? String {
                    self.ingressId = value
                }
                if let value = dict["items"] as? [Any?] {
                    var tmp : [DescribeGreyTagRouteResponseBody.Data.AlbRules.Items] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeGreyTagRouteResponseBody.Data.AlbRules.Items()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.items = tmp
                }
                if let value = dict["serviceId"] as? String {
                    self.serviceId = value
                }
            }
        }
        public class DubboRules : Tea.TeaModel {
            public class Items : Tea.TeaModel {
                public var cond: String?

                public var expr: String?

                public var index: Int32?

                public var name: String?

                public var operator_: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cond != nil {
                        map["cond"] = self.cond!
                    }
                    if self.expr != nil {
                        map["expr"] = self.expr!
                    }
                    if self.index != nil {
                        map["index"] = self.index!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.operator_ != nil {
                        map["operator"] = self.operator_!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["cond"] as? String {
                        self.cond = value
                    }
                    if let value = dict["expr"] as? String {
                        self.expr = value
                    }
                    if let value = dict["index"] as? Int32 {
                        self.index = value
                    }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                    if let value = dict["operator"] as? String {
                        self.operator_ = value
                    }
                    if let value = dict["type"] as? String {
                        self.type = value
                    }
                    if let value = dict["value"] as? String {
                        self.value = value
                    }
                }
            }
            public var condition: String?

            public var group: String?

            public var items: [DescribeGreyTagRouteResponseBody.Data.DubboRules.Items]?

            public var methodName: String?

            public var serviceName: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["condition"] = self.condition!
                }
                if self.group != nil {
                    map["group"] = self.group!
                }
                if self.items != nil {
                    var tmp : [Any] = []
                    for k in self.items! {
                        tmp.append(k.toMap())
                    }
                    map["items"] = tmp
                }
                if self.methodName != nil {
                    map["methodName"] = self.methodName!
                }
                if self.serviceName != nil {
                    map["serviceName"] = self.serviceName!
                }
                if self.version != nil {
                    map["version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["condition"] as? String {
                    self.condition = value
                }
                if let value = dict["group"] as? String {
                    self.group = value
                }
                if let value = dict["items"] as? [Any?] {
                    var tmp : [DescribeGreyTagRouteResponseBody.Data.DubboRules.Items] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeGreyTagRouteResponseBody.Data.DubboRules.Items()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.items = tmp
                }
                if let value = dict["methodName"] as? String {
                    self.methodName = value
                }
                if let value = dict["serviceName"] as? String {
                    self.serviceName = value
                }
                if let value = dict["version"] as? String {
                    self.version = value
                }
            }
        }
        public class ScRules : Tea.TeaModel {
            public class Items : Tea.TeaModel {
                public var cond: String?

                public var expr: String?

                public var index: Int32?

                public var name: String?

                public var operator_: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cond != nil {
                        map["cond"] = self.cond!
                    }
                    if self.expr != nil {
                        map["expr"] = self.expr!
                    }
                    if self.index != nil {
                        map["index"] = self.index!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.operator_ != nil {
                        map["operator"] = self.operator_!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["cond"] as? String {
                        self.cond = value
                    }
                    if let value = dict["expr"] as? String {
                        self.expr = value
                    }
                    if let value = dict["index"] as? Int32 {
                        self.index = value
                    }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                    if let value = dict["operator"] as? String {
                        self.operator_ = value
                    }
                    if let value = dict["type"] as? String {
                        self.type = value
                    }
                    if let value = dict["value"] as? String {
                        self.value = value
                    }
                }
            }
            public var condition: String?

            public var items: [DescribeGreyTagRouteResponseBody.Data.ScRules.Items]?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.condition != nil {
                    map["condition"] = self.condition!
                }
                if self.items != nil {
                    var tmp : [Any] = []
                    for k in self.items! {
                        tmp.append(k.toMap())
                    }
                    map["items"] = tmp
                }
                if self.path != nil {
                    map["path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["condition"] as? String {
                    self.condition = value
                }
                if let value = dict["items"] as? [Any?] {
                    var tmp : [DescribeGreyTagRouteResponseBody.Data.ScRules.Items] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeGreyTagRouteResponseBody.Data.ScRules.Items()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.items = tmp
                }
                if let value = dict["path"] as? String {
                    self.path = value
                }
            }
        }
        public var albRules: [DescribeGreyTagRouteResponseBody.Data.AlbRules]?

        public var appId: String?

        public var createTime: Int64?

        public var description_: String?

        public var dubboRules: [DescribeGreyTagRouteResponseBody.Data.DubboRules]?

        public var greyTagRouteId: Int64?

        public var name: String?

        public var scRules: [DescribeGreyTagRouteResponseBody.Data.ScRules]?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.albRules != nil {
                var tmp : [Any] = []
                for k in self.albRules! {
                    tmp.append(k.toMap())
                }
                map["AlbRules"] = tmp
            }
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dubboRules != nil {
                var tmp : [Any] = []
                for k in self.dubboRules! {
                    tmp.append(k.toMap())
                }
                map["DubboRules"] = tmp
            }
            if self.greyTagRouteId != nil {
                map["GreyTagRouteId"] = self.greyTagRouteId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.scRules != nil {
                var tmp : [Any] = []
                for k in self.scRules! {
                    tmp.append(k.toMap())
                }
                map["ScRules"] = tmp
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AlbRules"] as? [Any?] {
                var tmp : [DescribeGreyTagRouteResponseBody.Data.AlbRules] = []
                for v in value {
                    if v != nil {
                        var model = DescribeGreyTagRouteResponseBody.Data.AlbRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.albRules = tmp
            }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DubboRules"] as? [Any?] {
                var tmp : [DescribeGreyTagRouteResponseBody.Data.DubboRules] = []
                for v in value {
                    if v != nil {
                        var model = DescribeGreyTagRouteResponseBody.Data.DubboRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dubboRules = tmp
            }
            if let value = dict["GreyTagRouteId"] as? Int64 {
                self.greyTagRouteId = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["ScRules"] as? [Any?] {
                var tmp : [DescribeGreyTagRouteResponseBody.Data.ScRules] = []
                for v in value {
                    if v != nil {
                        var model = DescribeGreyTagRouteResponseBody.Data.ScRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.scRules = tmp
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var code: String?

    public var data: DescribeGreyTagRouteResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeGreyTagRouteResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeGreyTagRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeGreyTagRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeGreyTagRouteResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeIngressRequest : Tea.TeaModel {
    public var ingressId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ingressId != nil {
            map["IngressId"] = self.ingressId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IngressId"] as? Int64 {
            self.ingressId = value
        }
    }
}

public class DescribeIngressResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CorsConfig : Tea.TeaModel {
            public var allowCredentials: String?

            public var allowHeaders: String?

            public var allowMethods: String?

            public var allowOrigin: String?

            public var enable: String?

            public var exposeHeaders: String?

            public var maxAge: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowCredentials != nil {
                    map["AllowCredentials"] = self.allowCredentials!
                }
                if self.allowHeaders != nil {
                    map["AllowHeaders"] = self.allowHeaders!
                }
                if self.allowMethods != nil {
                    map["AllowMethods"] = self.allowMethods!
                }
                if self.allowOrigin != nil {
                    map["AllowOrigin"] = self.allowOrigin!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.exposeHeaders != nil {
                    map["ExposeHeaders"] = self.exposeHeaders!
                }
                if self.maxAge != nil {
                    map["MaxAge"] = self.maxAge!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AllowCredentials"] as? String {
                    self.allowCredentials = value
                }
                if let value = dict["AllowHeaders"] as? String {
                    self.allowHeaders = value
                }
                if let value = dict["AllowMethods"] as? String {
                    self.allowMethods = value
                }
                if let value = dict["AllowOrigin"] as? String {
                    self.allowOrigin = value
                }
                if let value = dict["Enable"] as? String {
                    self.enable = value
                }
                if let value = dict["ExposeHeaders"] as? String {
                    self.exposeHeaders = value
                }
                if let value = dict["MaxAge"] as? String {
                    self.maxAge = value
                }
            }
        }
        public class DefaultRule : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var backendProtocol: String?

            public var containerPort: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.backendProtocol != nil {
                    map["BackendProtocol"] = self.backendProtocol!
                }
                if self.containerPort != nil {
                    map["ContainerPort"] = self.containerPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["BackendProtocol"] as? String {
                    self.backendProtocol = value
                }
                if let value = dict["ContainerPort"] as? Int32 {
                    self.containerPort = value
                }
            }
        }
        public class Rules : Tea.TeaModel {
            public class RuleActions : Tea.TeaModel {
                public var actionConfig: String?

                public var actionType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.actionConfig != nil {
                        map["ActionConfig"] = self.actionConfig!
                    }
                    if self.actionType != nil {
                        map["ActionType"] = self.actionType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ActionConfig"] as? String {
                        self.actionConfig = value
                    }
                    if let value = dict["ActionType"] as? String {
                        self.actionType = value
                    }
                }
            }
            public var appId: String?

            public var appName: String?

            public var backendProtocol: String?

            public var containerPort: Int32?

            public var domain: String?

            public var path: String?

            public var rewritePath: String?

            public var ruleActions: [DescribeIngressResponseBody.Data.Rules.RuleActions]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.backendProtocol != nil {
                    map["BackendProtocol"] = self.backendProtocol!
                }
                if self.containerPort != nil {
                    map["ContainerPort"] = self.containerPort!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                if self.rewritePath != nil {
                    map["RewritePath"] = self.rewritePath!
                }
                if self.ruleActions != nil {
                    var tmp : [Any] = []
                    for k in self.ruleActions! {
                        tmp.append(k.toMap())
                    }
                    map["RuleActions"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["BackendProtocol"] as? String {
                    self.backendProtocol = value
                }
                if let value = dict["ContainerPort"] as? Int32 {
                    self.containerPort = value
                }
                if let value = dict["Domain"] as? String {
                    self.domain = value
                }
                if let value = dict["Path"] as? String {
                    self.path = value
                }
                if let value = dict["RewritePath"] as? String {
                    self.rewritePath = value
                }
                if let value = dict["RuleActions"] as? [Any?] {
                    var tmp : [DescribeIngressResponseBody.Data.Rules.RuleActions] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeIngressResponseBody.Data.Rules.RuleActions()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.ruleActions = tmp
                }
            }
        }
        public var certId: String?

        public var certIds: String?

        public var corsConfig: DescribeIngressResponseBody.Data.CorsConfig?

        public var createdBySae: Bool?

        public var defaultRule: DescribeIngressResponseBody.Data.DefaultRule?

        public var description_: String?

        public var enableXForwardedFor: Bool?

        public var enableXForwardedForClientSrcPort: Bool?

        public var enableXForwardedForProto: Bool?

        public var enableXForwardedForSlbId: Bool?

        public var enableXForwardedForSlbPort: Bool?

        public var id: Int64?

        public var idleTimeout: Int32?

        public var listenerPort: Int32?

        public var listenerProtocol: String?

        public var loadBalanceType: String?

        public var name: String?

        public var namespaceId: String?

        public var requestTimeout: Int32?

        public var rules: [DescribeIngressResponseBody.Data.Rules]?

        public var securityPolicyId: String?

        public var slbId: String?

        public var slbType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.corsConfig?.validate()
            try self.defaultRule?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certId != nil {
                map["CertId"] = self.certId!
            }
            if self.certIds != nil {
                map["CertIds"] = self.certIds!
            }
            if self.corsConfig != nil {
                map["CorsConfig"] = self.corsConfig?.toMap()
            }
            if self.createdBySae != nil {
                map["CreatedBySae"] = self.createdBySae!
            }
            if self.defaultRule != nil {
                map["DefaultRule"] = self.defaultRule?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.enableXForwardedFor != nil {
                map["EnableXForwardedFor"] = self.enableXForwardedFor!
            }
            if self.enableXForwardedForClientSrcPort != nil {
                map["EnableXForwardedForClientSrcPort"] = self.enableXForwardedForClientSrcPort!
            }
            if self.enableXForwardedForProto != nil {
                map["EnableXForwardedForProto"] = self.enableXForwardedForProto!
            }
            if self.enableXForwardedForSlbId != nil {
                map["EnableXForwardedForSlbId"] = self.enableXForwardedForSlbId!
            }
            if self.enableXForwardedForSlbPort != nil {
                map["EnableXForwardedForSlbPort"] = self.enableXForwardedForSlbPort!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.idleTimeout != nil {
                map["IdleTimeout"] = self.idleTimeout!
            }
            if self.listenerPort != nil {
                map["ListenerPort"] = self.listenerPort!
            }
            if self.listenerProtocol != nil {
                map["ListenerProtocol"] = self.listenerProtocol!
            }
            if self.loadBalanceType != nil {
                map["LoadBalanceType"] = self.loadBalanceType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.requestTimeout != nil {
                map["RequestTimeout"] = self.requestTimeout!
            }
            if self.rules != nil {
                var tmp : [Any] = []
                for k in self.rules! {
                    tmp.append(k.toMap())
                }
                map["Rules"] = tmp
            }
            if self.securityPolicyId != nil {
                map["SecurityPolicyId"] = self.securityPolicyId!
            }
            if self.slbId != nil {
                map["SlbId"] = self.slbId!
            }
            if self.slbType != nil {
                map["SlbType"] = self.slbType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CertId"] as? String {
                self.certId = value
            }
            if let value = dict["CertIds"] as? String {
                self.certIds = value
            }
            if let value = dict["CorsConfig"] as? [String: Any?] {
                var model = DescribeIngressResponseBody.Data.CorsConfig()
                model.fromMap(value)
                self.corsConfig = model
            }
            if let value = dict["CreatedBySae"] as? Bool {
                self.createdBySae = value
            }
            if let value = dict["DefaultRule"] as? [String: Any?] {
                var model = DescribeIngressResponseBody.Data.DefaultRule()
                model.fromMap(value)
                self.defaultRule = model
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["EnableXForwardedFor"] as? Bool {
                self.enableXForwardedFor = value
            }
            if let value = dict["EnableXForwardedForClientSrcPort"] as? Bool {
                self.enableXForwardedForClientSrcPort = value
            }
            if let value = dict["EnableXForwardedForProto"] as? Bool {
                self.enableXForwardedForProto = value
            }
            if let value = dict["EnableXForwardedForSlbId"] as? Bool {
                self.enableXForwardedForSlbId = value
            }
            if let value = dict["EnableXForwardedForSlbPort"] as? Bool {
                self.enableXForwardedForSlbPort = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["IdleTimeout"] as? Int32 {
                self.idleTimeout = value
            }
            if let value = dict["ListenerPort"] as? Int32 {
                self.listenerPort = value
            }
            if let value = dict["ListenerProtocol"] as? String {
                self.listenerProtocol = value
            }
            if let value = dict["LoadBalanceType"] as? String {
                self.loadBalanceType = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["NamespaceId"] as? String {
                self.namespaceId = value
            }
            if let value = dict["RequestTimeout"] as? Int32 {
                self.requestTimeout = value
            }
            if let value = dict["Rules"] as? [Any?] {
                var tmp : [DescribeIngressResponseBody.Data.Rules] = []
                for v in value {
                    if v != nil {
                        var model = DescribeIngressResponseBody.Data.Rules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.rules = tmp
            }
            if let value = dict["SecurityPolicyId"] as? String {
                self.securityPolicyId = value
            }
            if let value = dict["SlbId"] as? String {
                self.slbId = value
            }
            if let value = dict["SlbType"] as? String {
                self.slbType = value
            }
        }
    }
    public var code: String?

    public var data: DescribeIngressResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeIngressResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeIngressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIngressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeIngressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceLogRequest : Tea.TeaModel {
    public var containerId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.containerId != nil {
            map["ContainerId"] = self.containerId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ContainerId"] as? String {
            self.containerId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DescribeInstanceLogResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeInstanceLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceSpecificationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var cpu: Int32?

        public var enable: Bool?

        public var id: Int32?

        public var memory: Int32?

        public var specInfo: String?

        public var version: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.specInfo != nil {
                map["SpecInfo"] = self.specInfo!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Cpu"] as? Int32 {
                self.cpu = value
            }
            if let value = dict["Enable"] as? Bool {
                self.enable = value
            }
            if let value = dict["Id"] as? Int32 {
                self.id = value
            }
            if let value = dict["Memory"] as? Int32 {
                self.memory = value
            }
            if let value = dict["SpecInfo"] as? String {
                self.specInfo = value
            }
            if let value = dict["Version"] as? Int32 {
                self.version = value
            }
        }
    }
    public var code: String?

    public var data: [DescribeInstanceSpecificationsResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DescribeInstanceSpecificationsResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DescribeInstanceSpecificationsResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeInstanceSpecificationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceSpecificationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceSpecificationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeJobRequest : Tea.TeaModel {
    public var appId: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
    }
}

public class DescribeJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ConfigMapMountDesc : Tea.TeaModel {
            public var configMapId: Int64?

            public var configMapName: String?

            public var key: String?

            public var mountPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configMapId != nil {
                    map["ConfigMapId"] = self.configMapId!
                }
                if self.configMapName != nil {
                    map["ConfigMapName"] = self.configMapName!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigMapId"] as? Int64 {
                    self.configMapId = value
                }
                if let value = dict["ConfigMapName"] as? String {
                    self.configMapName = value
                }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["MountPath"] as? String {
                    self.mountPath = value
                }
            }
        }
        public class MountDesc : Tea.TeaModel {
            public var mountPath: String?

            public var nasPath: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mountPath != nil {
                    map["MountPath"] = self.mountPath!
                }
                if self.nasPath != nil {
                    map["NasPath"] = self.nasPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MountPath"] as? String {
                    self.mountPath = value
                }
                if let value = dict["NasPath"] as? String {
                    self.nasPath = value
                }
            }
        }
        public class OssMountDescs : Tea.TeaModel {
            public var bucketName: String?

            public var bucketPath: String?

            public var mountPath: String?

            public var readOnly: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucketName != nil {
                    map["bucketName"] = self.bucketName!
                }
                if self.bucketPath != nil {
                    map["bucketPath"] = self.bucketPath!
                }
                if self.mountPath != nil {
                    map["mountPath"] = self.mountPath!
                }
                if self.readOnly != nil {
                    map["readOnly"] = self.readOnly!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["bucketName"] as? String {
                    self.bucketName = value
                }
                if let value = dict["bucketPath"] as? String {
                    self.bucketPath = value
                }
                if let value = dict["mountPath"] as? String {
                    self.mountPath = value
                }
                if let value = dict["readOnly"] as? Bool {
                    self.readOnly = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var acrAssumeRoleArn: String?

        public var acrInstanceId: String?

        public var appDescription: String?

        public var appId: String?

        public var appName: String?

        public var backoffLimit: Int64?

        public var bestEffortType: String?

        public var command: String?

        public var commandArgs: String?

        public var concurrencyPolicy: String?

        public var configMapMountDesc: [DescribeJobResponseBody.Data.ConfigMapMountDesc]?

        public var cpu: Int32?

        public var customHostAlias: String?

        public var edasContainerVersion: String?

        public var envs: String?

        public var imagePullSecrets: String?

        public var imageUrl: String?

        public var jarStartArgs: String?

        public var jarStartOptions: String?

        public var jdk: String?

        public var memory: Int32?

        public var mountDesc: [DescribeJobResponseBody.Data.MountDesc]?

        public var mountHost: String?

        public var namespaceId: String?

        public var nasConfigs: String?

        public var nasId: String?

        public var ossAkId: String?

        public var ossAkSecret: String?

        public var ossMountDescs: [DescribeJobResponseBody.Data.OssMountDescs]?

        public var packageType: String?

        public var packageUrl: String?

        public var packageVersion: String?

        public var phpConfig: String?

        public var phpConfigLocation: String?

        public var postStart: String?

        public var preStop: String?

        public var programmingLanguage: String?

        public var publicWebHookUrls: [String]?

        public var python: String?

        public var pythonModules: String?

        public var refAppId: String?

        public var refedAppIds: [String]?

        public var regionId: String?

        public var replicas: Int32?

        public var securityGroupId: String?

        public var slice: Bool?

        public var sliceEnvs: String?

        public var slsConfigs: String?

        public var suspend: Bool?

        public var tags: [DescribeJobResponseBody.Data.Tags]?

        public var terminationGracePeriodSeconds: Int32?

        public var timeout: Int64?

        public var timezone: String?

        public var tomcatConfig: String?

        public var triggerConfig: String?

        public var vSwitchId: String?

        public var vpcId: String?

        public var vpcWebHookUrls: [String]?

        public var warStartOptions: String?

        public var webContainer: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acrAssumeRoleArn != nil {
                map["AcrAssumeRoleArn"] = self.acrAssumeRoleArn!
            }
            if self.acrInstanceId != nil {
                map["AcrInstanceId"] = self.acrInstanceId!
            }
            if self.appDescription != nil {
                map["AppDescription"] = self.appDescription!
            }
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.backoffLimit != nil {
                map["BackoffLimit"] = self.backoffLimit!
            }
            if self.bestEffortType != nil {
                map["BestEffortType"] = self.bestEffortType!
            }
            if self.command != nil {
                map["Command"] = self.command!
            }
            if self.commandArgs != nil {
                map["CommandArgs"] = self.commandArgs!
            }
            if self.concurrencyPolicy != nil {
                map["ConcurrencyPolicy"] = self.concurrencyPolicy!
            }
            if self.configMapMountDesc != nil {
                var tmp : [Any] = []
                for k in self.configMapMountDesc! {
                    tmp.append(k.toMap())
                }
                map["ConfigMapMountDesc"] = tmp
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.customHostAlias != nil {
                map["CustomHostAlias"] = self.customHostAlias!
            }
            if self.edasContainerVersion != nil {
                map["EdasContainerVersion"] = self.edasContainerVersion!
            }
            if self.envs != nil {
                map["Envs"] = self.envs!
            }
            if self.imagePullSecrets != nil {
                map["ImagePullSecrets"] = self.imagePullSecrets!
            }
            if self.imageUrl != nil {
                map["ImageUrl"] = self.imageUrl!
            }
            if self.jarStartArgs != nil {
                map["JarStartArgs"] = self.jarStartArgs!
            }
            if self.jarStartOptions != nil {
                map["JarStartOptions"] = self.jarStartOptions!
            }
            if self.jdk != nil {
                map["Jdk"] = self.jdk!
            }
            if self.memory != nil {
                map["Memory"] = self.memory!
            }
            if self.mountDesc != nil {
                var tmp : [Any] = []
                for k in self.mountDesc! {
                    tmp.append(k.toMap())
                }
                map["MountDesc"] = tmp
            }
            if self.mountHost != nil {
                map["MountHost"] = self.mountHost!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.nasConfigs != nil {
                map["NasConfigs"] = self.nasConfigs!
            }
            if self.nasId != nil {
                map["NasId"] = self.nasId!
            }
            if self.ossAkId != nil {
                map["OssAkId"] = self.ossAkId!
            }
            if self.ossAkSecret != nil {
                map["OssAkSecret"] = self.ossAkSecret!
            }
            if self.ossMountDescs != nil {
                var tmp : [Any] = []
                for k in self.ossMountDescs! {
                    tmp.append(k.toMap())
                }
                map["OssMountDescs"] = tmp
            }
            if self.packageType != nil {
                map["PackageType"] = self.packageType!
            }
            if self.packageUrl != nil {
                map["PackageUrl"] = self.packageUrl!
            }
            if self.packageVersion != nil {
                map["PackageVersion"] = self.packageVersion!
            }
            if self.phpConfig != nil {
                map["PhpConfig"] = self.phpConfig!
            }
            if self.phpConfigLocation != nil {
                map["PhpConfigLocation"] = self.phpConfigLocation!
            }
            if self.postStart != nil {
                map["PostStart"] = self.postStart!
            }
            if self.preStop != nil {
                map["PreStop"] = self.preStop!
            }
            if self.programmingLanguage != nil {
                map["ProgrammingLanguage"] = self.programmingLanguage!
            }
            if self.publicWebHookUrls != nil {
                map["PublicWebHookUrls"] = self.publicWebHookUrls!
            }
            if self.python != nil {
                map["Python"] = self.python!
            }
            if self.pythonModules != nil {
                map["PythonModules"] = self.pythonModules!
            }
            if self.refAppId != nil {
                map["RefAppId"] = self.refAppId!
            }
            if self.refedAppIds != nil {
                map["RefedAppIds"] = self.refedAppIds!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.replicas != nil {
                map["Replicas"] = self.replicas!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.slice != nil {
                map["Slice"] = self.slice!
            }
            if self.sliceEnvs != nil {
                map["SliceEnvs"] = self.sliceEnvs!
            }
            if self.slsConfigs != nil {
                map["SlsConfigs"] = self.slsConfigs!
            }
            if self.suspend != nil {
                map["Suspend"] = self.suspend!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.terminationGracePeriodSeconds != nil {
                map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
            }
            if self.timeout != nil {
                map["Timeout"] = self.timeout!
            }
            if self.timezone != nil {
                map["Timezone"] = self.timezone!
            }
            if self.tomcatConfig != nil {
                map["TomcatConfig"] = self.tomcatConfig!
            }
            if self.triggerConfig != nil {
                map["TriggerConfig"] = self.triggerConfig!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.vpcWebHookUrls != nil {
                map["VpcWebHookUrls"] = self.vpcWebHookUrls!
            }
            if self.warStartOptions != nil {
                map["WarStartOptions"] = self.warStartOptions!
            }
            if self.webContainer != nil {
                map["WebContainer"] = self.webContainer!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AcrAssumeRoleArn"] as? String {
                self.acrAssumeRoleArn = value
            }
            if let value = dict["AcrInstanceId"] as? String {
                self.acrInstanceId = value
            }
            if let value = dict["AppDescription"] as? String {
                self.appDescription = value
            }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["BackoffLimit"] as? Int64 {
                self.backoffLimit = value
            }
            if let value = dict["BestEffortType"] as? String {
                self.bestEffortType = value
            }
            if let value = dict["Command"] as? String {
                self.command = value
            }
            if let value = dict["CommandArgs"] as? String {
                self.commandArgs = value
            }
            if let value = dict["ConcurrencyPolicy"] as? String {
                self.concurrencyPolicy = value
            }
            if let value = dict["ConfigMapMountDesc"] as? [Any?] {
                var tmp : [DescribeJobResponseBody.Data.ConfigMapMountDesc] = []
                for v in value {
                    if v != nil {
                        var model = DescribeJobResponseBody.Data.ConfigMapMountDesc()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configMapMountDesc = tmp
            }
            if let value = dict["Cpu"] as? Int32 {
                self.cpu = value
            }
            if let value = dict["CustomHostAlias"] as? String {
                self.customHostAlias = value
            }
            if let value = dict["EdasContainerVersion"] as? String {
                self.edasContainerVersion = value
            }
            if let value = dict["Envs"] as? String {
                self.envs = value
            }
            if let value = dict["ImagePullSecrets"] as? String {
                self.imagePullSecrets = value
            }
            if let value = dict["ImageUrl"] as? String {
                self.imageUrl = value
            }
            if let value = dict["JarStartArgs"] as? String {
                self.jarStartArgs = value
            }
            if let value = dict["JarStartOptions"] as? String {
                self.jarStartOptions = value
            }
            if let value = dict["Jdk"] as? String {
                self.jdk = value
            }
            if let value = dict["Memory"] as? Int32 {
                self.memory = value
            }
            if let value = dict["MountDesc"] as? [Any?] {
                var tmp : [DescribeJobResponseBody.Data.MountDesc] = []
                for v in value {
                    if v != nil {
                        var model = DescribeJobResponseBody.Data.MountDesc()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.mountDesc = tmp
            }
            if let value = dict["MountHost"] as? String {
                self.mountHost = value
            }
            if let value = dict["NamespaceId"] as? String {
                self.namespaceId = value
            }
            if let value = dict["NasConfigs"] as? String {
                self.nasConfigs = value
            }
            if let value = dict["NasId"] as? String {
                self.nasId = value
            }
            if let value = dict["OssAkId"] as? String {
                self.ossAkId = value
            }
            if let value = dict["OssAkSecret"] as? String {
                self.ossAkSecret = value
            }
            if let value = dict["OssMountDescs"] as? [Any?] {
                var tmp : [DescribeJobResponseBody.Data.OssMountDescs] = []
                for v in value {
                    if v != nil {
                        var model = DescribeJobResponseBody.Data.OssMountDescs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ossMountDescs = tmp
            }
            if let value = dict["PackageType"] as? String {
                self.packageType = value
            }
            if let value = dict["PackageUrl"] as? String {
                self.packageUrl = value
            }
            if let value = dict["PackageVersion"] as? String {
                self.packageVersion = value
            }
            if let value = dict["PhpConfig"] as? String {
                self.phpConfig = value
            }
            if let value = dict["PhpConfigLocation"] as? String {
                self.phpConfigLocation = value
            }
            if let value = dict["PostStart"] as? String {
                self.postStart = value
            }
            if let value = dict["PreStop"] as? String {
                self.preStop = value
            }
            if let value = dict["ProgrammingLanguage"] as? String {
                self.programmingLanguage = value
            }
            if let value = dict["PublicWebHookUrls"] as? [String] {
                self.publicWebHookUrls = value
            }
            if let value = dict["Python"] as? String {
                self.python = value
            }
            if let value = dict["PythonModules"] as? String {
                self.pythonModules = value
            }
            if let value = dict["RefAppId"] as? String {
                self.refAppId = value
            }
            if let value = dict["RefedAppIds"] as? [String] {
                self.refedAppIds = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["Replicas"] as? Int32 {
                self.replicas = value
            }
            if let value = dict["SecurityGroupId"] as? String {
                self.securityGroupId = value
            }
            if let value = dict["Slice"] as? Bool {
                self.slice = value
            }
            if let value = dict["SliceEnvs"] as? String {
                self.sliceEnvs = value
            }
            if let value = dict["SlsConfigs"] as? String {
                self.slsConfigs = value
            }
            if let value = dict["Suspend"] as? Bool {
                self.suspend = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [DescribeJobResponseBody.Data.Tags] = []
                for v in value {
                    if v != nil {
                        var model = DescribeJobResponseBody.Data.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["TerminationGracePeriodSeconds"] as? Int32 {
                self.terminationGracePeriodSeconds = value
            }
            if let value = dict["Timeout"] as? Int64 {
                self.timeout = value
            }
            if let value = dict["Timezone"] as? String {
                self.timezone = value
            }
            if let value = dict["TomcatConfig"] as? String {
                self.tomcatConfig = value
            }
            if let value = dict["TriggerConfig"] as? String {
                self.triggerConfig = value
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
            if let value = dict["VpcWebHookUrls"] as? [String] {
                self.vpcWebHookUrls = value
            }
            if let value = dict["WarStartOptions"] as? String {
                self.warStartOptions = value
            }
            if let value = dict["WebContainer"] as? String {
                self.webContainer = value
            }
        }
    }
    public var code: String?

    public var data: DescribeJobResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeJobResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeJobHistoryRequest : Tea.TeaModel {
    public var appId: String?

    public var currentPage: Int64?

    public var pageSize: Int64?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["CurrentPage"] as? Int64 {
            self.currentPage = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["State"] as? String {
            self.state = value
        }
    }
}

public class DescribeJobHistoryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Jobs : Tea.TeaModel {
            public var active: Int64?

            public var completionTime: Int64?

            public var failed: Int64?

            public var jobId: String?

            public var message: String?

            public var startTime: Int64?

            public var state: String?

            public var succeeded: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.active != nil {
                    map["Active"] = self.active!
                }
                if self.completionTime != nil {
                    map["CompletionTime"] = self.completionTime!
                }
                if self.failed != nil {
                    map["Failed"] = self.failed!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.succeeded != nil {
                    map["Succeeded"] = self.succeeded!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Active"] as? Int64 {
                    self.active = value
                }
                if let value = dict["CompletionTime"] as? Int64 {
                    self.completionTime = value
                }
                if let value = dict["Failed"] as? Int64 {
                    self.failed = value
                }
                if let value = dict["JobId"] as? String {
                    self.jobId = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
                if let value = dict["StartTime"] as? Int64 {
                    self.startTime = value
                }
                if let value = dict["State"] as? String {
                    self.state = value
                }
                if let value = dict["Succeeded"] as? Int64 {
                    self.succeeded = value
                }
            }
        }
        public var currentPage: Int64?

        public var jobs: [DescribeJobHistoryResponseBody.Data.Jobs]?

        public var pageSize: Int64?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.jobs != nil {
                var tmp : [Any] = []
                for k in self.jobs! {
                    tmp.append(k.toMap())
                }
                map["Jobs"] = tmp
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CurrentPage"] as? Int64 {
                self.currentPage = value
            }
            if let value = dict["Jobs"] as? [Any?] {
                var tmp : [DescribeJobHistoryResponseBody.Data.Jobs] = []
                for v in value {
                    if v != nil {
                        var model = DescribeJobHistoryResponseBody.Data.Jobs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.jobs = tmp
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["TotalSize"] as? Int64 {
                self.totalSize = value
            }
        }
    }
    public var code: String?

    public var data: DescribeJobHistoryResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeJobHistoryResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeJobHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeJobHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeJobHistoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeJobStatusRequest : Tea.TeaModel {
    public var appId: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["JobId"] as? String {
            self.jobId = value
        }
    }
}

public class DescribeJobStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var active: Int64?

        public var completionTime: Int64?

        public var failed: Int64?

        public var jobId: String?

        public var message: String?

        public var startTime: Int64?

        public var state: String?

        public var succeeded: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.active != nil {
                map["Active"] = self.active!
            }
            if self.completionTime != nil {
                map["CompletionTime"] = self.completionTime!
            }
            if self.failed != nil {
                map["Failed"] = self.failed!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.succeeded != nil {
                map["Succeeded"] = self.succeeded!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Active"] as? Int64 {
                self.active = value
            }
            if let value = dict["CompletionTime"] as? Int64 {
                self.completionTime = value
            }
            if let value = dict["Failed"] as? Int64 {
                self.failed = value
            }
            if let value = dict["JobId"] as? String {
                self.jobId = value
            }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["StartTime"] as? Int64 {
                self.startTime = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["Succeeded"] as? Int64 {
                self.succeeded = value
            }
        }
    }
    public var code: String?

    public var data: DescribeJobStatusResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeJobStatusResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeJobStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeJobStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeJobStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeNamespaceRequest : Tea.TeaModel {
    public var nameSpaceShortId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nameSpaceShortId != nil {
            map["NameSpaceShortId"] = self.nameSpaceShortId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NameSpaceShortId"] as? String {
            self.nameSpaceShortId = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class DescribeNamespaceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var enableMicroRegistration: Bool?

        public var nameSpaceShortId: String?

        public var namespaceDescription: String?

        public var namespaceId: String?

        public var namespaceName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableMicroRegistration != nil {
                map["EnableMicroRegistration"] = self.enableMicroRegistration!
            }
            if self.nameSpaceShortId != nil {
                map["NameSpaceShortId"] = self.nameSpaceShortId!
            }
            if self.namespaceDescription != nil {
                map["NamespaceDescription"] = self.namespaceDescription!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.namespaceName != nil {
                map["NamespaceName"] = self.namespaceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EnableMicroRegistration"] as? Bool {
                self.enableMicroRegistration = value
            }
            if let value = dict["NameSpaceShortId"] as? String {
                self.nameSpaceShortId = value
            }
            if let value = dict["NamespaceDescription"] as? String {
                self.namespaceDescription = value
            }
            if let value = dict["NamespaceId"] as? String {
                self.namespaceId = value
            }
            if let value = dict["NamespaceName"] as? String {
                self.namespaceName = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
        }
    }
    public var code: String?

    public var data: DescribeNamespaceResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeNamespaceResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeNamespaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeNamespaceListRequest : Tea.TeaModel {
    public var containCustom: Bool?

    public var hybridCloudExclude: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.containCustom != nil {
            map["ContainCustom"] = self.containCustom!
        }
        if self.hybridCloudExclude != nil {
            map["HybridCloudExclude"] = self.hybridCloudExclude!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ContainCustom"] as? Bool {
            self.containCustom = value
        }
        if let value = dict["HybridCloudExclude"] as? Bool {
            self.hybridCloudExclude = value
        }
    }
}

public class DescribeNamespaceListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var agentInstall: String?

        public var current: Bool?

        public var custom: Bool?

        public var hybridCloudEnable: Bool?

        public var nameSpaceShortId: String?

        public var namespaceId: String?

        public var namespaceName: String?

        public var regionId: String?

        public var securityGroupId: String?

        public var vSwitchId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentInstall != nil {
                map["AgentInstall"] = self.agentInstall!
            }
            if self.current != nil {
                map["Current"] = self.current!
            }
            if self.custom != nil {
                map["Custom"] = self.custom!
            }
            if self.hybridCloudEnable != nil {
                map["HybridCloudEnable"] = self.hybridCloudEnable!
            }
            if self.nameSpaceShortId != nil {
                map["NameSpaceShortId"] = self.nameSpaceShortId!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.namespaceName != nil {
                map["NamespaceName"] = self.namespaceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AgentInstall"] as? String {
                self.agentInstall = value
            }
            if let value = dict["Current"] as? Bool {
                self.current = value
            }
            if let value = dict["Custom"] as? Bool {
                self.custom = value
            }
            if let value = dict["HybridCloudEnable"] as? Bool {
                self.hybridCloudEnable = value
            }
            if let value = dict["NameSpaceShortId"] as? String {
                self.nameSpaceShortId = value
            }
            if let value = dict["NamespaceId"] as? String {
                self.namespaceId = value
            }
            if let value = dict["NamespaceName"] as? String {
                self.namespaceName = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["SecurityGroupId"] as? String {
                self.securityGroupId = value
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var code: String?

    public var data: [DescribeNamespaceListResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DescribeNamespaceListResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DescribeNamespaceListResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeNamespaceListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNamespaceListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeNamespaceListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeNamespaceResourcesRequest : Tea.TeaModel {
    public var nameSpaceShortId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nameSpaceShortId != nil {
            map["NameSpaceShortId"] = self.nameSpaceShortId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NameSpaceShortId"] as? String {
            self.nameSpaceShortId = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class DescribeNamespaceResourcesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appCount: Int64?

        public var belongRegion: String?

        public var description_: String?

        public var jumpServerAppId: String?

        public var jumpServerIp: String?

        public var lastChangeOrderId: String?

        public var lastChangeOrderRunning: Bool?

        public var lastChangeOrderStatus: String?

        public var nameSpaceShortId: String?

        public var namespaceId: String?

        public var namespaceName: String?

        public var notificationExpired: Bool?

        public var securityGroupId: String?

        public var tenantId: String?

        public var userId: String?

        public var vSwitchId: String?

        public var vSwitchName: String?

        public var vpcId: String?

        public var vpcName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appCount != nil {
                map["AppCount"] = self.appCount!
            }
            if self.belongRegion != nil {
                map["BelongRegion"] = self.belongRegion!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.jumpServerAppId != nil {
                map["JumpServerAppId"] = self.jumpServerAppId!
            }
            if self.jumpServerIp != nil {
                map["JumpServerIp"] = self.jumpServerIp!
            }
            if self.lastChangeOrderId != nil {
                map["LastChangeOrderId"] = self.lastChangeOrderId!
            }
            if self.lastChangeOrderRunning != nil {
                map["LastChangeOrderRunning"] = self.lastChangeOrderRunning!
            }
            if self.lastChangeOrderStatus != nil {
                map["LastChangeOrderStatus"] = self.lastChangeOrderStatus!
            }
            if self.nameSpaceShortId != nil {
                map["NameSpaceShortId"] = self.nameSpaceShortId!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.namespaceName != nil {
                map["NamespaceName"] = self.namespaceName!
            }
            if self.notificationExpired != nil {
                map["NotificationExpired"] = self.notificationExpired!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vSwitchName != nil {
                map["VSwitchName"] = self.vSwitchName!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.vpcName != nil {
                map["VpcName"] = self.vpcName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppCount"] as? Int64 {
                self.appCount = value
            }
            if let value = dict["BelongRegion"] as? String {
                self.belongRegion = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["JumpServerAppId"] as? String {
                self.jumpServerAppId = value
            }
            if let value = dict["JumpServerIp"] as? String {
                self.jumpServerIp = value
            }
            if let value = dict["LastChangeOrderId"] as? String {
                self.lastChangeOrderId = value
            }
            if let value = dict["LastChangeOrderRunning"] as? Bool {
                self.lastChangeOrderRunning = value
            }
            if let value = dict["LastChangeOrderStatus"] as? String {
                self.lastChangeOrderStatus = value
            }
            if let value = dict["NameSpaceShortId"] as? String {
                self.nameSpaceShortId = value
            }
            if let value = dict["NamespaceId"] as? String {
                self.namespaceId = value
            }
            if let value = dict["NamespaceName"] as? String {
                self.namespaceName = value
            }
            if let value = dict["NotificationExpired"] as? Bool {
                self.notificationExpired = value
            }
            if let value = dict["SecurityGroupId"] as? String {
                self.securityGroupId = value
            }
            if let value = dict["TenantId"] as? String {
                self.tenantId = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
            if let value = dict["VSwitchName"] as? String {
                self.vSwitchName = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
            if let value = dict["VpcName"] as? String {
                self.vpcName = value
            }
        }
    }
    public var code: String?

    public var data: DescribeNamespaceResourcesResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeNamespaceResourcesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeNamespaceResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNamespaceResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeNamespaceResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeNamespacesRequest : Tea.TeaModel {
    public var currentPage: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CurrentPage"] as? Int32 {
            self.currentPage = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class DescribeNamespacesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Namespaces : Tea.TeaModel {
            public var accessKey: String?

            public var addressServerHost: String?

            public var nameSpaceShortId: String?

            public var namespaceDescription: String?

            public var namespaceId: String?

            public var namespaceName: String?

            public var regionId: String?

            public var secretKey: String?

            public var tenantId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessKey != nil {
                    map["AccessKey"] = self.accessKey!
                }
                if self.addressServerHost != nil {
                    map["AddressServerHost"] = self.addressServerHost!
                }
                if self.nameSpaceShortId != nil {
                    map["NameSpaceShortId"] = self.nameSpaceShortId!
                }
                if self.namespaceDescription != nil {
                    map["NamespaceDescription"] = self.namespaceDescription!
                }
                if self.namespaceId != nil {
                    map["NamespaceId"] = self.namespaceId!
                }
                if self.namespaceName != nil {
                    map["NamespaceName"] = self.namespaceName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.secretKey != nil {
                    map["SecretKey"] = self.secretKey!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccessKey"] as? String {
                    self.accessKey = value
                }
                if let value = dict["AddressServerHost"] as? String {
                    self.addressServerHost = value
                }
                if let value = dict["NameSpaceShortId"] as? String {
                    self.nameSpaceShortId = value
                }
                if let value = dict["NamespaceDescription"] as? String {
                    self.namespaceDescription = value
                }
                if let value = dict["NamespaceId"] as? String {
                    self.namespaceId = value
                }
                if let value = dict["NamespaceName"] as? String {
                    self.namespaceName = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["SecretKey"] as? String {
                    self.secretKey = value
                }
                if let value = dict["TenantId"] as? String {
                    self.tenantId = value
                }
            }
        }
        public var currentPage: Int32?

        public var namespaces: [DescribeNamespacesResponseBody.Data.Namespaces]?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.namespaces != nil {
                var tmp : [Any] = []
                for k in self.namespaces! {
                    tmp.append(k.toMap())
                }
                map["Namespaces"] = tmp
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CurrentPage"] as? Int32 {
                self.currentPage = value
            }
            if let value = dict["Namespaces"] as? [Any?] {
                var tmp : [DescribeNamespacesResponseBody.Data.Namespaces] = []
                for v in value {
                    if v != nil {
                        var model = DescribeNamespacesResponseBody.Data.Namespaces()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.namespaces = tmp
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalSize"] as? Int32 {
                self.totalSize = value
            }
        }
    }
    public var code: String?

    public var data: DescribeNamespacesResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeNamespacesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeNamespacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNamespacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeNamespacesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePipelineRequest : Tea.TeaModel {
    public var pipelineId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pipelineId != nil {
            map["PipelineId"] = self.pipelineId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PipelineId"] as? String {
            self.pipelineId = value
        }
    }
}

public class DescribePipelineResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class StageList : Tea.TeaModel {
            public class TaskList : Tea.TeaModel {
                public var errorCode: String?

                public var errorIgnore: Int32?

                public var errorMessage: String?

                public var message: String?

                public var showManualIgnore: Bool?

                public var stageId: String?

                public var status: Int32?

                public var taskId: String?

                public var taskName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorIgnore != nil {
                        map["ErrorIgnore"] = self.errorIgnore!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.showManualIgnore != nil {
                        map["ShowManualIgnore"] = self.showManualIgnore!
                    }
                    if self.stageId != nil {
                        map["StageId"] = self.stageId!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.taskId != nil {
                        map["TaskId"] = self.taskId!
                    }
                    if self.taskName != nil {
                        map["TaskName"] = self.taskName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ErrorCode"] as? String {
                        self.errorCode = value
                    }
                    if let value = dict["ErrorIgnore"] as? Int32 {
                        self.errorIgnore = value
                    }
                    if let value = dict["ErrorMessage"] as? String {
                        self.errorMessage = value
                    }
                    if let value = dict["Message"] as? String {
                        self.message = value
                    }
                    if let value = dict["ShowManualIgnore"] as? Bool {
                        self.showManualIgnore = value
                    }
                    if let value = dict["StageId"] as? String {
                        self.stageId = value
                    }
                    if let value = dict["Status"] as? Int32 {
                        self.status = value
                    }
                    if let value = dict["TaskId"] as? String {
                        self.taskId = value
                    }
                    if let value = dict["TaskName"] as? String {
                        self.taskName = value
                    }
                }
            }
            public var executorType: Int32?

            public var stageId: String?

            public var stageName: String?

            public var status: Int32?

            public var taskList: [DescribePipelineResponseBody.Data.StageList.TaskList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.executorType != nil {
                    map["ExecutorType"] = self.executorType!
                }
                if self.stageId != nil {
                    map["StageId"] = self.stageId!
                }
                if self.stageName != nil {
                    map["StageName"] = self.stageName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskList != nil {
                    var tmp : [Any] = []
                    for k in self.taskList! {
                        tmp.append(k.toMap())
                    }
                    map["TaskList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ExecutorType"] as? Int32 {
                    self.executorType = value
                }
                if let value = dict["StageId"] as? String {
                    self.stageId = value
                }
                if let value = dict["StageName"] as? String {
                    self.stageName = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
                if let value = dict["TaskList"] as? [Any?] {
                    var tmp : [DescribePipelineResponseBody.Data.StageList.TaskList] = []
                    for v in value {
                        if v != nil {
                            var model = DescribePipelineResponseBody.Data.StageList.TaskList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.taskList = tmp
                }
            }
        }
        public var coStatus: String?

        public var currentStageId: String?

        public var nextPipelineId: String?

        public var pipelineId: String?

        public var pipelineName: String?

        public var pipelineStatus: Int32?

        public var showBatch: Bool?

        public var stageList: [DescribePipelineResponseBody.Data.StageList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.coStatus != nil {
                map["CoStatus"] = self.coStatus!
            }
            if self.currentStageId != nil {
                map["CurrentStageId"] = self.currentStageId!
            }
            if self.nextPipelineId != nil {
                map["NextPipelineId"] = self.nextPipelineId!
            }
            if self.pipelineId != nil {
                map["PipelineId"] = self.pipelineId!
            }
            if self.pipelineName != nil {
                map["PipelineName"] = self.pipelineName!
            }
            if self.pipelineStatus != nil {
                map["PipelineStatus"] = self.pipelineStatus!
            }
            if self.showBatch != nil {
                map["ShowBatch"] = self.showBatch!
            }
            if self.stageList != nil {
                var tmp : [Any] = []
                for k in self.stageList! {
                    tmp.append(k.toMap())
                }
                map["StageList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CoStatus"] as? String {
                self.coStatus = value
            }
            if let value = dict["CurrentStageId"] as? String {
                self.currentStageId = value
            }
            if let value = dict["NextPipelineId"] as? String {
                self.nextPipelineId = value
            }
            if let value = dict["PipelineId"] as? String {
                self.pipelineId = value
            }
            if let value = dict["PipelineName"] as? String {
                self.pipelineName = value
            }
            if let value = dict["PipelineStatus"] as? Int32 {
                self.pipelineStatus = value
            }
            if let value = dict["ShowBatch"] as? Bool {
                self.showBatch = value
            }
            if let value = dict["StageList"] as? [Any?] {
                var tmp : [DescribePipelineResponseBody.Data.StageList] = []
                for v in value {
                    if v != nil {
                        var model = DescribePipelineResponseBody.Data.StageList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.stageList = tmp
            }
        }
    }
    public var code: String?

    public var data: DescribePipelineResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribePipelineResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePipelineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public class Region : Tea.TeaModel {
            public class RecommendZones : Tea.TeaModel {
                public var recommendZone: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.recommendZone != nil {
                        map["RecommendZone"] = self.recommendZone!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RecommendZone"] as? [String] {
                        self.recommendZone = value
                    }
                }
            }
            public var localName: String?

            public var recommendZones: DescribeRegionsResponseBody.Regions.Region.RecommendZones?

            public var regionEndpoint: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.recommendZones?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localName != nil {
                    map["LocalName"] = self.localName!
                }
                if self.recommendZones != nil {
                    map["RecommendZones"] = self.recommendZones?.toMap()
                }
                if self.regionEndpoint != nil {
                    map["RegionEndpoint"] = self.regionEndpoint!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LocalName"] as? String {
                    self.localName = value
                }
                if let value = dict["RecommendZones"] as? [String: Any?] {
                    var model = DescribeRegionsResponseBody.Regions.Region.RecommendZones()
                    model.fromMap(value)
                    self.recommendZones = model
                }
                if let value = dict["RegionEndpoint"] as? String {
                    self.regionEndpoint = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
            }
        }
        public var region: [DescribeRegionsResponseBody.Regions.Region]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.region != nil {
                var tmp : [Any] = []
                for k in self.region! {
                    tmp.append(k.toMap())
                }
                map["Region"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Region"] as? [Any?] {
                var tmp : [DescribeRegionsResponseBody.Regions.Region] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRegionsResponseBody.Regions.Region()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.region = tmp
            }
        }
    }
    public var code: Int32?

    public var message: String?

    public var regions: DescribeRegionsResponseBody.Regions?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.regions != nil {
            map["Regions"] = self.regions?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["Regions"] as? [String: Any?] {
            var model = DescribeRegionsResponseBody.Regions()
            model.fromMap(value)
            self.regions = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRegionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSecretRequest : Tea.TeaModel {
    public var namespaceId: String?

    public var secretId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.secretId != nil {
            map["SecretId"] = self.secretId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["SecretId"] as? Int64 {
            self.secretId = value
        }
    }
}

public class DescribeSecretResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RelateApps : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
            }
        }
        public var createTime: Int64?

        public var namespaceId: String?

        public var relateApps: [DescribeSecretResponseBody.Data.RelateApps]?

        public var secretData: [String: String]?

        public var secretId: Int64?

        public var secretName: String?

        public var secretType: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.relateApps != nil {
                var tmp : [Any] = []
                for k in self.relateApps! {
                    tmp.append(k.toMap())
                }
                map["RelateApps"] = tmp
            }
            if self.secretData != nil {
                map["SecretData"] = self.secretData!
            }
            if self.secretId != nil {
                map["SecretId"] = self.secretId!
            }
            if self.secretName != nil {
                map["SecretName"] = self.secretName!
            }
            if self.secretType != nil {
                map["SecretType"] = self.secretType!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["NamespaceId"] as? String {
                self.namespaceId = value
            }
            if let value = dict["RelateApps"] as? [Any?] {
                var tmp : [DescribeSecretResponseBody.Data.RelateApps] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSecretResponseBody.Data.RelateApps()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.relateApps = tmp
            }
            if let value = dict["SecretData"] as? [String: String] {
                self.secretData = value
            }
            if let value = dict["SecretId"] as? Int64 {
                self.secretId = value
            }
            if let value = dict["SecretName"] as? String {
                self.secretName = value
            }
            if let value = dict["SecretType"] as? String {
                self.secretType = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var code: String?

    public var data: DescribeSecretResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeSecretResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSecretResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSwimmingLaneRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var laneId: Int64?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.laneId != nil {
            map["LaneId"] = self.laneId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? Int64 {
            self.groupId = value
        }
        if let value = dict["LaneId"] as? Int64 {
            self.laneId = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class DescribeSwimmingLaneResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AppEntryRule : Tea.TeaModel {
            public class Conditions : Tea.TeaModel {
                public var condition: String?

                public var name: String?

                public var type: String?

                public var value: String?

                public var values: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.condition != nil {
                        map["Condition"] = self.condition!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    if self.values != nil {
                        map["Values"] = self.values!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Condition"] as? String {
                        self.condition = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                    if let value = dict["Values"] as? [String] {
                        self.values = value
                    }
                }
            }
            public var conditionJoiner: String?

            public var conditions: [DescribeSwimmingLaneResponseBody.Data.AppEntryRule.Conditions]?

            public var independentPercentageEnable: Bool?

            public var paths: [String]?

            public var percentage: Int32?

            public var percentageByPath: [String: Int32]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.conditionJoiner != nil {
                    map["ConditionJoiner"] = self.conditionJoiner!
                }
                if self.conditions != nil {
                    var tmp : [Any] = []
                    for k in self.conditions! {
                        tmp.append(k.toMap())
                    }
                    map["Conditions"] = tmp
                }
                if self.independentPercentageEnable != nil {
                    map["IndependentPercentageEnable"] = self.independentPercentageEnable!
                }
                if self.paths != nil {
                    map["Paths"] = self.paths!
                }
                if self.percentage != nil {
                    map["Percentage"] = self.percentage!
                }
                if self.percentageByPath != nil {
                    map["PercentageByPath"] = self.percentageByPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConditionJoiner"] as? String {
                    self.conditionJoiner = value
                }
                if let value = dict["Conditions"] as? [Any?] {
                    var tmp : [DescribeSwimmingLaneResponseBody.Data.AppEntryRule.Conditions] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeSwimmingLaneResponseBody.Data.AppEntryRule.Conditions()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.conditions = tmp
                }
                if let value = dict["IndependentPercentageEnable"] as? Bool {
                    self.independentPercentageEnable = value
                }
                if let value = dict["Paths"] as? [String] {
                    self.paths = value
                }
                if let value = dict["Percentage"] as? Int32 {
                    self.percentage = value
                }
                if let value = dict["PercentageByPath"] as? [String: Int32] {
                    self.percentageByPath = value
                }
            }
        }
        public class Apps : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var mseAppId: String?

            public var mseAppName: String?

            public var mseNamespaceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.mseAppId != nil {
                    map["MseAppId"] = self.mseAppId!
                }
                if self.mseAppName != nil {
                    map["MseAppName"] = self.mseAppName!
                }
                if self.mseNamespaceId != nil {
                    map["mseNamespaceId"] = self.mseNamespaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["MseAppId"] as? String {
                    self.mseAppId = value
                }
                if let value = dict["MseAppName"] as? String {
                    self.mseAppName = value
                }
                if let value = dict["mseNamespaceId"] as? String {
                    self.mseNamespaceId = value
                }
            }
        }
        public class MseGatewayEntryRule : Tea.TeaModel {
            public class Conditions : Tea.TeaModel {
                public var condition: String?

                public var name: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.condition != nil {
                        map["Condition"] = self.condition!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Condition"] as? String {
                        self.condition = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public class Routes : Tea.TeaModel {
                public class RoutePredicate : Tea.TeaModel {
                    public class PathPredicate : Tea.TeaModel {
                        public var path: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.path != nil {
                                map["Path"] = self.path!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["Path"] as? String {
                                self.path = value
                            }
                            if let value = dict["Type"] as? String {
                                self.type = value
                            }
                        }
                    }
                    public var pathPredicate: DescribeSwimmingLaneResponseBody.Data.MseGatewayEntryRule.Routes.RoutePredicate.PathPredicate?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.pathPredicate?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.pathPredicate != nil {
                            map["PathPredicate"] = self.pathPredicate?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["PathPredicate"] as? [String: Any?] {
                            var model = DescribeSwimmingLaneResponseBody.Data.MseGatewayEntryRule.Routes.RoutePredicate.PathPredicate()
                            model.fromMap(value)
                            self.pathPredicate = model
                        }
                    }
                }
                public var routeId: Int64?

                public var routeName: String?

                public var routePredicate: DescribeSwimmingLaneResponseBody.Data.MseGatewayEntryRule.Routes.RoutePredicate?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.routePredicate?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.routeId != nil {
                        map["RouteId"] = self.routeId!
                    }
                    if self.routeName != nil {
                        map["RouteName"] = self.routeName!
                    }
                    if self.routePredicate != nil {
                        map["RoutePredicate"] = self.routePredicate?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RouteId"] as? Int64 {
                        self.routeId = value
                    }
                    if let value = dict["RouteName"] as? String {
                        self.routeName = value
                    }
                    if let value = dict["RoutePredicate"] as? [String: Any?] {
                        var model = DescribeSwimmingLaneResponseBody.Data.MseGatewayEntryRule.Routes.RoutePredicate()
                        model.fromMap(value)
                        self.routePredicate = model
                    }
                }
            }
            public var conditionJoiner: String?

            public var conditions: [DescribeSwimmingLaneResponseBody.Data.MseGatewayEntryRule.Conditions]?

            public var independentPercentageEnable: Bool?

            public var percentage: Int32?

            public var percentageByRoute: [String: Int32]?

            public var routeIds: [Int64]?

            public var routes: [DescribeSwimmingLaneResponseBody.Data.MseGatewayEntryRule.Routes]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.conditionJoiner != nil {
                    map["ConditionJoiner"] = self.conditionJoiner!
                }
                if self.conditions != nil {
                    var tmp : [Any] = []
                    for k in self.conditions! {
                        tmp.append(k.toMap())
                    }
                    map["Conditions"] = tmp
                }
                if self.independentPercentageEnable != nil {
                    map["IndependentPercentageEnable"] = self.independentPercentageEnable!
                }
                if self.percentage != nil {
                    map["Percentage"] = self.percentage!
                }
                if self.percentageByRoute != nil {
                    map["PercentageByRoute"] = self.percentageByRoute!
                }
                if self.routeIds != nil {
                    map["RouteIds"] = self.routeIds!
                }
                if self.routes != nil {
                    var tmp : [Any] = []
                    for k in self.routes! {
                        tmp.append(k.toMap())
                    }
                    map["Routes"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConditionJoiner"] as? String {
                    self.conditionJoiner = value
                }
                if let value = dict["Conditions"] as? [Any?] {
                    var tmp : [DescribeSwimmingLaneResponseBody.Data.MseGatewayEntryRule.Conditions] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeSwimmingLaneResponseBody.Data.MseGatewayEntryRule.Conditions()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.conditions = tmp
                }
                if let value = dict["IndependentPercentageEnable"] as? Bool {
                    self.independentPercentageEnable = value
                }
                if let value = dict["Percentage"] as? Int32 {
                    self.percentage = value
                }
                if let value = dict["PercentageByRoute"] as? [String: Int32] {
                    self.percentageByRoute = value
                }
                if let value = dict["RouteIds"] as? [Int64] {
                    self.routeIds = value
                }
                if let value = dict["Routes"] as? [Any?] {
                    var tmp : [DescribeSwimmingLaneResponseBody.Data.MseGatewayEntryRule.Routes] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeSwimmingLaneResponseBody.Data.MseGatewayEntryRule.Routes()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.routes = tmp
                }
            }
        }
        public var appEntryRule: DescribeSwimmingLaneResponseBody.Data.AppEntryRule?

        public var apps: [DescribeSwimmingLaneResponseBody.Data.Apps]?

        public var canaryModel: Int32?

        public var enable: Bool?

        public var enableRules: Bool?

        public var laneId: Int64?

        public var laneName: String?

        public var laneTag: String?

        public var mseGatewayEntryRule: DescribeSwimmingLaneResponseBody.Data.MseGatewayEntryRule?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.appEntryRule?.validate()
            try self.mseGatewayEntryRule?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appEntryRule != nil {
                map["AppEntryRule"] = self.appEntryRule?.toMap()
            }
            if self.apps != nil {
                var tmp : [Any] = []
                for k in self.apps! {
                    tmp.append(k.toMap())
                }
                map["Apps"] = tmp
            }
            if self.canaryModel != nil {
                map["CanaryModel"] = self.canaryModel!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.enableRules != nil {
                map["EnableRules"] = self.enableRules!
            }
            if self.laneId != nil {
                map["LaneId"] = self.laneId!
            }
            if self.laneName != nil {
                map["LaneName"] = self.laneName!
            }
            if self.laneTag != nil {
                map["LaneTag"] = self.laneTag!
            }
            if self.mseGatewayEntryRule != nil {
                map["MseGatewayEntryRule"] = self.mseGatewayEntryRule?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppEntryRule"] as? [String: Any?] {
                var model = DescribeSwimmingLaneResponseBody.Data.AppEntryRule()
                model.fromMap(value)
                self.appEntryRule = model
            }
            if let value = dict["Apps"] as? [Any?] {
                var tmp : [DescribeSwimmingLaneResponseBody.Data.Apps] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSwimmingLaneResponseBody.Data.Apps()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.apps = tmp
            }
            if let value = dict["CanaryModel"] as? Int32 {
                self.canaryModel = value
            }
            if let value = dict["Enable"] as? Bool {
                self.enable = value
            }
            if let value = dict["EnableRules"] as? Bool {
                self.enableRules = value
            }
            if let value = dict["LaneId"] as? Int64 {
                self.laneId = value
            }
            if let value = dict["LaneName"] as? String {
                self.laneName = value
            }
            if let value = dict["LaneTag"] as? String {
                self.laneTag = value
            }
            if let value = dict["MseGatewayEntryRule"] as? [String: Any?] {
                var model = DescribeSwimmingLaneResponseBody.Data.MseGatewayEntryRule()
                model.fromMap(value)
                self.mseGatewayEntryRule = model
            }
        }
    }
    public var code: String?

    public var data: DescribeSwimmingLaneResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeSwimmingLaneResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DescribeSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSwimmingLaneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeWebApplicationRequest : Tea.TeaModel {
    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class DescribeWebApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WebApplicationBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WebApplicationBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeWebApplicationResourceStaticsRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var namespaceId: String?

    public var regionId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class DescribeWebApplicationResourceStaticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WebApplicationResourceStaticsBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WebApplicationResourceStaticsBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeWebApplicationRevisionRequest : Tea.TeaModel {
    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class DescribeWebApplicationRevisionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WebApplicationRevisionBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WebApplicationRevisionBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeWebApplicationScalingConfigRequest : Tea.TeaModel {
    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class DescribeWebApplicationScalingConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WebApplicationScalingConfigBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WebApplicationScalingConfigBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeWebApplicationTrafficConfigRequest : Tea.TeaModel {
    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class DescribeWebApplicationTrafficConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WebApplicationTrafficConfigBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WebApplicationTrafficConfigBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeWebCustomDomainRequest : Tea.TeaModel {
    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class DescribeWebCustomDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WebCustomDomain?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WebCustomDomain()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeWebInstanceLogsRequest : Tea.TeaModel {
    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class DescribeWebInstanceLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WebApplicationInstanceLogsBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WebApplicationInstanceLogsBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var scalingRuleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ScalingRuleName"] as? String {
            self.scalingRuleName = value
        }
    }
}

public class DisableApplicationScalingRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DisableApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableApplicationScalingRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DowngradeApplicationApmServiceRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class DowngradeApplicationApmServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var status: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Status"] as? Bool {
                self.status = value
            }
        }
    }
    public var code: String?

    public var data: DowngradeApplicationApmServiceResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DowngradeApplicationApmServiceResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class DowngradeApplicationApmServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DowngradeApplicationApmServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DowngradeApplicationApmServiceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var scalingRuleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ScalingRuleName"] as? String {
            self.scalingRuleName = value
        }
    }
}

public class EnableApplicationScalingRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class EnableApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableApplicationScalingRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExecJobRequest : Tea.TeaModel {
    public var appId: String?

    public var command: String?

    public var commandArgs: String?

    public var envs: String?

    public var eventId: String?

    public var jarStartArgs: String?

    public var jarStartOptions: String?

    public var replicas: String?

    public var time: String?

    public var warStartOptions: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.commandArgs != nil {
            map["CommandArgs"] = self.commandArgs!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.jarStartArgs != nil {
            map["JarStartArgs"] = self.jarStartArgs!
        }
        if self.jarStartOptions != nil {
            map["JarStartOptions"] = self.jarStartOptions!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.time != nil {
            map["Time"] = self.time!
        }
        if self.warStartOptions != nil {
            map["WarStartOptions"] = self.warStartOptions!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Command"] as? String {
            self.command = value
        }
        if let value = dict["CommandArgs"] as? String {
            self.commandArgs = value
        }
        if let value = dict["Envs"] as? String {
            self.envs = value
        }
        if let value = dict["EventId"] as? String {
            self.eventId = value
        }
        if let value = dict["JarStartArgs"] as? String {
            self.jarStartArgs = value
        }
        if let value = dict["JarStartOptions"] as? String {
            self.jarStartOptions = value
        }
        if let value = dict["Replicas"] as? String {
            self.replicas = value
        }
        if let value = dict["Time"] as? String {
            self.time = value
        }
        if let value = dict["WarStartOptions"] as? String {
            self.warStartOptions = value
        }
    }
}

public class ExecJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var code: String?

        public var data: String?

        public var msg: String?

        public var success: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.data != nil {
                map["Data"] = self.data!
            }
            if self.msg != nil {
                map["Msg"] = self.msg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Code"] as? String {
                self.code = value
            }
            if let value = dict["Data"] as? String {
                self.data = value
            }
            if let value = dict["Msg"] as? String {
                self.msg = value
            }
            if let value = dict["Success"] as? String {
                self.success = value
            }
        }
    }
    public var code: String?

    public var data: ExecJobResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ExecJobResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class ExecJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExecJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var appName: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class GetApplicationResponseBody : Tea.TeaModel {
    public class Application : Tea.TeaModel {
        public var appDescription: String?

        public var appId: String?

        public var appName: String?

        public var baseAppId: String?

        public var cpu: Int32?

        public var instances: Int32?

        public var isStateful: Bool?

        public var mem: Int32?

        public var mseEnabled: Bool?

        public var mseNamespaceId: String?

        public var namespaceId: String?

        public var programmingLanguage: String?

        public var runningInstances: Int32?

        public var scaleRuleEnabled: String?

        public var scaleRuleType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appDescription != nil {
                map["AppDescription"] = self.appDescription!
            }
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.baseAppId != nil {
                map["BaseAppId"] = self.baseAppId!
            }
            if self.cpu != nil {
                map["Cpu"] = self.cpu!
            }
            if self.instances != nil {
                map["Instances"] = self.instances!
            }
            if self.isStateful != nil {
                map["IsStateful"] = self.isStateful!
            }
            if self.mem != nil {
                map["Mem"] = self.mem!
            }
            if self.mseEnabled != nil {
                map["MseEnabled"] = self.mseEnabled!
            }
            if self.mseNamespaceId != nil {
                map["MseNamespaceId"] = self.mseNamespaceId!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.programmingLanguage != nil {
                map["ProgrammingLanguage"] = self.programmingLanguage!
            }
            if self.runningInstances != nil {
                map["RunningInstances"] = self.runningInstances!
            }
            if self.scaleRuleEnabled != nil {
                map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
            }
            if self.scaleRuleType != nil {
                map["ScaleRuleType"] = self.scaleRuleType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppDescription"] as? String {
                self.appDescription = value
            }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["BaseAppId"] as? String {
                self.baseAppId = value
            }
            if let value = dict["Cpu"] as? Int32 {
                self.cpu = value
            }
            if let value = dict["Instances"] as? Int32 {
                self.instances = value
            }
            if let value = dict["IsStateful"] as? Bool {
                self.isStateful = value
            }
            if let value = dict["Mem"] as? Int32 {
                self.mem = value
            }
            if let value = dict["MseEnabled"] as? Bool {
                self.mseEnabled = value
            }
            if let value = dict["MseNamespaceId"] as? String {
                self.mseNamespaceId = value
            }
            if let value = dict["NamespaceId"] as? String {
                self.namespaceId = value
            }
            if let value = dict["ProgrammingLanguage"] as? String {
                self.programmingLanguage = value
            }
            if let value = dict["RunningInstances"] as? Int32 {
                self.runningInstances = value
            }
            if let value = dict["ScaleRuleEnabled"] as? String {
                self.scaleRuleEnabled = value
            }
            if let value = dict["ScaleRuleType"] as? String {
                self.scaleRuleType = value
            }
        }
    }
    public var application: GetApplicationResponseBody.Application?

    public var message: String?

    public var requestId: String?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.application?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.application != nil {
            map["Application"] = self.application?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Application"] as? [String: Any?] {
            var model = GetApplicationResponseBody.Application()
            model.fromMap(value)
            self.application = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class GetApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetArmsTopNMetricRequest : Tea.TeaModel {
    public var appSource: String?

    public var cpuStrategy: String?

    public var endTime: Int64?

    public var limit: Int64?

    public var orderBy: String?

    public var regionId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appSource != nil {
            map["AppSource"] = self.appSource!
        }
        if self.cpuStrategy != nil {
            map["CpuStrategy"] = self.cpuStrategy!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppSource"] as? String {
            self.appSource = value
        }
        if let value = dict["CpuStrategy"] as? String {
            self.cpuStrategy = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["Limit"] as? Int64 {
            self.limit = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class GetArmsTopNMetricResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var count: Int64?

        public var error: Int64?

        public var name: String?

        public var regionId: String?

        public var rt: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.count != nil {
                map["Count"] = self.count!
            }
            if self.error != nil {
                map["Error"] = self.error!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.rt != nil {
                map["Rt"] = self.rt!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["Count"] as? Int64 {
                self.count = value
            }
            if let value = dict["Error"] as? Int64 {
                self.error = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["Rt"] as? Int64 {
                self.rt = value
            }
        }
    }
    public var code: String?

    public var data: [GetArmsTopNMetricResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [GetArmsTopNMetricResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = GetArmsTopNMetricResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetArmsTopNMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetArmsTopNMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetArmsTopNMetricResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetAvailabilityMetricRequest : Tea.TeaModel {
    public var appSource: String?

    public var cpuStrategy: String?

    public var limit: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appSource != nil {
            map["AppSource"] = self.appSource!
        }
        if self.cpuStrategy != nil {
            map["CpuStrategy"] = self.cpuStrategy!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppSource"] as? String {
            self.appSource = value
        }
        if let value = dict["CpuStrategy"] as? String {
            self.cpuStrategy = value
        }
        if let value = dict["Limit"] as? Int64 {
            self.limit = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class GetAvailabilityMetricResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var enableAutoscale: Int64?

        public var errorInstances: Int64?

        public var instances: Int64?

        public var name: String?

        public var regionId: String?

        public var runnings: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.enableAutoscale != nil {
                map["EnableAutoscale"] = self.enableAutoscale!
            }
            if self.errorInstances != nil {
                map["ErrorInstances"] = self.errorInstances!
            }
            if self.instances != nil {
                map["Instances"] = self.instances!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.runnings != nil {
                map["Runnings"] = self.runnings!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["EnableAutoscale"] as? Int64 {
                self.enableAutoscale = value
            }
            if let value = dict["ErrorInstances"] as? Int64 {
                self.errorInstances = value
            }
            if let value = dict["Instances"] as? Int64 {
                self.instances = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["Runnings"] as? Int64 {
                self.runnings = value
            }
        }
    }
    public var code: String?

    public var data: [GetAvailabilityMetricResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [GetAvailabilityMetricResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = GetAvailabilityMetricResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetAvailabilityMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAvailabilityMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetAvailabilityMetricResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetChangeOrderMetricRequest : Tea.TeaModel {
    public var appId: String?

    public var appSource: String?

    public var coType: String?

    public var cpuStrategy: String?

    public var createTime: String?

    public var limit: Int64?

    public var orderBy: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appSource != nil {
            map["AppSource"] = self.appSource!
        }
        if self.coType != nil {
            map["CoType"] = self.coType!
        }
        if self.cpuStrategy != nil {
            map["CpuStrategy"] = self.cpuStrategy!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AppSource"] as? String {
            self.appSource = value
        }
        if let value = dict["CoType"] as? String {
            self.coType = value
        }
        if let value = dict["CpuStrategy"] as? String {
            self.cpuStrategy = value
        }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["Limit"] as? Int64 {
            self.limit = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class GetChangeOrderMetricResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var avgTimeCostMs: Double?

        public var error: Int64?

        public var errorPercent: Double?

        public var maxTimeCostMs: Double?

        public var name: String?

        public var optimizeSuggestions: String?

        public var regionId: String?

        public var taskTimeCostMsAvg: String?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.avgTimeCostMs != nil {
                map["AvgTimeCostMs"] = self.avgTimeCostMs!
            }
            if self.error != nil {
                map["Error"] = self.error!
            }
            if self.errorPercent != nil {
                map["ErrorPercent"] = self.errorPercent!
            }
            if self.maxTimeCostMs != nil {
                map["MaxTimeCostMs"] = self.maxTimeCostMs!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.optimizeSuggestions != nil {
                map["OptimizeSuggestions"] = self.optimizeSuggestions!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.taskTimeCostMsAvg != nil {
                map["TaskTimeCostMsAvg"] = self.taskTimeCostMsAvg!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AvgTimeCostMs"] as? Double {
                self.avgTimeCostMs = value
            }
            if let value = dict["Error"] as? Int64 {
                self.error = value
            }
            if let value = dict["ErrorPercent"] as? Double {
                self.errorPercent = value
            }
            if let value = dict["MaxTimeCostMs"] as? Double {
                self.maxTimeCostMs = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["OptimizeSuggestions"] as? String {
                self.optimizeSuggestions = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["TaskTimeCostMsAvg"] as? String {
                self.taskTimeCostMsAvg = value
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var code: String?

    public var data: [GetChangeOrderMetricResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [GetChangeOrderMetricResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = GetChangeOrderMetricResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetChangeOrderMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetChangeOrderMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetChangeOrderMetricResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetScaleAppMetricRequest : Tea.TeaModel {
    public var appSource: String?

    public var cpuStrategy: String?

    public var limit: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appSource != nil {
            map["AppSource"] = self.appSource!
        }
        if self.cpuStrategy != nil {
            map["CpuStrategy"] = self.cpuStrategy!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppSource"] as? String {
            self.appSource = value
        }
        if let value = dict["CpuStrategy"] as? String {
            self.cpuStrategy = value
        }
        if let value = dict["Limit"] as? Int64 {
            self.limit = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class GetScaleAppMetricResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var maxReplicas: Int64?

        public var name: String?

        public var regionId: String?

        public var runnings: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.maxReplicas != nil {
                map["MaxReplicas"] = self.maxReplicas!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.runnings != nil {
                map["Runnings"] = self.runnings!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["MaxReplicas"] as? Int64 {
                self.maxReplicas = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["Runnings"] as? Int64 {
                self.runnings = value
            }
        }
    }
    public var code: String?

    public var data: [GetScaleAppMetricResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [GetScaleAppMetricResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = GetScaleAppMetricResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetScaleAppMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetScaleAppMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetScaleAppMetricResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetWarningEventMetricRequest : Tea.TeaModel {
    public var appSource: String?

    public var cpuStrategy: String?

    public var endTime: Int64?

    public var limit: Int64?

    public var regionId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appSource != nil {
            map["AppSource"] = self.appSource!
        }
        if self.cpuStrategy != nil {
            map["CpuStrategy"] = self.cpuStrategy!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppSource"] as? String {
            self.appSource = value
        }
        if let value = dict["CpuStrategy"] as? String {
            self.cpuStrategy = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["Limit"] as? Int64 {
            self.limit = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class GetWarningEventMetricResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var name: String?

        public var regionId: String?

        public var warningCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.warningCount != nil {
                map["WarningCount"] = self.warningCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["WarningCount"] as? Int64 {
                self.warningCount = value
            }
        }
    }
    public var code: String?

    public var data: [GetWarningEventMetricResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [GetWarningEventMetricResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = GetWarningEventMetricResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetWarningEventMetricResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWarningEventMetricResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetWarningEventMetricResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetWebshellTokenRequest : Tea.TeaModel {
    public var appId: String?

    public var containerName: String?

    public var podName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.containerName != nil {
            map["ContainerName"] = self.containerName!
        }
        if self.podName != nil {
            map["PodName"] = self.podName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["ContainerName"] as? String {
            self.containerName = value
        }
        if let value = dict["PodName"] as? String {
            self.podName = value
        }
    }
}

public class GetWebshellTokenResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var httpUrl: String?

        public var token: String?

        public var webSocketUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.httpUrl != nil {
                map["HttpUrl"] = self.httpUrl!
            }
            if self.token != nil {
                map["Token"] = self.token!
            }
            if self.webSocketUrl != nil {
                map["WebSocketUrl"] = self.webSocketUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["HttpUrl"] as? String {
                self.httpUrl = value
            }
            if let value = dict["Token"] as? String {
                self.token = value
            }
            if let value = dict["WebSocketUrl"] as? String {
                self.webSocketUrl = value
            }
        }
    }
    public var code: String?

    public var data: GetWebshellTokenResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetWebshellTokenResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class GetWebshellTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetWebshellTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetWebshellTokenResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAllSwimmingLaneGroupsRequest : Tea.TeaModel {
    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class ListAllSwimmingLaneGroupsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Apps : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var mseAppId: String?

            public var mseAppName: String?

            public var mseNamespaceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.mseAppId != nil {
                    map["MseAppId"] = self.mseAppId!
                }
                if self.mseAppName != nil {
                    map["MseAppName"] = self.mseAppName!
                }
                if self.mseNamespaceId != nil {
                    map["MseNamespaceId"] = self.mseNamespaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["MseAppId"] as? String {
                    self.mseAppId = value
                }
                if let value = dict["MseAppName"] as? String {
                    self.mseAppName = value
                }
                if let value = dict["MseNamespaceId"] as? String {
                    self.mseNamespaceId = value
                }
            }
        }
        public class EntryApp : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var appType: String?

            public var mseAppId: String?

            public var mseAppName: String?

            public var mseNamespaceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.appType != nil {
                    map["AppType"] = self.appType!
                }
                if self.mseAppId != nil {
                    map["MseAppId"] = self.mseAppId!
                }
                if self.mseAppName != nil {
                    map["MseAppName"] = self.mseAppName!
                }
                if self.mseNamespaceId != nil {
                    map["MseNamespaceId"] = self.mseNamespaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["AppType"] as? String {
                    self.appType = value
                }
                if let value = dict["MseAppId"] as? String {
                    self.mseAppId = value
                }
                if let value = dict["MseAppName"] as? String {
                    self.mseAppName = value
                }
                if let value = dict["MseNamespaceId"] as? String {
                    self.mseNamespaceId = value
                }
            }
        }
        public var appIds: [String]?

        public var apps: [ListAllSwimmingLaneGroupsResponseBody.Data.Apps]?

        public var canaryModel: Int32?

        public var entryApp: ListAllSwimmingLaneGroupsResponseBody.Data.EntryApp?

        public var entryAppId: String?

        public var entryAppType: String?

        public var groupId: Int64?

        public var groupName: String?

        public var mseNamespaceId: String?

        public var namespaceId: String?

        public var swimVersion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.entryApp?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appIds != nil {
                map["AppIds"] = self.appIds!
            }
            if self.apps != nil {
                var tmp : [Any] = []
                for k in self.apps! {
                    tmp.append(k.toMap())
                }
                map["Apps"] = tmp
            }
            if self.canaryModel != nil {
                map["CanaryModel"] = self.canaryModel!
            }
            if self.entryApp != nil {
                map["EntryApp"] = self.entryApp?.toMap()
            }
            if self.entryAppId != nil {
                map["EntryAppId"] = self.entryAppId!
            }
            if self.entryAppType != nil {
                map["EntryAppType"] = self.entryAppType!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.mseNamespaceId != nil {
                map["MseNamespaceId"] = self.mseNamespaceId!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.swimVersion != nil {
                map["SwimVersion"] = self.swimVersion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppIds"] as? [String] {
                self.appIds = value
            }
            if let value = dict["Apps"] as? [Any?] {
                var tmp : [ListAllSwimmingLaneGroupsResponseBody.Data.Apps] = []
                for v in value {
                    if v != nil {
                        var model = ListAllSwimmingLaneGroupsResponseBody.Data.Apps()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.apps = tmp
            }
            if let value = dict["CanaryModel"] as? Int32 {
                self.canaryModel = value
            }
            if let value = dict["EntryApp"] as? [String: Any?] {
                var model = ListAllSwimmingLaneGroupsResponseBody.Data.EntryApp()
                model.fromMap(value)
                self.entryApp = model
            }
            if let value = dict["EntryAppId"] as? String {
                self.entryAppId = value
            }
            if let value = dict["EntryAppType"] as? String {
                self.entryAppType = value
            }
            if let value = dict["GroupId"] as? Int64 {
                self.groupId = value
            }
            if let value = dict["GroupName"] as? String {
                self.groupName = value
            }
            if let value = dict["MseNamespaceId"] as? String {
                self.mseNamespaceId = value
            }
            if let value = dict["NamespaceId"] as? String {
                self.namespaceId = value
            }
            if let value = dict["SwimVersion"] as? String {
                self.swimVersion = value
            }
        }
    }
    public var code: String?

    public var data: [ListAllSwimmingLaneGroupsResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListAllSwimmingLaneGroupsResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListAllSwimmingLaneGroupsResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class ListAllSwimmingLaneGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAllSwimmingLaneGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAllSwimmingLaneGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAllSwimmingLanesRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? Int64 {
            self.groupId = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class ListAllSwimmingLanesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AppEntryRule : Tea.TeaModel {
            public class Conditions : Tea.TeaModel {
                public var condition: String?

                public var name: String?

                public var type: String?

                public var value: String?

                public var values: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.condition != nil {
                        map["Condition"] = self.condition!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    if self.values != nil {
                        map["Values"] = self.values!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Condition"] as? String {
                        self.condition = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                    if let value = dict["Values"] as? [String] {
                        self.values = value
                    }
                }
            }
            public var conditionJoiner: String?

            public var conditions: [ListAllSwimmingLanesResponseBody.Data.AppEntryRule.Conditions]?

            public var independentPercentageEnable: Bool?

            public var paths: [String]?

            public var percentage: Int32?

            public var percentageByPath: [String: Int32]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.conditionJoiner != nil {
                    map["ConditionJoiner"] = self.conditionJoiner!
                }
                if self.conditions != nil {
                    var tmp : [Any] = []
                    for k in self.conditions! {
                        tmp.append(k.toMap())
                    }
                    map["Conditions"] = tmp
                }
                if self.independentPercentageEnable != nil {
                    map["IndependentPercentageEnable"] = self.independentPercentageEnable!
                }
                if self.paths != nil {
                    map["Paths"] = self.paths!
                }
                if self.percentage != nil {
                    map["Percentage"] = self.percentage!
                }
                if self.percentageByPath != nil {
                    map["PercentageByPath"] = self.percentageByPath!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConditionJoiner"] as? String {
                    self.conditionJoiner = value
                }
                if let value = dict["Conditions"] as? [Any?] {
                    var tmp : [ListAllSwimmingLanesResponseBody.Data.AppEntryRule.Conditions] = []
                    for v in value {
                        if v != nil {
                            var model = ListAllSwimmingLanesResponseBody.Data.AppEntryRule.Conditions()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.conditions = tmp
                }
                if let value = dict["IndependentPercentageEnable"] as? Bool {
                    self.independentPercentageEnable = value
                }
                if let value = dict["Paths"] as? [String] {
                    self.paths = value
                }
                if let value = dict["Percentage"] as? Int32 {
                    self.percentage = value
                }
                if let value = dict["PercentageByPath"] as? [String: Int32] {
                    self.percentageByPath = value
                }
            }
        }
        public class Apps : Tea.TeaModel {
            public var appId: String?

            public var appName: String?

            public var mseAppId: String?

            public var mseAppName: String?

            public var mseNamespaceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.mseAppId != nil {
                    map["MseAppId"] = self.mseAppId!
                }
                if self.mseAppName != nil {
                    map["MseAppName"] = self.mseAppName!
                }
                if self.mseNamespaceId != nil {
                    map["MseNamespaceId"] = self.mseNamespaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["MseAppId"] as? String {
                    self.mseAppId = value
                }
                if let value = dict["MseAppName"] as? String {
                    self.mseAppName = value
                }
                if let value = dict["MseNamespaceId"] as? String {
                    self.mseNamespaceId = value
                }
            }
        }
        public class MseGatewayEntryRule : Tea.TeaModel {
            public class Conditions : Tea.TeaModel {
                public var condition: String?

                public var name: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.condition != nil {
                        map["Condition"] = self.condition!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Condition"] as? String {
                        self.condition = value
                    }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public class Routes : Tea.TeaModel {
                public class RoutePredicate : Tea.TeaModel {
                    public class PathPredicate : Tea.TeaModel {
                        public var path: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.path != nil {
                                map["path"] = self.path!
                            }
                            if self.type != nil {
                                map["type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["path"] as? String {
                                self.path = value
                            }
                            if let value = dict["type"] as? String {
                                self.type = value
                            }
                        }
                    }
                    public var pathPredicate: ListAllSwimmingLanesResponseBody.Data.MseGatewayEntryRule.Routes.RoutePredicate.PathPredicate?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.pathPredicate?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.pathPredicate != nil {
                            map["PathPredicate"] = self.pathPredicate?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["PathPredicate"] as? [String: Any?] {
                            var model = ListAllSwimmingLanesResponseBody.Data.MseGatewayEntryRule.Routes.RoutePredicate.PathPredicate()
                            model.fromMap(value)
                            self.pathPredicate = model
                        }
                    }
                }
                public var routeId: Int64?

                public var routeName: String?

                public var routePredicate: ListAllSwimmingLanesResponseBody.Data.MseGatewayEntryRule.Routes.RoutePredicate?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.routePredicate?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.routeId != nil {
                        map["RouteId"] = self.routeId!
                    }
                    if self.routeName != nil {
                        map["RouteName"] = self.routeName!
                    }
                    if self.routePredicate != nil {
                        map["RoutePredicate"] = self.routePredicate?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["RouteId"] as? Int64 {
                        self.routeId = value
                    }
                    if let value = dict["RouteName"] as? String {
                        self.routeName = value
                    }
                    if let value = dict["RoutePredicate"] as? [String: Any?] {
                        var model = ListAllSwimmingLanesResponseBody.Data.MseGatewayEntryRule.Routes.RoutePredicate()
                        model.fromMap(value)
                        self.routePredicate = model
                    }
                }
            }
            public var conditionJoiner: String?

            public var conditions: [ListAllSwimmingLanesResponseBody.Data.MseGatewayEntryRule.Conditions]?

            public var independentPercentageEnable: Bool?

            public var percentage: Int32?

            public var percentageByRoute: [String: Int32]?

            public var routeIds: [Int64]?

            public var routes: [ListAllSwimmingLanesResponseBody.Data.MseGatewayEntryRule.Routes]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.conditionJoiner != nil {
                    map["ConditionJoiner"] = self.conditionJoiner!
                }
                if self.conditions != nil {
                    var tmp : [Any] = []
                    for k in self.conditions! {
                        tmp.append(k.toMap())
                    }
                    map["Conditions"] = tmp
                }
                if self.independentPercentageEnable != nil {
                    map["IndependentPercentageEnable"] = self.independentPercentageEnable!
                }
                if self.percentage != nil {
                    map["Percentage"] = self.percentage!
                }
                if self.percentageByRoute != nil {
                    map["PercentageByRoute"] = self.percentageByRoute!
                }
                if self.routeIds != nil {
                    map["RouteIds"] = self.routeIds!
                }
                if self.routes != nil {
                    var tmp : [Any] = []
                    for k in self.routes! {
                        tmp.append(k.toMap())
                    }
                    map["Routes"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConditionJoiner"] as? String {
                    self.conditionJoiner = value
                }
                if let value = dict["Conditions"] as? [Any?] {
                    var tmp : [ListAllSwimmingLanesResponseBody.Data.MseGatewayEntryRule.Conditions] = []
                    for v in value {
                        if v != nil {
                            var model = ListAllSwimmingLanesResponseBody.Data.MseGatewayEntryRule.Conditions()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.conditions = tmp
                }
                if let value = dict["IndependentPercentageEnable"] as? Bool {
                    self.independentPercentageEnable = value
                }
                if let value = dict["Percentage"] as? Int32 {
                    self.percentage = value
                }
                if let value = dict["PercentageByRoute"] as? [String: Int32] {
                    self.percentageByRoute = value
                }
                if let value = dict["RouteIds"] as? [Int64] {
                    self.routeIds = value
                }
                if let value = dict["Routes"] as? [Any?] {
                    var tmp : [ListAllSwimmingLanesResponseBody.Data.MseGatewayEntryRule.Routes] = []
                    for v in value {
                        if v != nil {
                            var model = ListAllSwimmingLanesResponseBody.Data.MseGatewayEntryRule.Routes()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.routes = tmp
                }
            }
        }
        public var appEntryRule: ListAllSwimmingLanesResponseBody.Data.AppEntryRule?

        public var apps: [ListAllSwimmingLanesResponseBody.Data.Apps]?

        public var canaryModel: Int32?

        public var enable: Bool?

        public var enableRules: Bool?

        public var laneId: Int64?

        public var laneName: String?

        public var laneTag: String?

        public var mseGatewayEntryRule: ListAllSwimmingLanesResponseBody.Data.MseGatewayEntryRule?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.appEntryRule?.validate()
            try self.mseGatewayEntryRule?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appEntryRule != nil {
                map["AppEntryRule"] = self.appEntryRule?.toMap()
            }
            if self.apps != nil {
                var tmp : [Any] = []
                for k in self.apps! {
                    tmp.append(k.toMap())
                }
                map["Apps"] = tmp
            }
            if self.canaryModel != nil {
                map["CanaryModel"] = self.canaryModel!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.enableRules != nil {
                map["EnableRules"] = self.enableRules!
            }
            if self.laneId != nil {
                map["LaneId"] = self.laneId!
            }
            if self.laneName != nil {
                map["LaneName"] = self.laneName!
            }
            if self.laneTag != nil {
                map["LaneTag"] = self.laneTag!
            }
            if self.mseGatewayEntryRule != nil {
                map["MseGatewayEntryRule"] = self.mseGatewayEntryRule?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppEntryRule"] as? [String: Any?] {
                var model = ListAllSwimmingLanesResponseBody.Data.AppEntryRule()
                model.fromMap(value)
                self.appEntryRule = model
            }
            if let value = dict["Apps"] as? [Any?] {
                var tmp : [ListAllSwimmingLanesResponseBody.Data.Apps] = []
                for v in value {
                    if v != nil {
                        var model = ListAllSwimmingLanesResponseBody.Data.Apps()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.apps = tmp
            }
            if let value = dict["CanaryModel"] as? Int32 {
                self.canaryModel = value
            }
            if let value = dict["Enable"] as? Bool {
                self.enable = value
            }
            if let value = dict["EnableRules"] as? Bool {
                self.enableRules = value
            }
            if let value = dict["LaneId"] as? Int64 {
                self.laneId = value
            }
            if let value = dict["LaneName"] as? String {
                self.laneName = value
            }
            if let value = dict["LaneTag"] as? String {
                self.laneTag = value
            }
            if let value = dict["MseGatewayEntryRule"] as? [String: Any?] {
                var model = ListAllSwimmingLanesResponseBody.Data.MseGatewayEntryRule()
                model.fromMap(value)
                self.mseGatewayEntryRule = model
            }
        }
    }
    public var code: String?

    public var data: [ListAllSwimmingLanesResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListAllSwimmingLanesResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListAllSwimmingLanesResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class ListAllSwimmingLanesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAllSwimmingLanesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAllSwimmingLanesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAppEventsRequest : Tea.TeaModel {
    public var appId: String?

    public var currentPage: Int32?

    public var eventType: String?

    public var namespace: String?

    public var objectKind: String?

    public var objectName: String?

    public var pageSize: Int32?

    public var reason: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.objectKind != nil {
            map["ObjectKind"] = self.objectKind!
        }
        if self.objectName != nil {
            map["ObjectName"] = self.objectName!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["CurrentPage"] as? Int32 {
            self.currentPage = value
        }
        if let value = dict["EventType"] as? String {
            self.eventType = value
        }
        if let value = dict["Namespace"] as? String {
            self.namespace = value
        }
        if let value = dict["ObjectKind"] as? String {
            self.objectKind = value
        }
        if let value = dict["ObjectName"] as? String {
            self.objectName = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Reason"] as? String {
            self.reason = value
        }
    }
}

public class ListAppEventsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AppEventEntity : Tea.TeaModel {
            public var causeAnalysis: String?

            public var eventType: String?

            public var firstTimestamp: String?

            public var lastTimestamp: String?

            public var message: String?

            public var objectKind: String?

            public var objectName: String?

            public var reason: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.causeAnalysis != nil {
                    map["CauseAnalysis"] = self.causeAnalysis!
                }
                if self.eventType != nil {
                    map["EventType"] = self.eventType!
                }
                if self.firstTimestamp != nil {
                    map["FirstTimestamp"] = self.firstTimestamp!
                }
                if self.lastTimestamp != nil {
                    map["LastTimestamp"] = self.lastTimestamp!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.objectKind != nil {
                    map["ObjectKind"] = self.objectKind!
                }
                if self.objectName != nil {
                    map["ObjectName"] = self.objectName!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CauseAnalysis"] as? String {
                    self.causeAnalysis = value
                }
                if let value = dict["EventType"] as? String {
                    self.eventType = value
                }
                if let value = dict["FirstTimestamp"] as? String {
                    self.firstTimestamp = value
                }
                if let value = dict["LastTimestamp"] as? String {
                    self.lastTimestamp = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
                if let value = dict["ObjectKind"] as? String {
                    self.objectKind = value
                }
                if let value = dict["ObjectName"] as? String {
                    self.objectName = value
                }
                if let value = dict["Reason"] as? String {
                    self.reason = value
                }
            }
        }
        public var appEventEntity: [ListAppEventsResponseBody.Data.AppEventEntity]?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appEventEntity != nil {
                var tmp : [Any] = []
                for k in self.appEventEntity! {
                    tmp.append(k.toMap())
                }
                map["AppEventEntity"] = tmp
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppEventEntity"] as? [Any?] {
                var tmp : [ListAppEventsResponseBody.Data.AppEventEntity] = []
                for v in value {
                    if v != nil {
                        var model = ListAppEventsResponseBody.Data.AppEventEntity()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.appEventEntity = tmp
            }
            if let value = dict["CurrentPage"] as? Int32 {
                self.currentPage = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalSize"] as? Int32 {
                self.totalSize = value
            }
        }
    }
    public var code: String?

    public var data: ListAppEventsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListAppEventsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListAppEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAppEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAppEventsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAppServicesRequest : Tea.TeaModel {
    public var appId: String?

    public var nacosInstanceId: String?

    public var nacosNamespaceId: String?

    public var namespaceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var registryType: String?

    public var serviceType: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.nacosInstanceId != nil {
            map["NacosInstanceId"] = self.nacosInstanceId!
        }
        if self.nacosNamespaceId != nil {
            map["NacosNamespaceId"] = self.nacosNamespaceId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.registryType != nil {
            map["RegistryType"] = self.registryType!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["NacosInstanceId"] as? String {
            self.nacosInstanceId = value
        }
        if let value = dict["NacosNamespaceId"] as? String {
            self.nacosNamespaceId = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegistryType"] as? String {
            self.registryType = value
        }
        if let value = dict["ServiceType"] as? String {
            self.serviceType = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class ListAppServicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var instanceCount: String?

        public var namespaceId: String?

        public var namespaceName: String?

        public var registryType: String?

        public var securityGroupId: String?

        public var serviceGroup: String?

        public var serviceName: String?

        public var servicePortAndProtocol: [String: String]?

        public var servicePorts: [Int32]?

        public var serviceProtocol: String?

        public var serviceType: String?

        public var serviceVersion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.namespaceName != nil {
                map["NamespaceName"] = self.namespaceName!
            }
            if self.registryType != nil {
                map["RegistryType"] = self.registryType!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.serviceGroup != nil {
                map["ServiceGroup"] = self.serviceGroup!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.servicePortAndProtocol != nil {
                map["ServicePortAndProtocol"] = self.servicePortAndProtocol!
            }
            if self.servicePorts != nil {
                map["ServicePorts"] = self.servicePorts!
            }
            if self.serviceProtocol != nil {
                map["ServiceProtocol"] = self.serviceProtocol!
            }
            if self.serviceType != nil {
                map["ServiceType"] = self.serviceType!
            }
            if self.serviceVersion != nil {
                map["ServiceVersion"] = self.serviceVersion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["InstanceCount"] as? String {
                self.instanceCount = value
            }
            if let value = dict["NamespaceId"] as? String {
                self.namespaceId = value
            }
            if let value = dict["NamespaceName"] as? String {
                self.namespaceName = value
            }
            if let value = dict["RegistryType"] as? String {
                self.registryType = value
            }
            if let value = dict["SecurityGroupId"] as? String {
                self.securityGroupId = value
            }
            if let value = dict["ServiceGroup"] as? String {
                self.serviceGroup = value
            }
            if let value = dict["ServiceName"] as? String {
                self.serviceName = value
            }
            if let value = dict["ServicePortAndProtocol"] as? [String: String] {
                self.servicePortAndProtocol = value
            }
            if let value = dict["ServicePorts"] as? [Int32] {
                self.servicePorts = value
            }
            if let value = dict["ServiceProtocol"] as? String {
                self.serviceProtocol = value
            }
            if let value = dict["ServiceType"] as? String {
                self.serviceType = value
            }
            if let value = dict["ServiceVersion"] as? String {
                self.serviceVersion = value
            }
        }
    }
    public var code: String?

    public var data: [ListAppServicesResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListAppServicesResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListAppServicesResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class ListAppServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAppServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAppServicesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAppServicesPageRequest : Tea.TeaModel {
    public var appId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var serviceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.serviceType != nil {
            map["ServiceType"] = self.serviceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ServiceType"] as? String {
            self.serviceType = value
        }
    }
}

public class ListAppServicesPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var edasAppId: String?

            public var edasAppName: String?

            public var group: String?

            public var instanceNum: Int64?

            public var serviceName: String?

            public var version: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.edasAppId != nil {
                    map["EdasAppId"] = self.edasAppId!
                }
                if self.edasAppName != nil {
                    map["EdasAppName"] = self.edasAppName!
                }
                if self.group != nil {
                    map["Group"] = self.group!
                }
                if self.instanceNum != nil {
                    map["InstanceNum"] = self.instanceNum!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EdasAppId"] as? String {
                    self.edasAppId = value
                }
                if let value = dict["EdasAppName"] as? String {
                    self.edasAppName = value
                }
                if let value = dict["Group"] as? String {
                    self.group = value
                }
                if let value = dict["InstanceNum"] as? Int64 {
                    self.instanceNum = value
                }
                if let value = dict["ServiceName"] as? String {
                    self.serviceName = value
                }
                if let value = dict["Version"] as? String {
                    self.version = value
                }
            }
        }
        public var currentPage: String?

        public var pageNumber: String?

        public var pageSize: String?

        public var result: [ListAppServicesPageResponseBody.Data.Result]?

        public var totalSize: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CurrentPage"] as? String {
                self.currentPage = value
            }
            if let value = dict["PageNumber"] as? String {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? String {
                self.pageSize = value
            }
            if let value = dict["Result"] as? [Any?] {
                var tmp : [ListAppServicesPageResponseBody.Data.Result] = []
                for v in value {
                    if v != nil {
                        var model = ListAppServicesPageResponseBody.Data.Result()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.result = tmp
            }
            if let value = dict["TotalSize"] as? String {
                self.totalSize = value
            }
        }
    }
    public var code: String?

    public var data: [ListAppServicesPageResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListAppServicesPageResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListAppServicesPageResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class ListAppServicesPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAppServicesPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAppServicesPageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAppVersionsRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class ListAppVersionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var buildPackageUrl: String?

        public var createTime: String?

        public var id: String?

        public var type: String?

        public var warUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.buildPackageUrl != nil {
                map["BuildPackageUrl"] = self.buildPackageUrl!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.warUrl != nil {
                map["WarUrl"] = self.warUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["BuildPackageUrl"] as? String {
                self.buildPackageUrl = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["WarUrl"] as? String {
                self.warUrl = value
            }
        }
    }
    public var code: String?

    public var data: [ListAppVersionsResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListAppVersionsResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListAppVersionsResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListAppVersionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAppVersionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAppVersionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListApplicationsRequest : Tea.TeaModel {
    public var appName: String?

    public var appSource: String?

    public var currentPage: Int32?

    public var fieldType: String?

    public var fieldValue: String?

    public var isStateful: String?

    public var namespaceId: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var reverse: Bool?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.appSource != nil {
            map["AppSource"] = self.appSource!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.fieldType != nil {
            map["FieldType"] = self.fieldType!
        }
        if self.fieldValue != nil {
            map["FieldValue"] = self.fieldValue!
        }
        if self.isStateful != nil {
            map["IsStateful"] = self.isStateful!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.reverse != nil {
            map["Reverse"] = self.reverse!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["AppSource"] as? String {
            self.appSource = value
        }
        if let value = dict["CurrentPage"] as? Int32 {
            self.currentPage = value
        }
        if let value = dict["FieldType"] as? String {
            self.fieldType = value
        }
        if let value = dict["FieldValue"] as? String {
            self.fieldValue = value
        }
        if let value = dict["IsStateful"] as? String {
            self.isStateful = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Reverse"] as? Bool {
            self.reverse = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
    }
}

public class ListApplicationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Applications : Tea.TeaModel {
            public class Children : Tea.TeaModel {
                public class Tags : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var appDeletingStatus: Bool?

                public var appDescription: String?

                public var appId: String?

                public var appName: String?

                public var appType: String?

                public var baseAppId: String?

                public var cpu: Int32?

                public var instances: Int32?

                public var isStateful: Bool?

                public var mem: Int32?

                public var mseEnabled: Bool?

                public var namespaceId: String?

                public var namespaceName: String?

                public var newSaeVersion: String?

                public var programmingLanguage: String?

                public var regionId: String?

                public var runningInstances: Int32?

                public var scaleRuleEnabled: Bool?

                public var scaleRuleType: String?

                public var tags: [ListApplicationsResponseBody.Data.Applications.Children.Tags]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appDeletingStatus != nil {
                        map["AppDeletingStatus"] = self.appDeletingStatus!
                    }
                    if self.appDescription != nil {
                        map["AppDescription"] = self.appDescription!
                    }
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appName != nil {
                        map["AppName"] = self.appName!
                    }
                    if self.appType != nil {
                        map["AppType"] = self.appType!
                    }
                    if self.baseAppId != nil {
                        map["BaseAppId"] = self.baseAppId!
                    }
                    if self.cpu != nil {
                        map["Cpu"] = self.cpu!
                    }
                    if self.instances != nil {
                        map["Instances"] = self.instances!
                    }
                    if self.isStateful != nil {
                        map["IsStateful"] = self.isStateful!
                    }
                    if self.mem != nil {
                        map["Mem"] = self.mem!
                    }
                    if self.mseEnabled != nil {
                        map["MseEnabled"] = self.mseEnabled!
                    }
                    if self.namespaceId != nil {
                        map["NamespaceId"] = self.namespaceId!
                    }
                    if self.namespaceName != nil {
                        map["NamespaceName"] = self.namespaceName!
                    }
                    if self.newSaeVersion != nil {
                        map["NewSaeVersion"] = self.newSaeVersion!
                    }
                    if self.programmingLanguage != nil {
                        map["ProgrammingLanguage"] = self.programmingLanguage!
                    }
                    if self.regionId != nil {
                        map["RegionId"] = self.regionId!
                    }
                    if self.runningInstances != nil {
                        map["RunningInstances"] = self.runningInstances!
                    }
                    if self.scaleRuleEnabled != nil {
                        map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
                    }
                    if self.scaleRuleType != nil {
                        map["ScaleRuleType"] = self.scaleRuleType!
                    }
                    if self.tags != nil {
                        var tmp : [Any] = []
                        for k in self.tags! {
                            tmp.append(k.toMap())
                        }
                        map["Tags"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AppDeletingStatus"] as? Bool {
                        self.appDeletingStatus = value
                    }
                    if let value = dict["AppDescription"] as? String {
                        self.appDescription = value
                    }
                    if let value = dict["AppId"] as? String {
                        self.appId = value
                    }
                    if let value = dict["AppName"] as? String {
                        self.appName = value
                    }
                    if let value = dict["AppType"] as? String {
                        self.appType = value
                    }
                    if let value = dict["BaseAppId"] as? String {
                        self.baseAppId = value
                    }
                    if let value = dict["Cpu"] as? Int32 {
                        self.cpu = value
                    }
                    if let value = dict["Instances"] as? Int32 {
                        self.instances = value
                    }
                    if let value = dict["IsStateful"] as? Bool {
                        self.isStateful = value
                    }
                    if let value = dict["Mem"] as? Int32 {
                        self.mem = value
                    }
                    if let value = dict["MseEnabled"] as? Bool {
                        self.mseEnabled = value
                    }
                    if let value = dict["NamespaceId"] as? String {
                        self.namespaceId = value
                    }
                    if let value = dict["NamespaceName"] as? String {
                        self.namespaceName = value
                    }
                    if let value = dict["NewSaeVersion"] as? String {
                        self.newSaeVersion = value
                    }
                    if let value = dict["ProgrammingLanguage"] as? String {
                        self.programmingLanguage = value
                    }
                    if let value = dict["RegionId"] as? String {
                        self.regionId = value
                    }
                    if let value = dict["RunningInstances"] as? Int32 {
                        self.runningInstances = value
                    }
                    if let value = dict["ScaleRuleEnabled"] as? Bool {
                        self.scaleRuleEnabled = value
                    }
                    if let value = dict["ScaleRuleType"] as? String {
                        self.scaleRuleType = value
                    }
                    if let value = dict["Tags"] as? [Any?] {
                        var tmp : [ListApplicationsResponseBody.Data.Applications.Children.Tags] = []
                        for v in value {
                            if v != nil {
                                var model = ListApplicationsResponseBody.Data.Applications.Children.Tags()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tags = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var appDeletingStatus: Bool?

            public var appDescription: String?

            public var appId: String?

            public var appName: String?

            public var appType: String?

            public var baseAppId: String?

            public var children: [ListApplicationsResponseBody.Data.Applications.Children]?

            public var cpu: Int32?

            public var diskSize: Int32?

            public var enableIdle: String?

            public var imageUrl: String?

            public var instances: Int32?

            public var isStateful: Bool?

            public var mem: Int32?

            public var mseEnabled: Bool?

            public var mseNamespaceId: String?

            public var namespaceId: String?

            public var namespaceName: String?

            public var newSaeVersion: String?

            public var packageUrl: String?

            public var programmingLanguage: String?

            public var regionId: String?

            public var runningInstances: Int32?

            public var tags: [ListApplicationsResponseBody.Data.Applications.Tags]?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appDeletingStatus != nil {
                    map["AppDeletingStatus"] = self.appDeletingStatus!
                }
                if self.appDescription != nil {
                    map["AppDescription"] = self.appDescription!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.appType != nil {
                    map["AppType"] = self.appType!
                }
                if self.baseAppId != nil {
                    map["BaseAppId"] = self.baseAppId!
                }
                if self.children != nil {
                    var tmp : [Any] = []
                    for k in self.children! {
                        tmp.append(k.toMap())
                    }
                    map["Children"] = tmp
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.diskSize != nil {
                    map["DiskSize"] = self.diskSize!
                }
                if self.enableIdle != nil {
                    map["EnableIdle"] = self.enableIdle!
                }
                if self.imageUrl != nil {
                    map["ImageUrl"] = self.imageUrl!
                }
                if self.instances != nil {
                    map["Instances"] = self.instances!
                }
                if self.isStateful != nil {
                    map["IsStateful"] = self.isStateful!
                }
                if self.mem != nil {
                    map["Mem"] = self.mem!
                }
                if self.mseEnabled != nil {
                    map["MseEnabled"] = self.mseEnabled!
                }
                if self.mseNamespaceId != nil {
                    map["MseNamespaceId"] = self.mseNamespaceId!
                }
                if self.namespaceId != nil {
                    map["NamespaceId"] = self.namespaceId!
                }
                if self.namespaceName != nil {
                    map["NamespaceName"] = self.namespaceName!
                }
                if self.newSaeVersion != nil {
                    map["NewSaeVersion"] = self.newSaeVersion!
                }
                if self.packageUrl != nil {
                    map["PackageUrl"] = self.packageUrl!
                }
                if self.programmingLanguage != nil {
                    map["ProgrammingLanguage"] = self.programmingLanguage!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.runningInstances != nil {
                    map["RunningInstances"] = self.runningInstances!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppDeletingStatus"] as? Bool {
                    self.appDeletingStatus = value
                }
                if let value = dict["AppDescription"] as? String {
                    self.appDescription = value
                }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["AppType"] as? String {
                    self.appType = value
                }
                if let value = dict["BaseAppId"] as? String {
                    self.baseAppId = value
                }
                if let value = dict["Children"] as? [Any?] {
                    var tmp : [ListApplicationsResponseBody.Data.Applications.Children] = []
                    for v in value {
                        if v != nil {
                            var model = ListApplicationsResponseBody.Data.Applications.Children()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.children = tmp
                }
                if let value = dict["Cpu"] as? Int32 {
                    self.cpu = value
                }
                if let value = dict["DiskSize"] as? Int32 {
                    self.diskSize = value
                }
                if let value = dict["EnableIdle"] as? String {
                    self.enableIdle = value
                }
                if let value = dict["ImageUrl"] as? String {
                    self.imageUrl = value
                }
                if let value = dict["Instances"] as? Int32 {
                    self.instances = value
                }
                if let value = dict["IsStateful"] as? Bool {
                    self.isStateful = value
                }
                if let value = dict["Mem"] as? Int32 {
                    self.mem = value
                }
                if let value = dict["MseEnabled"] as? Bool {
                    self.mseEnabled = value
                }
                if let value = dict["MseNamespaceId"] as? String {
                    self.mseNamespaceId = value
                }
                if let value = dict["NamespaceId"] as? String {
                    self.namespaceId = value
                }
                if let value = dict["NamespaceName"] as? String {
                    self.namespaceName = value
                }
                if let value = dict["NewSaeVersion"] as? String {
                    self.newSaeVersion = value
                }
                if let value = dict["PackageUrl"] as? String {
                    self.packageUrl = value
                }
                if let value = dict["ProgrammingLanguage"] as? String {
                    self.programmingLanguage = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["RunningInstances"] as? Int32 {
                    self.runningInstances = value
                }
                if let value = dict["Tags"] as? [Any?] {
                    var tmp : [ListApplicationsResponseBody.Data.Applications.Tags] = []
                    for v in value {
                        if v != nil {
                            var model = ListApplicationsResponseBody.Data.Applications.Tags()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.tags = tmp
                }
                if let value = dict["VpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public var applications: [ListApplicationsResponseBody.Data.Applications]?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applications != nil {
                var tmp : [Any] = []
                for k in self.applications! {
                    tmp.append(k.toMap())
                }
                map["Applications"] = tmp
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Applications"] as? [Any?] {
                var tmp : [ListApplicationsResponseBody.Data.Applications] = []
                for v in value {
                    if v != nil {
                        var model = ListApplicationsResponseBody.Data.Applications()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.applications = tmp
            }
            if let value = dict["CurrentPage"] as? Int32 {
                self.currentPage = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalSize"] as? Int32 {
                self.totalSize = value
            }
        }
    }
    public var code: String?

    public var currentPage: Int32?

    public var data: ListApplicationsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalSize != nil {
            map["TotalSize"] = self.totalSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["CurrentPage"] as? Int32 {
            self.currentPage = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListApplicationsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TotalSize"] as? Int32 {
            self.totalSize = value
        }
    }
}

public class ListApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListApplicationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListApplicationsForSwimmingLaneRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var namespaceId: String?

    public var tag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.tag != nil {
            map["Tag"] = self.tag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? Int64 {
            self.groupId = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["Tag"] as? String {
            self.tag = value
        }
    }
}

public class ListApplicationsForSwimmingLaneResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var baseAppId: String?

        public var baseAppName: String?

        public var mseAppId: String?

        public var mseAppName: String?

        public var mseNamespaceId: String?

        public var serviceTags: [String: String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.baseAppId != nil {
                map["BaseAppId"] = self.baseAppId!
            }
            if self.baseAppName != nil {
                map["BaseAppName"] = self.baseAppName!
            }
            if self.mseAppId != nil {
                map["MseAppId"] = self.mseAppId!
            }
            if self.mseAppName != nil {
                map["MseAppName"] = self.mseAppName!
            }
            if self.mseNamespaceId != nil {
                map["MseNamespaceId"] = self.mseNamespaceId!
            }
            if self.serviceTags != nil {
                map["ServiceTags"] = self.serviceTags!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["BaseAppId"] as? String {
                self.baseAppId = value
            }
            if let value = dict["BaseAppName"] as? String {
                self.baseAppName = value
            }
            if let value = dict["MseAppId"] as? String {
                self.mseAppId = value
            }
            if let value = dict["MseAppName"] as? String {
                self.mseAppName = value
            }
            if let value = dict["MseNamespaceId"] as? String {
                self.mseNamespaceId = value
            }
            if let value = dict["ServiceTags"] as? [String: String] {
                self.serviceTags = value
            }
        }
    }
    public var code: String?

    public var data: [ListApplicationsForSwimmingLaneResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListApplicationsForSwimmingLaneResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListApplicationsForSwimmingLaneResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListApplicationsForSwimmingLaneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationsForSwimmingLaneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListApplicationsForSwimmingLaneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListChangeOrdersRequest : Tea.TeaModel {
    public var appId: String?

    public var coStatus: String?

    public var coType: String?

    public var currentPage: Int32?

    public var key: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var reverse: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.coStatus != nil {
            map["CoStatus"] = self.coStatus!
        }
        if self.coType != nil {
            map["CoType"] = self.coType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.reverse != nil {
            map["Reverse"] = self.reverse!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["CoStatus"] as? String {
            self.coStatus = value
        }
        if let value = dict["CoType"] as? String {
            self.coType = value
        }
        if let value = dict["CurrentPage"] as? Int32 {
            self.currentPage = value
        }
        if let value = dict["Key"] as? String {
            self.key = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Reverse"] as? Bool {
            self.reverse = value
        }
    }
}

public class ListChangeOrdersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ChangeOrderList : Tea.TeaModel {
            public var appId: String?

            public var batchCount: Int32?

            public var batchType: String?

            public var changeOrderId: String?

            public var coType: String?

            public var coTypeCode: String?

            public var createTime: String?

            public var createUserId: String?

            public var description_: String?

            public var finishTime: String?

            public var groupId: String?

            public var source: String?

            public var status: Int32?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.batchCount != nil {
                    map["BatchCount"] = self.batchCount!
                }
                if self.batchType != nil {
                    map["BatchType"] = self.batchType!
                }
                if self.changeOrderId != nil {
                    map["ChangeOrderId"] = self.changeOrderId!
                }
                if self.coType != nil {
                    map["CoType"] = self.coType!
                }
                if self.coTypeCode != nil {
                    map["CoTypeCode"] = self.coTypeCode!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUserId != nil {
                    map["CreateUserId"] = self.createUserId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["BatchCount"] as? Int32 {
                    self.batchCount = value
                }
                if let value = dict["BatchType"] as? String {
                    self.batchType = value
                }
                if let value = dict["ChangeOrderId"] as? String {
                    self.changeOrderId = value
                }
                if let value = dict["CoType"] as? String {
                    self.coType = value
                }
                if let value = dict["CoTypeCode"] as? String {
                    self.coTypeCode = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateUserId"] as? String {
                    self.createUserId = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["FinishTime"] as? String {
                    self.finishTime = value
                }
                if let value = dict["GroupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["Source"] as? String {
                    self.source = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
            }
        }
        public var changeOrderList: [ListChangeOrdersResponseBody.Data.ChangeOrderList]?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderList != nil {
                var tmp : [Any] = []
                for k in self.changeOrderList! {
                    tmp.append(k.toMap())
                }
                map["ChangeOrderList"] = tmp
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderList"] as? [Any?] {
                var tmp : [ListChangeOrdersResponseBody.Data.ChangeOrderList] = []
                for v in value {
                    if v != nil {
                        var model = ListChangeOrdersResponseBody.Data.ChangeOrderList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.changeOrderList = tmp
            }
            if let value = dict["CurrentPage"] as? Int32 {
                self.currentPage = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalSize"] as? Int32 {
                self.totalSize = value
            }
        }
    }
    public var code: String?

    public var data: ListChangeOrdersResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListChangeOrdersResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class ListChangeOrdersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListChangeOrdersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListChangeOrdersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListConsumedServicesRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class ListConsumedServicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var group2Ip: String?

        public var groups: [String]?

        public var ips: [String]?

        public var name: String?

        public var type: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.group2Ip != nil {
                map["Group2Ip"] = self.group2Ip!
            }
            if self.groups != nil {
                map["Groups"] = self.groups!
            }
            if self.ips != nil {
                map["Ips"] = self.ips!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["Group2Ip"] as? String {
                self.group2Ip = value
            }
            if let value = dict["Groups"] as? [String] {
                self.groups = value
            }
            if let value = dict["Ips"] as? [String] {
                self.ips = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["Version"] as? String {
                self.version = value
            }
        }
    }
    public var code: String?

    public var data: [ListConsumedServicesResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListConsumedServicesResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListConsumedServicesResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class ListConsumedServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConsumedServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListConsumedServicesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListGreyTagRouteRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class ListGreyTagRouteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class AlbRules : Tea.TeaModel {
                public class Items : Tea.TeaModel {
                    public var cond: String?

                    public var expr: String?

                    public var index: Int32?

                    public var name: String?

                    public var operator_: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cond != nil {
                            map["cond"] = self.cond!
                        }
                        if self.expr != nil {
                            map["expr"] = self.expr!
                        }
                        if self.index != nil {
                            map["index"] = self.index!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        if self.operator_ != nil {
                            map["operator"] = self.operator_!
                        }
                        if self.type != nil {
                            map["type"] = self.type!
                        }
                        if self.value != nil {
                            map["value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["cond"] as? String {
                            self.cond = value
                        }
                        if let value = dict["expr"] as? String {
                            self.expr = value
                        }
                        if let value = dict["index"] as? Int32 {
                            self.index = value
                        }
                        if let value = dict["name"] as? String {
                            self.name = value
                        }
                        if let value = dict["operator"] as? String {
                            self.operator_ = value
                        }
                        if let value = dict["type"] as? String {
                            self.type = value
                        }
                        if let value = dict["value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var condition: String?

                public var ingressId: String?

                public var items: [ListGreyTagRouteResponseBody.Data.Result.AlbRules.Items]?

                public var serviceName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.condition != nil {
                        map["condition"] = self.condition!
                    }
                    if self.ingressId != nil {
                        map["ingressId"] = self.ingressId!
                    }
                    if self.items != nil {
                        var tmp : [Any] = []
                        for k in self.items! {
                            tmp.append(k.toMap())
                        }
                        map["items"] = tmp
                    }
                    if self.serviceName != nil {
                        map["serviceName"] = self.serviceName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["condition"] as? String {
                        self.condition = value
                    }
                    if let value = dict["ingressId"] as? String {
                        self.ingressId = value
                    }
                    if let value = dict["items"] as? [Any?] {
                        var tmp : [ListGreyTagRouteResponseBody.Data.Result.AlbRules.Items] = []
                        for v in value {
                            if v != nil {
                                var model = ListGreyTagRouteResponseBody.Data.Result.AlbRules.Items()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.items = tmp
                    }
                    if let value = dict["serviceName"] as? String {
                        self.serviceName = value
                    }
                }
            }
            public class DubboRules : Tea.TeaModel {
                public class Items : Tea.TeaModel {
                    public var cond: String?

                    public var expr: String?

                    public var index: Int32?

                    public var name: String?

                    public var operator_: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cond != nil {
                            map["cond"] = self.cond!
                        }
                        if self.expr != nil {
                            map["expr"] = self.expr!
                        }
                        if self.index != nil {
                            map["index"] = self.index!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        if self.operator_ != nil {
                            map["operator"] = self.operator_!
                        }
                        if self.type != nil {
                            map["type"] = self.type!
                        }
                        if self.value != nil {
                            map["value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["cond"] as? String {
                            self.cond = value
                        }
                        if let value = dict["expr"] as? String {
                            self.expr = value
                        }
                        if let value = dict["index"] as? Int32 {
                            self.index = value
                        }
                        if let value = dict["name"] as? String {
                            self.name = value
                        }
                        if let value = dict["operator"] as? String {
                            self.operator_ = value
                        }
                        if let value = dict["type"] as? String {
                            self.type = value
                        }
                        if let value = dict["value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var condition: String?

                public var group: String?

                public var items: [ListGreyTagRouteResponseBody.Data.Result.DubboRules.Items]?

                public var methodName: String?

                public var serviceName: String?

                public var version: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.condition != nil {
                        map["condition"] = self.condition!
                    }
                    if self.group != nil {
                        map["group"] = self.group!
                    }
                    if self.items != nil {
                        var tmp : [Any] = []
                        for k in self.items! {
                            tmp.append(k.toMap())
                        }
                        map["items"] = tmp
                    }
                    if self.methodName != nil {
                        map["methodName"] = self.methodName!
                    }
                    if self.serviceName != nil {
                        map["serviceName"] = self.serviceName!
                    }
                    if self.version != nil {
                        map["version"] = self.version!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["condition"] as? String {
                        self.condition = value
                    }
                    if let value = dict["group"] as? String {
                        self.group = value
                    }
                    if let value = dict["items"] as? [Any?] {
                        var tmp : [ListGreyTagRouteResponseBody.Data.Result.DubboRules.Items] = []
                        for v in value {
                            if v != nil {
                                var model = ListGreyTagRouteResponseBody.Data.Result.DubboRules.Items()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.items = tmp
                    }
                    if let value = dict["methodName"] as? String {
                        self.methodName = value
                    }
                    if let value = dict["serviceName"] as? String {
                        self.serviceName = value
                    }
                    if let value = dict["version"] as? String {
                        self.version = value
                    }
                }
            }
            public class ScRules : Tea.TeaModel {
                public class Items : Tea.TeaModel {
                    public var cond: String?

                    public var expr: String?

                    public var index: Int32?

                    public var name: String?

                    public var operator_: String?

                    public var type: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.cond != nil {
                            map["cond"] = self.cond!
                        }
                        if self.expr != nil {
                            map["expr"] = self.expr!
                        }
                        if self.index != nil {
                            map["index"] = self.index!
                        }
                        if self.name != nil {
                            map["name"] = self.name!
                        }
                        if self.operator_ != nil {
                            map["operator"] = self.operator_!
                        }
                        if self.type != nil {
                            map["type"] = self.type!
                        }
                        if self.value != nil {
                            map["value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["cond"] as? String {
                            self.cond = value
                        }
                        if let value = dict["expr"] as? String {
                            self.expr = value
                        }
                        if let value = dict["index"] as? Int32 {
                            self.index = value
                        }
                        if let value = dict["name"] as? String {
                            self.name = value
                        }
                        if let value = dict["operator"] as? String {
                            self.operator_ = value
                        }
                        if let value = dict["type"] as? String {
                            self.type = value
                        }
                        if let value = dict["value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var condition: String?

                public var items: [ListGreyTagRouteResponseBody.Data.Result.ScRules.Items]?

                public var path: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.condition != nil {
                        map["condition"] = self.condition!
                    }
                    if self.items != nil {
                        var tmp : [Any] = []
                        for k in self.items! {
                            tmp.append(k.toMap())
                        }
                        map["items"] = tmp
                    }
                    if self.path != nil {
                        map["path"] = self.path!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["condition"] as? String {
                        self.condition = value
                    }
                    if let value = dict["items"] as? [Any?] {
                        var tmp : [ListGreyTagRouteResponseBody.Data.Result.ScRules.Items] = []
                        for v in value {
                            if v != nil {
                                var model = ListGreyTagRouteResponseBody.Data.Result.ScRules.Items()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.items = tmp
                    }
                    if let value = dict["path"] as? String {
                        self.path = value
                    }
                }
            }
            public var albRules: [ListGreyTagRouteResponseBody.Data.Result.AlbRules]?

            public var createTime: Int64?

            public var description_: String?

            public var dubboRules: [ListGreyTagRouteResponseBody.Data.Result.DubboRules]?

            public var greyTagRouteId: Int64?

            public var name: String?

            public var scRules: [ListGreyTagRouteResponseBody.Data.Result.ScRules]?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.albRules != nil {
                    var tmp : [Any] = []
                    for k in self.albRules! {
                        tmp.append(k.toMap())
                    }
                    map["AlbRules"] = tmp
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.dubboRules != nil {
                    var tmp : [Any] = []
                    for k in self.dubboRules! {
                        tmp.append(k.toMap())
                    }
                    map["DubboRules"] = tmp
                }
                if self.greyTagRouteId != nil {
                    map["GreyTagRouteId"] = self.greyTagRouteId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.scRules != nil {
                    var tmp : [Any] = []
                    for k in self.scRules! {
                        tmp.append(k.toMap())
                    }
                    map["ScRules"] = tmp
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AlbRules"] as? [Any?] {
                    var tmp : [ListGreyTagRouteResponseBody.Data.Result.AlbRules] = []
                    for v in value {
                        if v != nil {
                            var model = ListGreyTagRouteResponseBody.Data.Result.AlbRules()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.albRules = tmp
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["DubboRules"] as? [Any?] {
                    var tmp : [ListGreyTagRouteResponseBody.Data.Result.DubboRules] = []
                    for v in value {
                        if v != nil {
                            var model = ListGreyTagRouteResponseBody.Data.Result.DubboRules()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.dubboRules = tmp
                }
                if let value = dict["GreyTagRouteId"] as? Int64 {
                    self.greyTagRouteId = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["ScRules"] as? [Any?] {
                    var tmp : [ListGreyTagRouteResponseBody.Data.Result.ScRules] = []
                    for v in value {
                        if v != nil {
                            var model = ListGreyTagRouteResponseBody.Data.Result.ScRules()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.scRules = tmp
                }
                if let value = dict["UpdateTime"] as? Int64 {
                    self.updateTime = value
                }
            }
        }
        public var currentPage: Int32?

        public var pageSize: Int32?

        public var result: [ListGreyTagRouteResponseBody.Data.Result]?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CurrentPage"] as? Int32 {
                self.currentPage = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["Result"] as? [Any?] {
                var tmp : [ListGreyTagRouteResponseBody.Data.Result] = []
                for v in value {
                    if v != nil {
                        var model = ListGreyTagRouteResponseBody.Data.Result()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.result = tmp
            }
            if let value = dict["TotalSize"] as? Int64 {
                self.totalSize = value
            }
        }
    }
    public var code: String?

    public var data: ListGreyTagRouteResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListGreyTagRouteResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class ListGreyTagRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGreyTagRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListGreyTagRouteResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListIngressesRequest : Tea.TeaModel {
    public var appId: String?

    public var currentPage: Int32?

    public var namespaceId: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["CurrentPage"] as? Int32 {
            self.currentPage = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class ListIngressesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class IngressList : Tea.TeaModel {
            public class CorsConfig : Tea.TeaModel {
                public var allowCredentials: String?

                public var allowHeaders: String?

                public var allowMethods: String?

                public var allowOrigin: String?

                public var enable: String?

                public var exposeHeaders: String?

                public var maxAge: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allowCredentials != nil {
                        map["AllowCredentials"] = self.allowCredentials!
                    }
                    if self.allowHeaders != nil {
                        map["AllowHeaders"] = self.allowHeaders!
                    }
                    if self.allowMethods != nil {
                        map["AllowMethods"] = self.allowMethods!
                    }
                    if self.allowOrigin != nil {
                        map["AllowOrigin"] = self.allowOrigin!
                    }
                    if self.enable != nil {
                        map["Enable"] = self.enable!
                    }
                    if self.exposeHeaders != nil {
                        map["ExposeHeaders"] = self.exposeHeaders!
                    }
                    if self.maxAge != nil {
                        map["MaxAge"] = self.maxAge!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AllowCredentials"] as? String {
                        self.allowCredentials = value
                    }
                    if let value = dict["AllowHeaders"] as? String {
                        self.allowHeaders = value
                    }
                    if let value = dict["AllowMethods"] as? String {
                        self.allowMethods = value
                    }
                    if let value = dict["AllowOrigin"] as? String {
                        self.allowOrigin = value
                    }
                    if let value = dict["Enable"] as? String {
                        self.enable = value
                    }
                    if let value = dict["ExposeHeaders"] as? String {
                        self.exposeHeaders = value
                    }
                    if let value = dict["MaxAge"] as? String {
                        self.maxAge = value
                    }
                }
            }
            public class DefaultRule : Tea.TeaModel {
                public var appId: String?

                public var appName: String?

                public var backendProtocol: String?

                public var containerPort: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appName != nil {
                        map["AppName"] = self.appName!
                    }
                    if self.backendProtocol != nil {
                        map["BackendProtocol"] = self.backendProtocol!
                    }
                    if self.containerPort != nil {
                        map["ContainerPort"] = self.containerPort!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AppId"] as? String {
                        self.appId = value
                    }
                    if let value = dict["AppName"] as? String {
                        self.appName = value
                    }
                    if let value = dict["BackendProtocol"] as? String {
                        self.backendProtocol = value
                    }
                    if let value = dict["ContainerPort"] as? Int32 {
                        self.containerPort = value
                    }
                }
            }
            public class Rules : Tea.TeaModel {
                public class RuleActions : Tea.TeaModel {
                    public var actionConfig: String?

                    public var actionType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.actionConfig != nil {
                            map["ActionConfig"] = self.actionConfig!
                        }
                        if self.actionType != nil {
                            map["ActionType"] = self.actionType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["ActionConfig"] as? String {
                            self.actionConfig = value
                        }
                        if let value = dict["ActionType"] as? String {
                            self.actionType = value
                        }
                    }
                }
                public var appId: String?

                public var appName: String?

                public var backendProtocol: String?

                public var containerPort: Int32?

                public var domain: String?

                public var path: String?

                public var rewritePath: String?

                public var ruleActions: [ListIngressesResponseBody.Data.IngressList.Rules.RuleActions]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appName != nil {
                        map["AppName"] = self.appName!
                    }
                    if self.backendProtocol != nil {
                        map["BackendProtocol"] = self.backendProtocol!
                    }
                    if self.containerPort != nil {
                        map["ContainerPort"] = self.containerPort!
                    }
                    if self.domain != nil {
                        map["Domain"] = self.domain!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.rewritePath != nil {
                        map["RewritePath"] = self.rewritePath!
                    }
                    if self.ruleActions != nil {
                        var tmp : [Any] = []
                        for k in self.ruleActions! {
                            tmp.append(k.toMap())
                        }
                        map["RuleActions"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AppId"] as? String {
                        self.appId = value
                    }
                    if let value = dict["AppName"] as? String {
                        self.appName = value
                    }
                    if let value = dict["BackendProtocol"] as? String {
                        self.backendProtocol = value
                    }
                    if let value = dict["ContainerPort"] as? Int32 {
                        self.containerPort = value
                    }
                    if let value = dict["Domain"] as? String {
                        self.domain = value
                    }
                    if let value = dict["Path"] as? String {
                        self.path = value
                    }
                    if let value = dict["RewritePath"] as? String {
                        self.rewritePath = value
                    }
                    if let value = dict["RuleActions"] as? [Any?] {
                        var tmp : [ListIngressesResponseBody.Data.IngressList.Rules.RuleActions] = []
                        for v in value {
                            if v != nil {
                                var model = ListIngressesResponseBody.Data.IngressList.Rules.RuleActions()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.ruleActions = tmp
                    }
                }
            }
            public var certId: String?

            public var certIds: String?

            public var corsConfig: ListIngressesResponseBody.Data.IngressList.CorsConfig?

            public var createTime: Int64?

            public var defaultRule: ListIngressesResponseBody.Data.IngressList.DefaultRule?

            public var description_: String?

            public var id: Int64?

            public var idleTimeout: Int64?

            public var listenerPort: String?

            public var listenerProtocol: String?

            public var loadBalanceType: String?

            public var mseGatewayId: String?

            public var mseGatewayPort: String?

            public var mseGatewayProtocol: String?

            public var name: String?

            public var namespaceId: String?

            public var requestTimeout: Int64?

            public var rules: [ListIngressesResponseBody.Data.IngressList.Rules]?

            public var slbId: String?

            public var slbType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.corsConfig?.validate()
                try self.defaultRule?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.certId != nil {
                    map["CertId"] = self.certId!
                }
                if self.certIds != nil {
                    map["CertIds"] = self.certIds!
                }
                if self.corsConfig != nil {
                    map["CorsConfig"] = self.corsConfig?.toMap()
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.defaultRule != nil {
                    map["DefaultRule"] = self.defaultRule?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.idleTimeout != nil {
                    map["IdleTimeout"] = self.idleTimeout!
                }
                if self.listenerPort != nil {
                    map["ListenerPort"] = self.listenerPort!
                }
                if self.listenerProtocol != nil {
                    map["ListenerProtocol"] = self.listenerProtocol!
                }
                if self.loadBalanceType != nil {
                    map["LoadBalanceType"] = self.loadBalanceType!
                }
                if self.mseGatewayId != nil {
                    map["MseGatewayId"] = self.mseGatewayId!
                }
                if self.mseGatewayPort != nil {
                    map["MseGatewayPort"] = self.mseGatewayPort!
                }
                if self.mseGatewayProtocol != nil {
                    map["MseGatewayProtocol"] = self.mseGatewayProtocol!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespaceId != nil {
                    map["NamespaceId"] = self.namespaceId!
                }
                if self.requestTimeout != nil {
                    map["RequestTimeout"] = self.requestTimeout!
                }
                if self.rules != nil {
                    var tmp : [Any] = []
                    for k in self.rules! {
                        tmp.append(k.toMap())
                    }
                    map["Rules"] = tmp
                }
                if self.slbId != nil {
                    map["SlbId"] = self.slbId!
                }
                if self.slbType != nil {
                    map["SlbType"] = self.slbType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CertId"] as? String {
                    self.certId = value
                }
                if let value = dict["CertIds"] as? String {
                    self.certIds = value
                }
                if let value = dict["CorsConfig"] as? [String: Any?] {
                    var model = ListIngressesResponseBody.Data.IngressList.CorsConfig()
                    model.fromMap(value)
                    self.corsConfig = model
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["DefaultRule"] as? [String: Any?] {
                    var model = ListIngressesResponseBody.Data.IngressList.DefaultRule()
                    model.fromMap(value)
                    self.defaultRule = model
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Id"] as? Int64 {
                    self.id = value
                }
                if let value = dict["IdleTimeout"] as? Int64 {
                    self.idleTimeout = value
                }
                if let value = dict["ListenerPort"] as? String {
                    self.listenerPort = value
                }
                if let value = dict["ListenerProtocol"] as? String {
                    self.listenerProtocol = value
                }
                if let value = dict["LoadBalanceType"] as? String {
                    self.loadBalanceType = value
                }
                if let value = dict["MseGatewayId"] as? String {
                    self.mseGatewayId = value
                }
                if let value = dict["MseGatewayPort"] as? String {
                    self.mseGatewayPort = value
                }
                if let value = dict["MseGatewayProtocol"] as? String {
                    self.mseGatewayProtocol = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["NamespaceId"] as? String {
                    self.namespaceId = value
                }
                if let value = dict["RequestTimeout"] as? Int64 {
                    self.requestTimeout = value
                }
                if let value = dict["Rules"] as? [Any?] {
                    var tmp : [ListIngressesResponseBody.Data.IngressList.Rules] = []
                    for v in value {
                        if v != nil {
                            var model = ListIngressesResponseBody.Data.IngressList.Rules()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.rules = tmp
                }
                if let value = dict["SlbId"] as? String {
                    self.slbId = value
                }
                if let value = dict["SlbType"] as? String {
                    self.slbType = value
                }
            }
        }
        public var currentPage: Int32?

        public var ingressList: [ListIngressesResponseBody.Data.IngressList]?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.ingressList != nil {
                var tmp : [Any] = []
                for k in self.ingressList! {
                    tmp.append(k.toMap())
                }
                map["IngressList"] = tmp
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CurrentPage"] as? Int32 {
                self.currentPage = value
            }
            if let value = dict["IngressList"] as? [Any?] {
                var tmp : [ListIngressesResponseBody.Data.IngressList] = []
                for v in value {
                    if v != nil {
                        var model = ListIngressesResponseBody.Data.IngressList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ingressList = tmp
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalSize"] as? Int32 {
                self.totalSize = value
            }
        }
    }
    public var code: String?

    public var data: ListIngressesResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListIngressesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class ListIngressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIngressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListIngressesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListJobsRequest : Tea.TeaModel {
    public var appName: String?

    public var currentPage: Int32?

    public var fieldType: String?

    public var fieldValue: String?

    public var namespaceId: String?

    public var orderBy: String?

    public var pageSize: Int32?

    public var reverse: Bool?

    public var tags: String?

    public var workload: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.fieldType != nil {
            map["FieldType"] = self.fieldType!
        }
        if self.fieldValue != nil {
            map["FieldValue"] = self.fieldValue!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.reverse != nil {
            map["Reverse"] = self.reverse!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.workload != nil {
            map["Workload"] = self.workload!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["CurrentPage"] as? Int32 {
            self.currentPage = value
        }
        if let value = dict["FieldType"] as? String {
            self.fieldType = value
        }
        if let value = dict["FieldValue"] as? String {
            self.fieldValue = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Reverse"] as? Bool {
            self.reverse = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
        if let value = dict["Workload"] as? String {
            self.workload = value
        }
    }
}

public class ListJobsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Applications : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Key"] as? String {
                        self.key = value
                    }
                    if let value = dict["Value"] as? String {
                        self.value = value
                    }
                }
            }
            public var active: Int64?

            public var appDescription: String?

            public var appId: String?

            public var appName: String?

            public var completionTime: Int64?

            public var cpu: Int32?

            public var failed: Int64?

            public var imageUrl: String?

            public var lastChangeorderState: String?

            public var lastJobState: String?

            public var lastStartTime: Int64?

            public var mem: Int32?

            public var message: String?

            public var namespaceId: String?

            public var regionId: String?

            public var succeeded: Int64?

            public var suspend: Bool?

            public var tags: [ListJobsResponseBody.Data.Applications.Tags]?

            public var triggerConfig: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.active != nil {
                    map["Active"] = self.active!
                }
                if self.appDescription != nil {
                    map["AppDescription"] = self.appDescription!
                }
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appName != nil {
                    map["AppName"] = self.appName!
                }
                if self.completionTime != nil {
                    map["CompletionTime"] = self.completionTime!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.failed != nil {
                    map["Failed"] = self.failed!
                }
                if self.imageUrl != nil {
                    map["ImageUrl"] = self.imageUrl!
                }
                if self.lastChangeorderState != nil {
                    map["LastChangeorderState"] = self.lastChangeorderState!
                }
                if self.lastJobState != nil {
                    map["LastJobState"] = self.lastJobState!
                }
                if self.lastStartTime != nil {
                    map["LastStartTime"] = self.lastStartTime!
                }
                if self.mem != nil {
                    map["Mem"] = self.mem!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.namespaceId != nil {
                    map["NamespaceId"] = self.namespaceId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.succeeded != nil {
                    map["Succeeded"] = self.succeeded!
                }
                if self.suspend != nil {
                    map["Suspend"] = self.suspend!
                }
                if self.tags != nil {
                    var tmp : [Any] = []
                    for k in self.tags! {
                        tmp.append(k.toMap())
                    }
                    map["Tags"] = tmp
                }
                if self.triggerConfig != nil {
                    map["TriggerConfig"] = self.triggerConfig!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Active"] as? Int64 {
                    self.active = value
                }
                if let value = dict["AppDescription"] as? String {
                    self.appDescription = value
                }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppName"] as? String {
                    self.appName = value
                }
                if let value = dict["CompletionTime"] as? Int64 {
                    self.completionTime = value
                }
                if let value = dict["Cpu"] as? Int32 {
                    self.cpu = value
                }
                if let value = dict["Failed"] as? Int64 {
                    self.failed = value
                }
                if let value = dict["ImageUrl"] as? String {
                    self.imageUrl = value
                }
                if let value = dict["LastChangeorderState"] as? String {
                    self.lastChangeorderState = value
                }
                if let value = dict["LastJobState"] as? String {
                    self.lastJobState = value
                }
                if let value = dict["LastStartTime"] as? Int64 {
                    self.lastStartTime = value
                }
                if let value = dict["Mem"] as? Int32 {
                    self.mem = value
                }
                if let value = dict["Message"] as? String {
                    self.message = value
                }
                if let value = dict["NamespaceId"] as? String {
                    self.namespaceId = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["Succeeded"] as? Int64 {
                    self.succeeded = value
                }
                if let value = dict["Suspend"] as? Bool {
                    self.suspend = value
                }
                if let value = dict["Tags"] as? [Any?] {
                    var tmp : [ListJobsResponseBody.Data.Applications.Tags] = []
                    for v in value {
                        if v != nil {
                            var model = ListJobsResponseBody.Data.Applications.Tags()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.tags = tmp
                }
                if let value = dict["TriggerConfig"] as? String {
                    self.triggerConfig = value
                }
            }
        }
        public var applications: [ListJobsResponseBody.Data.Applications]?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applications != nil {
                var tmp : [Any] = []
                for k in self.applications! {
                    tmp.append(k.toMap())
                }
                map["Applications"] = tmp
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Applications"] as? [Any?] {
                var tmp : [ListJobsResponseBody.Data.Applications] = []
                for v in value {
                    if v != nil {
                        var model = ListJobsResponseBody.Data.Applications()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.applications = tmp
            }
            if let value = dict["CurrentPage"] as? Int32 {
                self.currentPage = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalSize"] as? Int32 {
                self.totalSize = value
            }
        }
    }
    public var code: String?

    public var currentPage: Int32?

    public var data: ListJobsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalSize != nil {
            map["TotalSize"] = self.totalSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["CurrentPage"] as? Int32 {
            self.currentPage = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListJobsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TotalSize"] as? Int32 {
            self.totalSize = value
        }
    }
}

public class ListJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListJobsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListLogConfigsRequest : Tea.TeaModel {
    public var appId: String?

    public var currentPage: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["CurrentPage"] as? Int32 {
            self.currentPage = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class ListLogConfigsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class LogConfigs : Tea.TeaModel {
            public var configName: String?

            public var createTime: String?

            public var logDir: String?

            public var logType: String?

            public var regionId: String?

            public var slsLogStore: String?

            public var slsProject: String?

            public var storeType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configName != nil {
                    map["ConfigName"] = self.configName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.logDir != nil {
                    map["LogDir"] = self.logDir!
                }
                if self.logType != nil {
                    map["LogType"] = self.logType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.slsLogStore != nil {
                    map["SlsLogStore"] = self.slsLogStore!
                }
                if self.slsProject != nil {
                    map["SlsProject"] = self.slsProject!
                }
                if self.storeType != nil {
                    map["StoreType"] = self.storeType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigName"] as? String {
                    self.configName = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["LogDir"] as? String {
                    self.logDir = value
                }
                if let value = dict["LogType"] as? String {
                    self.logType = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["SlsLogStore"] as? String {
                    self.slsLogStore = value
                }
                if let value = dict["SlsProject"] as? String {
                    self.slsProject = value
                }
                if let value = dict["StoreType"] as? String {
                    self.storeType = value
                }
            }
        }
        public var currentPage: Int32?

        public var logConfigs: [ListLogConfigsResponseBody.Data.LogConfigs]?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.logConfigs != nil {
                var tmp : [Any] = []
                for k in self.logConfigs! {
                    tmp.append(k.toMap())
                }
                map["LogConfigs"] = tmp
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CurrentPage"] as? Int32 {
                self.currentPage = value
            }
            if let value = dict["LogConfigs"] as? [Any?] {
                var tmp : [ListLogConfigsResponseBody.Data.LogConfigs] = []
                for v in value {
                    if v != nil {
                        var model = ListLogConfigsResponseBody.Data.LogConfigs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.logConfigs = tmp
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalSize"] as? Int32 {
                self.totalSize = value
            }
        }
    }
    public var code: String?

    public var data: ListLogConfigsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListLogConfigsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class ListLogConfigsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLogConfigsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListLogConfigsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListNamespaceChangeOrdersRequest : Tea.TeaModel {
    public var coStatus: String?

    public var coType: String?

    public var currentPage: Int32?

    public var key: String?

    public var namespaceId: String?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coStatus != nil {
            map["CoStatus"] = self.coStatus!
        }
        if self.coType != nil {
            map["CoType"] = self.coType!
        }
        if self.currentPage != nil {
            map["CurrentPage"] = self.currentPage!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CoStatus"] as? String {
            self.coStatus = value
        }
        if let value = dict["CoType"] as? String {
            self.coType = value
        }
        if let value = dict["CurrentPage"] as? Int32 {
            self.currentPage = value
        }
        if let value = dict["Key"] as? String {
            self.key = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class ListNamespaceChangeOrdersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ChangeOrderList : Tea.TeaModel {
            public var batchCount: Int32?

            public var batchType: String?

            public var changeOrderId: String?

            public var coType: String?

            public var coTypeCode: String?

            public var createTime: String?

            public var createUserId: String?

            public var description_: String?

            public var finishTime: String?

            public var groupId: String?

            public var namespaceId: String?

            public var pipelines: String?

            public var source: String?

            public var status: Int32?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.batchCount != nil {
                    map["BatchCount"] = self.batchCount!
                }
                if self.batchType != nil {
                    map["BatchType"] = self.batchType!
                }
                if self.changeOrderId != nil {
                    map["ChangeOrderId"] = self.changeOrderId!
                }
                if self.coType != nil {
                    map["CoType"] = self.coType!
                }
                if self.coTypeCode != nil {
                    map["CoTypeCode"] = self.coTypeCode!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createUserId != nil {
                    map["CreateUserId"] = self.createUserId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.finishTime != nil {
                    map["FinishTime"] = self.finishTime!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.namespaceId != nil {
                    map["NamespaceId"] = self.namespaceId!
                }
                if self.pipelines != nil {
                    map["Pipelines"] = self.pipelines!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BatchCount"] as? Int32 {
                    self.batchCount = value
                }
                if let value = dict["BatchType"] as? String {
                    self.batchType = value
                }
                if let value = dict["ChangeOrderId"] as? String {
                    self.changeOrderId = value
                }
                if let value = dict["CoType"] as? String {
                    self.coType = value
                }
                if let value = dict["CoTypeCode"] as? String {
                    self.coTypeCode = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["CreateUserId"] as? String {
                    self.createUserId = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["FinishTime"] as? String {
                    self.finishTime = value
                }
                if let value = dict["GroupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["NamespaceId"] as? String {
                    self.namespaceId = value
                }
                if let value = dict["Pipelines"] as? String {
                    self.pipelines = value
                }
                if let value = dict["Source"] as? String {
                    self.source = value
                }
                if let value = dict["Status"] as? Int32 {
                    self.status = value
                }
                if let value = dict["UserId"] as? String {
                    self.userId = value
                }
            }
        }
        public var changeOrderList: [ListNamespaceChangeOrdersResponseBody.Data.ChangeOrderList]?

        public var currentPage: Int32?

        public var pageSize: Int32?

        public var totalSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderList != nil {
                var tmp : [Any] = []
                for k in self.changeOrderList! {
                    tmp.append(k.toMap())
                }
                map["ChangeOrderList"] = tmp
            }
            if self.currentPage != nil {
                map["CurrentPage"] = self.currentPage!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderList"] as? [Any?] {
                var tmp : [ListNamespaceChangeOrdersResponseBody.Data.ChangeOrderList] = []
                for v in value {
                    if v != nil {
                        var model = ListNamespaceChangeOrdersResponseBody.Data.ChangeOrderList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.changeOrderList = tmp
            }
            if let value = dict["CurrentPage"] as? Int32 {
                self.currentPage = value
            }
            if let value = dict["PageSize"] as? Int32 {
                self.pageSize = value
            }
            if let value = dict["TotalSize"] as? Int32 {
                self.totalSize = value
            }
        }
    }
    public var code: String?

    public var data: ListNamespaceChangeOrdersResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListNamespaceChangeOrdersResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class ListNamespaceChangeOrdersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNamespaceChangeOrdersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListNamespaceChangeOrdersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListNamespacedConfigMapsRequest : Tea.TeaModel {
    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class ListNamespacedConfigMapsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ConfigMaps : Tea.TeaModel {
            public class RelateApps : Tea.TeaModel {
                public var appId: String?

                public var appName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appName != nil {
                        map["AppName"] = self.appName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AppId"] as? String {
                        self.appId = value
                    }
                    if let value = dict["AppName"] as? String {
                        self.appName = value
                    }
                }
            }
            public var configMapId: Int64?

            public var createTime: Int64?

            public var data: [String: Any]?

            public var description_: String?

            public var name: String?

            public var namespaceId: String?

            public var relateApps: [ListNamespacedConfigMapsResponseBody.Data.ConfigMaps.RelateApps]?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configMapId != nil {
                    map["ConfigMapId"] = self.configMapId!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.namespaceId != nil {
                    map["NamespaceId"] = self.namespaceId!
                }
                if self.relateApps != nil {
                    var tmp : [Any] = []
                    for k in self.relateApps! {
                        tmp.append(k.toMap())
                    }
                    map["RelateApps"] = tmp
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigMapId"] as? Int64 {
                    self.configMapId = value
                }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["Data"] as? [String: Any] {
                    self.data = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["NamespaceId"] as? String {
                    self.namespaceId = value
                }
                if let value = dict["RelateApps"] as? [Any?] {
                    var tmp : [ListNamespacedConfigMapsResponseBody.Data.ConfigMaps.RelateApps] = []
                    for v in value {
                        if v != nil {
                            var model = ListNamespacedConfigMapsResponseBody.Data.ConfigMaps.RelateApps()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.relateApps = tmp
                }
                if let value = dict["UpdateTime"] as? Int64 {
                    self.updateTime = value
                }
            }
        }
        public var configMaps: [ListNamespacedConfigMapsResponseBody.Data.ConfigMaps]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configMaps != nil {
                var tmp : [Any] = []
                for k in self.configMaps! {
                    tmp.append(k.toMap())
                }
                map["ConfigMaps"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigMaps"] as? [Any?] {
                var tmp : [ListNamespacedConfigMapsResponseBody.Data.ConfigMaps] = []
                for v in value {
                    if v != nil {
                        var model = ListNamespacedConfigMapsResponseBody.Data.ConfigMaps()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configMaps = tmp
            }
        }
    }
    public var code: String?

    public var data: ListNamespacedConfigMapsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListNamespacedConfigMapsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class ListNamespacedConfigMapsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNamespacedConfigMapsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListNamespacedConfigMapsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPublishedServicesRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class ListPublishedServicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var group2Ip: String?

        public var groups: [String]?

        public var ips: [String]?

        public var name: String?

        public var type: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.group2Ip != nil {
                map["Group2Ip"] = self.group2Ip!
            }
            if self.groups != nil {
                map["Groups"] = self.groups!
            }
            if self.ips != nil {
                map["Ips"] = self.ips!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["Group2Ip"] as? String {
                self.group2Ip = value
            }
            if let value = dict["Groups"] as? [String] {
                self.groups = value
            }
            if let value = dict["Ips"] as? [String] {
                self.ips = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["Version"] as? String {
                self.version = value
            }
        }
    }
    public var code: String?

    public var data: [ListPublishedServicesResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListPublishedServicesResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListPublishedServicesResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class ListPublishedServicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPublishedServicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPublishedServicesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSecretsRequest : Tea.TeaModel {
    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class ListSecretsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Secrets : Tea.TeaModel {
            public class RelateApps : Tea.TeaModel {
                public var appId: String?

                public var appName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.appId != nil {
                        map["AppId"] = self.appId!
                    }
                    if self.appName != nil {
                        map["AppName"] = self.appName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AppId"] as? String {
                        self.appId = value
                    }
                    if let value = dict["AppName"] as? String {
                        self.appName = value
                    }
                }
            }
            public var createTime: Int64?

            public var namespaceId: String?

            public var relateApps: [ListSecretsResponseBody.Data.Secrets.RelateApps]?

            public var secretId: Int64?

            public var secretName: String?

            public var secretType: String?

            public var updateTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.namespaceId != nil {
                    map["NamespaceId"] = self.namespaceId!
                }
                if self.relateApps != nil {
                    var tmp : [Any] = []
                    for k in self.relateApps! {
                        tmp.append(k.toMap())
                    }
                    map["RelateApps"] = tmp
                }
                if self.secretId != nil {
                    map["SecretId"] = self.secretId!
                }
                if self.secretName != nil {
                    map["SecretName"] = self.secretName!
                }
                if self.secretType != nil {
                    map["SecretType"] = self.secretType!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CreateTime"] as? Int64 {
                    self.createTime = value
                }
                if let value = dict["NamespaceId"] as? String {
                    self.namespaceId = value
                }
                if let value = dict["RelateApps"] as? [Any?] {
                    var tmp : [ListSecretsResponseBody.Data.Secrets.RelateApps] = []
                    for v in value {
                        if v != nil {
                            var model = ListSecretsResponseBody.Data.Secrets.RelateApps()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.relateApps = tmp
                }
                if let value = dict["SecretId"] as? Int64 {
                    self.secretId = value
                }
                if let value = dict["SecretName"] as? String {
                    self.secretName = value
                }
                if let value = dict["SecretType"] as? String {
                    self.secretType = value
                }
                if let value = dict["UpdateTime"] as? Int64 {
                    self.updateTime = value
                }
            }
        }
        public var secrets: [ListSecretsResponseBody.Data.Secrets]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.secrets != nil {
                var tmp : [Any] = []
                for k in self.secrets! {
                    tmp.append(k.toMap())
                }
                map["Secrets"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Secrets"] as? [Any?] {
                var tmp : [ListSecretsResponseBody.Data.Secrets] = []
                for v in value {
                    if v != nil {
                        var model = ListSecretsResponseBody.Data.Secrets()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.secrets = tmp
            }
        }
    }
    public var code: String?

    public var data: ListSecretsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListSecretsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class ListSecretsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSecretsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSecretsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSwimmingLaneGatewayRoutesRequest : Tea.TeaModel {
    public var gatewayUniqueId: String?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gatewayUniqueId != nil {
            map["GatewayUniqueId"] = self.gatewayUniqueId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GatewayUniqueId"] as? String {
            self.gatewayUniqueId = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class ListSwimmingLaneGatewayRoutesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RoutePredicate : Tea.TeaModel {
            public class PathPredicate : Tea.TeaModel {
                public var path: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Path"] as? String {
                        self.path = value
                    }
                    if let value = dict["Type"] as? String {
                        self.type = value
                    }
                }
            }
            public var pathPredicate: ListSwimmingLaneGatewayRoutesResponseBody.Data.RoutePredicate.PathPredicate?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.pathPredicate?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.pathPredicate != nil {
                    map["PathPredicate"] = self.pathPredicate?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["PathPredicate"] as? [String: Any?] {
                    var model = ListSwimmingLaneGatewayRoutesResponseBody.Data.RoutePredicate.PathPredicate()
                    model.fromMap(value)
                    self.pathPredicate = model
                }
            }
        }
        public var routeId: Int64?

        public var routeName: String?

        public var routePredicate: ListSwimmingLaneGatewayRoutesResponseBody.Data.RoutePredicate?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.routePredicate?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routeId != nil {
                map["RouteId"] = self.routeId!
            }
            if self.routeName != nil {
                map["RouteName"] = self.routeName!
            }
            if self.routePredicate != nil {
                map["RoutePredicate"] = self.routePredicate?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RouteId"] as? Int64 {
                self.routeId = value
            }
            if let value = dict["RouteName"] as? String {
                self.routeName = value
            }
            if let value = dict["RoutePredicate"] as? [String: Any?] {
                var model = ListSwimmingLaneGatewayRoutesResponseBody.Data.RoutePredicate()
                model.fromMap(value)
                self.routePredicate = model
            }
        }
    }
    public var code: String?

    public var data: [ListSwimmingLaneGatewayRoutesResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListSwimmingLaneGatewayRoutesResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListSwimmingLaneGatewayRoutesResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class ListSwimmingLaneGatewayRoutesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSwimmingLaneGatewayRoutesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSwimmingLaneGatewayRoutesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSwimmingLaneGroupTagsRequest : Tea.TeaModel {
    public var groupId: Int64?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? Int64 {
            self.groupId = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class ListSwimmingLaneGroupTagsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var metadata: String?

        public var tag: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metadata != nil {
                map["Metadata"] = self.metadata!
            }
            if self.tag != nil {
                map["Tag"] = self.tag!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Metadata"] as? String {
                self.metadata = value
            }
            if let value = dict["Tag"] as? String {
                self.tag = value
            }
        }
    }
    public var code: String?

    public var data: [ListSwimmingLaneGroupTagsResponseBody.Data]?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListSwimmingLaneGroupTagsResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListSwimmingLaneGroupTagsResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class ListSwimmingLaneGroupTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSwimmingLaneGroupTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSwimmingLaneGroupTagsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public var nextToken: String?

    public var regionId: String?

    public var resourceIds: String?

    public var resourceType: String?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceIds"] as? String {
            self.resourceIds = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class TagResources : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var nextToken: String?

        public var tagResources: [ListTagResourcesResponseBody.Data.TagResources]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.tagResources != nil {
                var tmp : [Any] = []
                for k in self.tagResources! {
                    tmp.append(k.toMap())
                }
                map["TagResources"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["NextToken"] as? String {
                self.nextToken = value
            }
            if let value = dict["TagResources"] as? [Any?] {
                var tmp : [ListTagResourcesResponseBody.Data.TagResources] = []
                for v in value {
                    if v != nil {
                        var model = ListTagResourcesResponseBody.Data.TagResources()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tagResources = tmp
            }
        }
    }
    public var code: String?

    public var data: ListTagResourcesResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListTagResourcesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListWebApplicationInstancesRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceIds: [String]?

    public var limit: String?

    public var namespaceId: String?

    public var startTime: Int64?

    public var statuses: [String]?

    public var versionIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.statuses != nil {
            map["Statuses"] = self.statuses!
        }
        if self.versionIds != nil {
            map["VersionIds"] = self.versionIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["Limit"] as? String {
            self.limit = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["Statuses"] as? [String] {
            self.statuses = value
        }
        if let value = dict["VersionIds"] as? [String] {
            self.versionIds = value
        }
    }
}

public class ListWebApplicationInstancesShrinkRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceIdsShrink: String?

    public var limit: String?

    public var namespaceId: String?

    public var startTime: Int64?

    public var statusesShrink: String?

    public var versionIdsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceIdsShrink != nil {
            map["InstanceIds"] = self.instanceIdsShrink!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.statusesShrink != nil {
            map["Statuses"] = self.statusesShrink!
        }
        if self.versionIdsShrink != nil {
            map["VersionIds"] = self.versionIdsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIdsShrink = value
        }
        if let value = dict["Limit"] as? String {
            self.limit = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["Statuses"] as? String {
            self.statusesShrink = value
        }
        if let value = dict["VersionIds"] as? String {
            self.versionIdsShrink = value
        }
    }
}

public class ListWebApplicationInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWebApplicationInstancesBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListWebApplicationInstancesBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListWebApplicationRevisionsRequest : Tea.TeaModel {
    public var limit: Int32?

    public var namespaceId: String?

    public var nextToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Limit"] as? Int32 {
            self.limit = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
    }
}

public class ListWebApplicationRevisionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWebApplicationRevisionsBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListWebApplicationRevisionsBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListWebApplicationsRequest : Tea.TeaModel {
    public var limit: Int32?

    public var namespaceId: String?

    public var nextToken: String?

    public var prefix_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.prefix_ != nil {
            map["Prefix"] = self.prefix_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Limit"] as? Int32 {
            self.limit = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Prefix"] as? String {
            self.prefix_ = value
        }
    }
}

public class ListWebApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWebApplicationsBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListWebApplicationsBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListWebCustomDomainsRequest : Tea.TeaModel {
    public var applicationId: String?

    public var limit: Int32?

    public var namespaceId: String?

    public var nextToken: String?

    public var prefix_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.prefix_ != nil {
            map["Prefix"] = self.prefix_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["Limit"] as? Int32 {
            self.limit = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Prefix"] as? String {
            self.prefix_ = value
        }
    }
}

public class ListWebCustomDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWebCustomDomainBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListWebCustomDomainBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class OpenSaeServiceResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class OpenSaeServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenSaeServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = OpenSaeServiceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PublishWebApplicationRevisionRequest : Tea.TeaModel {
    public var namespaceId: String?

    public var body: PublishWebApplicationRevisionInput?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = PublishWebApplicationRevisionInput()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PublishWebApplicationRevisionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WebApplicationRevisionBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WebApplicationRevisionBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QueryArmsEnableRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class QueryArmsEnableResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var enable: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Enable"] as? Bool {
                self.enable = value
            }
        }
    }
    public var code: String?

    public var data: QueryArmsEnableResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = QueryArmsEnableResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class QueryArmsEnableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryArmsEnableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QueryArmsEnableResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class QueryResourceStaticsRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class QueryResourceStaticsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RealTimeRes : Tea.TeaModel {
            public var cpu: Double?

            public var ephemeralStorage: Double?

            public var memory: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.ephemeralStorage != nil {
                    map["EphemeralStorage"] = self.ephemeralStorage!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cpu"] as? Double {
                    self.cpu = value
                }
                if let value = dict["EphemeralStorage"] as? Double {
                    self.ephemeralStorage = value
                }
                if let value = dict["Memory"] as? Double {
                    self.memory = value
                }
            }
        }
        public class Summary : Tea.TeaModel {
            public var activeCpu: Double?

            public var cpu: Double?

            public var cu: Double?

            public var ephemeralStorage: Double?

            public var gpuA10: Double?

            public var gpuPpu810e: Double?

            public var idleCpu: Double?

            public var memory: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activeCpu != nil {
                    map["ActiveCpu"] = self.activeCpu!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.cu != nil {
                    map["Cu"] = self.cu!
                }
                if self.ephemeralStorage != nil {
                    map["EphemeralStorage"] = self.ephemeralStorage!
                }
                if self.gpuA10 != nil {
                    map["GpuA10"] = self.gpuA10!
                }
                if self.gpuPpu810e != nil {
                    map["GpuPpu810e"] = self.gpuPpu810e!
                }
                if self.idleCpu != nil {
                    map["IdleCpu"] = self.idleCpu!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ActiveCpu"] as? Double {
                    self.activeCpu = value
                }
                if let value = dict["Cpu"] as? Double {
                    self.cpu = value
                }
                if let value = dict["Cu"] as? Double {
                    self.cu = value
                }
                if let value = dict["EphemeralStorage"] as? Double {
                    self.ephemeralStorage = value
                }
                if let value = dict["GpuA10"] as? Double {
                    self.gpuA10 = value
                }
                if let value = dict["GpuPpu810e"] as? Double {
                    self.gpuPpu810e = value
                }
                if let value = dict["IdleCpu"] as? Double {
                    self.idleCpu = value
                }
                if let value = dict["Memory"] as? Double {
                    self.memory = value
                }
            }
        }
        public var realTimeRes: QueryResourceStaticsResponseBody.Data.RealTimeRes?

        public var summary: QueryResourceStaticsResponseBody.Data.Summary?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.realTimeRes?.validate()
            try self.summary?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.realTimeRes != nil {
                map["RealTimeRes"] = self.realTimeRes?.toMap()
            }
            if self.summary != nil {
                map["Summary"] = self.summary?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["RealTimeRes"] as? [String: Any?] {
                var model = QueryResourceStaticsResponseBody.Data.RealTimeRes()
                model.fromMap(value)
                self.realTimeRes = model
            }
            if let value = dict["Summary"] as? [String: Any?] {
                var model = QueryResourceStaticsResponseBody.Data.Summary()
                model.fromMap(value)
                self.summary = model
            }
        }
    }
    public var code: String?

    public var data: QueryResourceStaticsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = QueryResourceStaticsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class QueryResourceStaticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryResourceStaticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = QueryResourceStaticsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReduceApplicationCapacityByInstanceIdsRequest : Tea.TeaModel {
    public var appId: String?

    public var instanceIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
    }
}

public class ReduceApplicationCapacityByInstanceIdsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: ReduceApplicationCapacityByInstanceIdsResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ReduceApplicationCapacityByInstanceIdsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class ReduceApplicationCapacityByInstanceIdsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReduceApplicationCapacityByInstanceIdsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReduceApplicationCapacityByInstanceIdsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RescaleApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var autoEnableApplicationScalingRule: Bool?

    public var minReadyInstanceRatio: Int32?

    public var minReadyInstances: Int32?

    public var replicas: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.autoEnableApplicationScalingRule != nil {
            map["AutoEnableApplicationScalingRule"] = self.autoEnableApplicationScalingRule!
        }
        if self.minReadyInstanceRatio != nil {
            map["MinReadyInstanceRatio"] = self.minReadyInstanceRatio!
        }
        if self.minReadyInstances != nil {
            map["MinReadyInstances"] = self.minReadyInstances!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AutoEnableApplicationScalingRule"] as? Bool {
            self.autoEnableApplicationScalingRule = value
        }
        if let value = dict["MinReadyInstanceRatio"] as? Int32 {
            self.minReadyInstanceRatio = value
        }
        if let value = dict["MinReadyInstances"] as? Int32 {
            self.minReadyInstances = value
        }
        if let value = dict["Replicas"] as? Int32 {
            self.replicas = value
        }
    }
}

public class RescaleApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: RescaleApplicationResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = RescaleApplicationResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class RescaleApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RescaleApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RescaleApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RescaleApplicationVerticallyRequest : Tea.TeaModel {
    public var appId: String?

    public var cpu: String?

    public var diskSize: String?

    public var memory: String?

    public var resourceType: String?

    public var vSwitchId: String?

    public var autoEnableApplicationScalingRule: Bool?

    public var minReadyInstanceRatio: Int32?

    public var minReadyInstances: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.diskSize != nil {
            map["DiskSize"] = self.diskSize!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.autoEnableApplicationScalingRule != nil {
            map["autoEnableApplicationScalingRule"] = self.autoEnableApplicationScalingRule!
        }
        if self.minReadyInstanceRatio != nil {
            map["minReadyInstanceRatio"] = self.minReadyInstanceRatio!
        }
        if self.minReadyInstances != nil {
            map["minReadyInstances"] = self.minReadyInstances!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Cpu"] as? String {
            self.cpu = value
        }
        if let value = dict["DiskSize"] as? String {
            self.diskSize = value
        }
        if let value = dict["Memory"] as? String {
            self.memory = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["autoEnableApplicationScalingRule"] as? Bool {
            self.autoEnableApplicationScalingRule = value
        }
        if let value = dict["minReadyInstanceRatio"] as? Int32 {
            self.minReadyInstanceRatio = value
        }
        if let value = dict["minReadyInstances"] as? Int32 {
            self.minReadyInstances = value
        }
    }
}

public class RescaleApplicationVerticallyResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: RescaleApplicationVerticallyResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = RescaleApplicationVerticallyResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class RescaleApplicationVerticallyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RescaleApplicationVerticallyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RescaleApplicationVerticallyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RestartApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var autoEnableApplicationScalingRule: Bool?

    public var minReadyInstanceRatio: Int32?

    public var minReadyInstances: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.autoEnableApplicationScalingRule != nil {
            map["AutoEnableApplicationScalingRule"] = self.autoEnableApplicationScalingRule!
        }
        if self.minReadyInstanceRatio != nil {
            map["MinReadyInstanceRatio"] = self.minReadyInstanceRatio!
        }
        if self.minReadyInstances != nil {
            map["MinReadyInstances"] = self.minReadyInstances!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AutoEnableApplicationScalingRule"] as? Bool {
            self.autoEnableApplicationScalingRule = value
        }
        if let value = dict["MinReadyInstanceRatio"] as? Int32 {
            self.minReadyInstanceRatio = value
        }
        if let value = dict["MinReadyInstances"] as? Int32 {
            self.minReadyInstances = value
        }
    }
}

public class RestartApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: RestartApplicationResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = RestartApplicationResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class RestartApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RestartApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RestartInstancesRequest : Tea.TeaModel {
    public var appId: String?

    public var instanceIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["InstanceIds"] as? String {
            self.instanceIds = value
        }
    }
}

public class RestartInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: RestartInstancesResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = RestartInstancesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class RestartInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RestartInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RollbackApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public var autoEnableApplicationScalingRule: String?

    public var batchWaitTime: Int32?

    public var minReadyInstanceRatio: Int32?

    public var minReadyInstances: Int32?

    public var updateStrategy: String?

    public var versionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.autoEnableApplicationScalingRule != nil {
            map["AutoEnableApplicationScalingRule"] = self.autoEnableApplicationScalingRule!
        }
        if self.batchWaitTime != nil {
            map["BatchWaitTime"] = self.batchWaitTime!
        }
        if self.minReadyInstanceRatio != nil {
            map["MinReadyInstanceRatio"] = self.minReadyInstanceRatio!
        }
        if self.minReadyInstances != nil {
            map["MinReadyInstances"] = self.minReadyInstances!
        }
        if self.updateStrategy != nil {
            map["UpdateStrategy"] = self.updateStrategy!
        }
        if self.versionId != nil {
            map["VersionId"] = self.versionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AutoEnableApplicationScalingRule"] as? String {
            self.autoEnableApplicationScalingRule = value
        }
        if let value = dict["BatchWaitTime"] as? Int32 {
            self.batchWaitTime = value
        }
        if let value = dict["MinReadyInstanceRatio"] as? Int32 {
            self.minReadyInstanceRatio = value
        }
        if let value = dict["MinReadyInstances"] as? Int32 {
            self.minReadyInstances = value
        }
        if let value = dict["UpdateStrategy"] as? String {
            self.updateStrategy = value
        }
        if let value = dict["VersionId"] as? String {
            self.versionId = value
        }
    }
}

public class RollbackApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public var isNeedApproval: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            if self.isNeedApproval != nil {
                map["IsNeedApproval"] = self.isNeedApproval!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
            if let value = dict["IsNeedApproval"] as? Bool {
                self.isNeedApproval = value
            }
        }
    }
    public var code: String?

    public var data: RollbackApplicationResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = RollbackApplicationResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class RollbackApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RollbackApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RollbackApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class StartApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: StartApplicationResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = StartApplicationResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class StartApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartWebApplicationRequest : Tea.TeaModel {
    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class StartWebApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WebApplicationBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WebApplicationBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopApplicationRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class StopApplicationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: StopApplicationResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = StopApplicationResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class StopApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopWebApplicationRequest : Tea.TeaModel {
    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class StopWebApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WebApplicationBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WebApplicationBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SuspendJobRequest : Tea.TeaModel {
    public var appId: String?

    public var suspend: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.suspend != nil {
            map["Suspend"] = self.suspend!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Suspend"] as? Bool {
            self.suspend = value
        }
    }
}

public class SuspendJobResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class SuspendJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SuspendJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceIds: String?

    public var resourceType: String?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceIds"] as? String {
            self.resourceIds = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnbindNlbRequest : Tea.TeaModel {
    public var appId: String?

    public var nlbId: String?

    public var port: Int32?

    public var protocol_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.nlbId != nil {
            map["NlbId"] = self.nlbId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["NlbId"] as? String {
            self.nlbId = value
        }
        if let value = dict["Port"] as? Int32 {
            self.port = value
        }
        if let value = dict["Protocol"] as? String {
            self.protocol_ = value
        }
    }
}

public class UnbindNlbResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: UnbindNlbResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UnbindNlbResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class UnbindNlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindNlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnbindNlbResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnbindSlbRequest : Tea.TeaModel {
    public var appId: String?

    public var internet: Bool?

    public var intranet: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.internet != nil {
            map["Internet"] = self.internet!
        }
        if self.intranet != nil {
            map["Intranet"] = self.intranet!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Internet"] as? Bool {
            self.internet = value
        }
        if let value = dict["Intranet"] as? Bool {
            self.intranet = value
        }
    }
}

public class UnbindSlbResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: UnbindSlbResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UnbindSlbResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class UnbindSlbResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindSlbResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnbindSlbResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var deleteAll: Bool?

    public var regionId: String?

    public var resourceIds: String?

    public var resourceType: String?

    public var tagKeys: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteAll != nil {
            map["DeleteAll"] = self.deleteAll!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKeys != nil {
            map["TagKeys"] = self.tagKeys!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DeleteAll"] as? Bool {
            self.deleteAll = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceIds"] as? String {
            self.resourceIds = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["TagKeys"] as? String {
            self.tagKeys = value
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UntagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateAppModeRequest : Tea.TeaModel {
    public var appId: String?

    public var appIds: String?

    public var enableIdle: Bool?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appIds != nil {
            map["AppIds"] = self.appIds!
        }
        if self.enableIdle != nil {
            map["EnableIdle"] = self.enableIdle!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AppIds"] as? String {
            self.appIds = value
        }
        if let value = dict["EnableIdle"] as? Bool {
            self.enableIdle = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class UpdateAppModeResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class UpdateAppModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAppModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateAppModeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateAppSecurityGroupRequest : Tea.TeaModel {
    public var appId: String?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["SecurityGroupId"] as? String {
            self.securityGroupId = value
        }
    }
}

public class UpdateAppSecurityGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class UpdateAppSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAppSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateAppSecurityGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateApplicationDescriptionRequest : Tea.TeaModel {
    public var appDescription: String?

    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appDescription != nil {
            map["AppDescription"] = self.appDescription!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppDescription"] as? String {
            self.appDescription = value
        }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class UpdateApplicationDescriptionResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class UpdateApplicationDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApplicationDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateApplicationDescriptionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateApplicationScalingRuleRequest : Tea.TeaModel {
    public var appId: String?

    public var enableIdle: Bool?

    public var minReadyInstanceRatio: Int32?

    public var minReadyInstances: Int32?

    public var scalingRuleMetric: String?

    public var scalingRuleName: String?

    public var scalingRuleTimer: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.enableIdle != nil {
            map["EnableIdle"] = self.enableIdle!
        }
        if self.minReadyInstanceRatio != nil {
            map["MinReadyInstanceRatio"] = self.minReadyInstanceRatio!
        }
        if self.minReadyInstances != nil {
            map["MinReadyInstances"] = self.minReadyInstances!
        }
        if self.scalingRuleMetric != nil {
            map["ScalingRuleMetric"] = self.scalingRuleMetric!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        if self.scalingRuleTimer != nil {
            map["ScalingRuleTimer"] = self.scalingRuleTimer!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["EnableIdle"] as? Bool {
            self.enableIdle = value
        }
        if let value = dict["MinReadyInstanceRatio"] as? Int32 {
            self.minReadyInstanceRatio = value
        }
        if let value = dict["MinReadyInstances"] as? Int32 {
            self.minReadyInstances = value
        }
        if let value = dict["ScalingRuleMetric"] as? String {
            self.scalingRuleMetric = value
        }
        if let value = dict["ScalingRuleName"] as? String {
            self.scalingRuleName = value
        }
        if let value = dict["ScalingRuleTimer"] as? String {
            self.scalingRuleTimer = value
        }
    }
}

public class UpdateApplicationScalingRuleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Metric : Tea.TeaModel {
            public class Metrics : Tea.TeaModel {
                public var metricTargetAverageUtilization: Int32?

                public var metricType: String?

                public var slbId: String?

                public var slbLogstore: String?

                public var slbProject: String?

                public var vport: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricTargetAverageUtilization != nil {
                        map["MetricTargetAverageUtilization"] = self.metricTargetAverageUtilization!
                    }
                    if self.metricType != nil {
                        map["MetricType"] = self.metricType!
                    }
                    if self.slbId != nil {
                        map["SlbId"] = self.slbId!
                    }
                    if self.slbLogstore != nil {
                        map["SlbLogstore"] = self.slbLogstore!
                    }
                    if self.slbProject != nil {
                        map["SlbProject"] = self.slbProject!
                    }
                    if self.vport != nil {
                        map["Vport"] = self.vport!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MetricTargetAverageUtilization"] as? Int32 {
                        self.metricTargetAverageUtilization = value
                    }
                    if let value = dict["MetricType"] as? String {
                        self.metricType = value
                    }
                    if let value = dict["SlbId"] as? String {
                        self.slbId = value
                    }
                    if let value = dict["SlbLogstore"] as? String {
                        self.slbLogstore = value
                    }
                    if let value = dict["SlbProject"] as? String {
                        self.slbProject = value
                    }
                    if let value = dict["Vport"] as? String {
                        self.vport = value
                    }
                }
            }
            public var maxReplicas: Int32?

            public var metrics: [UpdateApplicationScalingRuleResponseBody.Data.Metric.Metrics]?

            public var minReplicas: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxReplicas != nil {
                    map["MaxReplicas"] = self.maxReplicas!
                }
                if self.metrics != nil {
                    var tmp : [Any] = []
                    for k in self.metrics! {
                        tmp.append(k.toMap())
                    }
                    map["Metrics"] = tmp
                }
                if self.minReplicas != nil {
                    map["MinReplicas"] = self.minReplicas!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["MaxReplicas"] as? Int32 {
                    self.maxReplicas = value
                }
                if let value = dict["Metrics"] as? [Any?] {
                    var tmp : [UpdateApplicationScalingRuleResponseBody.Data.Metric.Metrics] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateApplicationScalingRuleResponseBody.Data.Metric.Metrics()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.metrics = tmp
                }
                if let value = dict["MinReplicas"] as? Int32 {
                    self.minReplicas = value
                }
            }
        }
        public class Timer : Tea.TeaModel {
            public class Schedules : Tea.TeaModel {
                public var atTime: String?

                public var maxReplicas: Int32?

                public var minReplicas: Int32?

                public var targetReplicas: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.atTime != nil {
                        map["AtTime"] = self.atTime!
                    }
                    if self.maxReplicas != nil {
                        map["MaxReplicas"] = self.maxReplicas!
                    }
                    if self.minReplicas != nil {
                        map["MinReplicas"] = self.minReplicas!
                    }
                    if self.targetReplicas != nil {
                        map["TargetReplicas"] = self.targetReplicas!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AtTime"] as? String {
                        self.atTime = value
                    }
                    if let value = dict["MaxReplicas"] as? Int32 {
                        self.maxReplicas = value
                    }
                    if let value = dict["MinReplicas"] as? Int32 {
                        self.minReplicas = value
                    }
                    if let value = dict["TargetReplicas"] as? Int32 {
                        self.targetReplicas = value
                    }
                }
            }
            public var beginDate: String?

            public var endDate: String?

            public var period: String?

            public var schedules: [UpdateApplicationScalingRuleResponseBody.Data.Timer.Schedules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.beginDate != nil {
                    map["BeginDate"] = self.beginDate!
                }
                if self.endDate != nil {
                    map["EndDate"] = self.endDate!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.schedules != nil {
                    var tmp : [Any] = []
                    for k in self.schedules! {
                        tmp.append(k.toMap())
                    }
                    map["Schedules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BeginDate"] as? String {
                    self.beginDate = value
                }
                if let value = dict["EndDate"] as? String {
                    self.endDate = value
                }
                if let value = dict["Period"] as? String {
                    self.period = value
                }
                if let value = dict["Schedules"] as? [Any?] {
                    var tmp : [UpdateApplicationScalingRuleResponseBody.Data.Timer.Schedules] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateApplicationScalingRuleResponseBody.Data.Timer.Schedules()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.schedules = tmp
                }
            }
        }
        public var appId: String?

        public var createTime: Int64?

        public var enableIdle: Bool?

        public var lastDisableTime: Int64?

        public var metric: UpdateApplicationScalingRuleResponseBody.Data.Metric?

        public var scaleRuleEnabled: Bool?

        public var scaleRuleName: String?

        public var scaleRuleType: String?

        public var timer: UpdateApplicationScalingRuleResponseBody.Data.Timer?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metric?.validate()
            try self.timer?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.enableIdle != nil {
                map["EnableIdle"] = self.enableIdle!
            }
            if self.lastDisableTime != nil {
                map["LastDisableTime"] = self.lastDisableTime!
            }
            if self.metric != nil {
                map["Metric"] = self.metric?.toMap()
            }
            if self.scaleRuleEnabled != nil {
                map["ScaleRuleEnabled"] = self.scaleRuleEnabled!
            }
            if self.scaleRuleName != nil {
                map["ScaleRuleName"] = self.scaleRuleName!
            }
            if self.scaleRuleType != nil {
                map["ScaleRuleType"] = self.scaleRuleType!
            }
            if self.timer != nil {
                map["Timer"] = self.timer?.toMap()
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["EnableIdle"] as? Bool {
                self.enableIdle = value
            }
            if let value = dict["LastDisableTime"] as? Int64 {
                self.lastDisableTime = value
            }
            if let value = dict["Metric"] as? [String: Any?] {
                var model = UpdateApplicationScalingRuleResponseBody.Data.Metric()
                model.fromMap(value)
                self.metric = model
            }
            if let value = dict["ScaleRuleEnabled"] as? Bool {
                self.scaleRuleEnabled = value
            }
            if let value = dict["ScaleRuleName"] as? String {
                self.scaleRuleName = value
            }
            if let value = dict["ScaleRuleType"] as? String {
                self.scaleRuleType = value
            }
            if let value = dict["Timer"] as? [String: Any?] {
                var model = UpdateApplicationScalingRuleResponseBody.Data.Timer()
                model.fromMap(value)
                self.timer = model
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var code: String?

    public var data: UpdateApplicationScalingRuleResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UpdateApplicationScalingRuleResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class UpdateApplicationScalingRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApplicationScalingRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateApplicationScalingRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateApplicationVswitchesRequest : Tea.TeaModel {
    public var appId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class UpdateApplicationVswitchesResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class UpdateApplicationVswitchesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApplicationVswitchesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateApplicationVswitchesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateConfigMapRequest : Tea.TeaModel {
    public var configMapId: Int64?

    public var data: String?

    public var description_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configMapId != nil {
            map["ConfigMapId"] = self.configMapId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConfigMapId"] as? Int64 {
            self.configMapId = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
    }
}

public class UpdateConfigMapResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var configMapId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configMapId != nil {
                map["ConfigMapId"] = self.configMapId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConfigMapId"] as? String {
                self.configMapId = value
            }
        }
    }
    public var code: String?

    public var data: UpdateConfigMapResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UpdateConfigMapResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class UpdateConfigMapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateConfigMapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateConfigMapResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateGreyTagRouteRequest : Tea.TeaModel {
    public var albRules: String?

    public var description_: String?

    public var dubboRules: String?

    public var greyTagRouteId: Int64?

    public var scRules: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.albRules != nil {
            map["AlbRules"] = self.albRules!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dubboRules != nil {
            map["DubboRules"] = self.dubboRules!
        }
        if self.greyTagRouteId != nil {
            map["GreyTagRouteId"] = self.greyTagRouteId!
        }
        if self.scRules != nil {
            map["ScRules"] = self.scRules!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AlbRules"] as? String {
            self.albRules = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DubboRules"] as? String {
            self.dubboRules = value
        }
        if let value = dict["GreyTagRouteId"] as? Int64 {
            self.greyTagRouteId = value
        }
        if let value = dict["ScRules"] as? String {
            self.scRules = value
        }
    }
}

public class UpdateGreyTagRouteResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var greyTagRouteId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.greyTagRouteId != nil {
                map["GreyTagRouteId"] = self.greyTagRouteId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GreyTagRouteId"] as? Int64 {
                self.greyTagRouteId = value
            }
        }
    }
    public var code: String?

    public var data: UpdateGreyTagRouteResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UpdateGreyTagRouteResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class UpdateGreyTagRouteResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGreyTagRouteResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateGreyTagRouteResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateIngressRequest : Tea.TeaModel {
    public var certId: String?

    public var certIds: String?

    public var corsConfig: String?

    public var defaultRule: String?

    public var description_: String?

    public var enableXForwardedFor: Bool?

    public var enableXForwardedForClientSrcPort: Bool?

    public var enableXForwardedForProto: Bool?

    public var enableXForwardedForSlbId: Bool?

    public var enableXForwardedForSlbPort: Bool?

    public var idleTimeout: Int32?

    public var ingressId: Int64?

    public var listenerPort: String?

    public var listenerProtocol: String?

    public var loadBalanceType: String?

    public var requestTimeout: Int32?

    public var rules: String?

    public var securityPolicyId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certId != nil {
            map["CertId"] = self.certId!
        }
        if self.certIds != nil {
            map["CertIds"] = self.certIds!
        }
        if self.corsConfig != nil {
            map["CorsConfig"] = self.corsConfig!
        }
        if self.defaultRule != nil {
            map["DefaultRule"] = self.defaultRule!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableXForwardedFor != nil {
            map["EnableXForwardedFor"] = self.enableXForwardedFor!
        }
        if self.enableXForwardedForClientSrcPort != nil {
            map["EnableXForwardedForClientSrcPort"] = self.enableXForwardedForClientSrcPort!
        }
        if self.enableXForwardedForProto != nil {
            map["EnableXForwardedForProto"] = self.enableXForwardedForProto!
        }
        if self.enableXForwardedForSlbId != nil {
            map["EnableXForwardedForSlbId"] = self.enableXForwardedForSlbId!
        }
        if self.enableXForwardedForSlbPort != nil {
            map["EnableXForwardedForSlbPort"] = self.enableXForwardedForSlbPort!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.ingressId != nil {
            map["IngressId"] = self.ingressId!
        }
        if self.listenerPort != nil {
            map["ListenerPort"] = self.listenerPort!
        }
        if self.listenerProtocol != nil {
            map["ListenerProtocol"] = self.listenerProtocol!
        }
        if self.loadBalanceType != nil {
            map["LoadBalanceType"] = self.loadBalanceType!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.rules != nil {
            map["Rules"] = self.rules!
        }
        if self.securityPolicyId != nil {
            map["SecurityPolicyId"] = self.securityPolicyId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CertId"] as? String {
            self.certId = value
        }
        if let value = dict["CertIds"] as? String {
            self.certIds = value
        }
        if let value = dict["CorsConfig"] as? String {
            self.corsConfig = value
        }
        if let value = dict["DefaultRule"] as? String {
            self.defaultRule = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EnableXForwardedFor"] as? Bool {
            self.enableXForwardedFor = value
        }
        if let value = dict["EnableXForwardedForClientSrcPort"] as? Bool {
            self.enableXForwardedForClientSrcPort = value
        }
        if let value = dict["EnableXForwardedForProto"] as? Bool {
            self.enableXForwardedForProto = value
        }
        if let value = dict["EnableXForwardedForSlbId"] as? Bool {
            self.enableXForwardedForSlbId = value
        }
        if let value = dict["EnableXForwardedForSlbPort"] as? Bool {
            self.enableXForwardedForSlbPort = value
        }
        if let value = dict["IdleTimeout"] as? Int32 {
            self.idleTimeout = value
        }
        if let value = dict["IngressId"] as? Int64 {
            self.ingressId = value
        }
        if let value = dict["ListenerPort"] as? String {
            self.listenerPort = value
        }
        if let value = dict["ListenerProtocol"] as? String {
            self.listenerProtocol = value
        }
        if let value = dict["LoadBalanceType"] as? String {
            self.loadBalanceType = value
        }
        if let value = dict["RequestTimeout"] as? Int32 {
            self.requestTimeout = value
        }
        if let value = dict["Rules"] as? String {
            self.rules = value
        }
        if let value = dict["SecurityPolicyId"] as? String {
            self.securityPolicyId = value
        }
    }
}

public class UpdateIngressResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var ingressId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ingressId != nil {
                map["IngressId"] = self.ingressId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IngressId"] as? Int64 {
                self.ingressId = value
            }
        }
    }
    public var code: String?

    public var data: UpdateIngressResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UpdateIngressResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class UpdateIngressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIngressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateIngressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateJobRequest : Tea.TeaModel {
    public var acrAssumeRoleArn: String?

    public var acrInstanceId: String?

    public var appId: String?

    public var backoffLimit: Int64?

    public var bestEffortType: String?

    public var command: String?

    public var commandArgs: String?

    public var concurrencyPolicy: String?

    public var configMapMountDesc: String?

    public var customHostAlias: String?

    public var edasContainerVersion: String?

    public var enableImageAccl: Bool?

    public var envs: String?

    public var imagePullSecrets: String?

    public var imageUrl: String?

    public var jarStartArgs: String?

    public var jarStartOptions: String?

    public var jdk: String?

    public var mountDesc: String?

    public var mountHost: String?

    public var nasConfigs: String?

    public var nasId: String?

    public var ossAkId: String?

    public var ossAkSecret: String?

    public var ossMountDescs: String?

    public var packageUrl: String?

    public var packageVersion: String?

    public var php: String?

    public var phpConfig: String?

    public var phpConfigLocation: String?

    public var postStart: String?

    public var preStop: String?

    public var programmingLanguage: String?

    public var python: String?

    public var pythonModules: String?

    public var refAppId: String?

    public var replicas: String?

    public var slice: Bool?

    public var sliceEnvs: String?

    public var slsConfigs: String?

    public var terminationGracePeriodSeconds: Int32?

    public var timeout: Int64?

    public var timezone: String?

    public var tomcatConfig: String?

    public var triggerConfig: String?

    public var warStartOptions: String?

    public var webContainer: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acrAssumeRoleArn != nil {
            map["AcrAssumeRoleArn"] = self.acrAssumeRoleArn!
        }
        if self.acrInstanceId != nil {
            map["AcrInstanceId"] = self.acrInstanceId!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.backoffLimit != nil {
            map["BackoffLimit"] = self.backoffLimit!
        }
        if self.bestEffortType != nil {
            map["BestEffortType"] = self.bestEffortType!
        }
        if self.command != nil {
            map["Command"] = self.command!
        }
        if self.commandArgs != nil {
            map["CommandArgs"] = self.commandArgs!
        }
        if self.concurrencyPolicy != nil {
            map["ConcurrencyPolicy"] = self.concurrencyPolicy!
        }
        if self.configMapMountDesc != nil {
            map["ConfigMapMountDesc"] = self.configMapMountDesc!
        }
        if self.customHostAlias != nil {
            map["CustomHostAlias"] = self.customHostAlias!
        }
        if self.edasContainerVersion != nil {
            map["EdasContainerVersion"] = self.edasContainerVersion!
        }
        if self.enableImageAccl != nil {
            map["EnableImageAccl"] = self.enableImageAccl!
        }
        if self.envs != nil {
            map["Envs"] = self.envs!
        }
        if self.imagePullSecrets != nil {
            map["ImagePullSecrets"] = self.imagePullSecrets!
        }
        if self.imageUrl != nil {
            map["ImageUrl"] = self.imageUrl!
        }
        if self.jarStartArgs != nil {
            map["JarStartArgs"] = self.jarStartArgs!
        }
        if self.jarStartOptions != nil {
            map["JarStartOptions"] = self.jarStartOptions!
        }
        if self.jdk != nil {
            map["Jdk"] = self.jdk!
        }
        if self.mountDesc != nil {
            map["MountDesc"] = self.mountDesc!
        }
        if self.mountHost != nil {
            map["MountHost"] = self.mountHost!
        }
        if self.nasConfigs != nil {
            map["NasConfigs"] = self.nasConfigs!
        }
        if self.nasId != nil {
            map["NasId"] = self.nasId!
        }
        if self.ossAkId != nil {
            map["OssAkId"] = self.ossAkId!
        }
        if self.ossAkSecret != nil {
            map["OssAkSecret"] = self.ossAkSecret!
        }
        if self.ossMountDescs != nil {
            map["OssMountDescs"] = self.ossMountDescs!
        }
        if self.packageUrl != nil {
            map["PackageUrl"] = self.packageUrl!
        }
        if self.packageVersion != nil {
            map["PackageVersion"] = self.packageVersion!
        }
        if self.php != nil {
            map["Php"] = self.php!
        }
        if self.phpConfig != nil {
            map["PhpConfig"] = self.phpConfig!
        }
        if self.phpConfigLocation != nil {
            map["PhpConfigLocation"] = self.phpConfigLocation!
        }
        if self.postStart != nil {
            map["PostStart"] = self.postStart!
        }
        if self.preStop != nil {
            map["PreStop"] = self.preStop!
        }
        if self.programmingLanguage != nil {
            map["ProgrammingLanguage"] = self.programmingLanguage!
        }
        if self.python != nil {
            map["Python"] = self.python!
        }
        if self.pythonModules != nil {
            map["PythonModules"] = self.pythonModules!
        }
        if self.refAppId != nil {
            map["RefAppId"] = self.refAppId!
        }
        if self.replicas != nil {
            map["Replicas"] = self.replicas!
        }
        if self.slice != nil {
            map["Slice"] = self.slice!
        }
        if self.sliceEnvs != nil {
            map["SliceEnvs"] = self.sliceEnvs!
        }
        if self.slsConfigs != nil {
            map["SlsConfigs"] = self.slsConfigs!
        }
        if self.terminationGracePeriodSeconds != nil {
            map["TerminationGracePeriodSeconds"] = self.terminationGracePeriodSeconds!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.timezone != nil {
            map["Timezone"] = self.timezone!
        }
        if self.tomcatConfig != nil {
            map["TomcatConfig"] = self.tomcatConfig!
        }
        if self.triggerConfig != nil {
            map["TriggerConfig"] = self.triggerConfig!
        }
        if self.warStartOptions != nil {
            map["WarStartOptions"] = self.warStartOptions!
        }
        if self.webContainer != nil {
            map["WebContainer"] = self.webContainer!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcrAssumeRoleArn"] as? String {
            self.acrAssumeRoleArn = value
        }
        if let value = dict["AcrInstanceId"] as? String {
            self.acrInstanceId = value
        }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["BackoffLimit"] as? Int64 {
            self.backoffLimit = value
        }
        if let value = dict["BestEffortType"] as? String {
            self.bestEffortType = value
        }
        if let value = dict["Command"] as? String {
            self.command = value
        }
        if let value = dict["CommandArgs"] as? String {
            self.commandArgs = value
        }
        if let value = dict["ConcurrencyPolicy"] as? String {
            self.concurrencyPolicy = value
        }
        if let value = dict["ConfigMapMountDesc"] as? String {
            self.configMapMountDesc = value
        }
        if let value = dict["CustomHostAlias"] as? String {
            self.customHostAlias = value
        }
        if let value = dict["EdasContainerVersion"] as? String {
            self.edasContainerVersion = value
        }
        if let value = dict["EnableImageAccl"] as? Bool {
            self.enableImageAccl = value
        }
        if let value = dict["Envs"] as? String {
            self.envs = value
        }
        if let value = dict["ImagePullSecrets"] as? String {
            self.imagePullSecrets = value
        }
        if let value = dict["ImageUrl"] as? String {
            self.imageUrl = value
        }
        if let value = dict["JarStartArgs"] as? String {
            self.jarStartArgs = value
        }
        if let value = dict["JarStartOptions"] as? String {
            self.jarStartOptions = value
        }
        if let value = dict["Jdk"] as? String {
            self.jdk = value
        }
        if let value = dict["MountDesc"] as? String {
            self.mountDesc = value
        }
        if let value = dict["MountHost"] as? String {
            self.mountHost = value
        }
        if let value = dict["NasConfigs"] as? String {
            self.nasConfigs = value
        }
        if let value = dict["NasId"] as? String {
            self.nasId = value
        }
        if let value = dict["OssAkId"] as? String {
            self.ossAkId = value
        }
        if let value = dict["OssAkSecret"] as? String {
            self.ossAkSecret = value
        }
        if let value = dict["OssMountDescs"] as? String {
            self.ossMountDescs = value
        }
        if let value = dict["PackageUrl"] as? String {
            self.packageUrl = value
        }
        if let value = dict["PackageVersion"] as? String {
            self.packageVersion = value
        }
        if let value = dict["Php"] as? String {
            self.php = value
        }
        if let value = dict["PhpConfig"] as? String {
            self.phpConfig = value
        }
        if let value = dict["PhpConfigLocation"] as? String {
            self.phpConfigLocation = value
        }
        if let value = dict["PostStart"] as? String {
            self.postStart = value
        }
        if let value = dict["PreStop"] as? String {
            self.preStop = value
        }
        if let value = dict["ProgrammingLanguage"] as? String {
            self.programmingLanguage = value
        }
        if let value = dict["Python"] as? String {
            self.python = value
        }
        if let value = dict["PythonModules"] as? String {
            self.pythonModules = value
        }
        if let value = dict["RefAppId"] as? String {
            self.refAppId = value
        }
        if let value = dict["Replicas"] as? String {
            self.replicas = value
        }
        if let value = dict["Slice"] as? Bool {
            self.slice = value
        }
        if let value = dict["SliceEnvs"] as? String {
            self.sliceEnvs = value
        }
        if let value = dict["SlsConfigs"] as? String {
            self.slsConfigs = value
        }
        if let value = dict["TerminationGracePeriodSeconds"] as? Int32 {
            self.terminationGracePeriodSeconds = value
        }
        if let value = dict["Timeout"] as? Int64 {
            self.timeout = value
        }
        if let value = dict["Timezone"] as? String {
            self.timezone = value
        }
        if let value = dict["TomcatConfig"] as? String {
            self.tomcatConfig = value
        }
        if let value = dict["TriggerConfig"] as? String {
            self.triggerConfig = value
        }
        if let value = dict["WarStartOptions"] as? String {
            self.warStartOptions = value
        }
        if let value = dict["WebContainer"] as? String {
            self.webContainer = value
        }
    }
}

public class UpdateJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var changeOrderId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.changeOrderId != nil {
                map["ChangeOrderId"] = self.changeOrderId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["ChangeOrderId"] as? String {
                self.changeOrderId = value
            }
        }
    }
    public var code: String?

    public var data: UpdateJobResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UpdateJobResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class UpdateJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateNamespaceRequest : Tea.TeaModel {
    public var enableMicroRegistration: Bool?

    public var nameSpaceShortId: String?

    public var namespaceDescription: String?

    public var namespaceId: String?

    public var namespaceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enableMicroRegistration != nil {
            map["EnableMicroRegistration"] = self.enableMicroRegistration!
        }
        if self.nameSpaceShortId != nil {
            map["NameSpaceShortId"] = self.nameSpaceShortId!
        }
        if self.namespaceDescription != nil {
            map["NamespaceDescription"] = self.namespaceDescription!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.namespaceName != nil {
            map["NamespaceName"] = self.namespaceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EnableMicroRegistration"] as? Bool {
            self.enableMicroRegistration = value
        }
        if let value = dict["NameSpaceShortId"] as? String {
            self.nameSpaceShortId = value
        }
        if let value = dict["NamespaceDescription"] as? String {
            self.namespaceDescription = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["NamespaceName"] as? String {
            self.namespaceName = value
        }
    }
}

public class UpdateNamespaceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var enableMicroRegistration: Bool?

        public var nameSpaceShortId: String?

        public var namespaceDescription: String?

        public var namespaceId: String?

        public var namespaceName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableMicroRegistration != nil {
                map["EnableMicroRegistration"] = self.enableMicroRegistration!
            }
            if self.nameSpaceShortId != nil {
                map["NameSpaceShortId"] = self.nameSpaceShortId!
            }
            if self.namespaceDescription != nil {
                map["NamespaceDescription"] = self.namespaceDescription!
            }
            if self.namespaceId != nil {
                map["NamespaceId"] = self.namespaceId!
            }
            if self.namespaceName != nil {
                map["NamespaceName"] = self.namespaceName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EnableMicroRegistration"] as? Bool {
                self.enableMicroRegistration = value
            }
            if let value = dict["NameSpaceShortId"] as? String {
                self.nameSpaceShortId = value
            }
            if let value = dict["NamespaceDescription"] as? String {
                self.namespaceDescription = value
            }
            if let value = dict["NamespaceId"] as? String {
                self.namespaceId = value
            }
            if let value = dict["NamespaceName"] as? String {
                self.namespaceName = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
        }
    }
    public var code: String?

    public var data: UpdateNamespaceResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UpdateNamespaceResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class UpdateNamespaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNamespaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateNamespaceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateNamespaceVpcRequest : Tea.TeaModel {
    public var nameSpaceShortId: String?

    public var namespaceId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nameSpaceShortId != nil {
            map["NameSpaceShortId"] = self.nameSpaceShortId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NameSpaceShortId"] as? String {
            self.nameSpaceShortId = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class UpdateNamespaceVpcResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class UpdateNamespaceVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNamespaceVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateNamespaceVpcResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateSecretRequest : Tea.TeaModel {
    public class SecretData : Tea.TeaModel {
        public var secretData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.secretData != nil {
                map["SecretData"] = self.secretData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SecretData"] as? String {
                self.secretData = value
            }
        }
    }
    public var namespaceId: String?

    public var secretData: UpdateSecretRequest.SecretData?

    public var secretId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.secretData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.secretData != nil {
            map["SecretData"] = self.secretData?.toMap()
        }
        if self.secretId != nil {
            map["SecretId"] = self.secretId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["SecretData"] as? [String: Any?] {
            var model = UpdateSecretRequest.SecretData()
            model.fromMap(value)
            self.secretData = model
        }
        if let value = dict["SecretId"] as? Int64 {
            self.secretId = value
        }
    }
}

public class UpdateSecretShrinkRequest : Tea.TeaModel {
    public var namespaceId: String?

    public var secretDataShrink: String?

    public var secretId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.secretDataShrink != nil {
            map["SecretData"] = self.secretDataShrink!
        }
        if self.secretId != nil {
            map["SecretId"] = self.secretId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["SecretData"] as? String {
            self.secretDataShrink = value
        }
        if let value = dict["SecretId"] as? Int64 {
            self.secretId = value
        }
    }
}

public class UpdateSecretResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var secretId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.secretId != nil {
                map["SecretId"] = self.secretId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SecretId"] as? Int64 {
                self.secretId = value
            }
        }
    }
    public var code: String?

    public var data: UpdateSecretResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UpdateSecretResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class UpdateSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateSecretResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateSwimmingLaneEnableAttributeRequest : Tea.TeaModel {
    public var enable: Bool?

    public var groupId: Int64?

    public var laneId: Int64?

    public var namespaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.laneId != nil {
            map["LaneId"] = self.laneId!
        }
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Enable"] as? Bool {
            self.enable = value
        }
        if let value = dict["GroupId"] as? Int64 {
            self.groupId = value
        }
        if let value = dict["LaneId"] as? Int64 {
            self.laneId = value
        }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
    }
}

public class UpdateSwimmingLaneEnableAttributeResponseBody : Tea.TeaModel {
    public var code: String?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class UpdateSwimmingLaneEnableAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSwimmingLaneEnableAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateSwimmingLaneEnableAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateWebApplicationRequest : Tea.TeaModel {
    public var namespaceId: String?

    public var body: UpdateWebApplicationInput?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateWebApplicationInput()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateWebApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WebApplicationBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WebApplicationBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateWebApplicationScalingConfigRequest : Tea.TeaModel {
    public var namespaceId: String?

    public var body: UpdateWebApplicationScalingConfigInput?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateWebApplicationScalingConfigInput()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateWebApplicationScalingConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WebApplicationScalingConfigBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WebApplicationScalingConfigBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateWebApplicationTrafficConfigRequest : Tea.TeaModel {
    public var namespaceId: String?

    public var body: UpdateWebApplicationTrafficConfigInput?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateWebApplicationTrafficConfigInput()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateWebApplicationTrafficConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WebApplicationTrafficConfigBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WebApplicationTrafficConfigBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateWebCustomDomainRequest : Tea.TeaModel {
    public var namespaceId: String?

    public var body: UpdateWebCustomDomainInput?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.namespaceId != nil {
            map["NamespaceId"] = self.namespaceId!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NamespaceId"] as? String {
            self.namespaceId = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateWebCustomDomainInput()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateWebCustomDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WebCustomDomainBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = WebCustomDomainBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpgradeApplicationApmServiceRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class UpgradeApplicationApmServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var status: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Status"] as? Bool {
                self.status = value
            }
        }
    }
    public var code: String?

    public var data: UpgradeApplicationApmServiceResponseBody.Data?

    public var errorCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var traceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UpgradeApplicationApmServiceResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["ErrorCode"] as? String {
            self.errorCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TraceId"] as? String {
            self.traceId = value
        }
    }
}

public class UpgradeApplicationApmServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeApplicationApmServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpgradeApplicationApmServiceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}
