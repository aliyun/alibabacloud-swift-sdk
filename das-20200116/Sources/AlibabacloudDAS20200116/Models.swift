import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class DataResultValue : Tea.TeaModel {
    public var sqlId: String?

    public var instanceId: String?

    public var count: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.sqlId != nil {
            map["sqlId"] = self.sqlId!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.count != nil {
            map["count"] = self.count!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("sqlId") {
            self.sqlId = dict["sqlId"] as! String
        }
        if dict.keys.contains("instanceId") {
            self.instanceId = dict["instanceId"] as! String
        }
        if dict.keys.contains("count") {
            self.count = dict["count"] as! Int32
        }
    }
}

public class DataSessionStatClientStatsValue : Tea.TeaModel {
    public var activeCount: Int64?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activeCount != nil {
            map["ActiveCount"] = self.activeCount!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActiveCount") {
            self.activeCount = dict["ActiveCount"] as! Int64
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DataSessionStatDbStatsValue : Tea.TeaModel {
    public var activeCount: Int64?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activeCount != nil {
            map["ActiveCount"] = self.activeCount!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActiveCount") {
            self.activeCount = dict["ActiveCount"] as! Int64
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DataValue : Tea.TeaModel {
    public var timestamp: String?

    public var value: Any?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.timestamp != nil {
            map["Timestamp"] = self.timestamp!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Timestamp") {
            self.timestamp = dict["Timestamp"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! Any
        }
    }
}

public class AddHDMInstanceRequest : Tea.TeaModel {
    public var engine: String?

    public var flushAccount: String?

    public var instanceAlias: String?

    public var instanceArea: String?

    public var instanceId: String?

    public var ip: String?

    public var networkType: String?

    public var password: String?

    public var port: String?

    public var region: String?

    public var username: String?

    public var vpcId: String?

    public var context: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.flushAccount != nil {
            map["FlushAccount"] = self.flushAccount!
        }
        if self.instanceAlias != nil {
            map["InstanceAlias"] = self.instanceAlias!
        }
        if self.instanceArea != nil {
            map["InstanceArea"] = self.instanceArea!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ip != nil {
            map["Ip"] = self.ip!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.context != nil {
            map["__context"] = self.context!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Engine") {
            self.engine = dict["Engine"] as! String
        }
        if dict.keys.contains("FlushAccount") {
            self.flushAccount = dict["FlushAccount"] as! String
        }
        if dict.keys.contains("InstanceAlias") {
            self.instanceAlias = dict["InstanceAlias"] as! String
        }
        if dict.keys.contains("InstanceArea") {
            self.instanceArea = dict["InstanceArea"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ip") {
            self.ip = dict["Ip"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("Port") {
            self.port = dict["Port"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Username") {
            self.username = dict["Username"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("__context") {
            self.context = dict["__context"] as! String
        }
    }
}

public class AddHDMInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var callerUid: String?

        public var code: Int32?

        public var error: String?

        public var instanceId: String?

        public var ip: String?

        public var ownerId: String?

        public var port: Int32?

        public var role: String?

        public var tenantId: String?

        public var token: String?

        public var uuid: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callerUid != nil {
                map["CallerUid"] = self.callerUid!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.error != nil {
                map["Error"] = self.error!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.ip != nil {
                map["Ip"] = self.ip!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.tenantId != nil {
                map["TenantId"] = self.tenantId!
            }
            if self.token != nil {
                map["Token"] = self.token!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallerUid") {
                self.callerUid = dict["CallerUid"] as! String
            }
            if dict.keys.contains("Code") {
                self.code = dict["Code"] as! Int32
            }
            if dict.keys.contains("Error") {
                self.error = dict["Error"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Ip") {
                self.ip = dict["Ip"] as! String
            }
            if dict.keys.contains("OwnerId") {
                self.ownerId = dict["OwnerId"] as! String
            }
            if dict.keys.contains("Port") {
                self.port = dict["Port"] as! Int32
            }
            if dict.keys.contains("Role") {
                self.role = dict["Role"] as! String
            }
            if dict.keys.contains("TenantId") {
                self.tenantId = dict["TenantId"] as! String
            }
            if dict.keys.contains("Token") {
                self.token = dict["Token"] as! String
            }
            if dict.keys.contains("Uuid") {
                self.uuid = dict["Uuid"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var code: String?

    public var data: AddHDMInstanceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var synchro: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchro != nil {
            map["Synchro"] = self.synchro!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = AddHDMInstanceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Synchro") {
            self.synchro = dict["Synchro"] as! String
        }
    }
}

public class AddHDMInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddHDMInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddHDMInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCacheAnalysisJobRequest : Tea.TeaModel {
    public var backupSetId: String?

    public var instanceId: String?

    public var nodeId: String?

    public var separators: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupSetId != nil {
            map["BackupSetId"] = self.backupSetId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.separators != nil {
            map["Separators"] = self.separators!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackupSetId") {
            self.backupSetId = dict["BackupSetId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("Separators") {
            self.separators = dict["Separators"] as! String
        }
    }
}

public class CreateCacheAnalysisJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class BigKeys : Tea.TeaModel {
            public class KeyInfo : Tea.TeaModel {
                public var bytes: Int64?

                public var count: Int64?

                public var db: Int32?

                public var encoding: String?

                public var expirationTimeMillis: Int64?

                public var key: String?

                public var nodeId: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bytes != nil {
                        map["Bytes"] = self.bytes!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.db != nil {
                        map["Db"] = self.db!
                    }
                    if self.encoding != nil {
                        map["Encoding"] = self.encoding!
                    }
                    if self.expirationTimeMillis != nil {
                        map["ExpirationTimeMillis"] = self.expirationTimeMillis!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bytes") {
                        self.bytes = dict["Bytes"] as! Int64
                    }
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int64
                    }
                    if dict.keys.contains("Db") {
                        self.db = dict["Db"] as! Int32
                    }
                    if dict.keys.contains("Encoding") {
                        self.encoding = dict["Encoding"] as! String
                    }
                    if dict.keys.contains("ExpirationTimeMillis") {
                        self.expirationTimeMillis = dict["ExpirationTimeMillis"] as! Int64
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("NodeId") {
                        self.nodeId = dict["NodeId"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var keyInfo: [CreateCacheAnalysisJobResponseBody.Data.BigKeys.KeyInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.keyInfo != nil {
                    var tmp : [Any] = []
                    for k in self.keyInfo! {
                        tmp.append(k.toMap())
                    }
                    map["KeyInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("KeyInfo") {
                    var tmp : [CreateCacheAnalysisJobResponseBody.Data.BigKeys.KeyInfo] = []
                    for v in dict["KeyInfo"] as! [Any] {
                        var model = CreateCacheAnalysisJobResponseBody.Data.BigKeys.KeyInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.keyInfo = tmp
                }
            }
        }
        public var bigKeys: CreateCacheAnalysisJobResponseBody.Data.BigKeys?

        public var instanceId: String?

        public var jobId: String?

        public var message: String?

        public var nodeId: String?

        public var taskState: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.bigKeys?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bigKeys != nil {
                map["BigKeys"] = self.bigKeys?.toMap()
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.taskState != nil {
                map["TaskState"] = self.taskState!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BigKeys") {
                var model = CreateCacheAnalysisJobResponseBody.Data.BigKeys()
                model.fromMap(dict["BigKeys"] as! [String: Any])
                self.bigKeys = model
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("TaskState") {
                self.taskState = dict["TaskState"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateCacheAnalysisJobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateCacheAnalysisJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateCacheAnalysisJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCacheAnalysisJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCacheAnalysisJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCloudBenchTasksRequest : Tea.TeaModel {
    public var amount: String?

    public var backupId: String?

    public var backupTime: String?

    public var clientType: String?

    public var description_: String?

    public var dstConnectionString: String?

    public var dstInstanceId: String?

    public var dstPort: String?

    public var dstSuperAccount: String?

    public var dstSuperPassword: String?

    public var dstType: String?

    public var dtsJobClass: String?

    public var dtsJobId: String?

    public var endState: String?

    public var gatewayVpcId: String?

    public var gatewayVpcIp: String?

    public var rate: String?

    public var requestDuration: String?

    public var requestEndTime: String?

    public var requestStartTime: String?

    public var smartPressureTime: String?

    public var srcInstanceId: String?

    public var srcPublicIp: String?

    public var srcSuperAccount: String?

    public var srcSuperPassword: String?

    public var taskType: String?

    public var workDir: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.backupTime != nil {
            map["BackupTime"] = self.backupTime!
        }
        if self.clientType != nil {
            map["ClientType"] = self.clientType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dstConnectionString != nil {
            map["DstConnectionString"] = self.dstConnectionString!
        }
        if self.dstInstanceId != nil {
            map["DstInstanceId"] = self.dstInstanceId!
        }
        if self.dstPort != nil {
            map["DstPort"] = self.dstPort!
        }
        if self.dstSuperAccount != nil {
            map["DstSuperAccount"] = self.dstSuperAccount!
        }
        if self.dstSuperPassword != nil {
            map["DstSuperPassword"] = self.dstSuperPassword!
        }
        if self.dstType != nil {
            map["DstType"] = self.dstType!
        }
        if self.dtsJobClass != nil {
            map["DtsJobClass"] = self.dtsJobClass!
        }
        if self.dtsJobId != nil {
            map["DtsJobId"] = self.dtsJobId!
        }
        if self.endState != nil {
            map["EndState"] = self.endState!
        }
        if self.gatewayVpcId != nil {
            map["GatewayVpcId"] = self.gatewayVpcId!
        }
        if self.gatewayVpcIp != nil {
            map["GatewayVpcIp"] = self.gatewayVpcIp!
        }
        if self.rate != nil {
            map["Rate"] = self.rate!
        }
        if self.requestDuration != nil {
            map["RequestDuration"] = self.requestDuration!
        }
        if self.requestEndTime != nil {
            map["RequestEndTime"] = self.requestEndTime!
        }
        if self.requestStartTime != nil {
            map["RequestStartTime"] = self.requestStartTime!
        }
        if self.smartPressureTime != nil {
            map["SmartPressureTime"] = self.smartPressureTime!
        }
        if self.srcInstanceId != nil {
            map["SrcInstanceId"] = self.srcInstanceId!
        }
        if self.srcPublicIp != nil {
            map["SrcPublicIp"] = self.srcPublicIp!
        }
        if self.srcSuperAccount != nil {
            map["SrcSuperAccount"] = self.srcSuperAccount!
        }
        if self.srcSuperPassword != nil {
            map["SrcSuperPassword"] = self.srcSuperPassword!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        if self.workDir != nil {
            map["WorkDir"] = self.workDir!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! String
        }
        if dict.keys.contains("BackupId") {
            self.backupId = dict["BackupId"] as! String
        }
        if dict.keys.contains("BackupTime") {
            self.backupTime = dict["BackupTime"] as! String
        }
        if dict.keys.contains("ClientType") {
            self.clientType = dict["ClientType"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DstConnectionString") {
            self.dstConnectionString = dict["DstConnectionString"] as! String
        }
        if dict.keys.contains("DstInstanceId") {
            self.dstInstanceId = dict["DstInstanceId"] as! String
        }
        if dict.keys.contains("DstPort") {
            self.dstPort = dict["DstPort"] as! String
        }
        if dict.keys.contains("DstSuperAccount") {
            self.dstSuperAccount = dict["DstSuperAccount"] as! String
        }
        if dict.keys.contains("DstSuperPassword") {
            self.dstSuperPassword = dict["DstSuperPassword"] as! String
        }
        if dict.keys.contains("DstType") {
            self.dstType = dict["DstType"] as! String
        }
        if dict.keys.contains("DtsJobClass") {
            self.dtsJobClass = dict["DtsJobClass"] as! String
        }
        if dict.keys.contains("DtsJobId") {
            self.dtsJobId = dict["DtsJobId"] as! String
        }
        if dict.keys.contains("EndState") {
            self.endState = dict["EndState"] as! String
        }
        if dict.keys.contains("GatewayVpcId") {
            self.gatewayVpcId = dict["GatewayVpcId"] as! String
        }
        if dict.keys.contains("GatewayVpcIp") {
            self.gatewayVpcIp = dict["GatewayVpcIp"] as! String
        }
        if dict.keys.contains("Rate") {
            self.rate = dict["Rate"] as! String
        }
        if dict.keys.contains("RequestDuration") {
            self.requestDuration = dict["RequestDuration"] as! String
        }
        if dict.keys.contains("RequestEndTime") {
            self.requestEndTime = dict["RequestEndTime"] as! String
        }
        if dict.keys.contains("RequestStartTime") {
            self.requestStartTime = dict["RequestStartTime"] as! String
        }
        if dict.keys.contains("SmartPressureTime") {
            self.smartPressureTime = dict["SmartPressureTime"] as! String
        }
        if dict.keys.contains("SrcInstanceId") {
            self.srcInstanceId = dict["SrcInstanceId"] as! String
        }
        if dict.keys.contains("SrcPublicIp") {
            self.srcPublicIp = dict["SrcPublicIp"] as! String
        }
        if dict.keys.contains("SrcSuperAccount") {
            self.srcSuperAccount = dict["SrcSuperAccount"] as! String
        }
        if dict.keys.contains("SrcSuperPassword") {
            self.srcSuperPassword = dict["SrcSuperPassword"] as! String
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
        if dict.keys.contains("WorkDir") {
            self.workDir = dict["WorkDir"] as! String
        }
    }
}

public class CreateCloudBenchTasksResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var taskIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.taskIds != nil {
                map["taskIds"] = self.taskIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("taskIds") {
                self.taskIds = dict["taskIds"] as! [String]
            }
        }
    }
    public var code: String?

    public var data: CreateCloudBenchTasksResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateCloudBenchTasksResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateCloudBenchTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCloudBenchTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCloudBenchTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDiagnosticReportRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBInstanceId") {
            self.DBInstanceId = dict["DBInstanceId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class CreateDiagnosticReportResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateDiagnosticReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDiagnosticReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDiagnosticReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateKillInstanceSessionTaskRequest : Tea.TeaModel {
    public var dbUser: String?

    public var dbUserPassword: String?

    public var ignoredUsers: String?

    public var instanceId: String?

    public var killAllSessions: Bool?

    public var nodeId: String?

    public var sessionIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbUser != nil {
            map["DbUser"] = self.dbUser!
        }
        if self.dbUserPassword != nil {
            map["DbUserPassword"] = self.dbUserPassword!
        }
        if self.ignoredUsers != nil {
            map["IgnoredUsers"] = self.ignoredUsers!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.killAllSessions != nil {
            map["KillAllSessions"] = self.killAllSessions!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.sessionIds != nil {
            map["SessionIds"] = self.sessionIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbUser") {
            self.dbUser = dict["DbUser"] as! String
        }
        if dict.keys.contains("DbUserPassword") {
            self.dbUserPassword = dict["DbUserPassword"] as! String
        }
        if dict.keys.contains("IgnoredUsers") {
            self.ignoredUsers = dict["IgnoredUsers"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("KillAllSessions") {
            self.killAllSessions = dict["KillAllSessions"] as! Bool
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("SessionIds") {
            self.sessionIds = dict["SessionIds"] as! String
        }
    }
}

public class CreateKillInstanceSessionTaskResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateKillInstanceSessionTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateKillInstanceSessionTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateKillInstanceSessionTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateKillInstanceSessionTaskWithMaintainUserRequest : Tea.TeaModel {
    public var ignoredUsers: String?

    public var instanceId: String?

    public var killAllSessions: Bool?

    public var nodeId: String?

    public var sessionIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ignoredUsers != nil {
            map["IgnoredUsers"] = self.ignoredUsers!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.killAllSessions != nil {
            map["KillAllSessions"] = self.killAllSessions!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.sessionIds != nil {
            map["SessionIds"] = self.sessionIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IgnoredUsers") {
            self.ignoredUsers = dict["IgnoredUsers"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("KillAllSessions") {
            self.killAllSessions = dict["KillAllSessions"] as! Bool
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("SessionIds") {
            self.sessionIds = dict["SessionIds"] as! String
        }
    }
}

public class CreateKillInstanceSessionTaskWithMaintainUserResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateKillInstanceSessionTaskWithMaintainUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateKillInstanceSessionTaskWithMaintainUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateKillInstanceSessionTaskWithMaintainUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLatestDeadLockAnalysisRequest : Tea.TeaModel {
    public var instanceId: String?

    public var nodeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
    }
}

public class CreateLatestDeadLockAnalysisResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateLatestDeadLockAnalysisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLatestDeadLockAnalysisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLatestDeadLockAnalysisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateQueryOptimizeTagRequest : Tea.TeaModel {
    public var comments: String?

    public var engine: String?

    public var instanceId: String?

    public var sqlIds: String?

    public var status: Int32?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comments != nil {
            map["Comments"] = self.comments!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sqlIds != nil {
            map["SqlIds"] = self.sqlIds!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comments") {
            self.comments = dict["Comments"] as! String
        }
        if dict.keys.contains("Engine") {
            self.engine = dict["Engine"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SqlIds") {
            self.sqlIds = dict["SqlIds"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
    }
}

public class CreateQueryOptimizeTagResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateQueryOptimizeTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateQueryOptimizeTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateQueryOptimizeTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRequestDiagnosisRequest : Tea.TeaModel {
    public var database: String?

    public var instanceId: String?

    public var nodeId: String?

    public var sql: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.database != nil {
            map["Database"] = self.database!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.sql != nil {
            map["Sql"] = self.sql!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Database") {
            self.database = dict["Database"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("Sql") {
            self.sql = dict["Sql"] as! String
        }
    }
}

public class CreateRequestDiagnosisResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateRequestDiagnosisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRequestDiagnosisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRequestDiagnosisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSqlLogTaskRequest : Tea.TeaModel {
    public class Filters : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var endTime: Int64?

    public var filters: [CreateSqlLogTaskRequest.Filters]?

    public var instanceId: String?

    public var name: String?

    public var nodeId: String?

    public var role: String?

    public var startTime: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filters != nil {
            var tmp : [Any] = []
            for k in self.filters! {
                tmp.append(k.toMap())
            }
            map["Filters"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Filters") {
            var tmp : [CreateSqlLogTaskRequest.Filters] = []
            for v in dict["Filters"] as! [Any] {
                var model = CreateSqlLogTaskRequest.Filters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filters = tmp
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateSqlLogTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var createTime: Int64?

        public var end: Int64?

        public var instanceId: String?

        public var name: String?

        public var start: Int64?

        public var status: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.end != nil {
                map["End"] = self.end!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.start != nil {
                map["Start"] = self.start!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("End") {
                self.end = dict["End"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Start") {
                self.start = dict["Start"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateSqlLogTaskResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateSqlLogTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class CreateSqlLogTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSqlLogTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSqlLogTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateStorageAnalysisTaskRequest : Tea.TeaModel {
    public var dbName: String?

    public var instanceId: String?

    public var nodeId: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TableName") {
            self.tableName = dict["TableName"] as! String
        }
    }
}

public class CreateStorageAnalysisTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var createTaskSuccess: Bool?

        public var errorMessage: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTaskSuccess != nil {
                map["CreateTaskSuccess"] = self.createTaskSuccess!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTaskSuccess") {
                self.createTaskSuccess = dict["CreateTaskSuccess"] as! Bool
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
        }
    }
    public var code: Int64?

    public var data: CreateStorageAnalysisTaskResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = CreateStorageAnalysisTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class CreateStorageAnalysisTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateStorageAnalysisTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateStorageAnalysisTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCloudBenchTaskRequest : Tea.TeaModel {
    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DeleteCloudBenchTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DeleteCloudBenchTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCloudBenchTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCloudBenchTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteStopGatewayRequest : Tea.TeaModel {
    public var gatewayId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.gatewayId != nil {
            map["GatewayId"] = self.gatewayId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("GatewayId") {
            self.gatewayId = dict["GatewayId"] as! String
        }
    }
}

public class DeleteStopGatewayResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DeleteStopGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteStopGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteStopGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAutoScalingConfigRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeAutoScalingConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Bandwidth : Tea.TeaModel {
            public var bandwidthUsageLowerThreshold: Int32?

            public var bandwidthUsageUpperThreshold: Int32?

            public var downgrade: Bool?

            public var observationWindowSize: String?

            public var upgrade: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandwidthUsageLowerThreshold != nil {
                    map["BandwidthUsageLowerThreshold"] = self.bandwidthUsageLowerThreshold!
                }
                if self.bandwidthUsageUpperThreshold != nil {
                    map["BandwidthUsageUpperThreshold"] = self.bandwidthUsageUpperThreshold!
                }
                if self.downgrade != nil {
                    map["Downgrade"] = self.downgrade!
                }
                if self.observationWindowSize != nil {
                    map["ObservationWindowSize"] = self.observationWindowSize!
                }
                if self.upgrade != nil {
                    map["Upgrade"] = self.upgrade!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BandwidthUsageLowerThreshold") {
                    self.bandwidthUsageLowerThreshold = dict["BandwidthUsageLowerThreshold"] as! Int32
                }
                if dict.keys.contains("BandwidthUsageUpperThreshold") {
                    self.bandwidthUsageUpperThreshold = dict["BandwidthUsageUpperThreshold"] as! Int32
                }
                if dict.keys.contains("Downgrade") {
                    self.downgrade = dict["Downgrade"] as! Bool
                }
                if dict.keys.contains("ObservationWindowSize") {
                    self.observationWindowSize = dict["ObservationWindowSize"] as! String
                }
                if dict.keys.contains("Upgrade") {
                    self.upgrade = dict["Upgrade"] as! Bool
                }
            }
        }
        public class Resource : Tea.TeaModel {
            public var cpuStep: Int32?

            public var cpuUsageUpperThreshold: Int32?

            public var downgradeObservationWindowSize: String?

            public var enable: Bool?

            public var upgradeObservationWindowSize: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpuStep != nil {
                    map["CpuStep"] = self.cpuStep!
                }
                if self.cpuUsageUpperThreshold != nil {
                    map["CpuUsageUpperThreshold"] = self.cpuUsageUpperThreshold!
                }
                if self.downgradeObservationWindowSize != nil {
                    map["DowngradeObservationWindowSize"] = self.downgradeObservationWindowSize!
                }
                if self.enable != nil {
                    map["Enable"] = self.enable!
                }
                if self.upgradeObservationWindowSize != nil {
                    map["UpgradeObservationWindowSize"] = self.upgradeObservationWindowSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CpuStep") {
                    self.cpuStep = dict["CpuStep"] as! Int32
                }
                if dict.keys.contains("CpuUsageUpperThreshold") {
                    self.cpuUsageUpperThreshold = dict["CpuUsageUpperThreshold"] as! Int32
                }
                if dict.keys.contains("DowngradeObservationWindowSize") {
                    self.downgradeObservationWindowSize = dict["DowngradeObservationWindowSize"] as! String
                }
                if dict.keys.contains("Enable") {
                    self.enable = dict["Enable"] as! Bool
                }
                if dict.keys.contains("UpgradeObservationWindowSize") {
                    self.upgradeObservationWindowSize = dict["UpgradeObservationWindowSize"] as! String
                }
            }
        }
        public class Shard : Tea.TeaModel {
            public var downgrade: Bool?

            public var downgradeObservationWindowSize: String?

            public var maxShards: Int32?

            public var memUsageLowerThreshold: Int32?

            public var memUsageUpperThreshold: Int32?

            public var minShards: Int32?

            public var upgrade: Bool?

            public var upgradeObservationWindowSize: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.downgrade != nil {
                    map["Downgrade"] = self.downgrade!
                }
                if self.downgradeObservationWindowSize != nil {
                    map["DowngradeObservationWindowSize"] = self.downgradeObservationWindowSize!
                }
                if self.maxShards != nil {
                    map["MaxShards"] = self.maxShards!
                }
                if self.memUsageLowerThreshold != nil {
                    map["MemUsageLowerThreshold"] = self.memUsageLowerThreshold!
                }
                if self.memUsageUpperThreshold != nil {
                    map["MemUsageUpperThreshold"] = self.memUsageUpperThreshold!
                }
                if self.minShards != nil {
                    map["MinShards"] = self.minShards!
                }
                if self.upgrade != nil {
                    map["Upgrade"] = self.upgrade!
                }
                if self.upgradeObservationWindowSize != nil {
                    map["UpgradeObservationWindowSize"] = self.upgradeObservationWindowSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Downgrade") {
                    self.downgrade = dict["Downgrade"] as! Bool
                }
                if dict.keys.contains("DowngradeObservationWindowSize") {
                    self.downgradeObservationWindowSize = dict["DowngradeObservationWindowSize"] as! String
                }
                if dict.keys.contains("MaxShards") {
                    self.maxShards = dict["MaxShards"] as! Int32
                }
                if dict.keys.contains("MemUsageLowerThreshold") {
                    self.memUsageLowerThreshold = dict["MemUsageLowerThreshold"] as! Int32
                }
                if dict.keys.contains("MemUsageUpperThreshold") {
                    self.memUsageUpperThreshold = dict["MemUsageUpperThreshold"] as! Int32
                }
                if dict.keys.contains("MinShards") {
                    self.minShards = dict["MinShards"] as! Int32
                }
                if dict.keys.contains("Upgrade") {
                    self.upgrade = dict["Upgrade"] as! Bool
                }
                if dict.keys.contains("UpgradeObservationWindowSize") {
                    self.upgradeObservationWindowSize = dict["UpgradeObservationWindowSize"] as! String
                }
            }
        }
        public class Spec : Tea.TeaModel {
            public var coolDownTime: String?

            public var cpuUsageUpperThreshold: Int32?

            public var downgrade: Bool?

            public var maxReadOnlyNodes: Int32?

            public var maxSpec: String?

            public var memUsageUpperThreshold: Int32?

            public var observationWindowSize: String?

            public var upgrade: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coolDownTime != nil {
                    map["CoolDownTime"] = self.coolDownTime!
                }
                if self.cpuUsageUpperThreshold != nil {
                    map["CpuUsageUpperThreshold"] = self.cpuUsageUpperThreshold!
                }
                if self.downgrade != nil {
                    map["Downgrade"] = self.downgrade!
                }
                if self.maxReadOnlyNodes != nil {
                    map["MaxReadOnlyNodes"] = self.maxReadOnlyNodes!
                }
                if self.maxSpec != nil {
                    map["MaxSpec"] = self.maxSpec!
                }
                if self.memUsageUpperThreshold != nil {
                    map["MemUsageUpperThreshold"] = self.memUsageUpperThreshold!
                }
                if self.observationWindowSize != nil {
                    map["ObservationWindowSize"] = self.observationWindowSize!
                }
                if self.upgrade != nil {
                    map["Upgrade"] = self.upgrade!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CoolDownTime") {
                    self.coolDownTime = dict["CoolDownTime"] as! String
                }
                if dict.keys.contains("CpuUsageUpperThreshold") {
                    self.cpuUsageUpperThreshold = dict["CpuUsageUpperThreshold"] as! Int32
                }
                if dict.keys.contains("Downgrade") {
                    self.downgrade = dict["Downgrade"] as! Bool
                }
                if dict.keys.contains("MaxReadOnlyNodes") {
                    self.maxReadOnlyNodes = dict["MaxReadOnlyNodes"] as! Int32
                }
                if dict.keys.contains("MaxSpec") {
                    self.maxSpec = dict["MaxSpec"] as! String
                }
                if dict.keys.contains("MemUsageUpperThreshold") {
                    self.memUsageUpperThreshold = dict["MemUsageUpperThreshold"] as! Int32
                }
                if dict.keys.contains("ObservationWindowSize") {
                    self.observationWindowSize = dict["ObservationWindowSize"] as! String
                }
                if dict.keys.contains("Upgrade") {
                    self.upgrade = dict["Upgrade"] as! Bool
                }
            }
        }
        public class Storage : Tea.TeaModel {
            public var diskUsageUpperThreshold: Int32?

            public var maxStorage: Int32?

            public var upgrade: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskUsageUpperThreshold != nil {
                    map["DiskUsageUpperThreshold"] = self.diskUsageUpperThreshold!
                }
                if self.maxStorage != nil {
                    map["MaxStorage"] = self.maxStorage!
                }
                if self.upgrade != nil {
                    map["Upgrade"] = self.upgrade!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DiskUsageUpperThreshold") {
                    self.diskUsageUpperThreshold = dict["DiskUsageUpperThreshold"] as! Int32
                }
                if dict.keys.contains("MaxStorage") {
                    self.maxStorage = dict["MaxStorage"] as! Int32
                }
                if dict.keys.contains("Upgrade") {
                    self.upgrade = dict["Upgrade"] as! Bool
                }
            }
        }
        public var bandwidth: DescribeAutoScalingConfigResponseBody.Data.Bandwidth?

        public var resource: DescribeAutoScalingConfigResponseBody.Data.Resource?

        public var shard: DescribeAutoScalingConfigResponseBody.Data.Shard?

        public var spec: DescribeAutoScalingConfigResponseBody.Data.Spec?

        public var storage: DescribeAutoScalingConfigResponseBody.Data.Storage?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.bandwidth?.validate()
            try self.resource?.validate()
            try self.shard?.validate()
            try self.spec?.validate()
            try self.storage?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth?.toMap()
            }
            if self.resource != nil {
                map["Resource"] = self.resource?.toMap()
            }
            if self.shard != nil {
                map["Shard"] = self.shard?.toMap()
            }
            if self.spec != nil {
                map["Spec"] = self.spec?.toMap()
            }
            if self.storage != nil {
                map["Storage"] = self.storage?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bandwidth") {
                var model = DescribeAutoScalingConfigResponseBody.Data.Bandwidth()
                model.fromMap(dict["Bandwidth"] as! [String: Any])
                self.bandwidth = model
            }
            if dict.keys.contains("Resource") {
                var model = DescribeAutoScalingConfigResponseBody.Data.Resource()
                model.fromMap(dict["Resource"] as! [String: Any])
                self.resource = model
            }
            if dict.keys.contains("Shard") {
                var model = DescribeAutoScalingConfigResponseBody.Data.Shard()
                model.fromMap(dict["Shard"] as! [String: Any])
                self.shard = model
            }
            if dict.keys.contains("Spec") {
                var model = DescribeAutoScalingConfigResponseBody.Data.Spec()
                model.fromMap(dict["Spec"] as! [String: Any])
                self.spec = model
            }
            if dict.keys.contains("Storage") {
                var model = DescribeAutoScalingConfigResponseBody.Data.Storage()
                model.fromMap(dict["Storage"] as! [String: Any])
                self.storage = model
            }
        }
    }
    public var code: String?

    public var data: DescribeAutoScalingConfigResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeAutoScalingConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeAutoScalingConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAutoScalingConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAutoScalingConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAutoScalingHistoryRequest : Tea.TeaModel {
    public var autoScalingTaskType: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoScalingTaskType != nil {
            map["AutoScalingTaskType"] = self.autoScalingTaskType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoScalingTaskType") {
            self.autoScalingTaskType = dict["AutoScalingTaskType"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class DescribeAutoScalingHistoryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SpecHistory : Tea.TeaModel {
            public var errorCode: String?

            public var originCore: Int32?

            public var originInstanceClass: String?

            public var originMemory: Double?

            public var scaleType: String?

            public var targetCore: Int32?

            public var targetInstanceClass: String?

            public var targetMemory: Double?

            public var taskExcuteStatus: Bool?

            public var taskTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.originCore != nil {
                    map["OriginCore"] = self.originCore!
                }
                if self.originInstanceClass != nil {
                    map["OriginInstanceClass"] = self.originInstanceClass!
                }
                if self.originMemory != nil {
                    map["OriginMemory"] = self.originMemory!
                }
                if self.scaleType != nil {
                    map["ScaleType"] = self.scaleType!
                }
                if self.targetCore != nil {
                    map["TargetCore"] = self.targetCore!
                }
                if self.targetInstanceClass != nil {
                    map["TargetInstanceClass"] = self.targetInstanceClass!
                }
                if self.targetMemory != nil {
                    map["TargetMemory"] = self.targetMemory!
                }
                if self.taskExcuteStatus != nil {
                    map["TaskExcuteStatus"] = self.taskExcuteStatus!
                }
                if self.taskTime != nil {
                    map["TaskTime"] = self.taskTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("OriginCore") {
                    self.originCore = dict["OriginCore"] as! Int32
                }
                if dict.keys.contains("OriginInstanceClass") {
                    self.originInstanceClass = dict["OriginInstanceClass"] as! String
                }
                if dict.keys.contains("OriginMemory") {
                    self.originMemory = dict["OriginMemory"] as! Double
                }
                if dict.keys.contains("ScaleType") {
                    self.scaleType = dict["ScaleType"] as! String
                }
                if dict.keys.contains("TargetCore") {
                    self.targetCore = dict["TargetCore"] as! Int32
                }
                if dict.keys.contains("TargetInstanceClass") {
                    self.targetInstanceClass = dict["TargetInstanceClass"] as! String
                }
                if dict.keys.contains("TargetMemory") {
                    self.targetMemory = dict["TargetMemory"] as! Double
                }
                if dict.keys.contains("TaskExcuteStatus") {
                    self.taskExcuteStatus = dict["TaskExcuteStatus"] as! Bool
                }
                if dict.keys.contains("TaskTime") {
                    self.taskTime = dict["TaskTime"] as! Int64
                }
            }
        }
        public var bandwidth: [[String: Any]]?

        public var instanceId: String?

        public var resource: [[String: Any]]?

        public var shard: [[String: Any]]?

        public var specHistory: [DescribeAutoScalingHistoryResponseBody.Data.SpecHistory]?

        public var storage: [[String: Any]]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.resource != nil {
                map["Resource"] = self.resource!
            }
            if self.shard != nil {
                map["Shard"] = self.shard!
            }
            if self.specHistory != nil {
                var tmp : [Any] = []
                for k in self.specHistory! {
                    tmp.append(k.toMap())
                }
                map["SpecHistory"] = tmp
            }
            if self.storage != nil {
                map["Storage"] = self.storage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bandwidth") {
                self.bandwidth = dict["Bandwidth"] as! [[String: Any]]
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Resource") {
                self.resource = dict["Resource"] as! [[String: Any]]
            }
            if dict.keys.contains("Shard") {
                self.shard = dict["Shard"] as! [[String: Any]]
            }
            if dict.keys.contains("SpecHistory") {
                var tmp : [DescribeAutoScalingHistoryResponseBody.Data.SpecHistory] = []
                for v in dict["SpecHistory"] as! [Any] {
                    var model = DescribeAutoScalingHistoryResponseBody.Data.SpecHistory()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.specHistory = tmp
            }
            if dict.keys.contains("Storage") {
                self.storage = dict["Storage"] as! [[String: Any]]
            }
        }
    }
    public var code: String?

    public var data: DescribeAutoScalingHistoryResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeAutoScalingHistoryResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeAutoScalingHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAutoScalingHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAutoScalingHistoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCacheAnalysisJobRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class DescribeCacheAnalysisJobResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class BigKeys : Tea.TeaModel {
            public class KeyInfo : Tea.TeaModel {
                public var bytes: Int64?

                public var count: Int64?

                public var db: Int32?

                public var encoding: String?

                public var expirationTimeMillis: Int64?

                public var key: String?

                public var nodeId: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bytes != nil {
                        map["Bytes"] = self.bytes!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.db != nil {
                        map["Db"] = self.db!
                    }
                    if self.encoding != nil {
                        map["Encoding"] = self.encoding!
                    }
                    if self.expirationTimeMillis != nil {
                        map["ExpirationTimeMillis"] = self.expirationTimeMillis!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bytes") {
                        self.bytes = dict["Bytes"] as! Int64
                    }
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int64
                    }
                    if dict.keys.contains("Db") {
                        self.db = dict["Db"] as! Int32
                    }
                    if dict.keys.contains("Encoding") {
                        self.encoding = dict["Encoding"] as! String
                    }
                    if dict.keys.contains("ExpirationTimeMillis") {
                        self.expirationTimeMillis = dict["ExpirationTimeMillis"] as! Int64
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("NodeId") {
                        self.nodeId = dict["NodeId"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var keyInfo: [DescribeCacheAnalysisJobResponseBody.Data.BigKeys.KeyInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.keyInfo != nil {
                    var tmp : [Any] = []
                    for k in self.keyInfo! {
                        tmp.append(k.toMap())
                    }
                    map["KeyInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("KeyInfo") {
                    var tmp : [DescribeCacheAnalysisJobResponseBody.Data.BigKeys.KeyInfo] = []
                    for v in dict["KeyInfo"] as! [Any] {
                        var model = DescribeCacheAnalysisJobResponseBody.Data.BigKeys.KeyInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.keyInfo = tmp
                }
            }
        }
        public class BigKeysOfNum : Tea.TeaModel {
            public class KeyInfo : Tea.TeaModel {
                public var bytes: Int64?

                public var count: Int64?

                public var db: Int32?

                public var encoding: String?

                public var expirationTimeMillis: Int64?

                public var key: String?

                public var nodeId: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bytes != nil {
                        map["Bytes"] = self.bytes!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.db != nil {
                        map["Db"] = self.db!
                    }
                    if self.encoding != nil {
                        map["Encoding"] = self.encoding!
                    }
                    if self.expirationTimeMillis != nil {
                        map["ExpirationTimeMillis"] = self.expirationTimeMillis!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bytes") {
                        self.bytes = dict["Bytes"] as! Int64
                    }
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int64
                    }
                    if dict.keys.contains("Db") {
                        self.db = dict["Db"] as! Int32
                    }
                    if dict.keys.contains("Encoding") {
                        self.encoding = dict["Encoding"] as! String
                    }
                    if dict.keys.contains("ExpirationTimeMillis") {
                        self.expirationTimeMillis = dict["ExpirationTimeMillis"] as! Int64
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("NodeId") {
                        self.nodeId = dict["NodeId"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var keyInfo: [DescribeCacheAnalysisJobResponseBody.Data.BigKeysOfNum.KeyInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.keyInfo != nil {
                    var tmp : [Any] = []
                    for k in self.keyInfo! {
                        tmp.append(k.toMap())
                    }
                    map["KeyInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("KeyInfo") {
                    var tmp : [DescribeCacheAnalysisJobResponseBody.Data.BigKeysOfNum.KeyInfo] = []
                    for v in dict["KeyInfo"] as! [Any] {
                        var model = DescribeCacheAnalysisJobResponseBody.Data.BigKeysOfNum.KeyInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.keyInfo = tmp
                }
            }
        }
        public class ExpiryKeysLevelCount : Tea.TeaModel {
            public class ExpiryLevel : Tea.TeaModel {
                public var analysisTs: Int64?

                public var level: Int32?

                public var totalBytes: Int64?

                public var totalKeys: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.analysisTs != nil {
                        map["AnalysisTs"] = self.analysisTs!
                    }
                    if self.level != nil {
                        map["Level"] = self.level!
                    }
                    if self.totalBytes != nil {
                        map["TotalBytes"] = self.totalBytes!
                    }
                    if self.totalKeys != nil {
                        map["TotalKeys"] = self.totalKeys!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnalysisTs") {
                        self.analysisTs = dict["AnalysisTs"] as! Int64
                    }
                    if dict.keys.contains("Level") {
                        self.level = dict["Level"] as! Int32
                    }
                    if dict.keys.contains("TotalBytes") {
                        self.totalBytes = dict["TotalBytes"] as! Int64
                    }
                    if dict.keys.contains("TotalKeys") {
                        self.totalKeys = dict["TotalKeys"] as! Int64
                    }
                }
            }
            public var expiryLevel: [DescribeCacheAnalysisJobResponseBody.Data.ExpiryKeysLevelCount.ExpiryLevel]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.expiryLevel != nil {
                    var tmp : [Any] = []
                    for k in self.expiryLevel! {
                        tmp.append(k.toMap())
                    }
                    map["ExpiryLevel"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ExpiryLevel") {
                    var tmp : [DescribeCacheAnalysisJobResponseBody.Data.ExpiryKeysLevelCount.ExpiryLevel] = []
                    for v in dict["ExpiryLevel"] as! [Any] {
                        var model = DescribeCacheAnalysisJobResponseBody.Data.ExpiryKeysLevelCount.ExpiryLevel()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.expiryLevel = tmp
                }
            }
        }
        public class KeyPrefixes : Tea.TeaModel {
            public class Prefix_ : Tea.TeaModel {
                public var bytes: Int64?

                public var count: Int64?

                public var keyNum: Int64?

                public var prefix_: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bytes != nil {
                        map["Bytes"] = self.bytes!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.keyNum != nil {
                        map["KeyNum"] = self.keyNum!
                    }
                    if self.prefix_ != nil {
                        map["Prefix"] = self.prefix_!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bytes") {
                        self.bytes = dict["Bytes"] as! Int64
                    }
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int64
                    }
                    if dict.keys.contains("KeyNum") {
                        self.keyNum = dict["KeyNum"] as! Int64
                    }
                    if dict.keys.contains("Prefix") {
                        self.prefix_ = dict["Prefix"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var prefix_: [DescribeCacheAnalysisJobResponseBody.Data.KeyPrefixes.Prefix_]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.prefix_ != nil {
                    var tmp : [Any] = []
                    for k in self.prefix_! {
                        tmp.append(k.toMap())
                    }
                    map["Prefix"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Prefix") {
                    var tmp : [DescribeCacheAnalysisJobResponseBody.Data.KeyPrefixes.Prefix_] = []
                    for v in dict["Prefix"] as! [Any] {
                        var model = DescribeCacheAnalysisJobResponseBody.Data.KeyPrefixes.Prefix_()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.prefix_ = tmp
                }
            }
        }
        public class UnexBigKeysOfBytes : Tea.TeaModel {
            public class KeyInfo : Tea.TeaModel {
                public var bytes: Int64?

                public var count: Int64?

                public var db: Int32?

                public var encoding: String?

                public var expirationTimeMillis: Int64?

                public var key: String?

                public var nodeId: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bytes != nil {
                        map["Bytes"] = self.bytes!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.db != nil {
                        map["Db"] = self.db!
                    }
                    if self.encoding != nil {
                        map["Encoding"] = self.encoding!
                    }
                    if self.expirationTimeMillis != nil {
                        map["ExpirationTimeMillis"] = self.expirationTimeMillis!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bytes") {
                        self.bytes = dict["Bytes"] as! Int64
                    }
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int64
                    }
                    if dict.keys.contains("Db") {
                        self.db = dict["Db"] as! Int32
                    }
                    if dict.keys.contains("Encoding") {
                        self.encoding = dict["Encoding"] as! String
                    }
                    if dict.keys.contains("ExpirationTimeMillis") {
                        self.expirationTimeMillis = dict["ExpirationTimeMillis"] as! Int64
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("NodeId") {
                        self.nodeId = dict["NodeId"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var keyInfo: [DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfBytes.KeyInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.keyInfo != nil {
                    var tmp : [Any] = []
                    for k in self.keyInfo! {
                        tmp.append(k.toMap())
                    }
                    map["KeyInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("KeyInfo") {
                    var tmp : [DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfBytes.KeyInfo] = []
                    for v in dict["KeyInfo"] as! [Any] {
                        var model = DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfBytes.KeyInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.keyInfo = tmp
                }
            }
        }
        public class UnexBigKeysOfNum : Tea.TeaModel {
            public class KeyInfo : Tea.TeaModel {
                public var bytes: Int64?

                public var count: Int64?

                public var db: Int32?

                public var encoding: String?

                public var expirationTimeMillis: Int64?

                public var key: String?

                public var nodeId: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bytes != nil {
                        map["Bytes"] = self.bytes!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.db != nil {
                        map["Db"] = self.db!
                    }
                    if self.encoding != nil {
                        map["Encoding"] = self.encoding!
                    }
                    if self.expirationTimeMillis != nil {
                        map["ExpirationTimeMillis"] = self.expirationTimeMillis!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Bytes") {
                        self.bytes = dict["Bytes"] as! Int64
                    }
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int64
                    }
                    if dict.keys.contains("Db") {
                        self.db = dict["Db"] as! Int32
                    }
                    if dict.keys.contains("Encoding") {
                        self.encoding = dict["Encoding"] as! String
                    }
                    if dict.keys.contains("ExpirationTimeMillis") {
                        self.expirationTimeMillis = dict["ExpirationTimeMillis"] as! Int64
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("NodeId") {
                        self.nodeId = dict["NodeId"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var keyInfo: [DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfNum.KeyInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.keyInfo != nil {
                    var tmp : [Any] = []
                    for k in self.keyInfo! {
                        tmp.append(k.toMap())
                    }
                    map["KeyInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("KeyInfo") {
                    var tmp : [DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfNum.KeyInfo] = []
                    for v in dict["KeyInfo"] as! [Any] {
                        var model = DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfNum.KeyInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.keyInfo = tmp
                }
            }
        }
        public var bigKeys: DescribeCacheAnalysisJobResponseBody.Data.BigKeys?

        public var bigKeysOfNum: DescribeCacheAnalysisJobResponseBody.Data.BigKeysOfNum?

        public var expiryKeysLevelCount: DescribeCacheAnalysisJobResponseBody.Data.ExpiryKeysLevelCount?

        public var instanceId: String?

        public var jobId: String?

        public var keyPrefixes: DescribeCacheAnalysisJobResponseBody.Data.KeyPrefixes?

        public var message: String?

        public var nodeId: String?

        public var taskState: String?

        public var unexBigKeysOfBytes: DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfBytes?

        public var unexBigKeysOfNum: DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfNum?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.bigKeys?.validate()
            try self.bigKeysOfNum?.validate()
            try self.expiryKeysLevelCount?.validate()
            try self.keyPrefixes?.validate()
            try self.unexBigKeysOfBytes?.validate()
            try self.unexBigKeysOfNum?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bigKeys != nil {
                map["BigKeys"] = self.bigKeys?.toMap()
            }
            if self.bigKeysOfNum != nil {
                map["BigKeysOfNum"] = self.bigKeysOfNum?.toMap()
            }
            if self.expiryKeysLevelCount != nil {
                map["ExpiryKeysLevelCount"] = self.expiryKeysLevelCount?.toMap()
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.keyPrefixes != nil {
                map["KeyPrefixes"] = self.keyPrefixes?.toMap()
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.taskState != nil {
                map["TaskState"] = self.taskState!
            }
            if self.unexBigKeysOfBytes != nil {
                map["UnexBigKeysOfBytes"] = self.unexBigKeysOfBytes?.toMap()
            }
            if self.unexBigKeysOfNum != nil {
                map["UnexBigKeysOfNum"] = self.unexBigKeysOfNum?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BigKeys") {
                var model = DescribeCacheAnalysisJobResponseBody.Data.BigKeys()
                model.fromMap(dict["BigKeys"] as! [String: Any])
                self.bigKeys = model
            }
            if dict.keys.contains("BigKeysOfNum") {
                var model = DescribeCacheAnalysisJobResponseBody.Data.BigKeysOfNum()
                model.fromMap(dict["BigKeysOfNum"] as! [String: Any])
                self.bigKeysOfNum = model
            }
            if dict.keys.contains("ExpiryKeysLevelCount") {
                var model = DescribeCacheAnalysisJobResponseBody.Data.ExpiryKeysLevelCount()
                model.fromMap(dict["ExpiryKeysLevelCount"] as! [String: Any])
                self.expiryKeysLevelCount = model
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("KeyPrefixes") {
                var model = DescribeCacheAnalysisJobResponseBody.Data.KeyPrefixes()
                model.fromMap(dict["KeyPrefixes"] as! [String: Any])
                self.keyPrefixes = model
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("TaskState") {
                self.taskState = dict["TaskState"] as! String
            }
            if dict.keys.contains("UnexBigKeysOfBytes") {
                var model = DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfBytes()
                model.fromMap(dict["UnexBigKeysOfBytes"] as! [String: Any])
                self.unexBigKeysOfBytes = model
            }
            if dict.keys.contains("UnexBigKeysOfNum") {
                var model = DescribeCacheAnalysisJobResponseBody.Data.UnexBigKeysOfNum()
                model.fromMap(dict["UnexBigKeysOfNum"] as! [String: Any])
                self.unexBigKeysOfNum = model
            }
        }
    }
    public var code: String?

    public var data: DescribeCacheAnalysisJobResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeCacheAnalysisJobResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeCacheAnalysisJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCacheAnalysisJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCacheAnalysisJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCacheAnalysisJobsRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceId: String?

    public var pageNo: String?

    public var pageSize: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeCacheAnalysisJobsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class CacheAnalysisJob : Tea.TeaModel {
                public class BigKeys : Tea.TeaModel {
                    public class KeyInfo : Tea.TeaModel {
                        public var bytes: Int64?

                        public var count: Int64?

                        public var db: Int32?

                        public var encoding: String?

                        public var expirationTimeMillis: Int64?

                        public var key: String?

                        public var nodeId: String?

                        public var type: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.bytes != nil {
                                map["Bytes"] = self.bytes!
                            }
                            if self.count != nil {
                                map["Count"] = self.count!
                            }
                            if self.db != nil {
                                map["Db"] = self.db!
                            }
                            if self.encoding != nil {
                                map["Encoding"] = self.encoding!
                            }
                            if self.expirationTimeMillis != nil {
                                map["ExpirationTimeMillis"] = self.expirationTimeMillis!
                            }
                            if self.key != nil {
                                map["Key"] = self.key!
                            }
                            if self.nodeId != nil {
                                map["NodeId"] = self.nodeId!
                            }
                            if self.type != nil {
                                map["Type"] = self.type!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Bytes") {
                                self.bytes = dict["Bytes"] as! Int64
                            }
                            if dict.keys.contains("Count") {
                                self.count = dict["Count"] as! Int64
                            }
                            if dict.keys.contains("Db") {
                                self.db = dict["Db"] as! Int32
                            }
                            if dict.keys.contains("Encoding") {
                                self.encoding = dict["Encoding"] as! String
                            }
                            if dict.keys.contains("ExpirationTimeMillis") {
                                self.expirationTimeMillis = dict["ExpirationTimeMillis"] as! Int64
                            }
                            if dict.keys.contains("Key") {
                                self.key = dict["Key"] as! String
                            }
                            if dict.keys.contains("NodeId") {
                                self.nodeId = dict["NodeId"] as! String
                            }
                            if dict.keys.contains("Type") {
                                self.type = dict["Type"] as! String
                            }
                        }
                    }
                    public var keyInfo: [DescribeCacheAnalysisJobsResponseBody.Data.List.CacheAnalysisJob.BigKeys.KeyInfo]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.keyInfo != nil {
                            var tmp : [Any] = []
                            for k in self.keyInfo! {
                                tmp.append(k.toMap())
                            }
                            map["KeyInfo"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("KeyInfo") {
                            var tmp : [DescribeCacheAnalysisJobsResponseBody.Data.List.CacheAnalysisJob.BigKeys.KeyInfo] = []
                            for v in dict["KeyInfo"] as! [Any] {
                                var model = DescribeCacheAnalysisJobsResponseBody.Data.List.CacheAnalysisJob.BigKeys.KeyInfo()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.keyInfo = tmp
                        }
                    }
                }
                public var bigKeys: DescribeCacheAnalysisJobsResponseBody.Data.List.CacheAnalysisJob.BigKeys?

                public var instanceId: String?

                public var jobId: String?

                public var message: String?

                public var nodeId: String?

                public var taskState: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.bigKeys?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bigKeys != nil {
                        map["BigKeys"] = self.bigKeys?.toMap()
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.message != nil {
                        map["Message"] = self.message!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.taskState != nil {
                        map["TaskState"] = self.taskState!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BigKeys") {
                        var model = DescribeCacheAnalysisJobsResponseBody.Data.List.CacheAnalysisJob.BigKeys()
                        model.fromMap(dict["BigKeys"] as! [String: Any])
                        self.bigKeys = model
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Message") {
                        self.message = dict["Message"] as! String
                    }
                    if dict.keys.contains("NodeId") {
                        self.nodeId = dict["NodeId"] as! String
                    }
                    if dict.keys.contains("TaskState") {
                        self.taskState = dict["TaskState"] as! String
                    }
                }
            }
            public var cacheAnalysisJob: [DescribeCacheAnalysisJobsResponseBody.Data.List.CacheAnalysisJob]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cacheAnalysisJob != nil {
                    var tmp : [Any] = []
                    for k in self.cacheAnalysisJob! {
                        tmp.append(k.toMap())
                    }
                    map["CacheAnalysisJob"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CacheAnalysisJob") {
                    var tmp : [DescribeCacheAnalysisJobsResponseBody.Data.List.CacheAnalysisJob] = []
                    for v in dict["CacheAnalysisJob"] as! [Any] {
                        var model = DescribeCacheAnalysisJobsResponseBody.Data.List.CacheAnalysisJob()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.cacheAnalysisJob = tmp
                }
            }
        }
        public var extra: String?

        public var list: DescribeCacheAnalysisJobsResponseBody.Data.List?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.list?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                map["List"] = self.list?.toMap()
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extra") {
                self.extra = dict["Extra"] as! String
            }
            if dict.keys.contains("List") {
                var model = DescribeCacheAnalysisJobsResponseBody.Data.List()
                model.fromMap(dict["List"] as! [String: Any])
                self.list = model
            }
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeCacheAnalysisJobsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeCacheAnalysisJobsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeCacheAnalysisJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCacheAnalysisJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCacheAnalysisJobsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudBenchTasksRequest : Tea.TeaModel {
    public var endTime: String?

    public var pageNo: String?

    public var pageSize: String?

    public var startTime: String?

    public var status: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.taskType != nil {
            map["TaskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TaskType") {
            self.taskType = dict["TaskType"] as! String
        }
    }
}

public class DescribeCloudBenchTasksResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class CloudbenchTasks : Tea.TeaModel {
                public var archiveJobId: String?

                public var archiveOssTableName: String?

                public var archiveState: Int32?

                public var backupId: String?

                public var backupType: String?

                public var benchStep: String?

                public var benchStepStatus: String?

                public var clientGatewayId: String?

                public var clientType: String?

                public var description_: String?

                public var dstInstanceUuid: String?

                public var dstIp: String?

                public var dstPort: Int32?

                public var dstType: String?

                public var dtsJobClass: String?

                public var dtsJobId: String?

                public var dtsJobName: String?

                public var dtsJobState: Int32?

                public var dtsJobStatus: String?

                public var ecsInstanceId: String?

                public var endState: String?

                public var errorCode: String?

                public var errorMessage: String?

                public var external: String?

                public var rate: Int32?

                public var requestDuration: Int64?

                public var smartPressureTime: Int32?

                public var source: String?

                public var sqlCompleteReuse: String?

                public var srcInstanceArea: String?

                public var srcInstanceUuid: String?

                public var srcPublicIp: String?

                public var state: String?

                public var status: String?

                public var tableSchema: String?

                public var taskId: String?

                public var taskType: String?

                public var topic: String?

                public var userId: String?

                public var version: String?

                public var workDir: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.archiveJobId != nil {
                        map["ArchiveJobId"] = self.archiveJobId!
                    }
                    if self.archiveOssTableName != nil {
                        map["ArchiveOssTableName"] = self.archiveOssTableName!
                    }
                    if self.archiveState != nil {
                        map["ArchiveState"] = self.archiveState!
                    }
                    if self.backupId != nil {
                        map["BackupId"] = self.backupId!
                    }
                    if self.backupType != nil {
                        map["BackupType"] = self.backupType!
                    }
                    if self.benchStep != nil {
                        map["BenchStep"] = self.benchStep!
                    }
                    if self.benchStepStatus != nil {
                        map["BenchStepStatus"] = self.benchStepStatus!
                    }
                    if self.clientGatewayId != nil {
                        map["ClientGatewayId"] = self.clientGatewayId!
                    }
                    if self.clientType != nil {
                        map["ClientType"] = self.clientType!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.dstInstanceUuid != nil {
                        map["DstInstanceUuid"] = self.dstInstanceUuid!
                    }
                    if self.dstIp != nil {
                        map["DstIp"] = self.dstIp!
                    }
                    if self.dstPort != nil {
                        map["DstPort"] = self.dstPort!
                    }
                    if self.dstType != nil {
                        map["DstType"] = self.dstType!
                    }
                    if self.dtsJobClass != nil {
                        map["DtsJobClass"] = self.dtsJobClass!
                    }
                    if self.dtsJobId != nil {
                        map["DtsJobId"] = self.dtsJobId!
                    }
                    if self.dtsJobName != nil {
                        map["DtsJobName"] = self.dtsJobName!
                    }
                    if self.dtsJobState != nil {
                        map["DtsJobState"] = self.dtsJobState!
                    }
                    if self.dtsJobStatus != nil {
                        map["DtsJobStatus"] = self.dtsJobStatus!
                    }
                    if self.ecsInstanceId != nil {
                        map["EcsInstanceId"] = self.ecsInstanceId!
                    }
                    if self.endState != nil {
                        map["EndState"] = self.endState!
                    }
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.external != nil {
                        map["External"] = self.external!
                    }
                    if self.rate != nil {
                        map["Rate"] = self.rate!
                    }
                    if self.requestDuration != nil {
                        map["RequestDuration"] = self.requestDuration!
                    }
                    if self.smartPressureTime != nil {
                        map["SmartPressureTime"] = self.smartPressureTime!
                    }
                    if self.source != nil {
                        map["Source"] = self.source!
                    }
                    if self.sqlCompleteReuse != nil {
                        map["SqlCompleteReuse"] = self.sqlCompleteReuse!
                    }
                    if self.srcInstanceArea != nil {
                        map["SrcInstanceArea"] = self.srcInstanceArea!
                    }
                    if self.srcInstanceUuid != nil {
                        map["SrcInstanceUuid"] = self.srcInstanceUuid!
                    }
                    if self.srcPublicIp != nil {
                        map["SrcPublicIp"] = self.srcPublicIp!
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.tableSchema != nil {
                        map["TableSchema"] = self.tableSchema!
                    }
                    if self.taskId != nil {
                        map["TaskId"] = self.taskId!
                    }
                    if self.taskType != nil {
                        map["TaskType"] = self.taskType!
                    }
                    if self.topic != nil {
                        map["Topic"] = self.topic!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    if self.version != nil {
                        map["Version"] = self.version!
                    }
                    if self.workDir != nil {
                        map["WorkDir"] = self.workDir!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ArchiveJobId") {
                        self.archiveJobId = dict["ArchiveJobId"] as! String
                    }
                    if dict.keys.contains("ArchiveOssTableName") {
                        self.archiveOssTableName = dict["ArchiveOssTableName"] as! String
                    }
                    if dict.keys.contains("ArchiveState") {
                        self.archiveState = dict["ArchiveState"] as! Int32
                    }
                    if dict.keys.contains("BackupId") {
                        self.backupId = dict["BackupId"] as! String
                    }
                    if dict.keys.contains("BackupType") {
                        self.backupType = dict["BackupType"] as! String
                    }
                    if dict.keys.contains("BenchStep") {
                        self.benchStep = dict["BenchStep"] as! String
                    }
                    if dict.keys.contains("BenchStepStatus") {
                        self.benchStepStatus = dict["BenchStepStatus"] as! String
                    }
                    if dict.keys.contains("ClientGatewayId") {
                        self.clientGatewayId = dict["ClientGatewayId"] as! String
                    }
                    if dict.keys.contains("ClientType") {
                        self.clientType = dict["ClientType"] as! String
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("DstInstanceUuid") {
                        self.dstInstanceUuid = dict["DstInstanceUuid"] as! String
                    }
                    if dict.keys.contains("DstIp") {
                        self.dstIp = dict["DstIp"] as! String
                    }
                    if dict.keys.contains("DstPort") {
                        self.dstPort = dict["DstPort"] as! Int32
                    }
                    if dict.keys.contains("DstType") {
                        self.dstType = dict["DstType"] as! String
                    }
                    if dict.keys.contains("DtsJobClass") {
                        self.dtsJobClass = dict["DtsJobClass"] as! String
                    }
                    if dict.keys.contains("DtsJobId") {
                        self.dtsJobId = dict["DtsJobId"] as! String
                    }
                    if dict.keys.contains("DtsJobName") {
                        self.dtsJobName = dict["DtsJobName"] as! String
                    }
                    if dict.keys.contains("DtsJobState") {
                        self.dtsJobState = dict["DtsJobState"] as! Int32
                    }
                    if dict.keys.contains("DtsJobStatus") {
                        self.dtsJobStatus = dict["DtsJobStatus"] as! String
                    }
                    if dict.keys.contains("EcsInstanceId") {
                        self.ecsInstanceId = dict["EcsInstanceId"] as! String
                    }
                    if dict.keys.contains("EndState") {
                        self.endState = dict["EndState"] as! String
                    }
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("External") {
                        self.external = dict["External"] as! String
                    }
                    if dict.keys.contains("Rate") {
                        self.rate = dict["Rate"] as! Int32
                    }
                    if dict.keys.contains("RequestDuration") {
                        self.requestDuration = dict["RequestDuration"] as! Int64
                    }
                    if dict.keys.contains("SmartPressureTime") {
                        self.smartPressureTime = dict["SmartPressureTime"] as! Int32
                    }
                    if dict.keys.contains("Source") {
                        self.source = dict["Source"] as! String
                    }
                    if dict.keys.contains("SqlCompleteReuse") {
                        self.sqlCompleteReuse = dict["SqlCompleteReuse"] as! String
                    }
                    if dict.keys.contains("SrcInstanceArea") {
                        self.srcInstanceArea = dict["SrcInstanceArea"] as! String
                    }
                    if dict.keys.contains("SrcInstanceUuid") {
                        self.srcInstanceUuid = dict["SrcInstanceUuid"] as! String
                    }
                    if dict.keys.contains("SrcPublicIp") {
                        self.srcPublicIp = dict["SrcPublicIp"] as! String
                    }
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("TableSchema") {
                        self.tableSchema = dict["TableSchema"] as! String
                    }
                    if dict.keys.contains("TaskId") {
                        self.taskId = dict["TaskId"] as! String
                    }
                    if dict.keys.contains("TaskType") {
                        self.taskType = dict["TaskType"] as! String
                    }
                    if dict.keys.contains("Topic") {
                        self.topic = dict["Topic"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                    if dict.keys.contains("Version") {
                        self.version = dict["Version"] as! String
                    }
                    if dict.keys.contains("WorkDir") {
                        self.workDir = dict["WorkDir"] as! String
                    }
                }
            }
            public var cloudbenchTasks: [DescribeCloudBenchTasksResponseBody.Data.List.CloudbenchTasks]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cloudbenchTasks != nil {
                    var tmp : [Any] = []
                    for k in self.cloudbenchTasks! {
                        tmp.append(k.toMap())
                    }
                    map["cloudbenchTasks"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cloudbenchTasks") {
                    var tmp : [DescribeCloudBenchTasksResponseBody.Data.List.CloudbenchTasks] = []
                    for v in dict["cloudbenchTasks"] as! [Any] {
                        var model = DescribeCloudBenchTasksResponseBody.Data.List.CloudbenchTasks()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.cloudbenchTasks = tmp
                }
            }
        }
        public var extra: String?

        public var list: DescribeCloudBenchTasksResponseBody.Data.List?

        public var pageNo: Int32?

        public var pageSize: Int32?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.list?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                map["List"] = self.list?.toMap()
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extra") {
                self.extra = dict["Extra"] as! String
            }
            if dict.keys.contains("List") {
                var model = DescribeCloudBenchTasksResponseBody.Data.List()
                model.fromMap(dict["List"] as! [String: Any])
                self.list = model
            }
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeCloudBenchTasksResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeCloudBenchTasksResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeCloudBenchTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudBenchTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudBenchTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudbenchTaskRequest : Tea.TeaModel {
    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribeCloudbenchTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var archiveJobId: String?

        public var archiveOssTableName: String?

        public var archiveState: Int32?

        public var backupId: String?

        public var backupType: String?

        public var benchStep: String?

        public var benchStepStatus: String?

        public var clientGatewayId: String?

        public var clientType: String?

        public var description_: String?

        public var dstInstanceUuid: String?

        public var dstIp: String?

        public var dstPort: Int32?

        public var dstType: String?

        public var dtsJobClass: String?

        public var dtsJobId: String?

        public var dtsJobName: String?

        public var dtsJobState: Int32?

        public var dtsJobStatus: String?

        public var ecsInstanceId: String?

        public var endState: String?

        public var errorCode: String?

        public var errorMessage: String?

        public var external: String?

        public var rate: Int64?

        public var requestDuration: Int64?

        public var smartPressureTime: Int32?

        public var source: String?

        public var sqlCompleteReuse: String?

        public var srcInstanceArea: String?

        public var srcInstanceUuid: String?

        public var srcPublicIp: String?

        public var state: String?

        public var status: String?

        public var tableSchema: String?

        public var taskId: String?

        public var taskType: String?

        public var topic: String?

        public var userId: String?

        public var version: String?

        public var workDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.archiveJobId != nil {
                map["ArchiveJobId"] = self.archiveJobId!
            }
            if self.archiveOssTableName != nil {
                map["ArchiveOssTableName"] = self.archiveOssTableName!
            }
            if self.archiveState != nil {
                map["ArchiveState"] = self.archiveState!
            }
            if self.backupId != nil {
                map["BackupId"] = self.backupId!
            }
            if self.backupType != nil {
                map["BackupType"] = self.backupType!
            }
            if self.benchStep != nil {
                map["BenchStep"] = self.benchStep!
            }
            if self.benchStepStatus != nil {
                map["BenchStepStatus"] = self.benchStepStatus!
            }
            if self.clientGatewayId != nil {
                map["ClientGatewayId"] = self.clientGatewayId!
            }
            if self.clientType != nil {
                map["ClientType"] = self.clientType!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dstInstanceUuid != nil {
                map["DstInstanceUuid"] = self.dstInstanceUuid!
            }
            if self.dstIp != nil {
                map["DstIp"] = self.dstIp!
            }
            if self.dstPort != nil {
                map["DstPort"] = self.dstPort!
            }
            if self.dstType != nil {
                map["DstType"] = self.dstType!
            }
            if self.dtsJobClass != nil {
                map["DtsJobClass"] = self.dtsJobClass!
            }
            if self.dtsJobId != nil {
                map["DtsJobId"] = self.dtsJobId!
            }
            if self.dtsJobName != nil {
                map["DtsJobName"] = self.dtsJobName!
            }
            if self.dtsJobState != nil {
                map["DtsJobState"] = self.dtsJobState!
            }
            if self.dtsJobStatus != nil {
                map["DtsJobStatus"] = self.dtsJobStatus!
            }
            if self.ecsInstanceId != nil {
                map["EcsInstanceId"] = self.ecsInstanceId!
            }
            if self.endState != nil {
                map["EndState"] = self.endState!
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMessage != nil {
                map["ErrorMessage"] = self.errorMessage!
            }
            if self.external != nil {
                map["External"] = self.external!
            }
            if self.rate != nil {
                map["Rate"] = self.rate!
            }
            if self.requestDuration != nil {
                map["RequestDuration"] = self.requestDuration!
            }
            if self.smartPressureTime != nil {
                map["SmartPressureTime"] = self.smartPressureTime!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.sqlCompleteReuse != nil {
                map["SqlCompleteReuse"] = self.sqlCompleteReuse!
            }
            if self.srcInstanceArea != nil {
                map["SrcInstanceArea"] = self.srcInstanceArea!
            }
            if self.srcInstanceUuid != nil {
                map["SrcInstanceUuid"] = self.srcInstanceUuid!
            }
            if self.srcPublicIp != nil {
                map["SrcPublicIp"] = self.srcPublicIp!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tableSchema != nil {
                map["TableSchema"] = self.tableSchema!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.topic != nil {
                map["Topic"] = self.topic!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            if self.workDir != nil {
                map["WorkDir"] = self.workDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ArchiveJobId") {
                self.archiveJobId = dict["ArchiveJobId"] as! String
            }
            if dict.keys.contains("ArchiveOssTableName") {
                self.archiveOssTableName = dict["ArchiveOssTableName"] as! String
            }
            if dict.keys.contains("ArchiveState") {
                self.archiveState = dict["ArchiveState"] as! Int32
            }
            if dict.keys.contains("BackupId") {
                self.backupId = dict["BackupId"] as! String
            }
            if dict.keys.contains("BackupType") {
                self.backupType = dict["BackupType"] as! String
            }
            if dict.keys.contains("BenchStep") {
                self.benchStep = dict["BenchStep"] as! String
            }
            if dict.keys.contains("BenchStepStatus") {
                self.benchStepStatus = dict["BenchStepStatus"] as! String
            }
            if dict.keys.contains("ClientGatewayId") {
                self.clientGatewayId = dict["ClientGatewayId"] as! String
            }
            if dict.keys.contains("ClientType") {
                self.clientType = dict["ClientType"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DstInstanceUuid") {
                self.dstInstanceUuid = dict["DstInstanceUuid"] as! String
            }
            if dict.keys.contains("DstIp") {
                self.dstIp = dict["DstIp"] as! String
            }
            if dict.keys.contains("DstPort") {
                self.dstPort = dict["DstPort"] as! Int32
            }
            if dict.keys.contains("DstType") {
                self.dstType = dict["DstType"] as! String
            }
            if dict.keys.contains("DtsJobClass") {
                self.dtsJobClass = dict["DtsJobClass"] as! String
            }
            if dict.keys.contains("DtsJobId") {
                self.dtsJobId = dict["DtsJobId"] as! String
            }
            if dict.keys.contains("DtsJobName") {
                self.dtsJobName = dict["DtsJobName"] as! String
            }
            if dict.keys.contains("DtsJobState") {
                self.dtsJobState = dict["DtsJobState"] as! Int32
            }
            if dict.keys.contains("DtsJobStatus") {
                self.dtsJobStatus = dict["DtsJobStatus"] as! String
            }
            if dict.keys.contains("EcsInstanceId") {
                self.ecsInstanceId = dict["EcsInstanceId"] as! String
            }
            if dict.keys.contains("EndState") {
                self.endState = dict["EndState"] as! String
            }
            if dict.keys.contains("ErrorCode") {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ErrorMessage") {
                self.errorMessage = dict["ErrorMessage"] as! String
            }
            if dict.keys.contains("External") {
                self.external = dict["External"] as! String
            }
            if dict.keys.contains("Rate") {
                self.rate = dict["Rate"] as! Int64
            }
            if dict.keys.contains("RequestDuration") {
                self.requestDuration = dict["RequestDuration"] as! Int64
            }
            if dict.keys.contains("SmartPressureTime") {
                self.smartPressureTime = dict["SmartPressureTime"] as! Int32
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("SqlCompleteReuse") {
                self.sqlCompleteReuse = dict["SqlCompleteReuse"] as! String
            }
            if dict.keys.contains("SrcInstanceArea") {
                self.srcInstanceArea = dict["SrcInstanceArea"] as! String
            }
            if dict.keys.contains("SrcInstanceUuid") {
                self.srcInstanceUuid = dict["SrcInstanceUuid"] as! String
            }
            if dict.keys.contains("SrcPublicIp") {
                self.srcPublicIp = dict["SrcPublicIp"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TableSchema") {
                self.tableSchema = dict["TableSchema"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskType") {
                self.taskType = dict["TaskType"] as! String
            }
            if dict.keys.contains("Topic") {
                self.topic = dict["Topic"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
            if dict.keys.contains("WorkDir") {
                self.workDir = dict["WorkDir"] as! String
            }
        }
    }
    public var code: String?

    public var data: DescribeCloudbenchTaskResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeCloudbenchTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeCloudbenchTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudbenchTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudbenchTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudbenchTaskConfigRequest : Tea.TeaModel {
    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribeCloudbenchTaskConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var archiveFolder: String?

        public var benchCmd: String?

        public var clientJarPath: String?

        public var jarOnOss: String?

        public var loadCmd: String?

        public var metaFileName: String?

        public var metaFileOnOss: String?

        public var metaFilePath: String?

        public var parseCmd: String?

        public var parseFilePath: String?

        public var rocksDbPath: String?

        public var sqlFileName: String?

        public var sqlFileOnOss: String?

        public var sqlFilePath: String?

        public var taskId: String?

        public var userId: String?

        public var workDir: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.archiveFolder != nil {
                map["ArchiveFolder"] = self.archiveFolder!
            }
            if self.benchCmd != nil {
                map["BenchCmd"] = self.benchCmd!
            }
            if self.clientJarPath != nil {
                map["ClientJarPath"] = self.clientJarPath!
            }
            if self.jarOnOss != nil {
                map["JarOnOss"] = self.jarOnOss!
            }
            if self.loadCmd != nil {
                map["LoadCmd"] = self.loadCmd!
            }
            if self.metaFileName != nil {
                map["MetaFileName"] = self.metaFileName!
            }
            if self.metaFileOnOss != nil {
                map["MetaFileOnOss"] = self.metaFileOnOss!
            }
            if self.metaFilePath != nil {
                map["MetaFilePath"] = self.metaFilePath!
            }
            if self.parseCmd != nil {
                map["ParseCmd"] = self.parseCmd!
            }
            if self.parseFilePath != nil {
                map["ParseFilePath"] = self.parseFilePath!
            }
            if self.rocksDbPath != nil {
                map["RocksDbPath"] = self.rocksDbPath!
            }
            if self.sqlFileName != nil {
                map["SqlFileName"] = self.sqlFileName!
            }
            if self.sqlFileOnOss != nil {
                map["SqlFileOnOss"] = self.sqlFileOnOss!
            }
            if self.sqlFilePath != nil {
                map["SqlFilePath"] = self.sqlFilePath!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.workDir != nil {
                map["WorkDir"] = self.workDir!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ArchiveFolder") {
                self.archiveFolder = dict["ArchiveFolder"] as! String
            }
            if dict.keys.contains("BenchCmd") {
                self.benchCmd = dict["BenchCmd"] as! String
            }
            if dict.keys.contains("ClientJarPath") {
                self.clientJarPath = dict["ClientJarPath"] as! String
            }
            if dict.keys.contains("JarOnOss") {
                self.jarOnOss = dict["JarOnOss"] as! String
            }
            if dict.keys.contains("LoadCmd") {
                self.loadCmd = dict["LoadCmd"] as! String
            }
            if dict.keys.contains("MetaFileName") {
                self.metaFileName = dict["MetaFileName"] as! String
            }
            if dict.keys.contains("MetaFileOnOss") {
                self.metaFileOnOss = dict["MetaFileOnOss"] as! String
            }
            if dict.keys.contains("MetaFilePath") {
                self.metaFilePath = dict["MetaFilePath"] as! String
            }
            if dict.keys.contains("ParseCmd") {
                self.parseCmd = dict["ParseCmd"] as! String
            }
            if dict.keys.contains("ParseFilePath") {
                self.parseFilePath = dict["ParseFilePath"] as! String
            }
            if dict.keys.contains("RocksDbPath") {
                self.rocksDbPath = dict["RocksDbPath"] as! String
            }
            if dict.keys.contains("SqlFileName") {
                self.sqlFileName = dict["SqlFileName"] as! String
            }
            if dict.keys.contains("SqlFileOnOss") {
                self.sqlFileOnOss = dict["SqlFileOnOss"] as! String
            }
            if dict.keys.contains("SqlFilePath") {
                self.sqlFilePath = dict["SqlFilePath"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("WorkDir") {
                self.workDir = dict["WorkDir"] as! String
            }
        }
    }
    public var code: String?

    public var data: DescribeCloudbenchTaskConfigResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeCloudbenchTaskConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeCloudbenchTaskConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudbenchTaskConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudbenchTaskConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDiagnosticReportListRequest : Tea.TeaModel {
    public var DBInstanceId: String?

    public var endTime: String?

    public var pageNo: String?

    public var pageSize: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBInstanceId != nil {
            map["DBInstanceId"] = self.DBInstanceId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DBInstanceId") {
            self.DBInstanceId = dict["DBInstanceId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeDiagnosticReportListResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var synchro: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchro != nil {
            map["Synchro"] = self.synchro!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Synchro") {
            self.synchro = dict["Synchro"] as! String
        }
    }
}

public class DescribeDiagnosticReportListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnosticReportListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDiagnosticReportListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHotBigKeysRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceId: String?

    public var nodeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsoleContext") {
            self.consoleContext = dict["ConsoleContext"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
    }
}

public class DescribeHotBigKeysResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class BigKeys : Tea.TeaModel {
            public class BigKey : Tea.TeaModel {
                public var db: Int32?

                public var key: String?

                public var keyType: String?

                public var nodeId: String?

                public var size: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.db != nil {
                        map["Db"] = self.db!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.keyType != nil {
                        map["KeyType"] = self.keyType!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.size != nil {
                        map["Size"] = self.size!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Db") {
                        self.db = dict["Db"] as! Int32
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("KeyType") {
                        self.keyType = dict["KeyType"] as! String
                    }
                    if dict.keys.contains("NodeId") {
                        self.nodeId = dict["NodeId"] as! String
                    }
                    if dict.keys.contains("Size") {
                        self.size = dict["Size"] as! Int64
                    }
                }
            }
            public var bigKey: [DescribeHotBigKeysResponseBody.Data.BigKeys.BigKey]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bigKey != nil {
                    var tmp : [Any] = []
                    for k in self.bigKey! {
                        tmp.append(k.toMap())
                    }
                    map["BigKey"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BigKey") {
                    var tmp : [DescribeHotBigKeysResponseBody.Data.BigKeys.BigKey] = []
                    for v in dict["BigKey"] as! [Any] {
                        var model = DescribeHotBigKeysResponseBody.Data.BigKeys.BigKey()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.bigKey = tmp
                }
            }
        }
        public class HotKeys : Tea.TeaModel {
            public class HotKey : Tea.TeaModel {
                public var db: Int32?

                public var hot: String?

                public var key: String?

                public var keyType: String?

                public var lfu: Int32?

                public var nodeId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.db != nil {
                        map["Db"] = self.db!
                    }
                    if self.hot != nil {
                        map["Hot"] = self.hot!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.keyType != nil {
                        map["KeyType"] = self.keyType!
                    }
                    if self.lfu != nil {
                        map["Lfu"] = self.lfu!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Db") {
                        self.db = dict["Db"] as! Int32
                    }
                    if dict.keys.contains("Hot") {
                        self.hot = dict["Hot"] as! String
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("KeyType") {
                        self.keyType = dict["KeyType"] as! String
                    }
                    if dict.keys.contains("Lfu") {
                        self.lfu = dict["Lfu"] as! Int32
                    }
                    if dict.keys.contains("NodeId") {
                        self.nodeId = dict["NodeId"] as! String
                    }
                }
            }
            public var hotKey: [DescribeHotBigKeysResponseBody.Data.HotKeys.HotKey]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hotKey != nil {
                    var tmp : [Any] = []
                    for k in self.hotKey! {
                        tmp.append(k.toMap())
                    }
                    map["HotKey"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HotKey") {
                    var tmp : [DescribeHotBigKeysResponseBody.Data.HotKeys.HotKey] = []
                    for v in dict["HotKey"] as! [Any] {
                        var model = DescribeHotBigKeysResponseBody.Data.HotKeys.HotKey()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.hotKey = tmp
                }
            }
        }
        public var bigKeyMsg: String?

        public var bigKeys: DescribeHotBigKeysResponseBody.Data.BigKeys?

        public var hotKeyMsg: String?

        public var hotKeys: DescribeHotBigKeysResponseBody.Data.HotKeys?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.bigKeys?.validate()
            try self.hotKeys?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bigKeyMsg != nil {
                map["BigKeyMsg"] = self.bigKeyMsg!
            }
            if self.bigKeys != nil {
                map["BigKeys"] = self.bigKeys?.toMap()
            }
            if self.hotKeyMsg != nil {
                map["HotKeyMsg"] = self.hotKeyMsg!
            }
            if self.hotKeys != nil {
                map["HotKeys"] = self.hotKeys?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BigKeyMsg") {
                self.bigKeyMsg = dict["BigKeyMsg"] as! String
            }
            if dict.keys.contains("BigKeys") {
                var model = DescribeHotBigKeysResponseBody.Data.BigKeys()
                model.fromMap(dict["BigKeys"] as! [String: Any])
                self.bigKeys = model
            }
            if dict.keys.contains("HotKeyMsg") {
                self.hotKeyMsg = dict["HotKeyMsg"] as! String
            }
            if dict.keys.contains("HotKeys") {
                var model = DescribeHotBigKeysResponseBody.Data.HotKeys()
                model.fromMap(dict["HotKeys"] as! [String: Any])
                self.hotKeys = model
            }
        }
    }
    public var code: String?

    public var data: DescribeHotBigKeysResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeHotBigKeysResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeHotBigKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHotBigKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeHotBigKeysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHotKeysRequest : Tea.TeaModel {
    public var instanceId: String?

    public var nodeId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
    }
}

public class DescribeHotKeysResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class HotKey : Tea.TeaModel {
            public var db: Int32?

            public var hot: String?

            public var key: String?

            public var keyType: String?

            public var size: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.db != nil {
                    map["Db"] = self.db!
                }
                if self.hot != nil {
                    map["Hot"] = self.hot!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.keyType != nil {
                    map["KeyType"] = self.keyType!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Db") {
                    self.db = dict["Db"] as! Int32
                }
                if dict.keys.contains("Hot") {
                    self.hot = dict["Hot"] as! String
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("KeyType") {
                    self.keyType = dict["KeyType"] as! String
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int64
                }
            }
        }
        public var hotKey: [DescribeHotKeysResponseBody.Data.HotKey]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hotKey != nil {
                var tmp : [Any] = []
                for k in self.hotKey! {
                    tmp.append(k.toMap())
                }
                map["HotKey"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HotKey") {
                var tmp : [DescribeHotKeysResponseBody.Data.HotKey] = []
                for v in dict["HotKey"] as! [Any] {
                    var model = DescribeHotKeysResponseBody.Data.HotKey()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.hotKey = tmp
            }
        }
    }
    public var code: String?

    public var data: DescribeHotKeysResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeHotKeysResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeHotKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHotKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeHotKeysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceDasProRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeInstanceDasProResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Bool?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeInstanceDasProResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceDasProResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceDasProResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSlowLogHistogramAsyncRequest : Tea.TeaModel {
    public class Filters : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var endTime: Int64?

    public var filters: [DescribeSlowLogHistogramAsyncRequest.Filters]?

    public var instanceId: String?

    public var nodeId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filters != nil {
            var tmp : [Any] = []
            for k in self.filters! {
                tmp.append(k.toMap())
            }
            map["Filters"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Filters") {
            var tmp : [DescribeSlowLogHistogramAsyncRequest.Filters] = []
            for v in dict["Filters"] as! [Any] {
                var model = DescribeSlowLogHistogramAsyncRequest.Filters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filters = tmp
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class DescribeSlowLogHistogramAsyncResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class Item : Tea.TeaModel {
                public class InsItems : Tea.TeaModel {
                    public var count: [Int64]?

                    public var insId: String?

                    public var insRole: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.insId != nil {
                            map["InsId"] = self.insId!
                        }
                        if self.insRole != nil {
                            map["InsRole"] = self.insRole!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! [Int64]
                        }
                        if dict.keys.contains("InsId") {
                            self.insId = dict["InsId"] as! String
                        }
                        if dict.keys.contains("InsRole") {
                            self.insRole = dict["InsRole"] as! String
                        }
                    }
                }
                public var count: [Int64]?

                public var insItems: [DescribeSlowLogHistogramAsyncResponseBody.Data.Data.Item.InsItems]?

                public var nodeId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.insItems != nil {
                        var tmp : [Any] = []
                        for k in self.insItems! {
                            tmp.append(k.toMap())
                        }
                        map["InsItems"] = tmp
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! [Int64]
                    }
                    if dict.keys.contains("InsItems") {
                        var tmp : [DescribeSlowLogHistogramAsyncResponseBody.Data.Data.Item.InsItems] = []
                        for v in dict["InsItems"] as! [Any] {
                            var model = DescribeSlowLogHistogramAsyncResponseBody.Data.Data.Item.InsItems()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.insItems = tmp
                    }
                    if dict.keys.contains("NodeId") {
                        self.nodeId = dict["NodeId"] as! String
                    }
                }
            }
            public var avgCPUTime: [Double]?

            public var avgDocExamined: [Double]?

            public var avgFrows: [Double]?

            public var avgIOWrites: [Double]?

            public var avgKeysExamined: [Double]?

            public var avgLastRowsCountAffected: [Double]?

            public var avgLockTime: [Double]?

            public var avgLogicalIOReads: [Double]?

            public var avgPhysicalIOReads: [Double]?

            public var avgReturnNum: [Double]?

            public var avgRows: [Double]?

            public var avgRowsCountAffected: [Double]?

            public var avgRowsExamined: [Double]?

            public var avgRowsSent: [Double]?

            public var avgRt: [Double]?

            public var avgScnt: [Double]?

            public var CPUTime: [Double]?

            public var count: [Int64]?

            public var docExamined: [Int64]?

            public var frows: [Int64]?

            public var IOWrites: [Int64]?

            public var item: [DescribeSlowLogHistogramAsyncResponseBody.Data.Data.Item]?

            public var keysExamined: [Int64]?

            public var lastRowsCountAffected: [Int64]?

            public var lockTime: [Double]?

            public var logicalIOReads: [Int64]?

            public var maxCPUTime: [Double]?

            public var maxDocExamined: [Int64]?

            public var maxFrows: [Int64]?

            public var maxIOWrites: [Int64]?

            public var maxKeysExamined: [Int64]?

            public var maxLastRowsCountAffected: [Int64]?

            public var maxLockTime: [Double]?

            public var maxLogicalIOReads: [Int64]?

            public var maxPhysicalIOReads: [Int64]?

            public var maxReturnNum: [Int64]?

            public var maxRows: [Int64]?

            public var maxRowsCountAffected: [Int64]?

            public var maxRowsExamined: [Int64]?

            public var maxRowsSent: [Int64]?

            public var maxRt: [Double]?

            public var maxScnt: [Int64]?

            public var physicalIOReads: [Int64]?

            public var returnNum: [Int64]?

            public var rows: [Int64]?

            public var rowsCountAffected: [Int64]?

            public var rowsExamined: [Int64]?

            public var rowsSent: [Int64]?

            public var rt: [Double]?

            public var scnt: [Int64]?

            public var total: Int64?

            public var ts: [Int64]?

            public var tsEnd: [Int64]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgCPUTime != nil {
                    map["AvgCPUTime"] = self.avgCPUTime!
                }
                if self.avgDocExamined != nil {
                    map["AvgDocExamined"] = self.avgDocExamined!
                }
                if self.avgFrows != nil {
                    map["AvgFrows"] = self.avgFrows!
                }
                if self.avgIOWrites != nil {
                    map["AvgIOWrites"] = self.avgIOWrites!
                }
                if self.avgKeysExamined != nil {
                    map["AvgKeysExamined"] = self.avgKeysExamined!
                }
                if self.avgLastRowsCountAffected != nil {
                    map["AvgLastRowsCountAffected"] = self.avgLastRowsCountAffected!
                }
                if self.avgLockTime != nil {
                    map["AvgLockTime"] = self.avgLockTime!
                }
                if self.avgLogicalIOReads != nil {
                    map["AvgLogicalIOReads"] = self.avgLogicalIOReads!
                }
                if self.avgPhysicalIOReads != nil {
                    map["AvgPhysicalIOReads"] = self.avgPhysicalIOReads!
                }
                if self.avgReturnNum != nil {
                    map["AvgReturnNum"] = self.avgReturnNum!
                }
                if self.avgRows != nil {
                    map["AvgRows"] = self.avgRows!
                }
                if self.avgRowsCountAffected != nil {
                    map["AvgRowsCountAffected"] = self.avgRowsCountAffected!
                }
                if self.avgRowsExamined != nil {
                    map["AvgRowsExamined"] = self.avgRowsExamined!
                }
                if self.avgRowsSent != nil {
                    map["AvgRowsSent"] = self.avgRowsSent!
                }
                if self.avgRt != nil {
                    map["AvgRt"] = self.avgRt!
                }
                if self.avgScnt != nil {
                    map["AvgScnt"] = self.avgScnt!
                }
                if self.CPUTime != nil {
                    map["CPUTime"] = self.CPUTime!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.docExamined != nil {
                    map["DocExamined"] = self.docExamined!
                }
                if self.frows != nil {
                    map["Frows"] = self.frows!
                }
                if self.IOWrites != nil {
                    map["IOWrites"] = self.IOWrites!
                }
                if self.item != nil {
                    var tmp : [Any] = []
                    for k in self.item! {
                        tmp.append(k.toMap())
                    }
                    map["Item"] = tmp
                }
                if self.keysExamined != nil {
                    map["KeysExamined"] = self.keysExamined!
                }
                if self.lastRowsCountAffected != nil {
                    map["LastRowsCountAffected"] = self.lastRowsCountAffected!
                }
                if self.lockTime != nil {
                    map["LockTime"] = self.lockTime!
                }
                if self.logicalIOReads != nil {
                    map["LogicalIOReads"] = self.logicalIOReads!
                }
                if self.maxCPUTime != nil {
                    map["MaxCPUTime"] = self.maxCPUTime!
                }
                if self.maxDocExamined != nil {
                    map["MaxDocExamined"] = self.maxDocExamined!
                }
                if self.maxFrows != nil {
                    map["MaxFrows"] = self.maxFrows!
                }
                if self.maxIOWrites != nil {
                    map["MaxIOWrites"] = self.maxIOWrites!
                }
                if self.maxKeysExamined != nil {
                    map["MaxKeysExamined"] = self.maxKeysExamined!
                }
                if self.maxLastRowsCountAffected != nil {
                    map["MaxLastRowsCountAffected"] = self.maxLastRowsCountAffected!
                }
                if self.maxLockTime != nil {
                    map["MaxLockTime"] = self.maxLockTime!
                }
                if self.maxLogicalIOReads != nil {
                    map["MaxLogicalIOReads"] = self.maxLogicalIOReads!
                }
                if self.maxPhysicalIOReads != nil {
                    map["MaxPhysicalIOReads"] = self.maxPhysicalIOReads!
                }
                if self.maxReturnNum != nil {
                    map["MaxReturnNum"] = self.maxReturnNum!
                }
                if self.maxRows != nil {
                    map["MaxRows"] = self.maxRows!
                }
                if self.maxRowsCountAffected != nil {
                    map["MaxRowsCountAffected"] = self.maxRowsCountAffected!
                }
                if self.maxRowsExamined != nil {
                    map["MaxRowsExamined"] = self.maxRowsExamined!
                }
                if self.maxRowsSent != nil {
                    map["MaxRowsSent"] = self.maxRowsSent!
                }
                if self.maxRt != nil {
                    map["MaxRt"] = self.maxRt!
                }
                if self.maxScnt != nil {
                    map["MaxScnt"] = self.maxScnt!
                }
                if self.physicalIOReads != nil {
                    map["PhysicalIOReads"] = self.physicalIOReads!
                }
                if self.returnNum != nil {
                    map["ReturnNum"] = self.returnNum!
                }
                if self.rows != nil {
                    map["Rows"] = self.rows!
                }
                if self.rowsCountAffected != nil {
                    map["RowsCountAffected"] = self.rowsCountAffected!
                }
                if self.rowsExamined != nil {
                    map["RowsExamined"] = self.rowsExamined!
                }
                if self.rowsSent != nil {
                    map["RowsSent"] = self.rowsSent!
                }
                if self.rt != nil {
                    map["Rt"] = self.rt!
                }
                if self.scnt != nil {
                    map["Scnt"] = self.scnt!
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                if self.ts != nil {
                    map["Ts"] = self.ts!
                }
                if self.tsEnd != nil {
                    map["TsEnd"] = self.tsEnd!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvgCPUTime") {
                    self.avgCPUTime = dict["AvgCPUTime"] as! [Double]
                }
                if dict.keys.contains("AvgDocExamined") {
                    self.avgDocExamined = dict["AvgDocExamined"] as! [Double]
                }
                if dict.keys.contains("AvgFrows") {
                    self.avgFrows = dict["AvgFrows"] as! [Double]
                }
                if dict.keys.contains("AvgIOWrites") {
                    self.avgIOWrites = dict["AvgIOWrites"] as! [Double]
                }
                if dict.keys.contains("AvgKeysExamined") {
                    self.avgKeysExamined = dict["AvgKeysExamined"] as! [Double]
                }
                if dict.keys.contains("AvgLastRowsCountAffected") {
                    self.avgLastRowsCountAffected = dict["AvgLastRowsCountAffected"] as! [Double]
                }
                if dict.keys.contains("AvgLockTime") {
                    self.avgLockTime = dict["AvgLockTime"] as! [Double]
                }
                if dict.keys.contains("AvgLogicalIOReads") {
                    self.avgLogicalIOReads = dict["AvgLogicalIOReads"] as! [Double]
                }
                if dict.keys.contains("AvgPhysicalIOReads") {
                    self.avgPhysicalIOReads = dict["AvgPhysicalIOReads"] as! [Double]
                }
                if dict.keys.contains("AvgReturnNum") {
                    self.avgReturnNum = dict["AvgReturnNum"] as! [Double]
                }
                if dict.keys.contains("AvgRows") {
                    self.avgRows = dict["AvgRows"] as! [Double]
                }
                if dict.keys.contains("AvgRowsCountAffected") {
                    self.avgRowsCountAffected = dict["AvgRowsCountAffected"] as! [Double]
                }
                if dict.keys.contains("AvgRowsExamined") {
                    self.avgRowsExamined = dict["AvgRowsExamined"] as! [Double]
                }
                if dict.keys.contains("AvgRowsSent") {
                    self.avgRowsSent = dict["AvgRowsSent"] as! [Double]
                }
                if dict.keys.contains("AvgRt") {
                    self.avgRt = dict["AvgRt"] as! [Double]
                }
                if dict.keys.contains("AvgScnt") {
                    self.avgScnt = dict["AvgScnt"] as! [Double]
                }
                if dict.keys.contains("CPUTime") {
                    self.CPUTime = dict["CPUTime"] as! [Double]
                }
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! [Int64]
                }
                if dict.keys.contains("DocExamined") {
                    self.docExamined = dict["DocExamined"] as! [Int64]
                }
                if dict.keys.contains("Frows") {
                    self.frows = dict["Frows"] as! [Int64]
                }
                if dict.keys.contains("IOWrites") {
                    self.IOWrites = dict["IOWrites"] as! [Int64]
                }
                if dict.keys.contains("Item") {
                    var tmp : [DescribeSlowLogHistogramAsyncResponseBody.Data.Data.Item] = []
                    for v in dict["Item"] as! [Any] {
                        var model = DescribeSlowLogHistogramAsyncResponseBody.Data.Data.Item()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.item = tmp
                }
                if dict.keys.contains("KeysExamined") {
                    self.keysExamined = dict["KeysExamined"] as! [Int64]
                }
                if dict.keys.contains("LastRowsCountAffected") {
                    self.lastRowsCountAffected = dict["LastRowsCountAffected"] as! [Int64]
                }
                if dict.keys.contains("LockTime") {
                    self.lockTime = dict["LockTime"] as! [Double]
                }
                if dict.keys.contains("LogicalIOReads") {
                    self.logicalIOReads = dict["LogicalIOReads"] as! [Int64]
                }
                if dict.keys.contains("MaxCPUTime") {
                    self.maxCPUTime = dict["MaxCPUTime"] as! [Double]
                }
                if dict.keys.contains("MaxDocExamined") {
                    self.maxDocExamined = dict["MaxDocExamined"] as! [Int64]
                }
                if dict.keys.contains("MaxFrows") {
                    self.maxFrows = dict["MaxFrows"] as! [Int64]
                }
                if dict.keys.contains("MaxIOWrites") {
                    self.maxIOWrites = dict["MaxIOWrites"] as! [Int64]
                }
                if dict.keys.contains("MaxKeysExamined") {
                    self.maxKeysExamined = dict["MaxKeysExamined"] as! [Int64]
                }
                if dict.keys.contains("MaxLastRowsCountAffected") {
                    self.maxLastRowsCountAffected = dict["MaxLastRowsCountAffected"] as! [Int64]
                }
                if dict.keys.contains("MaxLockTime") {
                    self.maxLockTime = dict["MaxLockTime"] as! [Double]
                }
                if dict.keys.contains("MaxLogicalIOReads") {
                    self.maxLogicalIOReads = dict["MaxLogicalIOReads"] as! [Int64]
                }
                if dict.keys.contains("MaxPhysicalIOReads") {
                    self.maxPhysicalIOReads = dict["MaxPhysicalIOReads"] as! [Int64]
                }
                if dict.keys.contains("MaxReturnNum") {
                    self.maxReturnNum = dict["MaxReturnNum"] as! [Int64]
                }
                if dict.keys.contains("MaxRows") {
                    self.maxRows = dict["MaxRows"] as! [Int64]
                }
                if dict.keys.contains("MaxRowsCountAffected") {
                    self.maxRowsCountAffected = dict["MaxRowsCountAffected"] as! [Int64]
                }
                if dict.keys.contains("MaxRowsExamined") {
                    self.maxRowsExamined = dict["MaxRowsExamined"] as! [Int64]
                }
                if dict.keys.contains("MaxRowsSent") {
                    self.maxRowsSent = dict["MaxRowsSent"] as! [Int64]
                }
                if dict.keys.contains("MaxRt") {
                    self.maxRt = dict["MaxRt"] as! [Double]
                }
                if dict.keys.contains("MaxScnt") {
                    self.maxScnt = dict["MaxScnt"] as! [Int64]
                }
                if dict.keys.contains("PhysicalIOReads") {
                    self.physicalIOReads = dict["PhysicalIOReads"] as! [Int64]
                }
                if dict.keys.contains("ReturnNum") {
                    self.returnNum = dict["ReturnNum"] as! [Int64]
                }
                if dict.keys.contains("Rows") {
                    self.rows = dict["Rows"] as! [Int64]
                }
                if dict.keys.contains("RowsCountAffected") {
                    self.rowsCountAffected = dict["RowsCountAffected"] as! [Int64]
                }
                if dict.keys.contains("RowsExamined") {
                    self.rowsExamined = dict["RowsExamined"] as! [Int64]
                }
                if dict.keys.contains("RowsSent") {
                    self.rowsSent = dict["RowsSent"] as! [Int64]
                }
                if dict.keys.contains("Rt") {
                    self.rt = dict["Rt"] as! [Double]
                }
                if dict.keys.contains("Scnt") {
                    self.scnt = dict["Scnt"] as! [Int64]
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
                if dict.keys.contains("Ts") {
                    self.ts = dict["Ts"] as! [Int64]
                }
                if dict.keys.contains("TsEnd") {
                    self.tsEnd = dict["TsEnd"] as! [Int64]
                }
            }
        }
        public var data: DescribeSlowLogHistogramAsyncResponseBody.Data.Data?

        public var errorCode: Int32?

        public var isFinish: Bool?

        public var message: String?

        public var requestKey: String?

        public var resultId: String?

        public var state: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.isFinish != nil {
                map["IsFinish"] = self.isFinish!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.requestKey != nil {
                map["RequestKey"] = self.requestKey!
            }
            if self.resultId != nil {
                map["ResultId"] = self.resultId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") {
                var model = DescribeSlowLogHistogramAsyncResponseBody.Data.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
            if dict.keys.contains("ErrorCode") {
                self.errorCode = dict["ErrorCode"] as! Int32
            }
            if dict.keys.contains("IsFinish") {
                self.isFinish = dict["IsFinish"] as! Bool
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("RequestKey") {
                self.requestKey = dict["RequestKey"] as! String
            }
            if dict.keys.contains("ResultId") {
                self.resultId = dict["ResultId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeSlowLogHistogramAsyncResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeSlowLogHistogramAsyncResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeSlowLogHistogramAsyncResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSlowLogHistogramAsyncResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSlowLogHistogramAsyncResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSlowLogStatisticRequest : Tea.TeaModel {
    public class Filters : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var asc: Bool?

    public var endTime: Int64?

    public var filters: [DescribeSlowLogStatisticRequest.Filters]?

    public var instanceId: String?

    public var nodeId: String?

    public var orderBy: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public var templateId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asc != nil {
            map["Asc"] = self.asc!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filters != nil {
            var tmp : [Any] = []
            for k in self.filters! {
                tmp.append(k.toMap())
            }
            map["Filters"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Asc") {
            self.asc = dict["Asc"] as! Bool
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Filters") {
            var tmp : [DescribeSlowLogStatisticRequest.Filters] = []
            for v in dict["Filters"] as! [Any] {
                var model = DescribeSlowLogStatisticRequest.Filters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filters = tmp
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeSlowLogStatisticResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Data : Tea.TeaModel {
            public class Logs : Tea.TeaModel {
                public class Histogram : Tea.TeaModel {
                    public class Item : Tea.TeaModel {
                        public var count: [Int64]?

                        public var nodeId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.count != nil {
                                map["Count"] = self.count!
                            }
                            if self.nodeId != nil {
                                map["NodeId"] = self.nodeId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Count") {
                                self.count = dict["Count"] as! [Int64]
                            }
                            if dict.keys.contains("NodeId") {
                                self.nodeId = dict["NodeId"] as! String
                            }
                        }
                    }
                    public var avgLockTime: [Double]?

                    public var avgRowsExamined: [Double]?

                    public var avgRowsSent: [Double]?

                    public var avgRt: [Double]?

                    public var count: [Int64]?

                    public var item: [DescribeSlowLogStatisticResponseBody.Data.Data.Logs.Histogram.Item]?

                    public var lockTime: [Double]?

                    public var maxLockTime: [Double]?

                    public var maxRowsExamined: [Int64]?

                    public var maxRowsSent: [Int64]?

                    public var maxRt: [Double]?

                    public var rowsExamined: [Int64]?

                    public var rowsSent: [Int64]?

                    public var rt: [Double]?

                    public var total: Int64?

                    public var ts: [Int64]?

                    public var tsEnd: [Int64]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.avgLockTime != nil {
                            map["AvgLockTime"] = self.avgLockTime!
                        }
                        if self.avgRowsExamined != nil {
                            map["AvgRowsExamined"] = self.avgRowsExamined!
                        }
                        if self.avgRowsSent != nil {
                            map["AvgRowsSent"] = self.avgRowsSent!
                        }
                        if self.avgRt != nil {
                            map["AvgRt"] = self.avgRt!
                        }
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.item != nil {
                            var tmp : [Any] = []
                            for k in self.item! {
                                tmp.append(k.toMap())
                            }
                            map["Item"] = tmp
                        }
                        if self.lockTime != nil {
                            map["LockTime"] = self.lockTime!
                        }
                        if self.maxLockTime != nil {
                            map["MaxLockTime"] = self.maxLockTime!
                        }
                        if self.maxRowsExamined != nil {
                            map["MaxRowsExamined"] = self.maxRowsExamined!
                        }
                        if self.maxRowsSent != nil {
                            map["MaxRowsSent"] = self.maxRowsSent!
                        }
                        if self.maxRt != nil {
                            map["MaxRt"] = self.maxRt!
                        }
                        if self.rowsExamined != nil {
                            map["RowsExamined"] = self.rowsExamined!
                        }
                        if self.rowsSent != nil {
                            map["RowsSent"] = self.rowsSent!
                        }
                        if self.rt != nil {
                            map["Rt"] = self.rt!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        if self.ts != nil {
                            map["Ts"] = self.ts!
                        }
                        if self.tsEnd != nil {
                            map["TsEnd"] = self.tsEnd!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AvgLockTime") {
                            self.avgLockTime = dict["AvgLockTime"] as! [Double]
                        }
                        if dict.keys.contains("AvgRowsExamined") {
                            self.avgRowsExamined = dict["AvgRowsExamined"] as! [Double]
                        }
                        if dict.keys.contains("AvgRowsSent") {
                            self.avgRowsSent = dict["AvgRowsSent"] as! [Double]
                        }
                        if dict.keys.contains("AvgRt") {
                            self.avgRt = dict["AvgRt"] as! [Double]
                        }
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! [Int64]
                        }
                        if dict.keys.contains("Item") {
                            var tmp : [DescribeSlowLogStatisticResponseBody.Data.Data.Logs.Histogram.Item] = []
                            for v in dict["Item"] as! [Any] {
                                var model = DescribeSlowLogStatisticResponseBody.Data.Data.Logs.Histogram.Item()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.item = tmp
                        }
                        if dict.keys.contains("LockTime") {
                            self.lockTime = dict["LockTime"] as! [Double]
                        }
                        if dict.keys.contains("MaxLockTime") {
                            self.maxLockTime = dict["MaxLockTime"] as! [Double]
                        }
                        if dict.keys.contains("MaxRowsExamined") {
                            self.maxRowsExamined = dict["MaxRowsExamined"] as! [Int64]
                        }
                        if dict.keys.contains("MaxRowsSent") {
                            self.maxRowsSent = dict["MaxRowsSent"] as! [Int64]
                        }
                        if dict.keys.contains("MaxRt") {
                            self.maxRt = dict["MaxRt"] as! [Double]
                        }
                        if dict.keys.contains("RowsExamined") {
                            self.rowsExamined = dict["RowsExamined"] as! [Int64]
                        }
                        if dict.keys.contains("RowsSent") {
                            self.rowsSent = dict["RowsSent"] as! [Int64]
                        }
                        if dict.keys.contains("Rt") {
                            self.rt = dict["Rt"] as! [Double]
                        }
                        if dict.keys.contains("Total") {
                            self.total = dict["Total"] as! Int64
                        }
                        if dict.keys.contains("Ts") {
                            self.ts = dict["Ts"] as! [Int64]
                        }
                        if dict.keys.contains("TsEnd") {
                            self.tsEnd = dict["TsEnd"] as! [Int64]
                        }
                    }
                }
                public class SqlTag : Tea.TeaModel {
                    public var comments: String?

                    public var sqlId: String?

                    public var tags: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.comments != nil {
                            map["Comments"] = self.comments!
                        }
                        if self.sqlId != nil {
                            map["SqlId"] = self.sqlId!
                        }
                        if self.tags != nil {
                            map["Tags"] = self.tags!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Comments") {
                            self.comments = dict["Comments"] as! String
                        }
                        if dict.keys.contains("SqlId") {
                            self.sqlId = dict["SqlId"] as! String
                        }
                        if dict.keys.contains("Tags") {
                            self.tags = dict["Tags"] as! String
                        }
                    }
                }
                public class Trend : Tea.TeaModel {
                    public var timestamp: Int64?

                    public var value: Any?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.timestamp != nil {
                            map["Timestamp"] = self.timestamp!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Timestamp") {
                            self.timestamp = dict["Timestamp"] as! Int64
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! Any
                        }
                    }
                }
                public var accountName: String?

                public var avgCPUTime: Double?

                public var avgCPUTimeSeconds: Double?

                public var avgDocExamined: Double?

                public var avgFrows: Double?

                public var avgIOWrites: Double?

                public var avgKeysExamined: Double?

                public var avgLastRowsCountAffected: Double?

                public var avgLockTime: Double?

                public var avgLockTimeSeconds: Double?

                public var avgLogicalIOReads: Double?

                public var avgPhysicalIOReads: Double?

                public var avgQueryTime: Double?

                public var avgQueryTimeSeconds: Double?

                public var avgReturnNum: Double?

                public var avgRows: Double?

                public var avgRowsCountAffected: Double?

                public var avgRowsExamined: Double?

                public var avgRowsSent: Double?

                public var avgScnt: Double?

                public var CPUTime: Double?

                public var CPUTimeSeconds: Double?

                public var command: String?

                public var count: Int64?

                public var countRate: Double?

                public var DBName: String?

                public var database: String?

                public var dbInstanceName: String?

                public var docExamined: Int64?

                public var docsExamined: Int64?

                public var frows: Int64?

                public var histogram: DescribeSlowLogStatisticResponseBody.Data.Data.Logs.Histogram?

                public var hostAddress: String?

                public var hostInsId: String?

                public var IOWrites: Int64?

                public var insName: String?

                public var insRole: String?

                public var keysExamined: Int64?

                public var lastRowsCountAffected: Int64?

                public var lockTime: Double?

                public var lockTimeSeconds: Double?

                public var logicalIOReads: Int64?

                public var maxCPUTime: Double?

                public var maxCPUTimeSeconds: Double?

                public var maxDocExamined: Int64?

                public var maxFrows: Int64?

                public var maxIOWrites: Int64?

                public var maxKeysExamined: Int64?

                public var maxLastRowsCountAffected: Int64?

                public var maxLockTime: Double?

                public var maxLockTimeSeconds: Double?

                public var maxLogicalIOReads: Int64?

                public var maxPhysicalIOReads: Int64?

                public var maxQueryTime: Double?

                public var maxQueryTimeSeconds: Double?

                public var maxReturnNum: Int64?

                public var maxRows: Int64?

                public var maxRowsCountAffected: Int64?

                public var maxRowsExamined: Int64?

                public var maxRowsSent: Int64?

                public var maxScnt: Int64?

                public var namespace: String?

                public var nodeType: String?

                public var opType: String?

                public var originAlias: String?

                public var physicalIOReads: Int64?

                public var psql: String?

                public var queryId: String?

                public var queryStartTime: String?

                public var queryTime: Int64?

                public var queryTimeRate: Double?

                public var queryTimeSeconds: Double?

                public var returnItemNumbers: String?

                public var returnNum: Int64?

                public var rows: Int64?

                public var rowsCountAffected: Int64?

                public var rowsExamined: Int64?

                public var rowsSent: Int64?

                public var SQLText: String?

                public var scheme: String?

                public var scnt: Int64?

                public var sqlId: String?

                public var sqlTag: DescribeSlowLogStatisticResponseBody.Data.Data.Logs.SqlTag?

                public var sqlType: String?

                public var subInstanceId: String?

                public var tableName: String?

                public var threadId: String?

                public var timestamp: Int64?

                public var trend: [DescribeSlowLogStatisticResponseBody.Data.Data.Logs.Trend]?

                public var user: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.histogram?.validate()
                    try self.sqlTag?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accountName != nil {
                        map["AccountName"] = self.accountName!
                    }
                    if self.avgCPUTime != nil {
                        map["AvgCPUTime"] = self.avgCPUTime!
                    }
                    if self.avgCPUTimeSeconds != nil {
                        map["AvgCPUTimeSeconds"] = self.avgCPUTimeSeconds!
                    }
                    if self.avgDocExamined != nil {
                        map["AvgDocExamined"] = self.avgDocExamined!
                    }
                    if self.avgFrows != nil {
                        map["AvgFrows"] = self.avgFrows!
                    }
                    if self.avgIOWrites != nil {
                        map["AvgIOWrites"] = self.avgIOWrites!
                    }
                    if self.avgKeysExamined != nil {
                        map["AvgKeysExamined"] = self.avgKeysExamined!
                    }
                    if self.avgLastRowsCountAffected != nil {
                        map["AvgLastRowsCountAffected"] = self.avgLastRowsCountAffected!
                    }
                    if self.avgLockTime != nil {
                        map["AvgLockTime"] = self.avgLockTime!
                    }
                    if self.avgLockTimeSeconds != nil {
                        map["AvgLockTimeSeconds"] = self.avgLockTimeSeconds!
                    }
                    if self.avgLogicalIOReads != nil {
                        map["AvgLogicalIOReads"] = self.avgLogicalIOReads!
                    }
                    if self.avgPhysicalIOReads != nil {
                        map["AvgPhysicalIOReads"] = self.avgPhysicalIOReads!
                    }
                    if self.avgQueryTime != nil {
                        map["AvgQueryTime"] = self.avgQueryTime!
                    }
                    if self.avgQueryTimeSeconds != nil {
                        map["AvgQueryTimeSeconds"] = self.avgQueryTimeSeconds!
                    }
                    if self.avgReturnNum != nil {
                        map["AvgReturnNum"] = self.avgReturnNum!
                    }
                    if self.avgRows != nil {
                        map["AvgRows"] = self.avgRows!
                    }
                    if self.avgRowsCountAffected != nil {
                        map["AvgRowsCountAffected"] = self.avgRowsCountAffected!
                    }
                    if self.avgRowsExamined != nil {
                        map["AvgRowsExamined"] = self.avgRowsExamined!
                    }
                    if self.avgRowsSent != nil {
                        map["AvgRowsSent"] = self.avgRowsSent!
                    }
                    if self.avgScnt != nil {
                        map["AvgScnt"] = self.avgScnt!
                    }
                    if self.CPUTime != nil {
                        map["CPUTime"] = self.CPUTime!
                    }
                    if self.CPUTimeSeconds != nil {
                        map["CPUTimeSeconds"] = self.CPUTimeSeconds!
                    }
                    if self.command != nil {
                        map["Command"] = self.command!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.countRate != nil {
                        map["CountRate"] = self.countRate!
                    }
                    if self.DBName != nil {
                        map["DBName"] = self.DBName!
                    }
                    if self.database != nil {
                        map["Database"] = self.database!
                    }
                    if self.dbInstanceName != nil {
                        map["DbInstanceName"] = self.dbInstanceName!
                    }
                    if self.docExamined != nil {
                        map["DocExamined"] = self.docExamined!
                    }
                    if self.docsExamined != nil {
                        map["DocsExamined"] = self.docsExamined!
                    }
                    if self.frows != nil {
                        map["Frows"] = self.frows!
                    }
                    if self.histogram != nil {
                        map["Histogram"] = self.histogram?.toMap()
                    }
                    if self.hostAddress != nil {
                        map["HostAddress"] = self.hostAddress!
                    }
                    if self.hostInsId != nil {
                        map["HostInsId"] = self.hostInsId!
                    }
                    if self.IOWrites != nil {
                        map["IOWrites"] = self.IOWrites!
                    }
                    if self.insName != nil {
                        map["InsName"] = self.insName!
                    }
                    if self.insRole != nil {
                        map["InsRole"] = self.insRole!
                    }
                    if self.keysExamined != nil {
                        map["KeysExamined"] = self.keysExamined!
                    }
                    if self.lastRowsCountAffected != nil {
                        map["LastRowsCountAffected"] = self.lastRowsCountAffected!
                    }
                    if self.lockTime != nil {
                        map["LockTime"] = self.lockTime!
                    }
                    if self.lockTimeSeconds != nil {
                        map["LockTimeSeconds"] = self.lockTimeSeconds!
                    }
                    if self.logicalIOReads != nil {
                        map["LogicalIOReads"] = self.logicalIOReads!
                    }
                    if self.maxCPUTime != nil {
                        map["MaxCPUTime"] = self.maxCPUTime!
                    }
                    if self.maxCPUTimeSeconds != nil {
                        map["MaxCPUTimeSeconds"] = self.maxCPUTimeSeconds!
                    }
                    if self.maxDocExamined != nil {
                        map["MaxDocExamined"] = self.maxDocExamined!
                    }
                    if self.maxFrows != nil {
                        map["MaxFrows"] = self.maxFrows!
                    }
                    if self.maxIOWrites != nil {
                        map["MaxIOWrites"] = self.maxIOWrites!
                    }
                    if self.maxKeysExamined != nil {
                        map["MaxKeysExamined"] = self.maxKeysExamined!
                    }
                    if self.maxLastRowsCountAffected != nil {
                        map["MaxLastRowsCountAffected"] = self.maxLastRowsCountAffected!
                    }
                    if self.maxLockTime != nil {
                        map["MaxLockTime"] = self.maxLockTime!
                    }
                    if self.maxLockTimeSeconds != nil {
                        map["MaxLockTimeSeconds"] = self.maxLockTimeSeconds!
                    }
                    if self.maxLogicalIOReads != nil {
                        map["MaxLogicalIOReads"] = self.maxLogicalIOReads!
                    }
                    if self.maxPhysicalIOReads != nil {
                        map["MaxPhysicalIOReads"] = self.maxPhysicalIOReads!
                    }
                    if self.maxQueryTime != nil {
                        map["MaxQueryTime"] = self.maxQueryTime!
                    }
                    if self.maxQueryTimeSeconds != nil {
                        map["MaxQueryTimeSeconds"] = self.maxQueryTimeSeconds!
                    }
                    if self.maxReturnNum != nil {
                        map["MaxReturnNum"] = self.maxReturnNum!
                    }
                    if self.maxRows != nil {
                        map["MaxRows"] = self.maxRows!
                    }
                    if self.maxRowsCountAffected != nil {
                        map["MaxRowsCountAffected"] = self.maxRowsCountAffected!
                    }
                    if self.maxRowsExamined != nil {
                        map["MaxRowsExamined"] = self.maxRowsExamined!
                    }
                    if self.maxRowsSent != nil {
                        map["MaxRowsSent"] = self.maxRowsSent!
                    }
                    if self.maxScnt != nil {
                        map["MaxScnt"] = self.maxScnt!
                    }
                    if self.namespace != nil {
                        map["Namespace"] = self.namespace!
                    }
                    if self.nodeType != nil {
                        map["NodeType"] = self.nodeType!
                    }
                    if self.opType != nil {
                        map["OpType"] = self.opType!
                    }
                    if self.originAlias != nil {
                        map["OriginAlias"] = self.originAlias!
                    }
                    if self.physicalIOReads != nil {
                        map["PhysicalIOReads"] = self.physicalIOReads!
                    }
                    if self.psql != nil {
                        map["Psql"] = self.psql!
                    }
                    if self.queryId != nil {
                        map["QueryId"] = self.queryId!
                    }
                    if self.queryStartTime != nil {
                        map["QueryStartTime"] = self.queryStartTime!
                    }
                    if self.queryTime != nil {
                        map["QueryTime"] = self.queryTime!
                    }
                    if self.queryTimeRate != nil {
                        map["QueryTimeRate"] = self.queryTimeRate!
                    }
                    if self.queryTimeSeconds != nil {
                        map["QueryTimeSeconds"] = self.queryTimeSeconds!
                    }
                    if self.returnItemNumbers != nil {
                        map["ReturnItemNumbers"] = self.returnItemNumbers!
                    }
                    if self.returnNum != nil {
                        map["ReturnNum"] = self.returnNum!
                    }
                    if self.rows != nil {
                        map["Rows"] = self.rows!
                    }
                    if self.rowsCountAffected != nil {
                        map["RowsCountAffected"] = self.rowsCountAffected!
                    }
                    if self.rowsExamined != nil {
                        map["RowsExamined"] = self.rowsExamined!
                    }
                    if self.rowsSent != nil {
                        map["RowsSent"] = self.rowsSent!
                    }
                    if self.SQLText != nil {
                        map["SQLText"] = self.SQLText!
                    }
                    if self.scheme != nil {
                        map["Scheme"] = self.scheme!
                    }
                    if self.scnt != nil {
                        map["Scnt"] = self.scnt!
                    }
                    if self.sqlId != nil {
                        map["SqlId"] = self.sqlId!
                    }
                    if self.sqlTag != nil {
                        map["SqlTag"] = self.sqlTag?.toMap()
                    }
                    if self.sqlType != nil {
                        map["SqlType"] = self.sqlType!
                    }
                    if self.subInstanceId != nil {
                        map["SubInstanceId"] = self.subInstanceId!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    if self.threadId != nil {
                        map["ThreadId"] = self.threadId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.trend != nil {
                        var tmp : [Any] = []
                        for k in self.trend! {
                            tmp.append(k.toMap())
                        }
                        map["Trend"] = tmp
                    }
                    if self.user != nil {
                        map["User"] = self.user!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AccountName") {
                        self.accountName = dict["AccountName"] as! String
                    }
                    if dict.keys.contains("AvgCPUTime") {
                        self.avgCPUTime = dict["AvgCPUTime"] as! Double
                    }
                    if dict.keys.contains("AvgCPUTimeSeconds") {
                        self.avgCPUTimeSeconds = dict["AvgCPUTimeSeconds"] as! Double
                    }
                    if dict.keys.contains("AvgDocExamined") {
                        self.avgDocExamined = dict["AvgDocExamined"] as! Double
                    }
                    if dict.keys.contains("AvgFrows") {
                        self.avgFrows = dict["AvgFrows"] as! Double
                    }
                    if dict.keys.contains("AvgIOWrites") {
                        self.avgIOWrites = dict["AvgIOWrites"] as! Double
                    }
                    if dict.keys.contains("AvgKeysExamined") {
                        self.avgKeysExamined = dict["AvgKeysExamined"] as! Double
                    }
                    if dict.keys.contains("AvgLastRowsCountAffected") {
                        self.avgLastRowsCountAffected = dict["AvgLastRowsCountAffected"] as! Double
                    }
                    if dict.keys.contains("AvgLockTime") {
                        self.avgLockTime = dict["AvgLockTime"] as! Double
                    }
                    if dict.keys.contains("AvgLockTimeSeconds") {
                        self.avgLockTimeSeconds = dict["AvgLockTimeSeconds"] as! Double
                    }
                    if dict.keys.contains("AvgLogicalIOReads") {
                        self.avgLogicalIOReads = dict["AvgLogicalIOReads"] as! Double
                    }
                    if dict.keys.contains("AvgPhysicalIOReads") {
                        self.avgPhysicalIOReads = dict["AvgPhysicalIOReads"] as! Double
                    }
                    if dict.keys.contains("AvgQueryTime") {
                        self.avgQueryTime = dict["AvgQueryTime"] as! Double
                    }
                    if dict.keys.contains("AvgQueryTimeSeconds") {
                        self.avgQueryTimeSeconds = dict["AvgQueryTimeSeconds"] as! Double
                    }
                    if dict.keys.contains("AvgReturnNum") {
                        self.avgReturnNum = dict["AvgReturnNum"] as! Double
                    }
                    if dict.keys.contains("AvgRows") {
                        self.avgRows = dict["AvgRows"] as! Double
                    }
                    if dict.keys.contains("AvgRowsCountAffected") {
                        self.avgRowsCountAffected = dict["AvgRowsCountAffected"] as! Double
                    }
                    if dict.keys.contains("AvgRowsExamined") {
                        self.avgRowsExamined = dict["AvgRowsExamined"] as! Double
                    }
                    if dict.keys.contains("AvgRowsSent") {
                        self.avgRowsSent = dict["AvgRowsSent"] as! Double
                    }
                    if dict.keys.contains("AvgScnt") {
                        self.avgScnt = dict["AvgScnt"] as! Double
                    }
                    if dict.keys.contains("CPUTime") {
                        self.CPUTime = dict["CPUTime"] as! Double
                    }
                    if dict.keys.contains("CPUTimeSeconds") {
                        self.CPUTimeSeconds = dict["CPUTimeSeconds"] as! Double
                    }
                    if dict.keys.contains("Command") {
                        self.command = dict["Command"] as! String
                    }
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int64
                    }
                    if dict.keys.contains("CountRate") {
                        self.countRate = dict["CountRate"] as! Double
                    }
                    if dict.keys.contains("DBName") {
                        self.DBName = dict["DBName"] as! String
                    }
                    if dict.keys.contains("Database") {
                        self.database = dict["Database"] as! String
                    }
                    if dict.keys.contains("DbInstanceName") {
                        self.dbInstanceName = dict["DbInstanceName"] as! String
                    }
                    if dict.keys.contains("DocExamined") {
                        self.docExamined = dict["DocExamined"] as! Int64
                    }
                    if dict.keys.contains("DocsExamined") {
                        self.docsExamined = dict["DocsExamined"] as! Int64
                    }
                    if dict.keys.contains("Frows") {
                        self.frows = dict["Frows"] as! Int64
                    }
                    if dict.keys.contains("Histogram") {
                        var model = DescribeSlowLogStatisticResponseBody.Data.Data.Logs.Histogram()
                        model.fromMap(dict["Histogram"] as! [String: Any])
                        self.histogram = model
                    }
                    if dict.keys.contains("HostAddress") {
                        self.hostAddress = dict["HostAddress"] as! String
                    }
                    if dict.keys.contains("HostInsId") {
                        self.hostInsId = dict["HostInsId"] as! String
                    }
                    if dict.keys.contains("IOWrites") {
                        self.IOWrites = dict["IOWrites"] as! Int64
                    }
                    if dict.keys.contains("InsName") {
                        self.insName = dict["InsName"] as! String
                    }
                    if dict.keys.contains("InsRole") {
                        self.insRole = dict["InsRole"] as! String
                    }
                    if dict.keys.contains("KeysExamined") {
                        self.keysExamined = dict["KeysExamined"] as! Int64
                    }
                    if dict.keys.contains("LastRowsCountAffected") {
                        self.lastRowsCountAffected = dict["LastRowsCountAffected"] as! Int64
                    }
                    if dict.keys.contains("LockTime") {
                        self.lockTime = dict["LockTime"] as! Double
                    }
                    if dict.keys.contains("LockTimeSeconds") {
                        self.lockTimeSeconds = dict["LockTimeSeconds"] as! Double
                    }
                    if dict.keys.contains("LogicalIOReads") {
                        self.logicalIOReads = dict["LogicalIOReads"] as! Int64
                    }
                    if dict.keys.contains("MaxCPUTime") {
                        self.maxCPUTime = dict["MaxCPUTime"] as! Double
                    }
                    if dict.keys.contains("MaxCPUTimeSeconds") {
                        self.maxCPUTimeSeconds = dict["MaxCPUTimeSeconds"] as! Double
                    }
                    if dict.keys.contains("MaxDocExamined") {
                        self.maxDocExamined = dict["MaxDocExamined"] as! Int64
                    }
                    if dict.keys.contains("MaxFrows") {
                        self.maxFrows = dict["MaxFrows"] as! Int64
                    }
                    if dict.keys.contains("MaxIOWrites") {
                        self.maxIOWrites = dict["MaxIOWrites"] as! Int64
                    }
                    if dict.keys.contains("MaxKeysExamined") {
                        self.maxKeysExamined = dict["MaxKeysExamined"] as! Int64
                    }
                    if dict.keys.contains("MaxLastRowsCountAffected") {
                        self.maxLastRowsCountAffected = dict["MaxLastRowsCountAffected"] as! Int64
                    }
                    if dict.keys.contains("MaxLockTime") {
                        self.maxLockTime = dict["MaxLockTime"] as! Double
                    }
                    if dict.keys.contains("MaxLockTimeSeconds") {
                        self.maxLockTimeSeconds = dict["MaxLockTimeSeconds"] as! Double
                    }
                    if dict.keys.contains("MaxLogicalIOReads") {
                        self.maxLogicalIOReads = dict["MaxLogicalIOReads"] as! Int64
                    }
                    if dict.keys.contains("MaxPhysicalIOReads") {
                        self.maxPhysicalIOReads = dict["MaxPhysicalIOReads"] as! Int64
                    }
                    if dict.keys.contains("MaxQueryTime") {
                        self.maxQueryTime = dict["MaxQueryTime"] as! Double
                    }
                    if dict.keys.contains("MaxQueryTimeSeconds") {
                        self.maxQueryTimeSeconds = dict["MaxQueryTimeSeconds"] as! Double
                    }
                    if dict.keys.contains("MaxReturnNum") {
                        self.maxReturnNum = dict["MaxReturnNum"] as! Int64
                    }
                    if dict.keys.contains("MaxRows") {
                        self.maxRows = dict["MaxRows"] as! Int64
                    }
                    if dict.keys.contains("MaxRowsCountAffected") {
                        self.maxRowsCountAffected = dict["MaxRowsCountAffected"] as! Int64
                    }
                    if dict.keys.contains("MaxRowsExamined") {
                        self.maxRowsExamined = dict["MaxRowsExamined"] as! Int64
                    }
                    if dict.keys.contains("MaxRowsSent") {
                        self.maxRowsSent = dict["MaxRowsSent"] as! Int64
                    }
                    if dict.keys.contains("MaxScnt") {
                        self.maxScnt = dict["MaxScnt"] as! Int64
                    }
                    if dict.keys.contains("Namespace") {
                        self.namespace = dict["Namespace"] as! String
                    }
                    if dict.keys.contains("NodeType") {
                        self.nodeType = dict["NodeType"] as! String
                    }
                    if dict.keys.contains("OpType") {
                        self.opType = dict["OpType"] as! String
                    }
                    if dict.keys.contains("OriginAlias") {
                        self.originAlias = dict["OriginAlias"] as! String
                    }
                    if dict.keys.contains("PhysicalIOReads") {
                        self.physicalIOReads = dict["PhysicalIOReads"] as! Int64
                    }
                    if dict.keys.contains("Psql") {
                        self.psql = dict["Psql"] as! String
                    }
                    if dict.keys.contains("QueryId") {
                        self.queryId = dict["QueryId"] as! String
                    }
                    if dict.keys.contains("QueryStartTime") {
                        self.queryStartTime = dict["QueryStartTime"] as! String
                    }
                    if dict.keys.contains("QueryTime") {
                        self.queryTime = dict["QueryTime"] as! Int64
                    }
                    if dict.keys.contains("QueryTimeRate") {
                        self.queryTimeRate = dict["QueryTimeRate"] as! Double
                    }
                    if dict.keys.contains("QueryTimeSeconds") {
                        self.queryTimeSeconds = dict["QueryTimeSeconds"] as! Double
                    }
                    if dict.keys.contains("ReturnItemNumbers") {
                        self.returnItemNumbers = dict["ReturnItemNumbers"] as! String
                    }
                    if dict.keys.contains("ReturnNum") {
                        self.returnNum = dict["ReturnNum"] as! Int64
                    }
                    if dict.keys.contains("Rows") {
                        self.rows = dict["Rows"] as! Int64
                    }
                    if dict.keys.contains("RowsCountAffected") {
                        self.rowsCountAffected = dict["RowsCountAffected"] as! Int64
                    }
                    if dict.keys.contains("RowsExamined") {
                        self.rowsExamined = dict["RowsExamined"] as! Int64
                    }
                    if dict.keys.contains("RowsSent") {
                        self.rowsSent = dict["RowsSent"] as! Int64
                    }
                    if dict.keys.contains("SQLText") {
                        self.SQLText = dict["SQLText"] as! String
                    }
                    if dict.keys.contains("Scheme") {
                        self.scheme = dict["Scheme"] as! String
                    }
                    if dict.keys.contains("Scnt") {
                        self.scnt = dict["Scnt"] as! Int64
                    }
                    if dict.keys.contains("SqlId") {
                        self.sqlId = dict["SqlId"] as! String
                    }
                    if dict.keys.contains("SqlTag") {
                        var model = DescribeSlowLogStatisticResponseBody.Data.Data.Logs.SqlTag()
                        model.fromMap(dict["SqlTag"] as! [String: Any])
                        self.sqlTag = model
                    }
                    if dict.keys.contains("SqlType") {
                        self.sqlType = dict["SqlType"] as! String
                    }
                    if dict.keys.contains("SubInstanceId") {
                        self.subInstanceId = dict["SubInstanceId"] as! String
                    }
                    if dict.keys.contains("TableName") {
                        self.tableName = dict["TableName"] as! String
                    }
                    if dict.keys.contains("ThreadId") {
                        self.threadId = dict["ThreadId"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("Trend") {
                        var tmp : [DescribeSlowLogStatisticResponseBody.Data.Data.Logs.Trend] = []
                        for v in dict["Trend"] as! [Any] {
                            var model = DescribeSlowLogStatisticResponseBody.Data.Data.Logs.Trend()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.trend = tmp
                    }
                    if dict.keys.contains("User") {
                        self.user = dict["User"] as! String
                    }
                }
            }
            public var dbInstanceId: Int64?

            public var dbInstanceName: String?

            public var endTime: String?

            public var itemsNumbers: Int64?

            public var logs: [DescribeSlowLogStatisticResponseBody.Data.Data.Logs]?

            public var maxRecordsPerPage: Int32?

            public var nodeId: String?

            public var pageNumbers: Int32?

            public var startTime: String?

            public var totalRecords: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbInstanceId != nil {
                    map["DbInstanceId"] = self.dbInstanceId!
                }
                if self.dbInstanceName != nil {
                    map["DbInstanceName"] = self.dbInstanceName!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.itemsNumbers != nil {
                    map["ItemsNumbers"] = self.itemsNumbers!
                }
                if self.logs != nil {
                    var tmp : [Any] = []
                    for k in self.logs! {
                        tmp.append(k.toMap())
                    }
                    map["Logs"] = tmp
                }
                if self.maxRecordsPerPage != nil {
                    map["MaxRecordsPerPage"] = self.maxRecordsPerPage!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.pageNumbers != nil {
                    map["PageNumbers"] = self.pageNumbers!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.totalRecords != nil {
                    map["TotalRecords"] = self.totalRecords!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DbInstanceId") {
                    self.dbInstanceId = dict["DbInstanceId"] as! Int64
                }
                if dict.keys.contains("DbInstanceName") {
                    self.dbInstanceName = dict["DbInstanceName"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("ItemsNumbers") {
                    self.itemsNumbers = dict["ItemsNumbers"] as! Int64
                }
                if dict.keys.contains("Logs") {
                    var tmp : [DescribeSlowLogStatisticResponseBody.Data.Data.Logs] = []
                    for v in dict["Logs"] as! [Any] {
                        var model = DescribeSlowLogStatisticResponseBody.Data.Data.Logs()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.logs = tmp
                }
                if dict.keys.contains("MaxRecordsPerPage") {
                    self.maxRecordsPerPage = dict["MaxRecordsPerPage"] as! Int32
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! String
                }
                if dict.keys.contains("PageNumbers") {
                    self.pageNumbers = dict["PageNumbers"] as! Int32
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("TotalRecords") {
                    self.totalRecords = dict["TotalRecords"] as! Int64
                }
            }
        }
        public var data: DescribeSlowLogStatisticResponseBody.Data.Data?

        public var errorCode: Int32?

        public var isFinish: Bool?

        public var message: String?

        public var requestKey: String?

        public var resultId: String?

        public var state: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.data?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.data != nil {
                map["Data"] = self.data?.toMap()
            }
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.isFinish != nil {
                map["IsFinish"] = self.isFinish!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.requestKey != nil {
                map["RequestKey"] = self.requestKey!
            }
            if self.resultId != nil {
                map["ResultId"] = self.resultId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Data") {
                var model = DescribeSlowLogStatisticResponseBody.Data.Data()
                model.fromMap(dict["Data"] as! [String: Any])
                self.data = model
            }
            if dict.keys.contains("ErrorCode") {
                self.errorCode = dict["ErrorCode"] as! Int32
            }
            if dict.keys.contains("IsFinish") {
                self.isFinish = dict["IsFinish"] as! Bool
            }
            if dict.keys.contains("Message") {
                self.message = dict["Message"] as! String
            }
            if dict.keys.contains("RequestKey") {
                self.requestKey = dict["RequestKey"] as! String
            }
            if dict.keys.contains("ResultId") {
                self.resultId = dict["ResultId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeSlowLogStatisticResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeSlowLogStatisticResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeSlowLogStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSlowLogStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSlowLogStatisticResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSqlLogConfigRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeSqlLogConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var coldEnable: Bool?

        public var coldRetention: Int32?

        public var coldStartTime: Int64?

        public var collectorVersion: String?

        public var hotEnable: Bool?

        public var hotRetention: Int32?

        public var hotStartTime: Int64?

        public var logFilter: String?

        public var requestEnable: Bool?

        public var requestStartTime: Int64?

        public var requestStopTime: Int64?

        public var retention: Int32?

        public var sqlLogEnable: Bool?

        public var sqlLogSource: String?

        public var sqlLogState: String?

        public var sqlLogVisibleTime: Int64?

        public var supportMigration: Bool?

        public var supportVersion: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.coldEnable != nil {
                map["ColdEnable"] = self.coldEnable!
            }
            if self.coldRetention != nil {
                map["ColdRetention"] = self.coldRetention!
            }
            if self.coldStartTime != nil {
                map["ColdStartTime"] = self.coldStartTime!
            }
            if self.collectorVersion != nil {
                map["CollectorVersion"] = self.collectorVersion!
            }
            if self.hotEnable != nil {
                map["HotEnable"] = self.hotEnable!
            }
            if self.hotRetention != nil {
                map["HotRetention"] = self.hotRetention!
            }
            if self.hotStartTime != nil {
                map["HotStartTime"] = self.hotStartTime!
            }
            if self.logFilter != nil {
                map["LogFilter"] = self.logFilter!
            }
            if self.requestEnable != nil {
                map["RequestEnable"] = self.requestEnable!
            }
            if self.requestStartTime != nil {
                map["RequestStartTime"] = self.requestStartTime!
            }
            if self.requestStopTime != nil {
                map["RequestStopTime"] = self.requestStopTime!
            }
            if self.retention != nil {
                map["Retention"] = self.retention!
            }
            if self.sqlLogEnable != nil {
                map["SqlLogEnable"] = self.sqlLogEnable!
            }
            if self.sqlLogSource != nil {
                map["SqlLogSource"] = self.sqlLogSource!
            }
            if self.sqlLogState != nil {
                map["SqlLogState"] = self.sqlLogState!
            }
            if self.sqlLogVisibleTime != nil {
                map["SqlLogVisibleTime"] = self.sqlLogVisibleTime!
            }
            if self.supportMigration != nil {
                map["SupportMigration"] = self.supportMigration!
            }
            if self.supportVersion != nil {
                map["SupportVersion"] = self.supportVersion!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ColdEnable") {
                self.coldEnable = dict["ColdEnable"] as! Bool
            }
            if dict.keys.contains("ColdRetention") {
                self.coldRetention = dict["ColdRetention"] as! Int32
            }
            if dict.keys.contains("ColdStartTime") {
                self.coldStartTime = dict["ColdStartTime"] as! Int64
            }
            if dict.keys.contains("CollectorVersion") {
                self.collectorVersion = dict["CollectorVersion"] as! String
            }
            if dict.keys.contains("HotEnable") {
                self.hotEnable = dict["HotEnable"] as! Bool
            }
            if dict.keys.contains("HotRetention") {
                self.hotRetention = dict["HotRetention"] as! Int32
            }
            if dict.keys.contains("HotStartTime") {
                self.hotStartTime = dict["HotStartTime"] as! Int64
            }
            if dict.keys.contains("LogFilter") {
                self.logFilter = dict["LogFilter"] as! String
            }
            if dict.keys.contains("RequestEnable") {
                self.requestEnable = dict["RequestEnable"] as! Bool
            }
            if dict.keys.contains("RequestStartTime") {
                self.requestStartTime = dict["RequestStartTime"] as! Int64
            }
            if dict.keys.contains("RequestStopTime") {
                self.requestStopTime = dict["RequestStopTime"] as! Int64
            }
            if dict.keys.contains("Retention") {
                self.retention = dict["Retention"] as! Int32
            }
            if dict.keys.contains("SqlLogEnable") {
                self.sqlLogEnable = dict["SqlLogEnable"] as! Bool
            }
            if dict.keys.contains("SqlLogSource") {
                self.sqlLogSource = dict["SqlLogSource"] as! String
            }
            if dict.keys.contains("SqlLogState") {
                self.sqlLogState = dict["SqlLogState"] as! String
            }
            if dict.keys.contains("SqlLogVisibleTime") {
                self.sqlLogVisibleTime = dict["SqlLogVisibleTime"] as! Int64
            }
            if dict.keys.contains("SupportMigration") {
                self.supportMigration = dict["SupportMigration"] as! Bool
            }
            if dict.keys.contains("SupportVersion") {
                self.supportVersion = dict["SupportVersion"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: String?

    public var data: DescribeSqlLogConfigResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeSqlLogConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeSqlLogConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSqlLogConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSqlLogConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSqlLogRecordsRequest : Tea.TeaModel {
    public class Filters : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var endTime: Int64?

    public var filters: [DescribeSqlLogRecordsRequest.Filters]?

    public var instanceId: String?

    public var nodeId: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var role: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filters != nil {
            var tmp : [Any] = []
            for k in self.filters! {
                tmp.append(k.toMap())
            }
            map["Filters"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Filters") {
            var tmp : [DescribeSqlLogRecordsRequest.Filters] = []
            for v in dict["Filters"] as! [Any] {
                var model = DescribeSqlLogRecordsRequest.Filters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filters = tmp
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class DescribeSqlLogRecordsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Items : Tea.TeaModel {
            public class SQLLogRecord : Tea.TeaModel {
                public var accountName: String?

                public var collection: String?

                public var consume: Int64?

                public var cpuTime: Int64?

                public var DBName: String?

                public var executeTime: String?

                public var ext: String?

                public var frows: Int64?

                public var hostAddress: String?

                public var lockTime: Int64?

                public var logicRead: Int64?

                public var nodeId: String?

                public var originTime: Int64?

                public var parallelDegree: String?

                public var parallelQueueTime: String?

                public var physicAsyncRead: Int64?

                public var physicRead: Int64?

                public var physicSyncRead: Int64?

                public var returnRows: Int64?

                public var rows: Int64?

                public var scanRows: Int64?

                public var scnt: Int64?

                public var sqlId: String?

                public var sqlText: String?

                public var sqlType: String?

                public var state: String?

                public var threadId: Int64?

                public var traceId: String?

                public var trxId: String?

                public var updateRows: Int64?

                public var useImciEngine: String?

                public var vip: String?

                public var writes: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accountName != nil {
                        map["AccountName"] = self.accountName!
                    }
                    if self.collection != nil {
                        map["Collection"] = self.collection!
                    }
                    if self.consume != nil {
                        map["Consume"] = self.consume!
                    }
                    if self.cpuTime != nil {
                        map["CpuTime"] = self.cpuTime!
                    }
                    if self.DBName != nil {
                        map["DBName"] = self.DBName!
                    }
                    if self.executeTime != nil {
                        map["ExecuteTime"] = self.executeTime!
                    }
                    if self.ext != nil {
                        map["Ext"] = self.ext!
                    }
                    if self.frows != nil {
                        map["Frows"] = self.frows!
                    }
                    if self.hostAddress != nil {
                        map["HostAddress"] = self.hostAddress!
                    }
                    if self.lockTime != nil {
                        map["LockTime"] = self.lockTime!
                    }
                    if self.logicRead != nil {
                        map["LogicRead"] = self.logicRead!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.originTime != nil {
                        map["OriginTime"] = self.originTime!
                    }
                    if self.parallelDegree != nil {
                        map["ParallelDegree"] = self.parallelDegree!
                    }
                    if self.parallelQueueTime != nil {
                        map["ParallelQueueTime"] = self.parallelQueueTime!
                    }
                    if self.physicAsyncRead != nil {
                        map["PhysicAsyncRead"] = self.physicAsyncRead!
                    }
                    if self.physicRead != nil {
                        map["PhysicRead"] = self.physicRead!
                    }
                    if self.physicSyncRead != nil {
                        map["PhysicSyncRead"] = self.physicSyncRead!
                    }
                    if self.returnRows != nil {
                        map["ReturnRows"] = self.returnRows!
                    }
                    if self.rows != nil {
                        map["Rows"] = self.rows!
                    }
                    if self.scanRows != nil {
                        map["ScanRows"] = self.scanRows!
                    }
                    if self.scnt != nil {
                        map["Scnt"] = self.scnt!
                    }
                    if self.sqlId != nil {
                        map["SqlId"] = self.sqlId!
                    }
                    if self.sqlText != nil {
                        map["SqlText"] = self.sqlText!
                    }
                    if self.sqlType != nil {
                        map["SqlType"] = self.sqlType!
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    if self.threadId != nil {
                        map["ThreadId"] = self.threadId!
                    }
                    if self.traceId != nil {
                        map["TraceId"] = self.traceId!
                    }
                    if self.trxId != nil {
                        map["TrxId"] = self.trxId!
                    }
                    if self.updateRows != nil {
                        map["UpdateRows"] = self.updateRows!
                    }
                    if self.useImciEngine != nil {
                        map["UseImciEngine"] = self.useImciEngine!
                    }
                    if self.vip != nil {
                        map["Vip"] = self.vip!
                    }
                    if self.writes != nil {
                        map["Writes"] = self.writes!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AccountName") {
                        self.accountName = dict["AccountName"] as! String
                    }
                    if dict.keys.contains("Collection") {
                        self.collection = dict["Collection"] as! String
                    }
                    if dict.keys.contains("Consume") {
                        self.consume = dict["Consume"] as! Int64
                    }
                    if dict.keys.contains("CpuTime") {
                        self.cpuTime = dict["CpuTime"] as! Int64
                    }
                    if dict.keys.contains("DBName") {
                        self.DBName = dict["DBName"] as! String
                    }
                    if dict.keys.contains("ExecuteTime") {
                        self.executeTime = dict["ExecuteTime"] as! String
                    }
                    if dict.keys.contains("Ext") {
                        self.ext = dict["Ext"] as! String
                    }
                    if dict.keys.contains("Frows") {
                        self.frows = dict["Frows"] as! Int64
                    }
                    if dict.keys.contains("HostAddress") {
                        self.hostAddress = dict["HostAddress"] as! String
                    }
                    if dict.keys.contains("LockTime") {
                        self.lockTime = dict["LockTime"] as! Int64
                    }
                    if dict.keys.contains("LogicRead") {
                        self.logicRead = dict["LogicRead"] as! Int64
                    }
                    if dict.keys.contains("NodeId") {
                        self.nodeId = dict["NodeId"] as! String
                    }
                    if dict.keys.contains("OriginTime") {
                        self.originTime = dict["OriginTime"] as! Int64
                    }
                    if dict.keys.contains("ParallelDegree") {
                        self.parallelDegree = dict["ParallelDegree"] as! String
                    }
                    if dict.keys.contains("ParallelQueueTime") {
                        self.parallelQueueTime = dict["ParallelQueueTime"] as! String
                    }
                    if dict.keys.contains("PhysicAsyncRead") {
                        self.physicAsyncRead = dict["PhysicAsyncRead"] as! Int64
                    }
                    if dict.keys.contains("PhysicRead") {
                        self.physicRead = dict["PhysicRead"] as! Int64
                    }
                    if dict.keys.contains("PhysicSyncRead") {
                        self.physicSyncRead = dict["PhysicSyncRead"] as! Int64
                    }
                    if dict.keys.contains("ReturnRows") {
                        self.returnRows = dict["ReturnRows"] as! Int64
                    }
                    if dict.keys.contains("Rows") {
                        self.rows = dict["Rows"] as! Int64
                    }
                    if dict.keys.contains("ScanRows") {
                        self.scanRows = dict["ScanRows"] as! Int64
                    }
                    if dict.keys.contains("Scnt") {
                        self.scnt = dict["Scnt"] as! Int64
                    }
                    if dict.keys.contains("SqlId") {
                        self.sqlId = dict["SqlId"] as! String
                    }
                    if dict.keys.contains("SqlText") {
                        self.sqlText = dict["SqlText"] as! String
                    }
                    if dict.keys.contains("SqlType") {
                        self.sqlType = dict["SqlType"] as! String
                    }
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! String
                    }
                    if dict.keys.contains("ThreadId") {
                        self.threadId = dict["ThreadId"] as! Int64
                    }
                    if dict.keys.contains("TraceId") {
                        self.traceId = dict["TraceId"] as! String
                    }
                    if dict.keys.contains("TrxId") {
                        self.trxId = dict["TrxId"] as! String
                    }
                    if dict.keys.contains("UpdateRows") {
                        self.updateRows = dict["UpdateRows"] as! Int64
                    }
                    if dict.keys.contains("UseImciEngine") {
                        self.useImciEngine = dict["UseImciEngine"] as! String
                    }
                    if dict.keys.contains("Vip") {
                        self.vip = dict["Vip"] as! String
                    }
                    if dict.keys.contains("Writes") {
                        self.writes = dict["Writes"] as! Int64
                    }
                }
            }
            public var SQLLogRecord: [DescribeSqlLogRecordsResponseBody.Data.Items.SQLLogRecord]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.SQLLogRecord != nil {
                    var tmp : [Any] = []
                    for k in self.SQLLogRecord! {
                        tmp.append(k.toMap())
                    }
                    map["SQLLogRecord"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SQLLogRecord") {
                    var tmp : [DescribeSqlLogRecordsResponseBody.Data.Items.SQLLogRecord] = []
                    for v in dict["SQLLogRecord"] as! [Any] {
                        var model = DescribeSqlLogRecordsResponseBody.Data.Items.SQLLogRecord()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.SQLLogRecord = tmp
                }
            }
        }
        public var endTime: Int64?

        public var finish: String?

        public var items: DescribeSqlLogRecordsResponseBody.Data.Items?

        public var jobId: String?

        public var startTime: Int64?

        public var totalRecords: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.items?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.finish != nil {
                map["Finish"] = self.finish!
            }
            if self.items != nil {
                map["Items"] = self.items?.toMap()
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.totalRecords != nil {
                map["TotalRecords"] = self.totalRecords!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("Finish") {
                self.finish = dict["Finish"] as! String
            }
            if dict.keys.contains("Items") {
                var model = DescribeSqlLogRecordsResponseBody.Data.Items()
                model.fromMap(dict["Items"] as! [String: Any])
                self.items = model
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("TotalRecords") {
                self.totalRecords = dict["TotalRecords"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeSqlLogRecordsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeSqlLogRecordsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeSqlLogRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSqlLogRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSqlLogRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSqlLogStatisticRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DescribeSqlLogStatisticResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var coldSqlSize: Int64?

        public var freeColdSqlSize: Int64?

        public var freeHotSqlSize: Int64?

        public var hotSqlSize: Int64?

        public var importSqlSize: Int64?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.coldSqlSize != nil {
                map["ColdSqlSize"] = self.coldSqlSize!
            }
            if self.freeColdSqlSize != nil {
                map["FreeColdSqlSize"] = self.freeColdSqlSize!
            }
            if self.freeHotSqlSize != nil {
                map["FreeHotSqlSize"] = self.freeHotSqlSize!
            }
            if self.hotSqlSize != nil {
                map["HotSqlSize"] = self.hotSqlSize!
            }
            if self.importSqlSize != nil {
                map["ImportSqlSize"] = self.importSqlSize!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ColdSqlSize") {
                self.coldSqlSize = dict["ColdSqlSize"] as! Int64
            }
            if dict.keys.contains("FreeColdSqlSize") {
                self.freeColdSqlSize = dict["FreeColdSqlSize"] as! Int64
            }
            if dict.keys.contains("FreeHotSqlSize") {
                self.freeHotSqlSize = dict["FreeHotSqlSize"] as! Int64
            }
            if dict.keys.contains("HotSqlSize") {
                self.hotSqlSize = dict["HotSqlSize"] as! Int64
            }
            if dict.keys.contains("ImportSqlSize") {
                self.importSqlSize = dict["ImportSqlSize"] as! Int64
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeSqlLogStatisticResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeSqlLogStatisticResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeSqlLogStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSqlLogStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSqlLogStatisticResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSqlLogTaskRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribeSqlLogTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Filters : Tea.TeaModel {
            public var key: String?

            public var value: Any?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! Any
                }
            }
        }
        public class Queries : Tea.TeaModel {
            public var accountName: String?

            public var collection: String?

            public var consume: Int64?

            public var cpuTime: Int64?

            public var DBName: String?

            public var executeTime: String?

            public var ext: String?

            public var frows: Int64?

            public var hostAddress: String?

            public var lockTime: Int64?

            public var logicRead: Int64?

            public var nodeId: String?

            public var originTime: Int64?

            public var parallelDegree: String?

            public var parallelQueueTime: String?

            public var physicAsyncRead: Int64?

            public var physicRead: Int64?

            public var physicSyncRead: Int64?

            public var returnRows: Int64?

            public var rows: Int64?

            public var scanRows: Int64?

            public var scnt: Int64?

            public var sqlId: String?

            public var sqlText: String?

            public var sqlType: String?

            public var state: String?

            public var threadId: Int64?

            public var traceId: String?

            public var trxId: String?

            public var updateRows: Int64?

            public var useImciEngine: String?

            public var vip: String?

            public var writes: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountName != nil {
                    map["AccountName"] = self.accountName!
                }
                if self.collection != nil {
                    map["Collection"] = self.collection!
                }
                if self.consume != nil {
                    map["Consume"] = self.consume!
                }
                if self.cpuTime != nil {
                    map["CpuTime"] = self.cpuTime!
                }
                if self.DBName != nil {
                    map["DBName"] = self.DBName!
                }
                if self.executeTime != nil {
                    map["ExecuteTime"] = self.executeTime!
                }
                if self.ext != nil {
                    map["Ext"] = self.ext!
                }
                if self.frows != nil {
                    map["Frows"] = self.frows!
                }
                if self.hostAddress != nil {
                    map["HostAddress"] = self.hostAddress!
                }
                if self.lockTime != nil {
                    map["LockTime"] = self.lockTime!
                }
                if self.logicRead != nil {
                    map["LogicRead"] = self.logicRead!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.originTime != nil {
                    map["OriginTime"] = self.originTime!
                }
                if self.parallelDegree != nil {
                    map["ParallelDegree"] = self.parallelDegree!
                }
                if self.parallelQueueTime != nil {
                    map["ParallelQueueTime"] = self.parallelQueueTime!
                }
                if self.physicAsyncRead != nil {
                    map["PhysicAsyncRead"] = self.physicAsyncRead!
                }
                if self.physicRead != nil {
                    map["PhysicRead"] = self.physicRead!
                }
                if self.physicSyncRead != nil {
                    map["PhysicSyncRead"] = self.physicSyncRead!
                }
                if self.returnRows != nil {
                    map["ReturnRows"] = self.returnRows!
                }
                if self.rows != nil {
                    map["Rows"] = self.rows!
                }
                if self.scanRows != nil {
                    map["ScanRows"] = self.scanRows!
                }
                if self.scnt != nil {
                    map["Scnt"] = self.scnt!
                }
                if self.sqlId != nil {
                    map["SqlId"] = self.sqlId!
                }
                if self.sqlText != nil {
                    map["SqlText"] = self.sqlText!
                }
                if self.sqlType != nil {
                    map["SqlType"] = self.sqlType!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.threadId != nil {
                    map["ThreadId"] = self.threadId!
                }
                if self.traceId != nil {
                    map["TraceId"] = self.traceId!
                }
                if self.trxId != nil {
                    map["TrxId"] = self.trxId!
                }
                if self.updateRows != nil {
                    map["UpdateRows"] = self.updateRows!
                }
                if self.useImciEngine != nil {
                    map["UseImciEngine"] = self.useImciEngine!
                }
                if self.vip != nil {
                    map["Vip"] = self.vip!
                }
                if self.writes != nil {
                    map["Writes"] = self.writes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccountName") {
                    self.accountName = dict["AccountName"] as! String
                }
                if dict.keys.contains("Collection") {
                    self.collection = dict["Collection"] as! String
                }
                if dict.keys.contains("Consume") {
                    self.consume = dict["Consume"] as! Int64
                }
                if dict.keys.contains("CpuTime") {
                    self.cpuTime = dict["CpuTime"] as! Int64
                }
                if dict.keys.contains("DBName") {
                    self.DBName = dict["DBName"] as! String
                }
                if dict.keys.contains("ExecuteTime") {
                    self.executeTime = dict["ExecuteTime"] as! String
                }
                if dict.keys.contains("Ext") {
                    self.ext = dict["Ext"] as! String
                }
                if dict.keys.contains("Frows") {
                    self.frows = dict["Frows"] as! Int64
                }
                if dict.keys.contains("HostAddress") {
                    self.hostAddress = dict["HostAddress"] as! String
                }
                if dict.keys.contains("LockTime") {
                    self.lockTime = dict["LockTime"] as! Int64
                }
                if dict.keys.contains("LogicRead") {
                    self.logicRead = dict["LogicRead"] as! Int64
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! String
                }
                if dict.keys.contains("OriginTime") {
                    self.originTime = dict["OriginTime"] as! Int64
                }
                if dict.keys.contains("ParallelDegree") {
                    self.parallelDegree = dict["ParallelDegree"] as! String
                }
                if dict.keys.contains("ParallelQueueTime") {
                    self.parallelQueueTime = dict["ParallelQueueTime"] as! String
                }
                if dict.keys.contains("PhysicAsyncRead") {
                    self.physicAsyncRead = dict["PhysicAsyncRead"] as! Int64
                }
                if dict.keys.contains("PhysicRead") {
                    self.physicRead = dict["PhysicRead"] as! Int64
                }
                if dict.keys.contains("PhysicSyncRead") {
                    self.physicSyncRead = dict["PhysicSyncRead"] as! Int64
                }
                if dict.keys.contains("ReturnRows") {
                    self.returnRows = dict["ReturnRows"] as! Int64
                }
                if dict.keys.contains("Rows") {
                    self.rows = dict["Rows"] as! Int64
                }
                if dict.keys.contains("ScanRows") {
                    self.scanRows = dict["ScanRows"] as! Int64
                }
                if dict.keys.contains("Scnt") {
                    self.scnt = dict["Scnt"] as! Int64
                }
                if dict.keys.contains("SqlId") {
                    self.sqlId = dict["SqlId"] as! String
                }
                if dict.keys.contains("SqlText") {
                    self.sqlText = dict["SqlText"] as! String
                }
                if dict.keys.contains("SqlType") {
                    self.sqlType = dict["SqlType"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("ThreadId") {
                    self.threadId = dict["ThreadId"] as! Int64
                }
                if dict.keys.contains("TraceId") {
                    self.traceId = dict["TraceId"] as! String
                }
                if dict.keys.contains("TrxId") {
                    self.trxId = dict["TrxId"] as! String
                }
                if dict.keys.contains("UpdateRows") {
                    self.updateRows = dict["UpdateRows"] as! Int64
                }
                if dict.keys.contains("UseImciEngine") {
                    self.useImciEngine = dict["UseImciEngine"] as! String
                }
                if dict.keys.contains("Vip") {
                    self.vip = dict["Vip"] as! String
                }
                if dict.keys.contains("Writes") {
                    self.writes = dict["Writes"] as! Int64
                }
            }
        }
        public var createTime: Int64?

        public var end: Int64?

        public var expire: Bool?

        public var export: String?

        public var filters: [DescribeSqlLogTaskResponseBody.Data.Filters]?

        public var name: String?

        public var queries: [DescribeSqlLogTaskResponseBody.Data.Queries]?

        public var start: Int64?

        public var status: String?

        public var taskId: String?

        public var taskType: String?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.end != nil {
                map["End"] = self.end!
            }
            if self.expire != nil {
                map["Expire"] = self.expire!
            }
            if self.export != nil {
                map["Export"] = self.export!
            }
            if self.filters != nil {
                var tmp : [Any] = []
                for k in self.filters! {
                    tmp.append(k.toMap())
                }
                map["Filters"] = tmp
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.queries != nil {
                var tmp : [Any] = []
                for k in self.queries! {
                    tmp.append(k.toMap())
                }
                map["Queries"] = tmp
            }
            if self.start != nil {
                map["Start"] = self.start!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskType != nil {
                map["TaskType"] = self.taskType!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("End") {
                self.end = dict["End"] as! Int64
            }
            if dict.keys.contains("Expire") {
                self.expire = dict["Expire"] as! Bool
            }
            if dict.keys.contains("Export") {
                self.export = dict["Export"] as! String
            }
            if dict.keys.contains("Filters") {
                var tmp : [DescribeSqlLogTaskResponseBody.Data.Filters] = []
                for v in dict["Filters"] as! [Any] {
                    var model = DescribeSqlLogTaskResponseBody.Data.Filters()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.filters = tmp
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Queries") {
                var tmp : [DescribeSqlLogTaskResponseBody.Data.Queries] = []
                for v in dict["Queries"] as! [Any] {
                    var model = DescribeSqlLogTaskResponseBody.Data.Queries()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.queries = tmp
            }
            if dict.keys.contains("Start") {
                self.start = dict["Start"] as! Int64
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskType") {
                self.taskType = dict["TaskType"] as! String
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeSqlLogTaskResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeSqlLogTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeSqlLogTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSqlLogTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSqlLogTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSqlLogTasksRequest : Tea.TeaModel {
    public class Filters : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var endTime: Int64?

    public var filters: [DescribeSqlLogTasksRequest.Filters]?

    public var instanceId: String?

    public var nodeId: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filters != nil {
            var tmp : [Any] = []
            for k in self.filters! {
                tmp.append(k.toMap())
            }
            map["Filters"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Filters") {
            var tmp : [DescribeSqlLogTasksRequest.Filters] = []
            for v in dict["Filters"] as! [Any] {
                var model = DescribeSqlLogTasksRequest.Filters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filters = tmp
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class DescribeSqlLogTasksResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class Filters : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var analysisTaskFinishTime: Int64?

            public var analysisTaskStatus: String?

            public var createTime: Int64?

            public var end: Int64?

            public var expire: Bool?

            public var filters: [DescribeSqlLogTasksResponseBody.Data.List.Filters]?

            public var instanceId: String?

            public var logCount: Int64?

            public var name: String?

            public var progress: Int32?

            public var result: String?

            public var scanFileSize: Int64?

            public var start: Int64?

            public var status: String?

            public var taskId: String?

            public var taskType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.analysisTaskFinishTime != nil {
                    map["AnalysisTaskFinishTime"] = self.analysisTaskFinishTime!
                }
                if self.analysisTaskStatus != nil {
                    map["AnalysisTaskStatus"] = self.analysisTaskStatus!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.end != nil {
                    map["End"] = self.end!
                }
                if self.expire != nil {
                    map["Expire"] = self.expire!
                }
                if self.filters != nil {
                    var tmp : [Any] = []
                    for k in self.filters! {
                        tmp.append(k.toMap())
                    }
                    map["Filters"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.logCount != nil {
                    map["LogCount"] = self.logCount!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.result != nil {
                    map["Result"] = self.result!
                }
                if self.scanFileSize != nil {
                    map["ScanFileSize"] = self.scanFileSize!
                }
                if self.start != nil {
                    map["Start"] = self.start!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AnalysisTaskFinishTime") {
                    self.analysisTaskFinishTime = dict["AnalysisTaskFinishTime"] as! Int64
                }
                if dict.keys.contains("AnalysisTaskStatus") {
                    self.analysisTaskStatus = dict["AnalysisTaskStatus"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("End") {
                    self.end = dict["End"] as! Int64
                }
                if dict.keys.contains("Expire") {
                    self.expire = dict["Expire"] as! Bool
                }
                if dict.keys.contains("Filters") {
                    var tmp : [DescribeSqlLogTasksResponseBody.Data.List.Filters] = []
                    for v in dict["Filters"] as! [Any] {
                        var model = DescribeSqlLogTasksResponseBody.Data.List.Filters()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.filters = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("LogCount") {
                    self.logCount = dict["LogCount"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! Int32
                }
                if dict.keys.contains("Result") {
                    self.result = dict["Result"] as! String
                }
                if dict.keys.contains("ScanFileSize") {
                    self.scanFileSize = dict["ScanFileSize"] as! Int64
                }
                if dict.keys.contains("Start") {
                    self.start = dict["Start"] as! Int64
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("TaskType") {
                    self.taskType = dict["TaskType"] as! String
                }
            }
        }
        public var list: [DescribeSqlLogTasksResponseBody.Data.List]?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [DescribeSqlLogTasksResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = DescribeSqlLogTasksResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: DescribeSqlLogTasksResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeSqlLogTasksResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeSqlLogTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSqlLogTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSqlLogTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTopBigKeysRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var endTime: String?

    public var instanceId: String?

    public var nodeId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsoleContext") {
            self.consoleContext = dict["ConsoleContext"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeTopBigKeysResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class BigKey : Tea.TeaModel {
            public var db: Int32?

            public var key: String?

            public var keyType: String?

            public var nodeId: String?

            public var size: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.db != nil {
                    map["Db"] = self.db!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.keyType != nil {
                    map["KeyType"] = self.keyType!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Db") {
                    self.db = dict["Db"] as! Int32
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("KeyType") {
                    self.keyType = dict["KeyType"] as! String
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! String
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int64
                }
            }
        }
        public var bigKey: [DescribeTopBigKeysResponseBody.Data.BigKey]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bigKey != nil {
                var tmp : [Any] = []
                for k in self.bigKey! {
                    tmp.append(k.toMap())
                }
                map["BigKey"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BigKey") {
                var tmp : [DescribeTopBigKeysResponseBody.Data.BigKey] = []
                for v in dict["BigKey"] as! [Any] {
                    var model = DescribeTopBigKeysResponseBody.Data.BigKey()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.bigKey = tmp
            }
        }
    }
    public var code: String?

    public var data: DescribeTopBigKeysResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeTopBigKeysResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeTopBigKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTopBigKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTopBigKeysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTopHotKeysRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var endTime: String?

    public var instanceId: String?

    public var nodeId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsoleContext") {
            self.consoleContext = dict["ConsoleContext"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeTopHotKeysResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class HotKey : Tea.TeaModel {
            public var db: Int32?

            public var hot: String?

            public var key: String?

            public var keyType: String?

            public var lfu: Int32?

            public var nodeId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.db != nil {
                    map["Db"] = self.db!
                }
                if self.hot != nil {
                    map["Hot"] = self.hot!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.keyType != nil {
                    map["KeyType"] = self.keyType!
                }
                if self.lfu != nil {
                    map["Lfu"] = self.lfu!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Db") {
                    self.db = dict["Db"] as! Int32
                }
                if dict.keys.contains("Hot") {
                    self.hot = dict["Hot"] as! String
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("KeyType") {
                    self.keyType = dict["KeyType"] as! String
                }
                if dict.keys.contains("Lfu") {
                    self.lfu = dict["Lfu"] as! Int32
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! String
                }
            }
        }
        public var hotKey: [DescribeTopHotKeysResponseBody.Data.HotKey]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hotKey != nil {
                var tmp : [Any] = []
                for k in self.hotKey! {
                    tmp.append(k.toMap())
                }
                map["HotKey"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HotKey") {
                var tmp : [DescribeTopHotKeysResponseBody.Data.HotKey] = []
                for v in dict["HotKey"] as! [Any] {
                    var model = DescribeTopHotKeysResponseBody.Data.HotKey()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.hotKey = tmp
            }
        }
    }
    public var code: String?

    public var data: DescribeTopHotKeysResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = DescribeTopHotKeysResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeTopHotKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTopHotKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTopHotKeysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableAllSqlConcurrencyControlRulesRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsoleContext") {
            self.consoleContext = dict["ConsoleContext"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DisableAllSqlConcurrencyControlRulesResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DisableAllSqlConcurrencyControlRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableAllSqlConcurrencyControlRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableAllSqlConcurrencyControlRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableAutoResourceOptimizeRulesRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsoleContext") {
            self.consoleContext = dict["ConsoleContext"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
    }
}

public class DisableAutoResourceOptimizeRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ConfigFailInstanceList : Tea.TeaModel {
            public var configSuccess: Bool?

            public var errorMessage: String?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configSuccess != nil {
                    map["ConfigSuccess"] = self.configSuccess!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigSuccess") {
                    self.configSuccess = dict["ConfigSuccess"] as! Bool
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public class ConfigSuccessInstanceList : Tea.TeaModel {
            public var configSuccess: Bool?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configSuccess != nil {
                    map["ConfigSuccess"] = self.configSuccess!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigSuccess") {
                    self.configSuccess = dict["ConfigSuccess"] as! Bool
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public var configFailInstanceCount: Int64?

        public var configFailInstanceList: [DisableAutoResourceOptimizeRulesResponseBody.Data.ConfigFailInstanceList]?

        public var configSuccessInstanceCount: Int64?

        public var configSuccessInstanceList: [DisableAutoResourceOptimizeRulesResponseBody.Data.ConfigSuccessInstanceList]?

        public var totalInstanceCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configFailInstanceCount != nil {
                map["ConfigFailInstanceCount"] = self.configFailInstanceCount!
            }
            if self.configFailInstanceList != nil {
                var tmp : [Any] = []
                for k in self.configFailInstanceList! {
                    tmp.append(k.toMap())
                }
                map["ConfigFailInstanceList"] = tmp
            }
            if self.configSuccessInstanceCount != nil {
                map["ConfigSuccessInstanceCount"] = self.configSuccessInstanceCount!
            }
            if self.configSuccessInstanceList != nil {
                var tmp : [Any] = []
                for k in self.configSuccessInstanceList! {
                    tmp.append(k.toMap())
                }
                map["ConfigSuccessInstanceList"] = tmp
            }
            if self.totalInstanceCount != nil {
                map["TotalInstanceCount"] = self.totalInstanceCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigFailInstanceCount") {
                self.configFailInstanceCount = dict["ConfigFailInstanceCount"] as! Int64
            }
            if dict.keys.contains("ConfigFailInstanceList") {
                var tmp : [DisableAutoResourceOptimizeRulesResponseBody.Data.ConfigFailInstanceList] = []
                for v in dict["ConfigFailInstanceList"] as! [Any] {
                    var model = DisableAutoResourceOptimizeRulesResponseBody.Data.ConfigFailInstanceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configFailInstanceList = tmp
            }
            if dict.keys.contains("ConfigSuccessInstanceCount") {
                self.configSuccessInstanceCount = dict["ConfigSuccessInstanceCount"] as! Int64
            }
            if dict.keys.contains("ConfigSuccessInstanceList") {
                var tmp : [DisableAutoResourceOptimizeRulesResponseBody.Data.ConfigSuccessInstanceList] = []
                for v in dict["ConfigSuccessInstanceList"] as! [Any] {
                    var model = DisableAutoResourceOptimizeRulesResponseBody.Data.ConfigSuccessInstanceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configSuccessInstanceList = tmp
            }
            if dict.keys.contains("TotalInstanceCount") {
                self.totalInstanceCount = dict["TotalInstanceCount"] as! Int64
            }
        }
    }
    public var code: Int64?

    public var data: DisableAutoResourceOptimizeRulesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = DisableAutoResourceOptimizeRulesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DisableAutoResourceOptimizeRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableAutoResourceOptimizeRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableAutoResourceOptimizeRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableAutoThrottleRulesRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsoleContext") {
            self.consoleContext = dict["ConsoleContext"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
    }
}

public class DisableAutoThrottleRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ConfigFailInstanceList : Tea.TeaModel {
            public var configSuccess: Bool?

            public var errorMessage: String?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configSuccess != nil {
                    map["ConfigSuccess"] = self.configSuccess!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigSuccess") {
                    self.configSuccess = dict["ConfigSuccess"] as! Bool
                }
                if dict.keys.contains("ErrorMessage") {
                    self.errorMessage = dict["ErrorMessage"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public class ConfigSuccessInstanceList : Tea.TeaModel {
            public var configSuccess: Bool?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configSuccess != nil {
                    map["ConfigSuccess"] = self.configSuccess!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigSuccess") {
                    self.configSuccess = dict["ConfigSuccess"] as! Bool
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public var configFailInstanceCount: Int64?

        public var configFailInstanceList: [DisableAutoThrottleRulesResponseBody.Data.ConfigFailInstanceList]?

        public var configSuccessInstanceCount: Int64?

        public var configSuccessInstanceList: [DisableAutoThrottleRulesResponseBody.Data.ConfigSuccessInstanceList]?

        public var totalInstanceCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configFailInstanceCount != nil {
                map["ConfigFailInstanceCount"] = self.configFailInstanceCount!
            }
            if self.configFailInstanceList != nil {
                var tmp : [Any] = []
                for k in self.configFailInstanceList! {
                    tmp.append(k.toMap())
                }
                map["ConfigFailInstanceList"] = tmp
            }
            if self.configSuccessInstanceCount != nil {
                map["ConfigSuccessInstanceCount"] = self.configSuccessInstanceCount!
            }
            if self.configSuccessInstanceList != nil {
                var tmp : [Any] = []
                for k in self.configSuccessInstanceList! {
                    tmp.append(k.toMap())
                }
                map["ConfigSuccessInstanceList"] = tmp
            }
            if self.totalInstanceCount != nil {
                map["TotalInstanceCount"] = self.totalInstanceCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigFailInstanceCount") {
                self.configFailInstanceCount = dict["ConfigFailInstanceCount"] as! Int64
            }
            if dict.keys.contains("ConfigFailInstanceList") {
                var tmp : [DisableAutoThrottleRulesResponseBody.Data.ConfigFailInstanceList] = []
                for v in dict["ConfigFailInstanceList"] as! [Any] {
                    var model = DisableAutoThrottleRulesResponseBody.Data.ConfigFailInstanceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configFailInstanceList = tmp
            }
            if dict.keys.contains("ConfigSuccessInstanceCount") {
                self.configSuccessInstanceCount = dict["ConfigSuccessInstanceCount"] as! Int64
            }
            if dict.keys.contains("ConfigSuccessInstanceList") {
                var tmp : [DisableAutoThrottleRulesResponseBody.Data.ConfigSuccessInstanceList] = []
                for v in dict["ConfigSuccessInstanceList"] as! [Any] {
                    var model = DisableAutoThrottleRulesResponseBody.Data.ConfigSuccessInstanceList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configSuccessInstanceList = tmp
            }
            if dict.keys.contains("TotalInstanceCount") {
                self.totalInstanceCount = dict["TotalInstanceCount"] as! Int64
            }
        }
    }
    public var code: Int64?

    public var data: DisableAutoThrottleRulesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = DisableAutoThrottleRulesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class DisableAutoThrottleRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableAutoThrottleRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableAutoThrottleRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableDasProRequest : Tea.TeaModel {
    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class DisableDasProResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var synchro: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchro != nil {
            map["Synchro"] = self.synchro!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Synchro") {
            self.synchro = dict["Synchro"] as! String
        }
    }
}

public class DisableDasProResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableDasProResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableDasProResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableInstanceDasConfigRequest : Tea.TeaModel {
    public var engine: String?

    public var instanceId: String?

    public var scaleType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scaleType != nil {
            map["ScaleType"] = self.scaleType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Engine") {
            self.engine = dict["Engine"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ScaleType") {
            self.scaleType = dict["ScaleType"] as! String
        }
    }
}

public class DisableInstanceDasConfigResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DisableInstanceDasConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableInstanceDasConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableInstanceDasConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableSqlConcurrencyControlRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceId: String?

    public var itemId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.itemId != nil {
            map["ItemId"] = self.itemId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsoleContext") {
            self.consoleContext = dict["ConsoleContext"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ItemId") {
            self.itemId = dict["ItemId"] as! Int64
        }
    }
}

public class DisableSqlConcurrencyControlResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class DisableSqlConcurrencyControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableSqlConcurrencyControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableSqlConcurrencyControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableDasProRequest : Tea.TeaModel {
    public var instanceId: String?

    public var sqlRetention: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sqlRetention != nil {
            map["SqlRetention"] = self.sqlRetention!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SqlRetention") {
            self.sqlRetention = dict["SqlRetention"] as! Int32
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class EnableDasProResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var synchro: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchro != nil {
            map["Synchro"] = self.synchro!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Synchro") {
            self.synchro = dict["Synchro"] as! String
        }
    }
}

public class EnableDasProResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableDasProResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableDasProResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableSqlConcurrencyControlRequest : Tea.TeaModel {
    public var concurrencyControlTime: Int64?

    public var consoleContext: String?

    public var instanceId: String?

    public var maxConcurrency: Int64?

    public var sqlKeywords: String?

    public var sqlType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.concurrencyControlTime != nil {
            map["ConcurrencyControlTime"] = self.concurrencyControlTime!
        }
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxConcurrency != nil {
            map["MaxConcurrency"] = self.maxConcurrency!
        }
        if self.sqlKeywords != nil {
            map["SqlKeywords"] = self.sqlKeywords!
        }
        if self.sqlType != nil {
            map["SqlType"] = self.sqlType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConcurrencyControlTime") {
            self.concurrencyControlTime = dict["ConcurrencyControlTime"] as! Int64
        }
        if dict.keys.contains("ConsoleContext") {
            self.consoleContext = dict["ConsoleContext"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MaxConcurrency") {
            self.maxConcurrency = dict["MaxConcurrency"] as! Int64
        }
        if dict.keys.contains("SqlKeywords") {
            self.sqlKeywords = dict["SqlKeywords"] as! String
        }
        if dict.keys.contains("SqlType") {
            self.sqlType = dict["SqlType"] as! String
        }
    }
}

public class EnableSqlConcurrencyControlResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class EnableSqlConcurrencyControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableSqlConcurrencyControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableSqlConcurrencyControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAsyncErrorRequestListByCodeRequest : Tea.TeaModel {
    public var end: Int64?

    public var errorCode: String?

    public var instanceId: String?

    public var nodeId: String?

    public var start: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.errorCode != nil {
            map["ErrorCode"] = self.errorCode!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("End") {
            self.end = dict["End"] as! Int64
        }
        if dict.keys.contains("ErrorCode") {
            self.errorCode = dict["ErrorCode"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("Start") {
            self.start = dict["Start"] as! Int64
        }
    }
}

public class GetAsyncErrorRequestListByCodeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var instanceId: String?

            public var sqlId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["instanceId"] = self.instanceId!
                }
                if self.sqlId != nil {
                    map["sqlId"] = self.sqlId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("instanceId") {
                    self.instanceId = dict["instanceId"] as! String
                }
                if dict.keys.contains("sqlId") {
                    self.sqlId = dict["sqlId"] as! String
                }
            }
        }
        public var complete: Bool?

        public var fail: Bool?

        public var isFinish: Bool?

        public var result: [GetAsyncErrorRequestListByCodeResponseBody.Data.Result]?

        public var resultId: String?

        public var state: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complete != nil {
                map["complete"] = self.complete!
            }
            if self.fail != nil {
                map["fail"] = self.fail!
            }
            if self.isFinish != nil {
                map["isFinish"] = self.isFinish!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["result"] = tmp
            }
            if self.resultId != nil {
                map["resultId"] = self.resultId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.timestamp != nil {
                map["timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("complete") {
                self.complete = dict["complete"] as! Bool
            }
            if dict.keys.contains("fail") {
                self.fail = dict["fail"] as! Bool
            }
            if dict.keys.contains("isFinish") {
                self.isFinish = dict["isFinish"] as! Bool
            }
            if dict.keys.contains("result") {
                var tmp : [GetAsyncErrorRequestListByCodeResponseBody.Data.Result] = []
                for v in dict["result"] as! [Any] {
                    var model = GetAsyncErrorRequestListByCodeResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("resultId") {
                self.resultId = dict["resultId"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
            if dict.keys.contains("timestamp") {
                self.timestamp = dict["timestamp"] as! Int64
            }
        }
    }
    public var code: Int64?

    public var data: GetAsyncErrorRequestListByCodeResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = GetAsyncErrorRequestListByCodeResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAsyncErrorRequestListByCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAsyncErrorRequestListByCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAsyncErrorRequestListByCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAsyncErrorRequestStatByCodeRequest : Tea.TeaModel {
    public var dbName: String?

    public var end: Int64?

    public var instanceId: String?

    public var nodeId: String?

    public var start: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("End") {
            self.end = dict["End"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("Start") {
            self.start = dict["Start"] as! Int64
        }
    }
}

public class GetAsyncErrorRequestStatByCodeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var count: Int32?

            public var errorCode: String?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["count"] = self.count!
                }
                if self.errorCode != nil {
                    map["errorCode"] = self.errorCode!
                }
                if self.instanceId != nil {
                    map["instanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("count") {
                    self.count = dict["count"] as! Int32
                }
                if dict.keys.contains("errorCode") {
                    self.errorCode = dict["errorCode"] as! String
                }
                if dict.keys.contains("instanceId") {
                    self.instanceId = dict["instanceId"] as! String
                }
            }
        }
        public var complete: Bool?

        public var fail: Bool?

        public var isFinish: Bool?

        public var result: [GetAsyncErrorRequestStatByCodeResponseBody.Data.Result]?

        public var resultId: String?

        public var state: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complete != nil {
                map["complete"] = self.complete!
            }
            if self.fail != nil {
                map["fail"] = self.fail!
            }
            if self.isFinish != nil {
                map["isFinish"] = self.isFinish!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["result"] = tmp
            }
            if self.resultId != nil {
                map["resultId"] = self.resultId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.timestamp != nil {
                map["timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("complete") {
                self.complete = dict["complete"] as! Bool
            }
            if dict.keys.contains("fail") {
                self.fail = dict["fail"] as! Bool
            }
            if dict.keys.contains("isFinish") {
                self.isFinish = dict["isFinish"] as! Bool
            }
            if dict.keys.contains("result") {
                var tmp : [GetAsyncErrorRequestStatByCodeResponseBody.Data.Result] = []
                for v in dict["result"] as! [Any] {
                    var model = GetAsyncErrorRequestStatByCodeResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("resultId") {
                self.resultId = dict["resultId"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
            if dict.keys.contains("timestamp") {
                self.timestamp = dict["timestamp"] as! Int64
            }
        }
    }
    public var code: Int64?

    public var data: GetAsyncErrorRequestStatByCodeResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = GetAsyncErrorRequestStatByCodeResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAsyncErrorRequestStatByCodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAsyncErrorRequestStatByCodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAsyncErrorRequestStatByCodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAsyncErrorRequestStatResultRequest : Tea.TeaModel {
    public var dbName: String?

    public var end: Int64?

    public var instanceId: String?

    public var nodeId: String?

    public var sqlIdList: String?

    public var start: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.sqlIdList != nil {
            map["SqlIdList"] = self.sqlIdList!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("End") {
            self.end = dict["End"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("SqlIdList") {
            self.sqlIdList = dict["SqlIdList"] as! String
        }
        if dict.keys.contains("Start") {
            self.start = dict["Start"] as! Int64
        }
    }
}

public class GetAsyncErrorRequestStatResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var complete: Bool?

        public var fail: Bool?

        public var isFinish: Bool?

        public var result: [String: DataResultValue]?

        public var resultId: String?

        public var state: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complete != nil {
                map["complete"] = self.complete!
            }
            if self.fail != nil {
                map["fail"] = self.fail!
            }
            if self.isFinish != nil {
                map["isFinish"] = self.isFinish!
            }
            if self.result != nil {
                var tmp : [String: Any] = [:]
                for (k, v) in self.result! {
                    tmp[k] = v.toMap()
                }
                map["result"] = tmp
            }
            if self.resultId != nil {
                map["resultId"] = self.resultId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.timestamp != nil {
                map["timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("complete") {
                self.complete = dict["complete"] as! Bool
            }
            if dict.keys.contains("fail") {
                self.fail = dict["fail"] as! Bool
            }
            if dict.keys.contains("isFinish") {
                self.isFinish = dict["isFinish"] as! Bool
            }
            if dict.keys.contains("result") {
                var tmp : [String: DataResultValue] = [:]
                for (k, v) in dict["result"] as! [String: Any] {
                    if v != nil {
                        var model = DataResultValue()
                        model.fromMap(v as! [String: Any])
                        tmp[k] = model
                    }
                }
                self.result = tmp
            }
            if dict.keys.contains("resultId") {
                self.resultId = dict["resultId"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
            if dict.keys.contains("timestamp") {
                self.timestamp = dict["timestamp"] as! Int64
            }
        }
    }
    public var code: Int64?

    public var data: GetAsyncErrorRequestStatResultResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = GetAsyncErrorRequestStatResultResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAsyncErrorRequestStatResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAsyncErrorRequestStatResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAsyncErrorRequestStatResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAutoIncrementUsageStatisticRequest : Tea.TeaModel {
    public var dbNames: String?

    public var instanceId: String?

    public var ratioFilter: Double?

    public var realTime: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbNames != nil {
            map["DbNames"] = self.dbNames!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ratioFilter != nil {
            map["RatioFilter"] = self.ratioFilter!
        }
        if self.realTime != nil {
            map["RealTime"] = self.realTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbNames") {
            self.dbNames = dict["DbNames"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RatioFilter") {
            self.ratioFilter = dict["RatioFilter"] as! Double
        }
        if dict.keys.contains("RealTime") {
            self.realTime = dict["RealTime"] as! Bool
        }
    }
}

public class GetAutoIncrementUsageStatisticResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AutoIncrementUsageList : Tea.TeaModel {
            public var autoIncrementCurrentValue: Int64?

            public var autoIncrementRatio: Double?

            public var columnName: String?

            public var dbName: String?

            public var maximumValue: Int64?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoIncrementCurrentValue != nil {
                    map["AutoIncrementCurrentValue"] = self.autoIncrementCurrentValue!
                }
                if self.autoIncrementRatio != nil {
                    map["AutoIncrementRatio"] = self.autoIncrementRatio!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.dbName != nil {
                    map["DbName"] = self.dbName!
                }
                if self.maximumValue != nil {
                    map["MaximumValue"] = self.maximumValue!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoIncrementCurrentValue") {
                    self.autoIncrementCurrentValue = dict["AutoIncrementCurrentValue"] as! Int64
                }
                if dict.keys.contains("AutoIncrementRatio") {
                    self.autoIncrementRatio = dict["AutoIncrementRatio"] as! Double
                }
                if dict.keys.contains("ColumnName") {
                    self.columnName = dict["ColumnName"] as! String
                }
                if dict.keys.contains("DbName") {
                    self.dbName = dict["DbName"] as! String
                }
                if dict.keys.contains("MaximumValue") {
                    self.maximumValue = dict["MaximumValue"] as! Int64
                }
                if dict.keys.contains("TableName") {
                    self.tableName = dict["TableName"] as! String
                }
            }
        }
        public var autoIncrementUsageList: [GetAutoIncrementUsageStatisticResponseBody.Data.AutoIncrementUsageList]?

        public var errorInfo: String?

        public var finish: Bool?

        public var taskStatus: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoIncrementUsageList != nil {
                var tmp : [Any] = []
                for k in self.autoIncrementUsageList! {
                    tmp.append(k.toMap())
                }
                map["AutoIncrementUsageList"] = tmp
            }
            if self.errorInfo != nil {
                map["ErrorInfo"] = self.errorInfo!
            }
            if self.finish != nil {
                map["Finish"] = self.finish!
            }
            if self.taskStatus != nil {
                map["TaskStatus"] = self.taskStatus!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoIncrementUsageList") {
                var tmp : [GetAutoIncrementUsageStatisticResponseBody.Data.AutoIncrementUsageList] = []
                for v in dict["AutoIncrementUsageList"] as! [Any] {
                    var model = GetAutoIncrementUsageStatisticResponseBody.Data.AutoIncrementUsageList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.autoIncrementUsageList = tmp
            }
            if dict.keys.contains("ErrorInfo") {
                self.errorInfo = dict["ErrorInfo"] as! String
            }
            if dict.keys.contains("Finish") {
                self.finish = dict["Finish"] as! Bool
            }
            if dict.keys.contains("TaskStatus") {
                self.taskStatus = dict["TaskStatus"] as! String
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
        }
    }
    public var code: Int64?

    public var data: GetAutoIncrementUsageStatisticResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = GetAutoIncrementUsageStatisticResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAutoIncrementUsageStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAutoIncrementUsageStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAutoIncrementUsageStatisticResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAutoResourceOptimizeRulesRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsoleContext") {
            self.consoleContext = dict["ConsoleContext"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
    }
}

public class GetAutoResourceOptimizeRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EnableAutoResourceOptimizeList : Tea.TeaModel {
            public var autoDefragment: Bool?

            public var dasProOn: Bool?

            public var instanceId: String?

            public var tableFragmentationRatio: Double?

            public var tableSpaceSize: Double?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoDefragment != nil {
                    map["AutoDefragment"] = self.autoDefragment!
                }
                if self.dasProOn != nil {
                    map["DasProOn"] = self.dasProOn!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.tableFragmentationRatio != nil {
                    map["TableFragmentationRatio"] = self.tableFragmentationRatio!
                }
                if self.tableSpaceSize != nil {
                    map["TableSpaceSize"] = self.tableSpaceSize!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoDefragment") {
                    self.autoDefragment = dict["AutoDefragment"] as! Bool
                }
                if dict.keys.contains("DasProOn") {
                    self.dasProOn = dict["DasProOn"] as! Bool
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("TableFragmentationRatio") {
                    self.tableFragmentationRatio = dict["TableFragmentationRatio"] as! Double
                }
                if dict.keys.contains("TableSpaceSize") {
                    self.tableSpaceSize = dict["TableSpaceSize"] as! Double
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class HasEnableRuleButNotDasProList : Tea.TeaModel {
            public var autoDefragment: Bool?

            public var dasProOn: Bool?

            public var instanceId: String?

            public var tableFragmentationRatio: Double?

            public var tableSpaceSize: Double?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoDefragment != nil {
                    map["AutoDefragment"] = self.autoDefragment!
                }
                if self.dasProOn != nil {
                    map["DasProOn"] = self.dasProOn!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.tableFragmentationRatio != nil {
                    map["TableFragmentationRatio"] = self.tableFragmentationRatio!
                }
                if self.tableSpaceSize != nil {
                    map["TableSpaceSize"] = self.tableSpaceSize!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoDefragment") {
                    self.autoDefragment = dict["AutoDefragment"] as! Bool
                }
                if dict.keys.contains("DasProOn") {
                    self.dasProOn = dict["DasProOn"] as! Bool
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("TableFragmentationRatio") {
                    self.tableFragmentationRatio = dict["TableFragmentationRatio"] as! Double
                }
                if dict.keys.contains("TableSpaceSize") {
                    self.tableSpaceSize = dict["TableSpaceSize"] as! Double
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public class TurnOffAutoResourceOptimizeList : Tea.TeaModel {
            public var autoDefragment: Bool?

            public var dasProOn: Bool?

            public var instanceId: String?

            public var tableFragmentationRatio: Double?

            public var tableSpaceSize: Double?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoDefragment != nil {
                    map["AutoDefragment"] = self.autoDefragment!
                }
                if self.dasProOn != nil {
                    map["DasProOn"] = self.dasProOn!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.tableFragmentationRatio != nil {
                    map["TableFragmentationRatio"] = self.tableFragmentationRatio!
                }
                if self.tableSpaceSize != nil {
                    map["TableSpaceSize"] = self.tableSpaceSize!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoDefragment") {
                    self.autoDefragment = dict["AutoDefragment"] as! Bool
                }
                if dict.keys.contains("DasProOn") {
                    self.dasProOn = dict["DasProOn"] as! Bool
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("TableFragmentationRatio") {
                    self.tableFragmentationRatio = dict["TableFragmentationRatio"] as! Double
                }
                if dict.keys.contains("TableSpaceSize") {
                    self.tableSpaceSize = dict["TableSpaceSize"] as! Double
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var enableAutoResourceOptimizeCount: Int64?

        public var enableAutoResourceOptimizeList: [GetAutoResourceOptimizeRulesResponseBody.Data.EnableAutoResourceOptimizeList]?

        public var hasEnableRuleButNotDasProCount: Int64?

        public var hasEnableRuleButNotDasProList: [GetAutoResourceOptimizeRulesResponseBody.Data.HasEnableRuleButNotDasProList]?

        public var neverEnableAutoResourceOptimizeOrReleasedInstanceCount: Int64?

        public var neverEnableAutoResourceOptimizeOrReleasedInstanceIdList: [String]?

        public var totalAutoResourceOptimizeRulesCount: Int64?

        public var turnOffAutoResourceOptimizeCount: Int64?

        public var turnOffAutoResourceOptimizeList: [GetAutoResourceOptimizeRulesResponseBody.Data.TurnOffAutoResourceOptimizeList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableAutoResourceOptimizeCount != nil {
                map["EnableAutoResourceOptimizeCount"] = self.enableAutoResourceOptimizeCount!
            }
            if self.enableAutoResourceOptimizeList != nil {
                var tmp : [Any] = []
                for k in self.enableAutoResourceOptimizeList! {
                    tmp.append(k.toMap())
                }
                map["EnableAutoResourceOptimizeList"] = tmp
            }
            if self.hasEnableRuleButNotDasProCount != nil {
                map["HasEnableRuleButNotDasProCount"] = self.hasEnableRuleButNotDasProCount!
            }
            if self.hasEnableRuleButNotDasProList != nil {
                var tmp : [Any] = []
                for k in self.hasEnableRuleButNotDasProList! {
                    tmp.append(k.toMap())
                }
                map["HasEnableRuleButNotDasProList"] = tmp
            }
            if self.neverEnableAutoResourceOptimizeOrReleasedInstanceCount != nil {
                map["NeverEnableAutoResourceOptimizeOrReleasedInstanceCount"] = self.neverEnableAutoResourceOptimizeOrReleasedInstanceCount!
            }
            if self.neverEnableAutoResourceOptimizeOrReleasedInstanceIdList != nil {
                map["NeverEnableAutoResourceOptimizeOrReleasedInstanceIdList"] = self.neverEnableAutoResourceOptimizeOrReleasedInstanceIdList!
            }
            if self.totalAutoResourceOptimizeRulesCount != nil {
                map["TotalAutoResourceOptimizeRulesCount"] = self.totalAutoResourceOptimizeRulesCount!
            }
            if self.turnOffAutoResourceOptimizeCount != nil {
                map["TurnOffAutoResourceOptimizeCount"] = self.turnOffAutoResourceOptimizeCount!
            }
            if self.turnOffAutoResourceOptimizeList != nil {
                var tmp : [Any] = []
                for k in self.turnOffAutoResourceOptimizeList! {
                    tmp.append(k.toMap())
                }
                map["TurnOffAutoResourceOptimizeList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableAutoResourceOptimizeCount") {
                self.enableAutoResourceOptimizeCount = dict["EnableAutoResourceOptimizeCount"] as! Int64
            }
            if dict.keys.contains("EnableAutoResourceOptimizeList") {
                var tmp : [GetAutoResourceOptimizeRulesResponseBody.Data.EnableAutoResourceOptimizeList] = []
                for v in dict["EnableAutoResourceOptimizeList"] as! [Any] {
                    var model = GetAutoResourceOptimizeRulesResponseBody.Data.EnableAutoResourceOptimizeList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.enableAutoResourceOptimizeList = tmp
            }
            if dict.keys.contains("HasEnableRuleButNotDasProCount") {
                self.hasEnableRuleButNotDasProCount = dict["HasEnableRuleButNotDasProCount"] as! Int64
            }
            if dict.keys.contains("HasEnableRuleButNotDasProList") {
                var tmp : [GetAutoResourceOptimizeRulesResponseBody.Data.HasEnableRuleButNotDasProList] = []
                for v in dict["HasEnableRuleButNotDasProList"] as! [Any] {
                    var model = GetAutoResourceOptimizeRulesResponseBody.Data.HasEnableRuleButNotDasProList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.hasEnableRuleButNotDasProList = tmp
            }
            if dict.keys.contains("NeverEnableAutoResourceOptimizeOrReleasedInstanceCount") {
                self.neverEnableAutoResourceOptimizeOrReleasedInstanceCount = dict["NeverEnableAutoResourceOptimizeOrReleasedInstanceCount"] as! Int64
            }
            if dict.keys.contains("NeverEnableAutoResourceOptimizeOrReleasedInstanceIdList") {
                self.neverEnableAutoResourceOptimizeOrReleasedInstanceIdList = dict["NeverEnableAutoResourceOptimizeOrReleasedInstanceIdList"] as! [String]
            }
            if dict.keys.contains("TotalAutoResourceOptimizeRulesCount") {
                self.totalAutoResourceOptimizeRulesCount = dict["TotalAutoResourceOptimizeRulesCount"] as! Int64
            }
            if dict.keys.contains("TurnOffAutoResourceOptimizeCount") {
                self.turnOffAutoResourceOptimizeCount = dict["TurnOffAutoResourceOptimizeCount"] as! Int64
            }
            if dict.keys.contains("TurnOffAutoResourceOptimizeList") {
                var tmp : [GetAutoResourceOptimizeRulesResponseBody.Data.TurnOffAutoResourceOptimizeList] = []
                for v in dict["TurnOffAutoResourceOptimizeList"] as! [Any] {
                    var model = GetAutoResourceOptimizeRulesResponseBody.Data.TurnOffAutoResourceOptimizeList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.turnOffAutoResourceOptimizeList = tmp
            }
        }
    }
    public var code: Int64?

    public var data: GetAutoResourceOptimizeRulesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = GetAutoResourceOptimizeRulesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAutoResourceOptimizeRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAutoResourceOptimizeRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAutoResourceOptimizeRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAutoThrottleRulesRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsoleContext") {
            self.consoleContext = dict["ConsoleContext"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
    }
}

public class GetAutoThrottleRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class EnableAutoThrottleList : Tea.TeaModel {
            public var abnormalDuration: Double?

            public var activeSessions: Int64?

            public var allowThrottleEndTime: String?

            public var allowThrottleStartTime: String?

            public var autoKillSession: Bool?

            public var cpuSessionRelation: String?

            public var cpuUsage: Double?

            public var instanceId: String?

            public var maxThrottleTime: Double?

            public var userId: String?

            public var visible: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.abnormalDuration != nil {
                    map["AbnormalDuration"] = self.abnormalDuration!
                }
                if self.activeSessions != nil {
                    map["ActiveSessions"] = self.activeSessions!
                }
                if self.allowThrottleEndTime != nil {
                    map["AllowThrottleEndTime"] = self.allowThrottleEndTime!
                }
                if self.allowThrottleStartTime != nil {
                    map["AllowThrottleStartTime"] = self.allowThrottleStartTime!
                }
                if self.autoKillSession != nil {
                    map["AutoKillSession"] = self.autoKillSession!
                }
                if self.cpuSessionRelation != nil {
                    map["CpuSessionRelation"] = self.cpuSessionRelation!
                }
                if self.cpuUsage != nil {
                    map["CpuUsage"] = self.cpuUsage!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.maxThrottleTime != nil {
                    map["MaxThrottleTime"] = self.maxThrottleTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.visible != nil {
                    map["Visible"] = self.visible!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AbnormalDuration") {
                    self.abnormalDuration = dict["AbnormalDuration"] as! Double
                }
                if dict.keys.contains("ActiveSessions") {
                    self.activeSessions = dict["ActiveSessions"] as! Int64
                }
                if dict.keys.contains("AllowThrottleEndTime") {
                    self.allowThrottleEndTime = dict["AllowThrottleEndTime"] as! String
                }
                if dict.keys.contains("AllowThrottleStartTime") {
                    self.allowThrottleStartTime = dict["AllowThrottleStartTime"] as! String
                }
                if dict.keys.contains("AutoKillSession") {
                    self.autoKillSession = dict["AutoKillSession"] as! Bool
                }
                if dict.keys.contains("CpuSessionRelation") {
                    self.cpuSessionRelation = dict["CpuSessionRelation"] as! String
                }
                if dict.keys.contains("CpuUsage") {
                    self.cpuUsage = dict["CpuUsage"] as! Double
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("MaxThrottleTime") {
                    self.maxThrottleTime = dict["MaxThrottleTime"] as! Double
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("Visible") {
                    self.visible = dict["Visible"] as! Bool
                }
            }
        }
        public class TurnOffAutoThrottleList : Tea.TeaModel {
            public var abnormalDuration: Double?

            public var activeSessions: Int64?

            public var allowThrottleEndTime: String?

            public var allowThrottleStartTime: String?

            public var autoKillSession: Bool?

            public var cpuSessionRelation: String?

            public var cpuUsage: Double?

            public var instanceId: String?

            public var maxThrottleTime: Double?

            public var userId: String?

            public var visible: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.abnormalDuration != nil {
                    map["AbnormalDuration"] = self.abnormalDuration!
                }
                if self.activeSessions != nil {
                    map["ActiveSessions"] = self.activeSessions!
                }
                if self.allowThrottleEndTime != nil {
                    map["AllowThrottleEndTime"] = self.allowThrottleEndTime!
                }
                if self.allowThrottleStartTime != nil {
                    map["AllowThrottleStartTime"] = self.allowThrottleStartTime!
                }
                if self.autoKillSession != nil {
                    map["AutoKillSession"] = self.autoKillSession!
                }
                if self.cpuSessionRelation != nil {
                    map["CpuSessionRelation"] = self.cpuSessionRelation!
                }
                if self.cpuUsage != nil {
                    map["CpuUsage"] = self.cpuUsage!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.maxThrottleTime != nil {
                    map["MaxThrottleTime"] = self.maxThrottleTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.visible != nil {
                    map["Visible"] = self.visible!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AbnormalDuration") {
                    self.abnormalDuration = dict["AbnormalDuration"] as! Double
                }
                if dict.keys.contains("ActiveSessions") {
                    self.activeSessions = dict["ActiveSessions"] as! Int64
                }
                if dict.keys.contains("AllowThrottleEndTime") {
                    self.allowThrottleEndTime = dict["AllowThrottleEndTime"] as! String
                }
                if dict.keys.contains("AllowThrottleStartTime") {
                    self.allowThrottleStartTime = dict["AllowThrottleStartTime"] as! String
                }
                if dict.keys.contains("AutoKillSession") {
                    self.autoKillSession = dict["AutoKillSession"] as! Bool
                }
                if dict.keys.contains("CpuSessionRelation") {
                    self.cpuSessionRelation = dict["CpuSessionRelation"] as! String
                }
                if dict.keys.contains("CpuUsage") {
                    self.cpuUsage = dict["CpuUsage"] as! Double
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("MaxThrottleTime") {
                    self.maxThrottleTime = dict["MaxThrottleTime"] as! Double
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("Visible") {
                    self.visible = dict["Visible"] as! Bool
                }
            }
        }
        public var enableAutoThrottleCount: Int64?

        public var enableAutoThrottleList: [GetAutoThrottleRulesResponseBody.Data.EnableAutoThrottleList]?

        public var neverEnableAutoThrottleOrReleasedInstanceCount: Int64?

        public var neverEnableAutoThrottleOrReleasedInstanceIdList: [String]?

        public var totalAutoThrottleRulesCount: Int64?

        public var turnOffAutoThrottleCount: Int64?

        public var turnOffAutoThrottleList: [GetAutoThrottleRulesResponseBody.Data.TurnOffAutoThrottleList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableAutoThrottleCount != nil {
                map["EnableAutoThrottleCount"] = self.enableAutoThrottleCount!
            }
            if self.enableAutoThrottleList != nil {
                var tmp : [Any] = []
                for k in self.enableAutoThrottleList! {
                    tmp.append(k.toMap())
                }
                map["EnableAutoThrottleList"] = tmp
            }
            if self.neverEnableAutoThrottleOrReleasedInstanceCount != nil {
                map["NeverEnableAutoThrottleOrReleasedInstanceCount"] = self.neverEnableAutoThrottleOrReleasedInstanceCount!
            }
            if self.neverEnableAutoThrottleOrReleasedInstanceIdList != nil {
                map["NeverEnableAutoThrottleOrReleasedInstanceIdList"] = self.neverEnableAutoThrottleOrReleasedInstanceIdList!
            }
            if self.totalAutoThrottleRulesCount != nil {
                map["TotalAutoThrottleRulesCount"] = self.totalAutoThrottleRulesCount!
            }
            if self.turnOffAutoThrottleCount != nil {
                map["TurnOffAutoThrottleCount"] = self.turnOffAutoThrottleCount!
            }
            if self.turnOffAutoThrottleList != nil {
                var tmp : [Any] = []
                for k in self.turnOffAutoThrottleList! {
                    tmp.append(k.toMap())
                }
                map["TurnOffAutoThrottleList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableAutoThrottleCount") {
                self.enableAutoThrottleCount = dict["EnableAutoThrottleCount"] as! Int64
            }
            if dict.keys.contains("EnableAutoThrottleList") {
                var tmp : [GetAutoThrottleRulesResponseBody.Data.EnableAutoThrottleList] = []
                for v in dict["EnableAutoThrottleList"] as! [Any] {
                    var model = GetAutoThrottleRulesResponseBody.Data.EnableAutoThrottleList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.enableAutoThrottleList = tmp
            }
            if dict.keys.contains("NeverEnableAutoThrottleOrReleasedInstanceCount") {
                self.neverEnableAutoThrottleOrReleasedInstanceCount = dict["NeverEnableAutoThrottleOrReleasedInstanceCount"] as! Int64
            }
            if dict.keys.contains("NeverEnableAutoThrottleOrReleasedInstanceIdList") {
                self.neverEnableAutoThrottleOrReleasedInstanceIdList = dict["NeverEnableAutoThrottleOrReleasedInstanceIdList"] as! [String]
            }
            if dict.keys.contains("TotalAutoThrottleRulesCount") {
                self.totalAutoThrottleRulesCount = dict["TotalAutoThrottleRulesCount"] as! Int64
            }
            if dict.keys.contains("TurnOffAutoThrottleCount") {
                self.turnOffAutoThrottleCount = dict["TurnOffAutoThrottleCount"] as! Int64
            }
            if dict.keys.contains("TurnOffAutoThrottleList") {
                var tmp : [GetAutoThrottleRulesResponseBody.Data.TurnOffAutoThrottleList] = []
                for v in dict["TurnOffAutoThrottleList"] as! [Any] {
                    var model = GetAutoThrottleRulesResponseBody.Data.TurnOffAutoThrottleList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.turnOffAutoThrottleList = tmp
            }
        }
    }
    public var code: Int64?

    public var data: GetAutoThrottleRulesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = GetAutoThrottleRulesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetAutoThrottleRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAutoThrottleRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAutoThrottleRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAutonomousNotifyEventContentRequest : Tea.TeaModel {
    public var instanceId: String?

    public var spanId: String?

    public var context: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.spanId != nil {
            map["SpanId"] = self.spanId!
        }
        if self.context != nil {
            map["__context"] = self.context!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SpanId") {
            self.spanId = dict["SpanId"] as! String
        }
        if dict.keys.contains("__context") {
            self.context = dict["__context"] as! String
        }
    }
}

public class GetAutonomousNotifyEventContentResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetAutonomousNotifyEventContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAutonomousNotifyEventContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAutonomousNotifyEventContentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAutonomousNotifyEventsInRangeRequest : Tea.TeaModel {
    public var endTime: String?

    public var eventContext: String?

    public var instanceId: String?

    public var level: String?

    public var minLevel: String?

    public var nodeId: String?

    public var pageOffset: String?

    public var pageSize: String?

    public var startTime: String?

    public var context: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.eventContext != nil {
            map["EventContext"] = self.eventContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.minLevel != nil {
            map["MinLevel"] = self.minLevel!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.pageOffset != nil {
            map["PageOffset"] = self.pageOffset!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.context != nil {
            map["__context"] = self.context!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EventContext") {
            self.eventContext = dict["EventContext"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Level") {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("MinLevel") {
            self.minLevel = dict["MinLevel"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("PageOffset") {
            self.pageOffset = dict["PageOffset"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("__context") {
            self.context = dict["__context"] as! String
        }
    }
}

public class GetAutonomousNotifyEventsInRangeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var t: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.t != nil {
                    map["T"] = self.t!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("T") {
                    self.t = dict["T"] as! [String]
                }
            }
        }
        public var extra: String?

        public var list: GetAutonomousNotifyEventsInRangeResponseBody.Data.List?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.list?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                map["List"] = self.list?.toMap()
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extra") {
                self.extra = dict["Extra"] as! String
            }
            if dict.keys.contains("List") {
                var model = GetAutonomousNotifyEventsInRangeResponseBody.Data.List()
                model.fromMap(dict["List"] as! [String: Any])
                self.list = model
            }
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetAutonomousNotifyEventsInRangeResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetAutonomousNotifyEventsInRangeResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetAutonomousNotifyEventsInRangeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAutonomousNotifyEventsInRangeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAutonomousNotifyEventsInRangeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBlockingDetailListRequest : Tea.TeaModel {
    public var dbNameList: String?

    public var endTime: String?

    public var instanceId: String?

    public var pageNo: String?

    public var pageSize: String?

    public var queryHash: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbNameList != nil {
            map["DbNameList"] = self.dbNameList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.queryHash != nil {
            map["QueryHash"] = self.queryHash!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbNameList") {
            self.dbNameList = dict["DbNameList"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("QueryHash") {
            self.queryHash = dict["QueryHash"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class GetBlockingDetailListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var batchId: Int64?

            public var clientAppName: String?

            public var currentCollectionTime: Int64?

            public var dataBase: String?

            public var hostName: String?

            public var loginId: String?

            public var queryHash: String?

            public var spid: String?

            public var sqlText: String?

            public var startTime: String?

            public var waitTimeMs: Int64?

            public var waitType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.batchId != nil {
                    map["BatchId"] = self.batchId!
                }
                if self.clientAppName != nil {
                    map["ClientAppName"] = self.clientAppName!
                }
                if self.currentCollectionTime != nil {
                    map["CurrentCollectionTime"] = self.currentCollectionTime!
                }
                if self.dataBase != nil {
                    map["DataBase"] = self.dataBase!
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.loginId != nil {
                    map["LoginId"] = self.loginId!
                }
                if self.queryHash != nil {
                    map["QueryHash"] = self.queryHash!
                }
                if self.spid != nil {
                    map["Spid"] = self.spid!
                }
                if self.sqlText != nil {
                    map["SqlText"] = self.sqlText!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.waitTimeMs != nil {
                    map["WaitTimeMs"] = self.waitTimeMs!
                }
                if self.waitType != nil {
                    map["WaitType"] = self.waitType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BatchId") {
                    self.batchId = dict["BatchId"] as! Int64
                }
                if dict.keys.contains("ClientAppName") {
                    self.clientAppName = dict["ClientAppName"] as! String
                }
                if dict.keys.contains("CurrentCollectionTime") {
                    self.currentCollectionTime = dict["CurrentCollectionTime"] as! Int64
                }
                if dict.keys.contains("DataBase") {
                    self.dataBase = dict["DataBase"] as! String
                }
                if dict.keys.contains("HostName") {
                    self.hostName = dict["HostName"] as! String
                }
                if dict.keys.contains("LoginId") {
                    self.loginId = dict["LoginId"] as! String
                }
                if dict.keys.contains("QueryHash") {
                    self.queryHash = dict["QueryHash"] as! String
                }
                if dict.keys.contains("Spid") {
                    self.spid = dict["Spid"] as! String
                }
                if dict.keys.contains("SqlText") {
                    self.sqlText = dict["SqlText"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("WaitTimeMs") {
                    self.waitTimeMs = dict["WaitTimeMs"] as! Int64
                }
                if dict.keys.contains("WaitType") {
                    self.waitType = dict["WaitType"] as! String
                }
            }
        }
        public var list: [GetBlockingDetailListResponseBody.Data.List]?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [GetBlockingDetailListResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetBlockingDetailListResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetBlockingDetailListResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetBlockingDetailListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetBlockingDetailListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBlockingDetailListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetBlockingDetailListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDBInstanceConnectivityDiagnosisRequest : Tea.TeaModel {
    public var instanceId: String?

    public var srcIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.srcIp != nil {
            map["SrcIp"] = self.srcIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SrcIp") {
            self.srcIp = dict["SrcIp"] as! String
        }
    }
}

public class GetDBInstanceConnectivityDiagnosisResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var connCheckErrorCode: String?

        public var connCheckErrorMessage: String?

        public var failType: String?

        public var instanceId: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connCheckErrorCode != nil {
                map["connCheckErrorCode"] = self.connCheckErrorCode!
            }
            if self.connCheckErrorMessage != nil {
                map["connCheckErrorMessage"] = self.connCheckErrorMessage!
            }
            if self.failType != nil {
                map["failType"] = self.failType!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.success != nil {
                map["success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("connCheckErrorCode") {
                self.connCheckErrorCode = dict["connCheckErrorCode"] as! String
            }
            if dict.keys.contains("connCheckErrorMessage") {
                self.connCheckErrorMessage = dict["connCheckErrorMessage"] as! String
            }
            if dict.keys.contains("failType") {
                self.failType = dict["failType"] as! String
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("success") {
                self.success = dict["success"] as! Bool
            }
        }
    }
    public var code: String?

    public var data: GetDBInstanceConnectivityDiagnosisResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetDBInstanceConnectivityDiagnosisResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetDBInstanceConnectivityDiagnosisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDBInstanceConnectivityDiagnosisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDBInstanceConnectivityDiagnosisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDasProServiceUsageRequest : Tea.TeaModel {
    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GetDasProServiceUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var commodityInstanceId: String?

        public var engine: String?

        public var expireTime: Int64?

        public var instanceAlias: String?

        public var instanceId: String?

        public var ip: String?

        public var isSpare: Bool?

        public var migrationPredictRemainingTime: Int64?

        public var port: Int32?

        public var region: String?

        public var serviceUnitId: String?

        public var sqlRetention: String?

        public var startTime: Int64?

        public var storageFreeQuotaInMB: Double?

        public var storageUsed: Int64?

        public var userId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commodityInstanceId != nil {
                map["commodityInstanceId"] = self.commodityInstanceId!
            }
            if self.engine != nil {
                map["engine"] = self.engine!
            }
            if self.expireTime != nil {
                map["expireTime"] = self.expireTime!
            }
            if self.instanceAlias != nil {
                map["instanceAlias"] = self.instanceAlias!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.ip != nil {
                map["ip"] = self.ip!
            }
            if self.isSpare != nil {
                map["isSpare"] = self.isSpare!
            }
            if self.migrationPredictRemainingTime != nil {
                map["migrationPredictRemainingTime"] = self.migrationPredictRemainingTime!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            if self.region != nil {
                map["region"] = self.region!
            }
            if self.serviceUnitId != nil {
                map["serviceUnitId"] = self.serviceUnitId!
            }
            if self.sqlRetention != nil {
                map["sqlRetention"] = self.sqlRetention!
            }
            if self.startTime != nil {
                map["startTime"] = self.startTime!
            }
            if self.storageFreeQuotaInMB != nil {
                map["storageFreeQuotaInMB"] = self.storageFreeQuotaInMB!
            }
            if self.storageUsed != nil {
                map["storageUsed"] = self.storageUsed!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("commodityInstanceId") {
                self.commodityInstanceId = dict["commodityInstanceId"] as! String
            }
            if dict.keys.contains("engine") {
                self.engine = dict["engine"] as! String
            }
            if dict.keys.contains("expireTime") {
                self.expireTime = dict["expireTime"] as! Int64
            }
            if dict.keys.contains("instanceAlias") {
                self.instanceAlias = dict["instanceAlias"] as! String
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("ip") {
                self.ip = dict["ip"] as! String
            }
            if dict.keys.contains("isSpare") {
                self.isSpare = dict["isSpare"] as! Bool
            }
            if dict.keys.contains("migrationPredictRemainingTime") {
                self.migrationPredictRemainingTime = dict["migrationPredictRemainingTime"] as! Int64
            }
            if dict.keys.contains("port") {
                self.port = dict["port"] as! Int32
            }
            if dict.keys.contains("region") {
                self.region = dict["region"] as! String
            }
            if dict.keys.contains("serviceUnitId") {
                self.serviceUnitId = dict["serviceUnitId"] as! String
            }
            if dict.keys.contains("sqlRetention") {
                self.sqlRetention = dict["sqlRetention"] as! String
            }
            if dict.keys.contains("startTime") {
                self.startTime = dict["startTime"] as! Int64
            }
            if dict.keys.contains("storageFreeQuotaInMB") {
                self.storageFreeQuotaInMB = dict["storageFreeQuotaInMB"] as! Double
            }
            if dict.keys.contains("storageUsed") {
                self.storageUsed = dict["storageUsed"] as! Int64
            }
            if dict.keys.contains("userId") {
                self.userId = dict["userId"] as! String
            }
            if dict.keys.contains("vpcId") {
                self.vpcId = dict["vpcId"] as! String
            }
        }
    }
    public var code: Int64?

    public var data: GetDasProServiceUsageResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = GetDasProServiceUsageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDasProServiceUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDasProServiceUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDasProServiceUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDasSQLLogHotDataRequest : Tea.TeaModel {
    public var accountName: String?

    public var childDBInstanceIDs: String?

    public var DBName: String?

    public var end: Int64?

    public var fail: String?

    public var hostAddress: String?

    public var instanceId: String?

    public var logicalOperator: String?

    public var maxLatancy: Int64?

    public var maxRecordsPerPage: Int64?

    public var maxRows: Int64?

    public var maxScanRows: Int64?

    public var maxSpillCnt: Int64?

    public var minLatancy: Int64?

    public var minRows: Int64?

    public var minScanRows: Int64?

    public var minSpillCnt: Int64?

    public var pageNumbers: Int64?

    public var queryKeyword: String?

    public var role: String?

    public var sortKey: String?

    public var sortMethod: String?

    public var sqlType: String?

    public var start: Int64?

    public var state: String?

    public var threadID: String?

    public var traceId: String?

    public var transactionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.childDBInstanceIDs != nil {
            map["ChildDBInstanceIDs"] = self.childDBInstanceIDs!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.fail != nil {
            map["Fail"] = self.fail!
        }
        if self.hostAddress != nil {
            map["HostAddress"] = self.hostAddress!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.logicalOperator != nil {
            map["LogicalOperator"] = self.logicalOperator!
        }
        if self.maxLatancy != nil {
            map["MaxLatancy"] = self.maxLatancy!
        }
        if self.maxRecordsPerPage != nil {
            map["MaxRecordsPerPage"] = self.maxRecordsPerPage!
        }
        if self.maxRows != nil {
            map["MaxRows"] = self.maxRows!
        }
        if self.maxScanRows != nil {
            map["MaxScanRows"] = self.maxScanRows!
        }
        if self.maxSpillCnt != nil {
            map["MaxSpillCnt"] = self.maxSpillCnt!
        }
        if self.minLatancy != nil {
            map["MinLatancy"] = self.minLatancy!
        }
        if self.minRows != nil {
            map["MinRows"] = self.minRows!
        }
        if self.minScanRows != nil {
            map["MinScanRows"] = self.minScanRows!
        }
        if self.minSpillCnt != nil {
            map["MinSpillCnt"] = self.minSpillCnt!
        }
        if self.pageNumbers != nil {
            map["PageNumbers"] = self.pageNumbers!
        }
        if self.queryKeyword != nil {
            map["QueryKeyword"] = self.queryKeyword!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.sortKey != nil {
            map["SortKey"] = self.sortKey!
        }
        if self.sortMethod != nil {
            map["SortMethod"] = self.sortMethod!
        }
        if self.sqlType != nil {
            map["SqlType"] = self.sqlType!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.threadID != nil {
            map["ThreadID"] = self.threadID!
        }
        if self.traceId != nil {
            map["TraceId"] = self.traceId!
        }
        if self.transactionId != nil {
            map["TransactionId"] = self.transactionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountName") {
            self.accountName = dict["AccountName"] as! String
        }
        if dict.keys.contains("ChildDBInstanceIDs") {
            self.childDBInstanceIDs = dict["ChildDBInstanceIDs"] as! String
        }
        if dict.keys.contains("DBName") {
            self.DBName = dict["DBName"] as! String
        }
        if dict.keys.contains("End") {
            self.end = dict["End"] as! Int64
        }
        if dict.keys.contains("Fail") {
            self.fail = dict["Fail"] as! String
        }
        if dict.keys.contains("HostAddress") {
            self.hostAddress = dict["HostAddress"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("LogicalOperator") {
            self.logicalOperator = dict["LogicalOperator"] as! String
        }
        if dict.keys.contains("MaxLatancy") {
            self.maxLatancy = dict["MaxLatancy"] as! Int64
        }
        if dict.keys.contains("MaxRecordsPerPage") {
            self.maxRecordsPerPage = dict["MaxRecordsPerPage"] as! Int64
        }
        if dict.keys.contains("MaxRows") {
            self.maxRows = dict["MaxRows"] as! Int64
        }
        if dict.keys.contains("MaxScanRows") {
            self.maxScanRows = dict["MaxScanRows"] as! Int64
        }
        if dict.keys.contains("MaxSpillCnt") {
            self.maxSpillCnt = dict["MaxSpillCnt"] as! Int64
        }
        if dict.keys.contains("MinLatancy") {
            self.minLatancy = dict["MinLatancy"] as! Int64
        }
        if dict.keys.contains("MinRows") {
            self.minRows = dict["MinRows"] as! Int64
        }
        if dict.keys.contains("MinScanRows") {
            self.minScanRows = dict["MinScanRows"] as! Int64
        }
        if dict.keys.contains("MinSpillCnt") {
            self.minSpillCnt = dict["MinSpillCnt"] as! Int64
        }
        if dict.keys.contains("PageNumbers") {
            self.pageNumbers = dict["PageNumbers"] as! Int64
        }
        if dict.keys.contains("QueryKeyword") {
            self.queryKeyword = dict["QueryKeyword"] as! String
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! String
        }
        if dict.keys.contains("SortKey") {
            self.sortKey = dict["SortKey"] as! String
        }
        if dict.keys.contains("SortMethod") {
            self.sortMethod = dict["SortMethod"] as! String
        }
        if dict.keys.contains("SqlType") {
            self.sqlType = dict["SqlType"] as! String
        }
        if dict.keys.contains("Start") {
            self.start = dict["Start"] as! Int64
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("ThreadID") {
            self.threadID = dict["ThreadID"] as! String
        }
        if dict.keys.contains("TraceId") {
            self.traceId = dict["TraceId"] as! String
        }
        if dict.keys.contains("TransactionId") {
            self.transactionId = dict["TransactionId"] as! String
        }
    }
}

public class GetDasSQLLogHotDataResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var accountName: String?

            public var DBName: String?

            public var executeTime: String?

            public var ext: String?

            public var hostAddress: String?

            public var latancy: Int64?

            public var lockTime: Int64?

            public var logicRead: Int64?

            public var originTime: String?

            public var physicAsyncRead: Int64?

            public var physicSyncRead: Int64?

            public var returnRows: Int64?

            public var SQLText: String?

            public var scanRows: Int64?

            public var sqlType: String?

            public var state: String?

            public var threadID: Int64?

            public var transactionId: String?

            public var updateRows: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountName != nil {
                    map["AccountName"] = self.accountName!
                }
                if self.DBName != nil {
                    map["DBName"] = self.DBName!
                }
                if self.executeTime != nil {
                    map["ExecuteTime"] = self.executeTime!
                }
                if self.ext != nil {
                    map["Ext"] = self.ext!
                }
                if self.hostAddress != nil {
                    map["HostAddress"] = self.hostAddress!
                }
                if self.latancy != nil {
                    map["Latancy"] = self.latancy!
                }
                if self.lockTime != nil {
                    map["LockTime"] = self.lockTime!
                }
                if self.logicRead != nil {
                    map["LogicRead"] = self.logicRead!
                }
                if self.originTime != nil {
                    map["OriginTime"] = self.originTime!
                }
                if self.physicAsyncRead != nil {
                    map["PhysicAsyncRead"] = self.physicAsyncRead!
                }
                if self.physicSyncRead != nil {
                    map["PhysicSyncRead"] = self.physicSyncRead!
                }
                if self.returnRows != nil {
                    map["ReturnRows"] = self.returnRows!
                }
                if self.SQLText != nil {
                    map["SQLText"] = self.SQLText!
                }
                if self.scanRows != nil {
                    map["ScanRows"] = self.scanRows!
                }
                if self.sqlType != nil {
                    map["SqlType"] = self.sqlType!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.threadID != nil {
                    map["ThreadID"] = self.threadID!
                }
                if self.transactionId != nil {
                    map["TransactionId"] = self.transactionId!
                }
                if self.updateRows != nil {
                    map["UpdateRows"] = self.updateRows!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccountName") {
                    self.accountName = dict["AccountName"] as! String
                }
                if dict.keys.contains("DBName") {
                    self.DBName = dict["DBName"] as! String
                }
                if dict.keys.contains("ExecuteTime") {
                    self.executeTime = dict["ExecuteTime"] as! String
                }
                if dict.keys.contains("Ext") {
                    self.ext = dict["Ext"] as! String
                }
                if dict.keys.contains("HostAddress") {
                    self.hostAddress = dict["HostAddress"] as! String
                }
                if dict.keys.contains("Latancy") {
                    self.latancy = dict["Latancy"] as! Int64
                }
                if dict.keys.contains("LockTime") {
                    self.lockTime = dict["LockTime"] as! Int64
                }
                if dict.keys.contains("LogicRead") {
                    self.logicRead = dict["LogicRead"] as! Int64
                }
                if dict.keys.contains("OriginTime") {
                    self.originTime = dict["OriginTime"] as! String
                }
                if dict.keys.contains("PhysicAsyncRead") {
                    self.physicAsyncRead = dict["PhysicAsyncRead"] as! Int64
                }
                if dict.keys.contains("PhysicSyncRead") {
                    self.physicSyncRead = dict["PhysicSyncRead"] as! Int64
                }
                if dict.keys.contains("ReturnRows") {
                    self.returnRows = dict["ReturnRows"] as! Int64
                }
                if dict.keys.contains("SQLText") {
                    self.SQLText = dict["SQLText"] as! String
                }
                if dict.keys.contains("ScanRows") {
                    self.scanRows = dict["ScanRows"] as! Int64
                }
                if dict.keys.contains("SqlType") {
                    self.sqlType = dict["SqlType"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("ThreadID") {
                    self.threadID = dict["ThreadID"] as! Int64
                }
                if dict.keys.contains("TransactionId") {
                    self.transactionId = dict["TransactionId"] as! String
                }
                if dict.keys.contains("UpdateRows") {
                    self.updateRows = dict["UpdateRows"] as! Int64
                }
            }
        }
        public var extra: Any?

        public var list: [GetDasSQLLogHotDataResponseBody.Data.List]?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extra") {
                self.extra = dict["Extra"] as! Any
            }
            if dict.keys.contains("List") {
                var tmp : [GetDasSQLLogHotDataResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetDasSQLLogHotDataResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetDasSQLLogHotDataResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetDasSQLLogHotDataResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetDasSQLLogHotDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDasSQLLogHotDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDasSQLLogHotDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDeadLockDetailRequest : Tea.TeaModel {
    public var instanceId: String?

    public var nodeId: String?

    public var source: String?

    public var textId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.textId != nil {
            map["TextId"] = self.textId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("TextId") {
            self.textId = dict["TextId"] as! String
        }
    }
}

public class GetDeadLockDetailResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var synchro: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchro != nil {
            map["Synchro"] = self.synchro!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Synchro") {
            self.synchro = dict["Synchro"] as! String
        }
    }
}

public class GetDeadLockDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDeadLockDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDeadLockDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDeadLockDetailListRequest : Tea.TeaModel {
    public var dbNameList: String?

    public var endTime: String?

    public var instanceId: String?

    public var pageNo: String?

    public var pageSize: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbNameList != nil {
            map["DbNameList"] = self.dbNameList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbNameList") {
            self.dbNameList = dict["DbNameList"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class GetDeadLockDetailListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class BlockProcessList : Tea.TeaModel {
                public var clientApp: String?

                public var databaseName: String?

                public var hostName: String?

                public var lastTranStarted: Int64?

                public var lockMode: String?

                public var logUsed: Int64?

                public var loginName: String?

                public var objectOwned: String?

                public var objectRequested: String?

                public var ownMode: String?

                public var spid: Int64?

                public var sqlText: String?

                public var status: String?

                public var victim: Int64?

                public var waitMode: String?

                public var waitResource: String?

                public var waitResourceDescription: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clientApp != nil {
                        map["ClientApp"] = self.clientApp!
                    }
                    if self.databaseName != nil {
                        map["DatabaseName"] = self.databaseName!
                    }
                    if self.hostName != nil {
                        map["HostName"] = self.hostName!
                    }
                    if self.lastTranStarted != nil {
                        map["LastTranStarted"] = self.lastTranStarted!
                    }
                    if self.lockMode != nil {
                        map["LockMode"] = self.lockMode!
                    }
                    if self.logUsed != nil {
                        map["LogUsed"] = self.logUsed!
                    }
                    if self.loginName != nil {
                        map["LoginName"] = self.loginName!
                    }
                    if self.objectOwned != nil {
                        map["ObjectOwned"] = self.objectOwned!
                    }
                    if self.objectRequested != nil {
                        map["ObjectRequested"] = self.objectRequested!
                    }
                    if self.ownMode != nil {
                        map["OwnMode"] = self.ownMode!
                    }
                    if self.spid != nil {
                        map["Spid"] = self.spid!
                    }
                    if self.sqlText != nil {
                        map["SqlText"] = self.sqlText!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.victim != nil {
                        map["Victim"] = self.victim!
                    }
                    if self.waitMode != nil {
                        map["WaitMode"] = self.waitMode!
                    }
                    if self.waitResource != nil {
                        map["WaitResource"] = self.waitResource!
                    }
                    if self.waitResourceDescription != nil {
                        map["WaitResourceDescription"] = self.waitResourceDescription!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClientApp") {
                        self.clientApp = dict["ClientApp"] as! String
                    }
                    if dict.keys.contains("DatabaseName") {
                        self.databaseName = dict["DatabaseName"] as! String
                    }
                    if dict.keys.contains("HostName") {
                        self.hostName = dict["HostName"] as! String
                    }
                    if dict.keys.contains("LastTranStarted") {
                        self.lastTranStarted = dict["LastTranStarted"] as! Int64
                    }
                    if dict.keys.contains("LockMode") {
                        self.lockMode = dict["LockMode"] as! String
                    }
                    if dict.keys.contains("LogUsed") {
                        self.logUsed = dict["LogUsed"] as! Int64
                    }
                    if dict.keys.contains("LoginName") {
                        self.loginName = dict["LoginName"] as! String
                    }
                    if dict.keys.contains("ObjectOwned") {
                        self.objectOwned = dict["ObjectOwned"] as! String
                    }
                    if dict.keys.contains("ObjectRequested") {
                        self.objectRequested = dict["ObjectRequested"] as! String
                    }
                    if dict.keys.contains("OwnMode") {
                        self.ownMode = dict["OwnMode"] as! String
                    }
                    if dict.keys.contains("Spid") {
                        self.spid = dict["Spid"] as! Int64
                    }
                    if dict.keys.contains("SqlText") {
                        self.sqlText = dict["SqlText"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("Victim") {
                        self.victim = dict["Victim"] as! Int64
                    }
                    if dict.keys.contains("WaitMode") {
                        self.waitMode = dict["WaitMode"] as! String
                    }
                    if dict.keys.contains("WaitResource") {
                        self.waitResource = dict["WaitResource"] as! String
                    }
                    if dict.keys.contains("WaitResourceDescription") {
                        self.waitResourceDescription = dict["WaitResourceDescription"] as! String
                    }
                }
            }
            public var batchId: Int64?

            public var blockProcessList: [GetDeadLockDetailListResponseBody.Data.List.BlockProcessList]?

            public var clientApp: String?

            public var databaseName: String?

            public var hostName: String?

            public var lastTranStarted: Int64?

            public var lockMode: String?

            public var logUsed: Int64?

            public var loginName: String?

            public var objectOwned: String?

            public var objectRequested: String?

            public var ownMode: String?

            public var spid: Int64?

            public var sqlText: String?

            public var status: String?

            public var victim: Int64?

            public var waitMode: String?

            public var waitResource: String?

            public var waitResourceDescription: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.batchId != nil {
                    map["BatchId"] = self.batchId!
                }
                if self.blockProcessList != nil {
                    var tmp : [Any] = []
                    for k in self.blockProcessList! {
                        tmp.append(k.toMap())
                    }
                    map["BlockProcessList"] = tmp
                }
                if self.clientApp != nil {
                    map["ClientApp"] = self.clientApp!
                }
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.lastTranStarted != nil {
                    map["LastTranStarted"] = self.lastTranStarted!
                }
                if self.lockMode != nil {
                    map["LockMode"] = self.lockMode!
                }
                if self.logUsed != nil {
                    map["LogUsed"] = self.logUsed!
                }
                if self.loginName != nil {
                    map["LoginName"] = self.loginName!
                }
                if self.objectOwned != nil {
                    map["ObjectOwned"] = self.objectOwned!
                }
                if self.objectRequested != nil {
                    map["ObjectRequested"] = self.objectRequested!
                }
                if self.ownMode != nil {
                    map["OwnMode"] = self.ownMode!
                }
                if self.spid != nil {
                    map["Spid"] = self.spid!
                }
                if self.sqlText != nil {
                    map["SqlText"] = self.sqlText!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.victim != nil {
                    map["Victim"] = self.victim!
                }
                if self.waitMode != nil {
                    map["WaitMode"] = self.waitMode!
                }
                if self.waitResource != nil {
                    map["WaitResource"] = self.waitResource!
                }
                if self.waitResourceDescription != nil {
                    map["WaitResourceDescription"] = self.waitResourceDescription!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BatchId") {
                    self.batchId = dict["BatchId"] as! Int64
                }
                if dict.keys.contains("BlockProcessList") {
                    var tmp : [GetDeadLockDetailListResponseBody.Data.List.BlockProcessList] = []
                    for v in dict["BlockProcessList"] as! [Any] {
                        var model = GetDeadLockDetailListResponseBody.Data.List.BlockProcessList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.blockProcessList = tmp
                }
                if dict.keys.contains("ClientApp") {
                    self.clientApp = dict["ClientApp"] as! String
                }
                if dict.keys.contains("DatabaseName") {
                    self.databaseName = dict["DatabaseName"] as! String
                }
                if dict.keys.contains("HostName") {
                    self.hostName = dict["HostName"] as! String
                }
                if dict.keys.contains("LastTranStarted") {
                    self.lastTranStarted = dict["LastTranStarted"] as! Int64
                }
                if dict.keys.contains("LockMode") {
                    self.lockMode = dict["LockMode"] as! String
                }
                if dict.keys.contains("LogUsed") {
                    self.logUsed = dict["LogUsed"] as! Int64
                }
                if dict.keys.contains("LoginName") {
                    self.loginName = dict["LoginName"] as! String
                }
                if dict.keys.contains("ObjectOwned") {
                    self.objectOwned = dict["ObjectOwned"] as! String
                }
                if dict.keys.contains("ObjectRequested") {
                    self.objectRequested = dict["ObjectRequested"] as! String
                }
                if dict.keys.contains("OwnMode") {
                    self.ownMode = dict["OwnMode"] as! String
                }
                if dict.keys.contains("Spid") {
                    self.spid = dict["Spid"] as! Int64
                }
                if dict.keys.contains("SqlText") {
                    self.sqlText = dict["SqlText"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Victim") {
                    self.victim = dict["Victim"] as! Int64
                }
                if dict.keys.contains("WaitMode") {
                    self.waitMode = dict["WaitMode"] as! String
                }
                if dict.keys.contains("WaitResource") {
                    self.waitResource = dict["WaitResource"] as! String
                }
                if dict.keys.contains("WaitResourceDescription") {
                    self.waitResourceDescription = dict["WaitResourceDescription"] as! String
                }
            }
        }
        public var list: [GetDeadLockDetailListResponseBody.Data.List]?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [GetDeadLockDetailListResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetDeadLockDetailListResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetDeadLockDetailListResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetDeadLockDetailListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetDeadLockDetailListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDeadLockDetailListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDeadLockDetailListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDeadLockHistoryRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var nodeId: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var source: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class GetDeadLockHistoryResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var synchro: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchro != nil {
            map["Synchro"] = self.synchro!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Synchro") {
            self.synchro = dict["Synchro"] as! String
        }
    }
}

public class GetDeadLockHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDeadLockHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDeadLockHistoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDeadlockHistogramRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var nodeId: String?

    public var startTime: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class GetDeadlockHistogramResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var endTime: String?

        public var instanceId: String?

        public var lockNumber: Int32?

        public var nodeId: String?

        public var startTime: String?

        public var status: String?

        public var taskId: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.lockNumber != nil {
                map["LockNumber"] = self.lockNumber!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("LockNumber") {
                self.lockNumber = dict["LockNumber"] as! Int32
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var code: Int64?

    public var data: [GetDeadlockHistogramResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var tmp : [GetDeadlockHistogramResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetDeadlockHistogramResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDeadlockHistogramResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDeadlockHistogramResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDeadlockHistogramResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEndpointSwitchTaskRequest : Tea.TeaModel {
    public var taskId: String?

    public var uid: String?

    public var userId: String?

    public var context: String?

    public var accessKey: String?

    public var signature: String?

    public var skipAuth: String?

    public var timestamp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.context != nil {
            map["__context"] = self.context!
        }
        if self.accessKey != nil {
            map["accessKey"] = self.accessKey!
        }
        if self.signature != nil {
            map["signature"] = self.signature!
        }
        if self.skipAuth != nil {
            map["skipAuth"] = self.skipAuth!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("Uid") {
            self.uid = dict["Uid"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("__context") {
            self.context = dict["__context"] as! String
        }
        if dict.keys.contains("accessKey") {
            self.accessKey = dict["accessKey"] as! String
        }
        if dict.keys.contains("signature") {
            self.signature = dict["signature"] as! String
        }
        if dict.keys.contains("skipAuth") {
            self.skipAuth = dict["skipAuth"] as! String
        }
        if dict.keys.contains("timestamp") {
            self.timestamp = dict["timestamp"] as! String
        }
    }
}

public class GetEndpointSwitchTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var accountId: String?

        public var dbLinkId: Int64?

        public var errMsg: String?

        public var oriUuid: String?

        public var status: String?

        public var taskId: String?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.dbLinkId != nil {
                map["DbLinkId"] = self.dbLinkId!
            }
            if self.errMsg != nil {
                map["ErrMsg"] = self.errMsg!
            }
            if self.oriUuid != nil {
                map["OriUuid"] = self.oriUuid!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.uuid != nil {
                map["Uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountId") {
                self.accountId = dict["AccountId"] as! String
            }
            if dict.keys.contains("DbLinkId") {
                self.dbLinkId = dict["DbLinkId"] as! Int64
            }
            if dict.keys.contains("ErrMsg") {
                self.errMsg = dict["ErrMsg"] as! String
            }
            if dict.keys.contains("OriUuid") {
                self.oriUuid = dict["OriUuid"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("Uuid") {
                self.uuid = dict["Uuid"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetEndpointSwitchTaskResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var synchro: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchro != nil {
            map["Synchro"] = self.synchro!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetEndpointSwitchTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Synchro") {
            self.synchro = dict["Synchro"] as! String
        }
    }
}

public class GetEndpointSwitchTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEndpointSwitchTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEndpointSwitchTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetErrorRequestSampleRequest : Tea.TeaModel {
    public var dbName: String?

    public var end: Int64?

    public var instanceId: String?

    public var nodeId: String?

    public var sqlId: String?

    public var start: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("End") {
            self.end = dict["End"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("SqlId") {
            self.sqlId = dict["SqlId"] as! String
        }
        if dict.keys.contains("Start") {
            self.start = dict["Start"] as! Int64
        }
    }
}

public class GetErrorRequestSampleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var database: String?

        public var errorCode: String?

        public var instanceId: String?

        public var originHost: String?

        public var sql: String?

        public var sqlId: String?

        public var tables: [String]?

        public var timestamp: Int64?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.database != nil {
                map["database"] = self.database!
            }
            if self.errorCode != nil {
                map["errorCode"] = self.errorCode!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.originHost != nil {
                map["originHost"] = self.originHost!
            }
            if self.sql != nil {
                map["sql"] = self.sql!
            }
            if self.sqlId != nil {
                map["sqlId"] = self.sqlId!
            }
            if self.tables != nil {
                map["tables"] = self.tables!
            }
            if self.timestamp != nil {
                map["timestamp"] = self.timestamp!
            }
            if self.user != nil {
                map["user"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("database") {
                self.database = dict["database"] as! String
            }
            if dict.keys.contains("errorCode") {
                self.errorCode = dict["errorCode"] as! String
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("originHost") {
                self.originHost = dict["originHost"] as! String
            }
            if dict.keys.contains("sql") {
                self.sql = dict["sql"] as! String
            }
            if dict.keys.contains("sqlId") {
                self.sqlId = dict["sqlId"] as! String
            }
            if dict.keys.contains("tables") {
                self.tables = dict["tables"] as! [String]
            }
            if dict.keys.contains("timestamp") {
                self.timestamp = dict["timestamp"] as! Int64
            }
            if dict.keys.contains("user") {
                self.user = dict["user"] as! String
            }
        }
    }
    public var code: Int64?

    public var data: [GetErrorRequestSampleResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var tmp : [GetErrorRequestSampleResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetErrorRequestSampleResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetErrorRequestSampleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetErrorRequestSampleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetErrorRequestSampleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEventSubscriptionRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetEventSubscriptionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ContactGroups : Tea.TeaModel {
            public var contacts: String?

            public var description_: String?

            public var name: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contacts != nil {
                    map["contacts"] = self.contacts!
                }
                if self.description_ != nil {
                    map["description"] = self.description_!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.userId != nil {
                    map["userId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("contacts") {
                    self.contacts = dict["contacts"] as! String
                }
                if dict.keys.contains("description") {
                    self.description_ = dict["description"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("userId") {
                    self.userId = dict["userId"] as! String
                }
            }
        }
        public class Contacts : Tea.TeaModel {
            public var dingtalkHook: String?

            public var email: String?

            public var groups: [String]?

            public var isCmsReduplicated: Bool?

            public var name: String?

            public var phone: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dingtalkHook != nil {
                    map["dingtalkHook"] = self.dingtalkHook!
                }
                if self.email != nil {
                    map["email"] = self.email!
                }
                if self.groups != nil {
                    map["groups"] = self.groups!
                }
                if self.isCmsReduplicated != nil {
                    map["isCmsReduplicated"] = self.isCmsReduplicated!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.phone != nil {
                    map["phone"] = self.phone!
                }
                if self.userId != nil {
                    map["userId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("dingtalkHook") {
                    self.dingtalkHook = dict["dingtalkHook"] as! String
                }
                if dict.keys.contains("email") {
                    self.email = dict["email"] as! String
                }
                if dict.keys.contains("groups") {
                    self.groups = dict["groups"] as! [String]
                }
                if dict.keys.contains("isCmsReduplicated") {
                    self.isCmsReduplicated = dict["isCmsReduplicated"] as! Bool
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("phone") {
                    self.phone = dict["phone"] as! String
                }
                if dict.keys.contains("userId") {
                    self.userId = dict["userId"] as! String
                }
            }
        }
        public var active: Int32?

        public var channelType: String?

        public var contactGroupName: String?

        public var contactGroups: [GetEventSubscriptionResponseBody.Data.ContactGroups]?

        public var contactName: String?

        public var contacts: [GetEventSubscriptionResponseBody.Data.Contacts]?

        public var eventContext: String?

        public var eventSendGroup: [String]?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var id: Int64?

        public var instanceId: String?

        public var lang: String?

        public var level: String?

        public var minInterval: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.active != nil {
                map["active"] = self.active!
            }
            if self.channelType != nil {
                map["channelType"] = self.channelType!
            }
            if self.contactGroupName != nil {
                map["contactGroupName"] = self.contactGroupName!
            }
            if self.contactGroups != nil {
                var tmp : [Any] = []
                for k in self.contactGroups! {
                    tmp.append(k.toMap())
                }
                map["contactGroups"] = tmp
            }
            if self.contactName != nil {
                map["contactName"] = self.contactName!
            }
            if self.contacts != nil {
                var tmp : [Any] = []
                for k in self.contacts! {
                    tmp.append(k.toMap())
                }
                map["contacts"] = tmp
            }
            if self.eventContext != nil {
                map["eventContext"] = self.eventContext!
            }
            if self.eventSendGroup != nil {
                map["eventSendGroup"] = self.eventSendGroup!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.id != nil {
                map["id"] = self.id!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.lang != nil {
                map["lang"] = self.lang!
            }
            if self.level != nil {
                map["level"] = self.level!
            }
            if self.minInterval != nil {
                map["minInterval"] = self.minInterval!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("active") {
                self.active = dict["active"] as! Int32
            }
            if dict.keys.contains("channelType") {
                self.channelType = dict["channelType"] as! String
            }
            if dict.keys.contains("contactGroupName") {
                self.contactGroupName = dict["contactGroupName"] as! String
            }
            if dict.keys.contains("contactGroups") {
                var tmp : [GetEventSubscriptionResponseBody.Data.ContactGroups] = []
                for v in dict["contactGroups"] as! [Any] {
                    var model = GetEventSubscriptionResponseBody.Data.ContactGroups()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.contactGroups = tmp
            }
            if dict.keys.contains("contactName") {
                self.contactName = dict["contactName"] as! String
            }
            if dict.keys.contains("contacts") {
                var tmp : [GetEventSubscriptionResponseBody.Data.Contacts] = []
                for v in dict["contacts"] as! [Any] {
                    var model = GetEventSubscriptionResponseBody.Data.Contacts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.contacts = tmp
            }
            if dict.keys.contains("eventContext") {
                self.eventContext = dict["eventContext"] as! String
            }
            if dict.keys.contains("eventSendGroup") {
                self.eventSendGroup = dict["eventSendGroup"] as! [String]
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! Int64
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! Int64
            }
            if dict.keys.contains("id") {
                self.id = dict["id"] as! Int64
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("lang") {
                self.lang = dict["lang"] as! String
            }
            if dict.keys.contains("level") {
                self.level = dict["level"] as! String
            }
            if dict.keys.contains("minInterval") {
                self.minInterval = dict["minInterval"] as! String
            }
            if dict.keys.contains("userId") {
                self.userId = dict["userId"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetEventSubscriptionResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetEventSubscriptionResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetEventSubscriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEventSubscriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEventSubscriptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFullRequestOriginStatByInstanceIdRequest : Tea.TeaModel {
    public var asc: Bool?

    public var end: Int64?

    public var instanceId: String?

    public var nodeId: String?

    public var orderBy: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var role: String?

    public var sqlType: String?

    public var start: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asc != nil {
            map["Asc"] = self.asc!
        }
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.sqlType != nil {
            map["SqlType"] = self.sqlType!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Asc") {
            self.asc = dict["Asc"] as! Bool
        }
        if dict.keys.contains("End") {
            self.end = dict["End"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! String
        }
        if dict.keys.contains("SqlType") {
            self.sqlType = dict["SqlType"] as! String
        }
        if dict.keys.contains("Start") {
            self.start = dict["Start"] as! Int64
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GetFullRequestOriginStatByInstanceIdResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var avgExaminedRows: Double?

            public var avgFetchRows: Int64?

            public var avgLockWaitTime: Double?

            public var avgLogicalRead: Double?

            public var avgPhysicalAsyncRead: Int64?

            public var avgPhysicalSyncRead: Double?

            public var avgReturnedRows: Double?

            public var avgRows: Int64?

            public var avgRt: Double?

            public var avgSqlCount: Int64?

            public var avgUpdatedRows: Double?

            public var count: Int64?

            public var countRate: Double?

            public var database: String?

            public var errorCount: Int64?

            public var examinedRows: Int64?

            public var fetchRows: Int64?

            public var ip: String?

            public var key: String?

            public var lockWaitTime: Double?

            public var logicalRead: Int64?

            public var originHost: String?

            public var physicalAsyncRead: Int64?

            public var physicalSyncRead: Int64?

            public var port: Int64?

            public var rows: Int64?

            public var rtGreaterThanOneSecondCount: Int64?

            public var rtRate: Double?

            public var sqlCount: Int64?

            public var sumUpdatedRows: Int64?

            public var version: Int64?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgExaminedRows != nil {
                    map["AvgExaminedRows"] = self.avgExaminedRows!
                }
                if self.avgFetchRows != nil {
                    map["AvgFetchRows"] = self.avgFetchRows!
                }
                if self.avgLockWaitTime != nil {
                    map["AvgLockWaitTime"] = self.avgLockWaitTime!
                }
                if self.avgLogicalRead != nil {
                    map["AvgLogicalRead"] = self.avgLogicalRead!
                }
                if self.avgPhysicalAsyncRead != nil {
                    map["AvgPhysicalAsyncRead"] = self.avgPhysicalAsyncRead!
                }
                if self.avgPhysicalSyncRead != nil {
                    map["AvgPhysicalSyncRead"] = self.avgPhysicalSyncRead!
                }
                if self.avgReturnedRows != nil {
                    map["AvgReturnedRows"] = self.avgReturnedRows!
                }
                if self.avgRows != nil {
                    map["AvgRows"] = self.avgRows!
                }
                if self.avgRt != nil {
                    map["AvgRt"] = self.avgRt!
                }
                if self.avgSqlCount != nil {
                    map["AvgSqlCount"] = self.avgSqlCount!
                }
                if self.avgUpdatedRows != nil {
                    map["AvgUpdatedRows"] = self.avgUpdatedRows!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.countRate != nil {
                    map["CountRate"] = self.countRate!
                }
                if self.database != nil {
                    map["Database"] = self.database!
                }
                if self.errorCount != nil {
                    map["ErrorCount"] = self.errorCount!
                }
                if self.examinedRows != nil {
                    map["ExaminedRows"] = self.examinedRows!
                }
                if self.fetchRows != nil {
                    map["FetchRows"] = self.fetchRows!
                }
                if self.ip != nil {
                    map["Ip"] = self.ip!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.lockWaitTime != nil {
                    map["LockWaitTime"] = self.lockWaitTime!
                }
                if self.logicalRead != nil {
                    map["LogicalRead"] = self.logicalRead!
                }
                if self.originHost != nil {
                    map["OriginHost"] = self.originHost!
                }
                if self.physicalAsyncRead != nil {
                    map["PhysicalAsyncRead"] = self.physicalAsyncRead!
                }
                if self.physicalSyncRead != nil {
                    map["PhysicalSyncRead"] = self.physicalSyncRead!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.rows != nil {
                    map["Rows"] = self.rows!
                }
                if self.rtGreaterThanOneSecondCount != nil {
                    map["RtGreaterThanOneSecondCount"] = self.rtGreaterThanOneSecondCount!
                }
                if self.rtRate != nil {
                    map["RtRate"] = self.rtRate!
                }
                if self.sqlCount != nil {
                    map["SqlCount"] = self.sqlCount!
                }
                if self.sumUpdatedRows != nil {
                    map["SumUpdatedRows"] = self.sumUpdatedRows!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvgExaminedRows") {
                    self.avgExaminedRows = dict["AvgExaminedRows"] as! Double
                }
                if dict.keys.contains("AvgFetchRows") {
                    self.avgFetchRows = dict["AvgFetchRows"] as! Int64
                }
                if dict.keys.contains("AvgLockWaitTime") {
                    self.avgLockWaitTime = dict["AvgLockWaitTime"] as! Double
                }
                if dict.keys.contains("AvgLogicalRead") {
                    self.avgLogicalRead = dict["AvgLogicalRead"] as! Double
                }
                if dict.keys.contains("AvgPhysicalAsyncRead") {
                    self.avgPhysicalAsyncRead = dict["AvgPhysicalAsyncRead"] as! Int64
                }
                if dict.keys.contains("AvgPhysicalSyncRead") {
                    self.avgPhysicalSyncRead = dict["AvgPhysicalSyncRead"] as! Double
                }
                if dict.keys.contains("AvgReturnedRows") {
                    self.avgReturnedRows = dict["AvgReturnedRows"] as! Double
                }
                if dict.keys.contains("AvgRows") {
                    self.avgRows = dict["AvgRows"] as! Int64
                }
                if dict.keys.contains("AvgRt") {
                    self.avgRt = dict["AvgRt"] as! Double
                }
                if dict.keys.contains("AvgSqlCount") {
                    self.avgSqlCount = dict["AvgSqlCount"] as! Int64
                }
                if dict.keys.contains("AvgUpdatedRows") {
                    self.avgUpdatedRows = dict["AvgUpdatedRows"] as! Double
                }
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("CountRate") {
                    self.countRate = dict["CountRate"] as! Double
                }
                if dict.keys.contains("Database") {
                    self.database = dict["Database"] as! String
                }
                if dict.keys.contains("ErrorCount") {
                    self.errorCount = dict["ErrorCount"] as! Int64
                }
                if dict.keys.contains("ExaminedRows") {
                    self.examinedRows = dict["ExaminedRows"] as! Int64
                }
                if dict.keys.contains("FetchRows") {
                    self.fetchRows = dict["FetchRows"] as! Int64
                }
                if dict.keys.contains("Ip") {
                    self.ip = dict["Ip"] as! String
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("LockWaitTime") {
                    self.lockWaitTime = dict["LockWaitTime"] as! Double
                }
                if dict.keys.contains("LogicalRead") {
                    self.logicalRead = dict["LogicalRead"] as! Int64
                }
                if dict.keys.contains("OriginHost") {
                    self.originHost = dict["OriginHost"] as! String
                }
                if dict.keys.contains("PhysicalAsyncRead") {
                    self.physicalAsyncRead = dict["PhysicalAsyncRead"] as! Int64
                }
                if dict.keys.contains("PhysicalSyncRead") {
                    self.physicalSyncRead = dict["PhysicalSyncRead"] as! Int64
                }
                if dict.keys.contains("Port") {
                    self.port = dict["Port"] as! Int64
                }
                if dict.keys.contains("Rows") {
                    self.rows = dict["Rows"] as! Int64
                }
                if dict.keys.contains("RtGreaterThanOneSecondCount") {
                    self.rtGreaterThanOneSecondCount = dict["RtGreaterThanOneSecondCount"] as! Int64
                }
                if dict.keys.contains("RtRate") {
                    self.rtRate = dict["RtRate"] as! Double
                }
                if dict.keys.contains("SqlCount") {
                    self.sqlCount = dict["SqlCount"] as! Int64
                }
                if dict.keys.contains("SumUpdatedRows") {
                    self.sumUpdatedRows = dict["SumUpdatedRows"] as! Int64
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! Int64
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var list: [GetFullRequestOriginStatByInstanceIdResponseBody.Data.List]?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [GetFullRequestOriginStatByInstanceIdResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetFullRequestOriginStatByInstanceIdResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: Int64?

    public var data: GetFullRequestOriginStatByInstanceIdResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = GetFullRequestOriginStatByInstanceIdResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetFullRequestOriginStatByInstanceIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFullRequestOriginStatByInstanceIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFullRequestOriginStatByInstanceIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFullRequestSampleByInstanceIdRequest : Tea.TeaModel {
    public var end: Int64?

    public var instanceId: String?

    public var role: String?

    public var sqlId: String?

    public var start: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("End") {
            self.end = dict["End"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! String
        }
        if dict.keys.contains("SqlId") {
            self.sqlId = dict["SqlId"] as! String
        }
        if dict.keys.contains("Start") {
            self.start = dict["Start"] as! Int64
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GetFullRequestSampleByInstanceIdResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var database: String?

        public var frows: Int64?

        public var lockWaitTime: Double?

        public var logicalRead: Double?

        public var originHost: String?

        public var physicalAsyncRead: Double?

        public var physicalSyncRead: Double?

        public var rows: Int64?

        public var rowsExamined: Int64?

        public var rowsReturned: Int64?

        public var rt: Double?

        public var scanRows: Int64?

        public var scnt: Int64?

        public var sql: String?

        public var sqlId: String?

        public var sqlType: String?

        public var timestamp: Int64?

        public var updateRows: Int64?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.database != nil {
                map["Database"] = self.database!
            }
            if self.frows != nil {
                map["Frows"] = self.frows!
            }
            if self.lockWaitTime != nil {
                map["LockWaitTime"] = self.lockWaitTime!
            }
            if self.logicalRead != nil {
                map["LogicalRead"] = self.logicalRead!
            }
            if self.originHost != nil {
                map["OriginHost"] = self.originHost!
            }
            if self.physicalAsyncRead != nil {
                map["PhysicalAsyncRead"] = self.physicalAsyncRead!
            }
            if self.physicalSyncRead != nil {
                map["PhysicalSyncRead"] = self.physicalSyncRead!
            }
            if self.rows != nil {
                map["Rows"] = self.rows!
            }
            if self.rowsExamined != nil {
                map["RowsExamined"] = self.rowsExamined!
            }
            if self.rowsReturned != nil {
                map["RowsReturned"] = self.rowsReturned!
            }
            if self.rt != nil {
                map["Rt"] = self.rt!
            }
            if self.scanRows != nil {
                map["ScanRows"] = self.scanRows!
            }
            if self.scnt != nil {
                map["Scnt"] = self.scnt!
            }
            if self.sql != nil {
                map["Sql"] = self.sql!
            }
            if self.sqlId != nil {
                map["SqlId"] = self.sqlId!
            }
            if self.sqlType != nil {
                map["SqlType"] = self.sqlType!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.updateRows != nil {
                map["UpdateRows"] = self.updateRows!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Database") {
                self.database = dict["Database"] as! String
            }
            if dict.keys.contains("Frows") {
                self.frows = dict["Frows"] as! Int64
            }
            if dict.keys.contains("LockWaitTime") {
                self.lockWaitTime = dict["LockWaitTime"] as! Double
            }
            if dict.keys.contains("LogicalRead") {
                self.logicalRead = dict["LogicalRead"] as! Double
            }
            if dict.keys.contains("OriginHost") {
                self.originHost = dict["OriginHost"] as! String
            }
            if dict.keys.contains("PhysicalAsyncRead") {
                self.physicalAsyncRead = dict["PhysicalAsyncRead"] as! Double
            }
            if dict.keys.contains("PhysicalSyncRead") {
                self.physicalSyncRead = dict["PhysicalSyncRead"] as! Double
            }
            if dict.keys.contains("Rows") {
                self.rows = dict["Rows"] as! Int64
            }
            if dict.keys.contains("RowsExamined") {
                self.rowsExamined = dict["RowsExamined"] as! Int64
            }
            if dict.keys.contains("RowsReturned") {
                self.rowsReturned = dict["RowsReturned"] as! Int64
            }
            if dict.keys.contains("Rt") {
                self.rt = dict["Rt"] as! Double
            }
            if dict.keys.contains("ScanRows") {
                self.scanRows = dict["ScanRows"] as! Int64
            }
            if dict.keys.contains("Scnt") {
                self.scnt = dict["Scnt"] as! Int64
            }
            if dict.keys.contains("Sql") {
                self.sql = dict["Sql"] as! String
            }
            if dict.keys.contains("SqlId") {
                self.sqlId = dict["SqlId"] as! String
            }
            if dict.keys.contains("SqlType") {
                self.sqlType = dict["SqlType"] as! String
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
            if dict.keys.contains("UpdateRows") {
                self.updateRows = dict["UpdateRows"] as! Int64
            }
            if dict.keys.contains("User") {
                self.user = dict["User"] as! String
            }
        }
    }
    public var code: Int64?

    public var data: [GetFullRequestSampleByInstanceIdResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var tmp : [GetFullRequestSampleByInstanceIdResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetFullRequestSampleByInstanceIdResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetFullRequestSampleByInstanceIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFullRequestSampleByInstanceIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFullRequestSampleByInstanceIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetFullRequestStatResultByInstanceIdRequest : Tea.TeaModel {
    public var asc: Bool?

    public var dbName: String?

    public var end: Int64?

    public var instanceId: String?

    public var keyword: String?

    public var nodeId: String?

    public var orderBy: String?

    public var originHost: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var role: String?

    public var sqlId: String?

    public var sqlType: String?

    public var start: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asc != nil {
            map["Asc"] = self.asc!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.originHost != nil {
            map["OriginHost"] = self.originHost!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.sqlType != nil {
            map["SqlType"] = self.sqlType!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Asc") {
            self.asc = dict["Asc"] as! Bool
        }
        if dict.keys.contains("DbName") {
            self.dbName = dict["DbName"] as! String
        }
        if dict.keys.contains("End") {
            self.end = dict["End"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Keyword") {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("OriginHost") {
            self.originHost = dict["OriginHost"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! String
        }
        if dict.keys.contains("SqlId") {
            self.sqlId = dict["SqlId"] as! String
        }
        if dict.keys.contains("SqlType") {
            self.sqlType = dict["SqlType"] as! String
        }
        if dict.keys.contains("Start") {
            self.start = dict["Start"] as! Int64
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GetFullRequestStatResultByInstanceIdResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class List : Tea.TeaModel {
                public var avgExaminedRows: Double?

                public var avgFetchRows: Int64?

                public var avgLockWaitTime: Double?

                public var avgLogicalRead: Double?

                public var avgPhysicalAsyncRead: Int64?

                public var avgPhysicalSyncRead: Int64?

                public var avgReturnedRows: Double?

                public var avgRt: Double?

                public var avgSqlCount: Int64?

                public var avgUpdatedRows: Int64?

                public var count: Int64?

                public var countRate: Double?

                public var database: String?

                public var errorCount: Int64?

                public var examinedRows: Int64?

                public var fetchRows: Int64?

                public var ip: String?

                public var lockWaitTime: Double?

                public var logicalRead: Int64?

                public var physicalAsyncRead: Int64?

                public var physicalSyncRead: Int64?

                public var port: Int64?

                public var psql: String?

                public var rows: Int64?

                public var rtGreaterThanOneSecondCount: Int64?

                public var rtRate: Double?

                public var sqlCount: Int64?

                public var sqlId: String?

                public var sumUpdatedRows: Int64?

                public var tables: [String]?

                public var version: Int64?

                public var vpcId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgExaminedRows != nil {
                        map["AvgExaminedRows"] = self.avgExaminedRows!
                    }
                    if self.avgFetchRows != nil {
                        map["AvgFetchRows"] = self.avgFetchRows!
                    }
                    if self.avgLockWaitTime != nil {
                        map["AvgLockWaitTime"] = self.avgLockWaitTime!
                    }
                    if self.avgLogicalRead != nil {
                        map["AvgLogicalRead"] = self.avgLogicalRead!
                    }
                    if self.avgPhysicalAsyncRead != nil {
                        map["AvgPhysicalAsyncRead"] = self.avgPhysicalAsyncRead!
                    }
                    if self.avgPhysicalSyncRead != nil {
                        map["AvgPhysicalSyncRead"] = self.avgPhysicalSyncRead!
                    }
                    if self.avgReturnedRows != nil {
                        map["AvgReturnedRows"] = self.avgReturnedRows!
                    }
                    if self.avgRt != nil {
                        map["AvgRt"] = self.avgRt!
                    }
                    if self.avgSqlCount != nil {
                        map["AvgSqlCount"] = self.avgSqlCount!
                    }
                    if self.avgUpdatedRows != nil {
                        map["AvgUpdatedRows"] = self.avgUpdatedRows!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.countRate != nil {
                        map["CountRate"] = self.countRate!
                    }
                    if self.database != nil {
                        map["Database"] = self.database!
                    }
                    if self.errorCount != nil {
                        map["ErrorCount"] = self.errorCount!
                    }
                    if self.examinedRows != nil {
                        map["ExaminedRows"] = self.examinedRows!
                    }
                    if self.fetchRows != nil {
                        map["FetchRows"] = self.fetchRows!
                    }
                    if self.ip != nil {
                        map["Ip"] = self.ip!
                    }
                    if self.lockWaitTime != nil {
                        map["LockWaitTime"] = self.lockWaitTime!
                    }
                    if self.logicalRead != nil {
                        map["LogicalRead"] = self.logicalRead!
                    }
                    if self.physicalAsyncRead != nil {
                        map["PhysicalAsyncRead"] = self.physicalAsyncRead!
                    }
                    if self.physicalSyncRead != nil {
                        map["PhysicalSyncRead"] = self.physicalSyncRead!
                    }
                    if self.port != nil {
                        map["Port"] = self.port!
                    }
                    if self.psql != nil {
                        map["Psql"] = self.psql!
                    }
                    if self.rows != nil {
                        map["Rows"] = self.rows!
                    }
                    if self.rtGreaterThanOneSecondCount != nil {
                        map["RtGreaterThanOneSecondCount"] = self.rtGreaterThanOneSecondCount!
                    }
                    if self.rtRate != nil {
                        map["RtRate"] = self.rtRate!
                    }
                    if self.sqlCount != nil {
                        map["SqlCount"] = self.sqlCount!
                    }
                    if self.sqlId != nil {
                        map["SqlId"] = self.sqlId!
                    }
                    if self.sumUpdatedRows != nil {
                        map["SumUpdatedRows"] = self.sumUpdatedRows!
                    }
                    if self.tables != nil {
                        map["Tables"] = self.tables!
                    }
                    if self.version != nil {
                        map["Version"] = self.version!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvgExaminedRows") {
                        self.avgExaminedRows = dict["AvgExaminedRows"] as! Double
                    }
                    if dict.keys.contains("AvgFetchRows") {
                        self.avgFetchRows = dict["AvgFetchRows"] as! Int64
                    }
                    if dict.keys.contains("AvgLockWaitTime") {
                        self.avgLockWaitTime = dict["AvgLockWaitTime"] as! Double
                    }
                    if dict.keys.contains("AvgLogicalRead") {
                        self.avgLogicalRead = dict["AvgLogicalRead"] as! Double
                    }
                    if dict.keys.contains("AvgPhysicalAsyncRead") {
                        self.avgPhysicalAsyncRead = dict["AvgPhysicalAsyncRead"] as! Int64
                    }
                    if dict.keys.contains("AvgPhysicalSyncRead") {
                        self.avgPhysicalSyncRead = dict["AvgPhysicalSyncRead"] as! Int64
                    }
                    if dict.keys.contains("AvgReturnedRows") {
                        self.avgReturnedRows = dict["AvgReturnedRows"] as! Double
                    }
                    if dict.keys.contains("AvgRt") {
                        self.avgRt = dict["AvgRt"] as! Double
                    }
                    if dict.keys.contains("AvgSqlCount") {
                        self.avgSqlCount = dict["AvgSqlCount"] as! Int64
                    }
                    if dict.keys.contains("AvgUpdatedRows") {
                        self.avgUpdatedRows = dict["AvgUpdatedRows"] as! Int64
                    }
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int64
                    }
                    if dict.keys.contains("CountRate") {
                        self.countRate = dict["CountRate"] as! Double
                    }
                    if dict.keys.contains("Database") {
                        self.database = dict["Database"] as! String
                    }
                    if dict.keys.contains("ErrorCount") {
                        self.errorCount = dict["ErrorCount"] as! Int64
                    }
                    if dict.keys.contains("ExaminedRows") {
                        self.examinedRows = dict["ExaminedRows"] as! Int64
                    }
                    if dict.keys.contains("FetchRows") {
                        self.fetchRows = dict["FetchRows"] as! Int64
                    }
                    if dict.keys.contains("Ip") {
                        self.ip = dict["Ip"] as! String
                    }
                    if dict.keys.contains("LockWaitTime") {
                        self.lockWaitTime = dict["LockWaitTime"] as! Double
                    }
                    if dict.keys.contains("LogicalRead") {
                        self.logicalRead = dict["LogicalRead"] as! Int64
                    }
                    if dict.keys.contains("PhysicalAsyncRead") {
                        self.physicalAsyncRead = dict["PhysicalAsyncRead"] as! Int64
                    }
                    if dict.keys.contains("PhysicalSyncRead") {
                        self.physicalSyncRead = dict["PhysicalSyncRead"] as! Int64
                    }
                    if dict.keys.contains("Port") {
                        self.port = dict["Port"] as! Int64
                    }
                    if dict.keys.contains("Psql") {
                        self.psql = dict["Psql"] as! String
                    }
                    if dict.keys.contains("Rows") {
                        self.rows = dict["Rows"] as! Int64
                    }
                    if dict.keys.contains("RtGreaterThanOneSecondCount") {
                        self.rtGreaterThanOneSecondCount = dict["RtGreaterThanOneSecondCount"] as! Int64
                    }
                    if dict.keys.contains("RtRate") {
                        self.rtRate = dict["RtRate"] as! Double
                    }
                    if dict.keys.contains("SqlCount") {
                        self.sqlCount = dict["SqlCount"] as! Int64
                    }
                    if dict.keys.contains("SqlId") {
                        self.sqlId = dict["SqlId"] as! String
                    }
                    if dict.keys.contains("SumUpdatedRows") {
                        self.sumUpdatedRows = dict["SumUpdatedRows"] as! Int64
                    }
                    if dict.keys.contains("Tables") {
                        self.tables = dict["Tables"] as! [String]
                    }
                    if dict.keys.contains("Version") {
                        self.version = dict["Version"] as! Int64
                    }
                    if dict.keys.contains("VpcId") {
                        self.vpcId = dict["VpcId"] as! String
                    }
                }
            }
            public var list: [GetFullRequestStatResultByInstanceIdResponseBody.Data.Result.List]?

            public var total: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.list != nil {
                    var tmp : [Any] = []
                    for k in self.list! {
                        tmp.append(k.toMap())
                    }
                    map["List"] = tmp
                }
                if self.total != nil {
                    map["Total"] = self.total!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("List") {
                    var tmp : [GetFullRequestStatResultByInstanceIdResponseBody.Data.Result.List] = []
                    for v in dict["List"] as! [Any] {
                        var model = GetFullRequestStatResultByInstanceIdResponseBody.Data.Result.List()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.list = tmp
                }
                if dict.keys.contains("Total") {
                    self.total = dict["Total"] as! Int64
                }
            }
        }
        public var fail: Bool?

        public var isFinish: Bool?

        public var result: GetFullRequestStatResultByInstanceIdResponseBody.Data.Result?

        public var resultId: String?

        public var state: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.result?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fail != nil {
                map["Fail"] = self.fail!
            }
            if self.isFinish != nil {
                map["IsFinish"] = self.isFinish!
            }
            if self.result != nil {
                map["Result"] = self.result?.toMap()
            }
            if self.resultId != nil {
                map["ResultId"] = self.resultId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Fail") {
                self.fail = dict["Fail"] as! Bool
            }
            if dict.keys.contains("IsFinish") {
                self.isFinish = dict["IsFinish"] as! Bool
            }
            if dict.keys.contains("Result") {
                var model = GetFullRequestStatResultByInstanceIdResponseBody.Data.Result()
                model.fromMap(dict["Result"] as! [String: Any])
                self.result = model
            }
            if dict.keys.contains("ResultId") {
                self.resultId = dict["ResultId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
        }
    }
    public var code: Int64?

    public var data: GetFullRequestStatResultByInstanceIdResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = GetFullRequestStatResultByInstanceIdResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetFullRequestStatResultByInstanceIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetFullRequestStatResultByInstanceIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetFullRequestStatResultByInstanceIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetHDMAliyunResourceSyncResultRequest : Tea.TeaModel {
    public var taskId: String?

    public var uid: String?

    public var userId: String?

    public var context: String?

    public var accessKey: String?

    public var signature: String?

    public var skipAuth: String?

    public var timestamp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.context != nil {
            map["__context"] = self.context!
        }
        if self.accessKey != nil {
            map["accessKey"] = self.accessKey!
        }
        if self.signature != nil {
            map["signature"] = self.signature!
        }
        if self.skipAuth != nil {
            map["skipAuth"] = self.skipAuth!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("Uid") {
            self.uid = dict["Uid"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("__context") {
            self.context = dict["__context"] as! String
        }
        if dict.keys.contains("accessKey") {
            self.accessKey = dict["accessKey"] as! String
        }
        if dict.keys.contains("signature") {
            self.signature = dict["signature"] as! String
        }
        if dict.keys.contains("skipAuth") {
            self.skipAuth = dict["skipAuth"] as! String
        }
        if dict.keys.contains("timestamp") {
            self.timestamp = dict["timestamp"] as! String
        }
    }
}

public class GetHDMAliyunResourceSyncResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SubResults : Tea.TeaModel {
            public class ResourceSyncSubResult : Tea.TeaModel {
                public var errMsg: String?

                public var resourceType: String?

                public var success: Bool?

                public var syncCount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errMsg != nil {
                        map["ErrMsg"] = self.errMsg!
                    }
                    if self.resourceType != nil {
                        map["ResourceType"] = self.resourceType!
                    }
                    if self.success != nil {
                        map["Success"] = self.success!
                    }
                    if self.syncCount != nil {
                        map["SyncCount"] = self.syncCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrMsg") {
                        self.errMsg = dict["ErrMsg"] as! String
                    }
                    if dict.keys.contains("ResourceType") {
                        self.resourceType = dict["ResourceType"] as! String
                    }
                    if dict.keys.contains("Success") {
                        self.success = dict["Success"] as! Bool
                    }
                    if dict.keys.contains("SyncCount") {
                        self.syncCount = dict["SyncCount"] as! Int32
                    }
                }
            }
            public var resourceSyncSubResult: [GetHDMAliyunResourceSyncResultResponseBody.Data.SubResults.ResourceSyncSubResult]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceSyncSubResult != nil {
                    var tmp : [Any] = []
                    for k in self.resourceSyncSubResult! {
                        tmp.append(k.toMap())
                    }
                    map["ResourceSyncSubResult"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceSyncSubResult") {
                    var tmp : [GetHDMAliyunResourceSyncResultResponseBody.Data.SubResults.ResourceSyncSubResult] = []
                    for v in dict["ResourceSyncSubResult"] as! [Any] {
                        var model = GetHDMAliyunResourceSyncResultResponseBody.Data.SubResults.ResourceSyncSubResult()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.resourceSyncSubResult = tmp
                }
            }
        }
        public var errorMsg: String?

        public var results: String?

        public var subResults: GetHDMAliyunResourceSyncResultResponseBody.Data.SubResults?

        public var syncStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.subResults?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorMsg != nil {
                map["ErrorMsg"] = self.errorMsg!
            }
            if self.results != nil {
                map["Results"] = self.results!
            }
            if self.subResults != nil {
                map["SubResults"] = self.subResults?.toMap()
            }
            if self.syncStatus != nil {
                map["SyncStatus"] = self.syncStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorMsg") {
                self.errorMsg = dict["ErrorMsg"] as! String
            }
            if dict.keys.contains("Results") {
                self.results = dict["Results"] as! String
            }
            if dict.keys.contains("SubResults") {
                var model = GetHDMAliyunResourceSyncResultResponseBody.Data.SubResults()
                model.fromMap(dict["SubResults"] as! [String: Any])
                self.subResults = model
            }
            if dict.keys.contains("SyncStatus") {
                self.syncStatus = dict["SyncStatus"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetHDMAliyunResourceSyncResultResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var synchro: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchro != nil {
            map["Synchro"] = self.synchro!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetHDMAliyunResourceSyncResultResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Synchro") {
            self.synchro = dict["Synchro"] as! String
        }
    }
}

public class GetHDMAliyunResourceSyncResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHDMAliyunResourceSyncResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetHDMAliyunResourceSyncResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetHDMLastAliyunResourceSyncResultRequest : Tea.TeaModel {
    public var uid: String?

    public var userId: String?

    public var context: String?

    public var accessKey: String?

    public var signature: String?

    public var skipAuth: String?

    public var timestamp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.context != nil {
            map["__context"] = self.context!
        }
        if self.accessKey != nil {
            map["accessKey"] = self.accessKey!
        }
        if self.signature != nil {
            map["signature"] = self.signature!
        }
        if self.skipAuth != nil {
            map["skipAuth"] = self.skipAuth!
        }
        if self.timestamp != nil {
            map["timestamp"] = self.timestamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Uid") {
            self.uid = dict["Uid"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("__context") {
            self.context = dict["__context"] as! String
        }
        if dict.keys.contains("accessKey") {
            self.accessKey = dict["accessKey"] as! String
        }
        if dict.keys.contains("signature") {
            self.signature = dict["signature"] as! String
        }
        if dict.keys.contains("skipAuth") {
            self.skipAuth = dict["skipAuth"] as! String
        }
        if dict.keys.contains("timestamp") {
            self.timestamp = dict["timestamp"] as! String
        }
    }
}

public class GetHDMLastAliyunResourceSyncResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SubResults : Tea.TeaModel {
            public class ResourceSyncSubResult : Tea.TeaModel {
                public var errMsg: String?

                public var resourceType: String?

                public var success: Bool?

                public var syncCount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errMsg != nil {
                        map["ErrMsg"] = self.errMsg!
                    }
                    if self.resourceType != nil {
                        map["ResourceType"] = self.resourceType!
                    }
                    if self.success != nil {
                        map["Success"] = self.success!
                    }
                    if self.syncCount != nil {
                        map["SyncCount"] = self.syncCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrMsg") {
                        self.errMsg = dict["ErrMsg"] as! String
                    }
                    if dict.keys.contains("ResourceType") {
                        self.resourceType = dict["ResourceType"] as! String
                    }
                    if dict.keys.contains("Success") {
                        self.success = dict["Success"] as! Bool
                    }
                    if dict.keys.contains("SyncCount") {
                        self.syncCount = dict["SyncCount"] as! Int32
                    }
                }
            }
            public var resourceSyncSubResult: [GetHDMLastAliyunResourceSyncResultResponseBody.Data.SubResults.ResourceSyncSubResult]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceSyncSubResult != nil {
                    var tmp : [Any] = []
                    for k in self.resourceSyncSubResult! {
                        tmp.append(k.toMap())
                    }
                    map["ResourceSyncSubResult"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceSyncSubResult") {
                    var tmp : [GetHDMLastAliyunResourceSyncResultResponseBody.Data.SubResults.ResourceSyncSubResult] = []
                    for v in dict["ResourceSyncSubResult"] as! [Any] {
                        var model = GetHDMLastAliyunResourceSyncResultResponseBody.Data.SubResults.ResourceSyncSubResult()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.resourceSyncSubResult = tmp
                }
            }
        }
        public var errorMsg: String?

        public var results: String?

        public var subResults: GetHDMLastAliyunResourceSyncResultResponseBody.Data.SubResults?

        public var syncStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.subResults?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorMsg != nil {
                map["ErrorMsg"] = self.errorMsg!
            }
            if self.results != nil {
                map["Results"] = self.results!
            }
            if self.subResults != nil {
                map["SubResults"] = self.subResults?.toMap()
            }
            if self.syncStatus != nil {
                map["SyncStatus"] = self.syncStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorMsg") {
                self.errorMsg = dict["ErrorMsg"] as! String
            }
            if dict.keys.contains("Results") {
                self.results = dict["Results"] as! String
            }
            if dict.keys.contains("SubResults") {
                var model = GetHDMLastAliyunResourceSyncResultResponseBody.Data.SubResults()
                model.fromMap(dict["SubResults"] as! [String: Any])
                self.subResults = model
            }
            if dict.keys.contains("SyncStatus") {
                self.syncStatus = dict["SyncStatus"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetHDMLastAliyunResourceSyncResultResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public var synchro: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.synchro != nil {
            map["Synchro"] = self.synchro!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetHDMLastAliyunResourceSyncResultResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
        if dict.keys.contains("Synchro") {
            self.synchro = dict["Synchro"] as! String
        }
    }
}

public class GetHDMLastAliyunResourceSyncResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHDMLastAliyunResourceSyncResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetHDMLastAliyunResourceSyncResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceInspectionsRequest : Tea.TeaModel {
    public var endTime: String?

    public var engine: String?

    public var instanceArea: String?

    public var pageNo: String?

    public var pageSize: String?

    public var resourceGroupId: String?

    public var searchMap: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceArea != nil {
            map["InstanceArea"] = self.instanceArea!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.searchMap != nil {
            map["SearchMap"] = self.searchMap!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("Engine") {
            self.engine = dict["Engine"] as! String
        }
        if dict.keys.contains("InstanceArea") {
            self.instanceArea = dict["InstanceArea"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SearchMap") {
            self.searchMap = dict["SearchMap"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class GetInstanceInspectionsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class AutoFunction : Tea.TeaModel {
                public var autoIndex: Int32?

                public var autoLimitedSql: Int32?

                public var autoResourceOptimize: Int32?

                public var autoScale: Int32?

                public var eventSubscription: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.autoIndex != nil {
                        map["AutoIndex"] = self.autoIndex!
                    }
                    if self.autoLimitedSql != nil {
                        map["AutoLimitedSql"] = self.autoLimitedSql!
                    }
                    if self.autoResourceOptimize != nil {
                        map["AutoResourceOptimize"] = self.autoResourceOptimize!
                    }
                    if self.autoScale != nil {
                        map["AutoScale"] = self.autoScale!
                    }
                    if self.eventSubscription != nil {
                        map["EventSubscription"] = self.eventSubscription!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AutoIndex") {
                        self.autoIndex = dict["AutoIndex"] as! Int32
                    }
                    if dict.keys.contains("AutoLimitedSql") {
                        self.autoLimitedSql = dict["AutoLimitedSql"] as! Int32
                    }
                    if dict.keys.contains("AutoResourceOptimize") {
                        self.autoResourceOptimize = dict["AutoResourceOptimize"] as! Int32
                    }
                    if dict.keys.contains("AutoScale") {
                        self.autoScale = dict["AutoScale"] as! Int32
                    }
                    if dict.keys.contains("EventSubscription") {
                        self.eventSubscription = dict["EventSubscription"] as! Int32
                    }
                }
            }
            public class Instance : Tea.TeaModel {
                public var accountId: String?

                public var category: String?

                public var cpu: String?

                public var engine: String?

                public var engineVersion: String?

                public var instanceAlias: String?

                public var instanceArea: String?

                public var instanceClass: String?

                public var instanceId: String?

                public var memory: Int32?

                public var networkType: String?

                public var nodeId: String?

                public var region: String?

                public var storage: Int32?

                public var uuid: String?

                public var vpcId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accountId != nil {
                        map["AccountId"] = self.accountId!
                    }
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.cpu != nil {
                        map["Cpu"] = self.cpu!
                    }
                    if self.engine != nil {
                        map["Engine"] = self.engine!
                    }
                    if self.engineVersion != nil {
                        map["EngineVersion"] = self.engineVersion!
                    }
                    if self.instanceAlias != nil {
                        map["InstanceAlias"] = self.instanceAlias!
                    }
                    if self.instanceArea != nil {
                        map["InstanceArea"] = self.instanceArea!
                    }
                    if self.instanceClass != nil {
                        map["InstanceClass"] = self.instanceClass!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.memory != nil {
                        map["Memory"] = self.memory!
                    }
                    if self.networkType != nil {
                        map["NetworkType"] = self.networkType!
                    }
                    if self.nodeId != nil {
                        map["NodeId"] = self.nodeId!
                    }
                    if self.region != nil {
                        map["Region"] = self.region!
                    }
                    if self.storage != nil {
                        map["Storage"] = self.storage!
                    }
                    if self.uuid != nil {
                        map["Uuid"] = self.uuid!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AccountId") {
                        self.accountId = dict["AccountId"] as! String
                    }
                    if dict.keys.contains("Category") {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("Cpu") {
                        self.cpu = dict["Cpu"] as! String
                    }
                    if dict.keys.contains("Engine") {
                        self.engine = dict["Engine"] as! String
                    }
                    if dict.keys.contains("EngineVersion") {
                        self.engineVersion = dict["EngineVersion"] as! String
                    }
                    if dict.keys.contains("InstanceAlias") {
                        self.instanceAlias = dict["InstanceAlias"] as! String
                    }
                    if dict.keys.contains("InstanceArea") {
                        self.instanceArea = dict["InstanceArea"] as! String
                    }
                    if dict.keys.contains("InstanceClass") {
                        self.instanceClass = dict["InstanceClass"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("Memory") {
                        self.memory = dict["Memory"] as! Int32
                    }
                    if dict.keys.contains("NetworkType") {
                        self.networkType = dict["NetworkType"] as! String
                    }
                    if dict.keys.contains("NodeId") {
                        self.nodeId = dict["NodeId"] as! String
                    }
                    if dict.keys.contains("Region") {
                        self.region = dict["Region"] as! String
                    }
                    if dict.keys.contains("Storage") {
                        self.storage = dict["Storage"] as! Int32
                    }
                    if dict.keys.contains("Uuid") {
                        self.uuid = dict["Uuid"] as! String
                    }
                    if dict.keys.contains("VpcId") {
                        self.vpcId = dict["VpcId"] as! String
                    }
                }
            }
            public var autoFunction: GetInstanceInspectionsResponseBody.Data.List.AutoFunction?

            public var data: [String: Any]?

            public var enableDasPro: Int32?

            public var endTime: Int64?

            public var gmtCreate: Int64?

            public var instance: GetInstanceInspectionsResponseBody.Data.List.Instance?

            public var score: Int32?

            public var scoreMap: [String: Any]?

            public var startTime: Int64?

            public var state: Int32?

            public var taskType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.autoFunction?.validate()
                try self.instance?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoFunction != nil {
                    map["AutoFunction"] = self.autoFunction?.toMap()
                }
                if self.data != nil {
                    map["Data"] = self.data!
                }
                if self.enableDasPro != nil {
                    map["EnableDasPro"] = self.enableDasPro!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.instance != nil {
                    map["Instance"] = self.instance?.toMap()
                }
                if self.score != nil {
                    map["Score"] = self.score!
                }
                if self.scoreMap != nil {
                    map["ScoreMap"] = self.scoreMap!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.taskType != nil {
                    map["TaskType"] = self.taskType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoFunction") {
                    var model = GetInstanceInspectionsResponseBody.Data.List.AutoFunction()
                    model.fromMap(dict["AutoFunction"] as! [String: Any])
                    self.autoFunction = model
                }
                if dict.keys.contains("Data") {
                    self.data = dict["Data"] as! [String: Any]
                }
                if dict.keys.contains("EnableDasPro") {
                    self.enableDasPro = dict["EnableDasPro"] as! Int32
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("GmtCreate") {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("Instance") {
                    var model = GetInstanceInspectionsResponseBody.Data.List.Instance()
                    model.fromMap(dict["Instance"] as! [String: Any])
                    self.instance = model
                }
                if dict.keys.contains("Score") {
                    self.score = dict["Score"] as! Int32
                }
                if dict.keys.contains("ScoreMap") {
                    self.scoreMap = dict["ScoreMap"] as! [String: Any]
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! Int32
                }
                if dict.keys.contains("TaskType") {
                    self.taskType = dict["TaskType"] as! Int32
                }
            }
        }
        public var list: [GetInstanceInspectionsResponseBody.Data.List]?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [GetInstanceInspectionsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetInstanceInspectionsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetInstanceInspectionsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetInstanceInspectionsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetInstanceInspectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceInspectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInstanceInspectionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceMissingIndexListRequest : Tea.TeaModel {
    public var avgTotalUserCost: String?

    public var avgUserImpact: String?

    public var endTime: String?

    public var indexCount: String?

    public var instanceId: String?

    public var objectName: String?

    public var pageNo: String?

    public var pageSize: String?

    public var reservedPages: String?

    public var reservedSize: String?

    public var rowCount: String?

    public var startTime: String?

    public var uniqueCompiles: String?

    public var userScans: String?

    public var userSeeks: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avgTotalUserCost != nil {
            map["AvgTotalUserCost"] = self.avgTotalUserCost!
        }
        if self.avgUserImpact != nil {
            map["AvgUserImpact"] = self.avgUserImpact!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.indexCount != nil {
            map["IndexCount"] = self.indexCount!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.objectName != nil {
            map["ObjectName"] = self.objectName!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.reservedPages != nil {
            map["ReservedPages"] = self.reservedPages!
        }
        if self.reservedSize != nil {
            map["ReservedSize"] = self.reservedSize!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.uniqueCompiles != nil {
            map["UniqueCompiles"] = self.uniqueCompiles!
        }
        if self.userScans != nil {
            map["UserScans"] = self.userScans!
        }
        if self.userSeeks != nil {
            map["UserSeeks"] = self.userSeeks!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvgTotalUserCost") {
            self.avgTotalUserCost = dict["AvgTotalUserCost"] as! String
        }
        if dict.keys.contains("AvgUserImpact") {
            self.avgUserImpact = dict["AvgUserImpact"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("IndexCount") {
            self.indexCount = dict["IndexCount"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ObjectName") {
            self.objectName = dict["ObjectName"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("ReservedPages") {
            self.reservedPages = dict["ReservedPages"] as! String
        }
        if dict.keys.contains("ReservedSize") {
            self.reservedSize = dict["ReservedSize"] as! String
        }
        if dict.keys.contains("RowCount") {
            self.rowCount = dict["RowCount"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("UniqueCompiles") {
            self.uniqueCompiles = dict["UniqueCompiles"] as! String
        }
        if dict.keys.contains("UserScans") {
            self.userScans = dict["UserScans"] as! String
        }
        if dict.keys.contains("UserSeeks") {
            self.userSeeks = dict["UserSeeks"] as! String
        }
    }
}

public class GetInstanceMissingIndexListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var avgTotalUserCost: Double?

            public var avgUserImpact: Double?

            public var createIndex: String?

            public var databaseName: String?

            public var equalityColumns: String?

            public var includedColumns: String?

            public var indexCount: Int64?

            public var inequalityColumns: String?

            public var lastUserSeek: Int64?

            public var objectName: String?

            public var reservedPages: Int64?

            public var reservedSize: Double?

            public var rowCount: Int64?

            public var schemaName: String?

            public var systemScans: Int64?

            public var systemSeeks: Int64?

            public var uniqueCompiles: Int64?

            public var userScans: Int64?

            public var userSeeks: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgTotalUserCost != nil {
                    map["AvgTotalUserCost"] = self.avgTotalUserCost!
                }
                if self.avgUserImpact != nil {
                    map["AvgUserImpact"] = self.avgUserImpact!
                }
                if self.createIndex != nil {
                    map["CreateIndex"] = self.createIndex!
                }
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.equalityColumns != nil {
                    map["EqualityColumns"] = self.equalityColumns!
                }
                if self.includedColumns != nil {
                    map["IncludedColumns"] = self.includedColumns!
                }
                if self.indexCount != nil {
                    map["IndexCount"] = self.indexCount!
                }
                if self.inequalityColumns != nil {
                    map["InequalityColumns"] = self.inequalityColumns!
                }
                if self.lastUserSeek != nil {
                    map["LastUserSeek"] = self.lastUserSeek!
                }
                if self.objectName != nil {
                    map["ObjectName"] = self.objectName!
                }
                if self.reservedPages != nil {
                    map["ReservedPages"] = self.reservedPages!
                }
                if self.reservedSize != nil {
                    map["ReservedSize"] = self.reservedSize!
                }
                if self.rowCount != nil {
                    map["RowCount"] = self.rowCount!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.systemScans != nil {
                    map["SystemScans"] = self.systemScans!
                }
                if self.systemSeeks != nil {
                    map["SystemSeeks"] = self.systemSeeks!
                }
                if self.uniqueCompiles != nil {
                    map["UniqueCompiles"] = self.uniqueCompiles!
                }
                if self.userScans != nil {
                    map["UserScans"] = self.userScans!
                }
                if self.userSeeks != nil {
                    map["UserSeeks"] = self.userSeeks!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvgTotalUserCost") {
                    self.avgTotalUserCost = dict["AvgTotalUserCost"] as! Double
                }
                if dict.keys.contains("AvgUserImpact") {
                    self.avgUserImpact = dict["AvgUserImpact"] as! Double
                }
                if dict.keys.contains("CreateIndex") {
                    self.createIndex = dict["CreateIndex"] as! String
                }
                if dict.keys.contains("DatabaseName") {
                    self.databaseName = dict["DatabaseName"] as! String
                }
                if dict.keys.contains("EqualityColumns") {
                    self.equalityColumns = dict["EqualityColumns"] as! String
                }
                if dict.keys.contains("IncludedColumns") {
                    self.includedColumns = dict["IncludedColumns"] as! String
                }
                if dict.keys.contains("IndexCount") {
                    self.indexCount = dict["IndexCount"] as! Int64
                }
                if dict.keys.contains("InequalityColumns") {
                    self.inequalityColumns = dict["InequalityColumns"] as! String
                }
                if dict.keys.contains("LastUserSeek") {
                    self.lastUserSeek = dict["LastUserSeek"] as! Int64
                }
                if dict.keys.contains("ObjectName") {
                    self.objectName = dict["ObjectName"] as! String
                }
                if dict.keys.contains("ReservedPages") {
                    self.reservedPages = dict["ReservedPages"] as! Int64
                }
                if dict.keys.contains("ReservedSize") {
                    self.reservedSize = dict["ReservedSize"] as! Double
                }
                if dict.keys.contains("RowCount") {
                    self.rowCount = dict["RowCount"] as! Int64
                }
                if dict.keys.contains("SchemaName") {
                    self.schemaName = dict["SchemaName"] as! String
                }
                if dict.keys.contains("SystemScans") {
                    self.systemScans = dict["SystemScans"] as! Int64
                }
                if dict.keys.contains("SystemSeeks") {
                    self.systemSeeks = dict["SystemSeeks"] as! Int64
                }
                if dict.keys.contains("UniqueCompiles") {
                    self.uniqueCompiles = dict["UniqueCompiles"] as! Int64
                }
                if dict.keys.contains("UserScans") {
                    self.userScans = dict["UserScans"] as! Int64
                }
                if dict.keys.contains("UserSeeks") {
                    self.userSeeks = dict["UserSeeks"] as! Int64
                }
            }
        }
        public var list: [GetInstanceMissingIndexListResponseBody.Data.List]?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [GetInstanceMissingIndexListResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetInstanceMissingIndexListResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetInstanceMissingIndexListResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetInstanceMissingIndexListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetInstanceMissingIndexListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceMissingIndexListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInstanceMissingIndexListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceSqlOptimizeStatisticRequest : Tea.TeaModel {
    public var endTime: String?

    public var filterEnable: String?

    public var instanceId: String?

    public var nodeId: String?

    public var startTime: String?

    public var threshold: String?

    public var useMerging: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filterEnable != nil {
            map["FilterEnable"] = self.filterEnable!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.threshold != nil {
            map["Threshold"] = self.threshold!
        }
        if self.useMerging != nil {
            map["UseMerging"] = self.useMerging!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("FilterEnable") {
            self.filterEnable = dict["FilterEnable"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Threshold") {
            self.threshold = dict["Threshold"] as! String
        }
        if dict.keys.contains("UseMerging") {
            self.useMerging = dict["UseMerging"] as! String
        }
    }
}

public class GetInstanceSqlOptimizeStatisticResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var count: Int32?

        public var improvement: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.count != nil {
                map["count"] = self.count!
            }
            if self.improvement != nil {
                map["improvement"] = self.improvement!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("count") {
                self.count = dict["count"] as! Int32
            }
            if dict.keys.contains("improvement") {
                self.improvement = dict["improvement"] as! Double
            }
        }
    }
    public var code: String?

    public var data: GetInstanceSqlOptimizeStatisticResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetInstanceSqlOptimizeStatisticResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetInstanceSqlOptimizeStatisticResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceSqlOptimizeStatisticResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInstanceSqlOptimizeStatisticResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetKillInstanceSessionTaskResultRequest : Tea.TeaModel {
    public var instanceId: String?

    public var nodeId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class GetKillInstanceSessionTaskResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var active: Bool?

            public var command: String?

            public var db: String?

            public var host: String?

            public var id: Int64?

            public var info: String?

            public var reason: String?

            public var state: String?

            public var taskId: String?

            public var time: Int64?

            public var user: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.active != nil {
                    map["Active"] = self.active!
                }
                if self.command != nil {
                    map["Command"] = self.command!
                }
                if self.db != nil {
                    map["Db"] = self.db!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.info != nil {
                    map["Info"] = self.info!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.time != nil {
                    map["Time"] = self.time!
                }
                if self.user != nil {
                    map["User"] = self.user!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Active") {
                    self.active = dict["Active"] as! Bool
                }
                if dict.keys.contains("Command") {
                    self.command = dict["Command"] as! String
                }
                if dict.keys.contains("Db") {
                    self.db = dict["Db"] as! String
                }
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Info") {
                    self.info = dict["Info"] as! String
                }
                if dict.keys.contains("Reason") {
                    self.reason = dict["Reason"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("Time") {
                    self.time = dict["Time"] as! Int64
                }
                if dict.keys.contains("User") {
                    self.user = dict["User"] as! String
                }
            }
        }
        public var ignoredUserSessionCount: Int64?

        public var instanceId: String?

        public var killFailCount: Int64?

        public var killSuccessCount: Int64?

        public var nodeId: String?

        public var result: [GetKillInstanceSessionTaskResultResponseBody.Data.Result]?

        public var sessions: [Int64]?

        public var taskId: String?

        public var taskState: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ignoredUserSessionCount != nil {
                map["IgnoredUserSessionCount"] = self.ignoredUserSessionCount!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.killFailCount != nil {
                map["KillFailCount"] = self.killFailCount!
            }
            if self.killSuccessCount != nil {
                map["KillSuccessCount"] = self.killSuccessCount!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.sessions != nil {
                map["Sessions"] = self.sessions!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskState != nil {
                map["TaskState"] = self.taskState!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IgnoredUserSessionCount") {
                self.ignoredUserSessionCount = dict["IgnoredUserSessionCount"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("KillFailCount") {
                self.killFailCount = dict["KillFailCount"] as! Int64
            }
            if dict.keys.contains("KillSuccessCount") {
                self.killSuccessCount = dict["KillSuccessCount"] as! Int64
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("Result") {
                var tmp : [GetKillInstanceSessionTaskResultResponseBody.Data.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = GetKillInstanceSessionTaskResultResponseBody.Data.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
            if dict.keys.contains("Sessions") {
                self.sessions = dict["Sessions"] as! [Int64]
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskState") {
                self.taskState = dict["TaskState"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var code: Int64?

    public var data: GetKillInstanceSessionTaskResultResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = GetKillInstanceSessionTaskResultResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetKillInstanceSessionTaskResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetKillInstanceSessionTaskResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetKillInstanceSessionTaskResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMongoDBCurrentOpRequest : Tea.TeaModel {
    public var filterDoc: String?

    public var instanceId: String?

    public var nodeId: String?

    public var role: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filterDoc != nil {
            map["FilterDoc"] = self.filterDoc!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FilterDoc") {
            self.filterDoc = dict["FilterDoc"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! String
        }
    }
}

public class GetMongoDBCurrentOpResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SessionList : Tea.TeaModel {
            public var active: Bool?

            public var client: String?

            public var command: String?

            public var connectionId: Int64?

            public var desc: String?

            public var driver: String?

            public var host: String?

            public var killPending: Bool?

            public var ns: String?

            public var op: String?

            public var opId: String?

            public var osArch: String?

            public var osName: String?

            public var osType: String?

            public var planSummary: String?

            public var platform: String?

            public var secsRunning: Int64?

            public var shard: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.active != nil {
                    map["Active"] = self.active!
                }
                if self.client != nil {
                    map["Client"] = self.client!
                }
                if self.command != nil {
                    map["Command"] = self.command!
                }
                if self.connectionId != nil {
                    map["ConnectionId"] = self.connectionId!
                }
                if self.desc != nil {
                    map["Desc"] = self.desc!
                }
                if self.driver != nil {
                    map["Driver"] = self.driver!
                }
                if self.host != nil {
                    map["Host"] = self.host!
                }
                if self.killPending != nil {
                    map["KillPending"] = self.killPending!
                }
                if self.ns != nil {
                    map["Ns"] = self.ns!
                }
                if self.op != nil {
                    map["Op"] = self.op!
                }
                if self.opId != nil {
                    map["OpId"] = self.opId!
                }
                if self.osArch != nil {
                    map["OsArch"] = self.osArch!
                }
                if self.osName != nil {
                    map["OsName"] = self.osName!
                }
                if self.osType != nil {
                    map["OsType"] = self.osType!
                }
                if self.planSummary != nil {
                    map["PlanSummary"] = self.planSummary!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.secsRunning != nil {
                    map["SecsRunning"] = self.secsRunning!
                }
                if self.shard != nil {
                    map["Shard"] = self.shard!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Active") {
                    self.active = dict["Active"] as! Bool
                }
                if dict.keys.contains("Client") {
                    self.client = dict["Client"] as! String
                }
                if dict.keys.contains("Command") {
                    self.command = dict["Command"] as! String
                }
                if dict.keys.contains("ConnectionId") {
                    self.connectionId = dict["ConnectionId"] as! Int64
                }
                if dict.keys.contains("Desc") {
                    self.desc = dict["Desc"] as! String
                }
                if dict.keys.contains("Driver") {
                    self.driver = dict["Driver"] as! String
                }
                if dict.keys.contains("Host") {
                    self.host = dict["Host"] as! String
                }
                if dict.keys.contains("KillPending") {
                    self.killPending = dict["KillPending"] as! Bool
                }
                if dict.keys.contains("Ns") {
                    self.ns = dict["Ns"] as! String
                }
                if dict.keys.contains("Op") {
                    self.op = dict["Op"] as! String
                }
                if dict.keys.contains("OpId") {
                    self.opId = dict["OpId"] as! String
                }
                if dict.keys.contains("OsArch") {
                    self.osArch = dict["OsArch"] as! String
                }
                if dict.keys.contains("OsName") {
                    self.osName = dict["OsName"] as! String
                }
                if dict.keys.contains("OsType") {
                    self.osType = dict["OsType"] as! String
                }
                if dict.keys.contains("PlanSummary") {
                    self.planSummary = dict["PlanSummary"] as! String
                }
                if dict.keys.contains("Platform") {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("SecsRunning") {
                    self.secsRunning = dict["SecsRunning"] as! Int64
                }
                if dict.keys.contains("Shard") {
                    self.shard = dict["Shard"] as! String
                }
            }
        }
        public class SessionStat : Tea.TeaModel {
            public var activeCount: Int64?

            public var clientStats: [String: DataSessionStatClientStatsValue]?

            public var dbStats: [String: DataSessionStatDbStatsValue]?

            public var longestSecsRunning: Int64?

            public var totalCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activeCount != nil {
                    map["ActiveCount"] = self.activeCount!
                }
                if self.clientStats != nil {
                    var tmp : [String: Any] = [:]
                    for (k, v) in self.clientStats! {
                        tmp[k] = v.toMap()
                    }
                    map["ClientStats"] = tmp
                }
                if self.dbStats != nil {
                    var tmp : [String: Any] = [:]
                    for (k, v) in self.dbStats! {
                        tmp[k] = v.toMap()
                    }
                    map["DbStats"] = tmp
                }
                if self.longestSecsRunning != nil {
                    map["LongestSecsRunning"] = self.longestSecsRunning!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActiveCount") {
                    self.activeCount = dict["ActiveCount"] as! Int64
                }
                if dict.keys.contains("ClientStats") {
                    var tmp : [String: DataSessionStatClientStatsValue] = [:]
                    for (k, v) in dict["ClientStats"] as! [String: Any] {
                        if v != nil {
                            var model = DataSessionStatClientStatsValue()
                            model.fromMap(v as! [String: Any])
                            tmp[k] = model
                        }
                    }
                    self.clientStats = tmp
                }
                if dict.keys.contains("DbStats") {
                    var tmp : [String: DataSessionStatDbStatsValue] = [:]
                    for (k, v) in dict["DbStats"] as! [String: Any] {
                        if v != nil {
                            var model = DataSessionStatDbStatsValue()
                            model.fromMap(v as! [String: Any])
                            tmp[k] = model
                        }
                    }
                    self.dbStats = tmp
                }
                if dict.keys.contains("LongestSecsRunning") {
                    self.longestSecsRunning = dict["LongestSecsRunning"] as! Int64
                }
                if dict.keys.contains("TotalCount") {
                    self.totalCount = dict["TotalCount"] as! Int64
                }
            }
        }
        public var sessionList: [GetMongoDBCurrentOpResponseBody.Data.SessionList]?

        public var sessionStat: GetMongoDBCurrentOpResponseBody.Data.SessionStat?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.sessionStat?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sessionList != nil {
                var tmp : [Any] = []
                for k in self.sessionList! {
                    tmp.append(k.toMap())
                }
                map["SessionList"] = tmp
            }
            if self.sessionStat != nil {
                map["SessionStat"] = self.sessionStat?.toMap()
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SessionList") {
                var tmp : [GetMongoDBCurrentOpResponseBody.Data.SessionList] = []
                for v in dict["SessionList"] as! [Any] {
                    var model = GetMongoDBCurrentOpResponseBody.Data.SessionList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sessionList = tmp
            }
            if dict.keys.contains("SessionStat") {
                var model = GetMongoDBCurrentOpResponseBody.Data.SessionStat()
                model.fromMap(dict["SessionStat"] as! [String: Any])
                self.sessionStat = model
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
        }
    }
    public var code: Int64?

    public var data: GetMongoDBCurrentOpResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = GetMongoDBCurrentOpResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMongoDBCurrentOpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMongoDBCurrentOpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMongoDBCurrentOpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMySQLAllSessionAsyncRequest : Tea.TeaModel {
    public var instanceId: String?

    public var nodeId: String?

    public var resultId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.resultId != nil {
            map["ResultId"] = self.resultId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("ResultId") {
            self.resultId = dict["ResultId"] as! String
        }
    }
}

public class GetMySQLAllSessionAsyncResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class SessionData : Tea.TeaModel {
            public class ClientStats : Tea.TeaModel {
                public var activeCount: Int64?

                public var key: String?

                public var threadIdList: [Int64]?

                public var totalCount: Int64?

                public var userList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.activeCount != nil {
                        map["ActiveCount"] = self.activeCount!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.threadIdList != nil {
                        map["ThreadIdList"] = self.threadIdList!
                    }
                    if self.totalCount != nil {
                        map["TotalCount"] = self.totalCount!
                    }
                    if self.userList != nil {
                        map["UserList"] = self.userList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ActiveCount") {
                        self.activeCount = dict["ActiveCount"] as! Int64
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("ThreadIdList") {
                        self.threadIdList = dict["ThreadIdList"] as! [Int64]
                    }
                    if dict.keys.contains("TotalCount") {
                        self.totalCount = dict["TotalCount"] as! Int64
                    }
                    if dict.keys.contains("UserList") {
                        self.userList = dict["UserList"] as! [String]
                    }
                }
            }
            public class DbStats : Tea.TeaModel {
                public var activeCount: Int64?

                public var key: String?

                public var threadIdList: [Int64]?

                public var totalCount: Int64?

                public var userList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.activeCount != nil {
                        map["ActiveCount"] = self.activeCount!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.threadIdList != nil {
                        map["ThreadIdList"] = self.threadIdList!
                    }
                    if self.totalCount != nil {
                        map["TotalCount"] = self.totalCount!
                    }
                    if self.userList != nil {
                        map["UserList"] = self.userList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ActiveCount") {
                        self.activeCount = dict["ActiveCount"] as! Int64
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("ThreadIdList") {
                        self.threadIdList = dict["ThreadIdList"] as! [Int64]
                    }
                    if dict.keys.contains("TotalCount") {
                        self.totalCount = dict["TotalCount"] as! Int64
                    }
                    if dict.keys.contains("UserList") {
                        self.userList = dict["UserList"] as! [String]
                    }
                }
            }
            public class SessionList : Tea.TeaModel {
                public var client: String?

                public var command: String?

                public var dbName: String?

                public var sessionId: Int64?

                public var sqlTemplateId: String?

                public var sqlText: String?

                public var state: String?

                public var time: Int64?

                public var trxDuration: Int64?

                public var trxId: String?

                public var user: String?

                public var userClientAlias: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.client != nil {
                        map["Client"] = self.client!
                    }
                    if self.command != nil {
                        map["Command"] = self.command!
                    }
                    if self.dbName != nil {
                        map["DbName"] = self.dbName!
                    }
                    if self.sessionId != nil {
                        map["SessionId"] = self.sessionId!
                    }
                    if self.sqlTemplateId != nil {
                        map["SqlTemplateId"] = self.sqlTemplateId!
                    }
                    if self.sqlText != nil {
                        map["SqlText"] = self.sqlText!
                    }
                    if self.state != nil {
                        map["State"] = self.state!
                    }
                    if self.time != nil {
                        map["Time"] = self.time!
                    }
                    if self.trxDuration != nil {
                        map["TrxDuration"] = self.trxDuration!
                    }
                    if self.trxId != nil {
                        map["TrxId"] = self.trxId!
                    }
                    if self.user != nil {
                        map["User"] = self.user!
                    }
                    if self.userClientAlias != nil {
                        map["UserClientAlias"] = self.userClientAlias!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Client") {
                        self.client = dict["Client"] as! String
                    }
                    if dict.keys.contains("Command") {
                        self.command = dict["Command"] as! String
                    }
                    if dict.keys.contains("DbName") {
                        self.dbName = dict["DbName"] as! String
                    }
                    if dict.keys.contains("SessionId") {
                        self.sessionId = dict["SessionId"] as! Int64
                    }
                    if dict.keys.contains("SqlTemplateId") {
                        self.sqlTemplateId = dict["SqlTemplateId"] as! String
                    }
                    if dict.keys.contains("SqlText") {
                        self.sqlText = dict["SqlText"] as! String
                    }
                    if dict.keys.contains("State") {
                        self.state = dict["State"] as! String
                    }
                    if dict.keys.contains("Time") {
                        self.time = dict["Time"] as! Int64
                    }
                    if dict.keys.contains("TrxDuration") {
                        self.trxDuration = dict["TrxDuration"] as! Int64
                    }
                    if dict.keys.contains("TrxId") {
                        self.trxId = dict["TrxId"] as! String
                    }
                    if dict.keys.contains("User") {
                        self.user = dict["User"] as! String
                    }
                    if dict.keys.contains("UserClientAlias") {
                        self.userClientAlias = dict["UserClientAlias"] as! String
                    }
                }
            }
            public class UserStats : Tea.TeaModel {
                public var activeCount: Int64?

                public var key: String?

                public var threadIdList: [Int64]?

                public var totalCount: Int64?

                public var userList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.activeCount != nil {
                        map["ActiveCount"] = self.activeCount!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.threadIdList != nil {
                        map["ThreadIdList"] = self.threadIdList!
                    }
                    if self.totalCount != nil {
                        map["TotalCount"] = self.totalCount!
                    }
                    if self.userList != nil {
                        map["UserList"] = self.userList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ActiveCount") {
                        self.activeCount = dict["ActiveCount"] as! Int64
                    }
                    if dict.keys.contains("Key") {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("ThreadIdList") {
                        self.threadIdList = dict["ThreadIdList"] as! [Int64]
                    }
                    if dict.keys.contains("TotalCount") {
                        self.totalCount = dict["TotalCount"] as! Int64
                    }
                    if dict.keys.contains("UserList") {
                        self.userList = dict["UserList"] as! [String]
                    }
                }
            }
            public var activeSessionCount: Int64?

            public var clientStats: [GetMySQLAllSessionAsyncResponseBody.Data.SessionData.ClientStats]?

            public var dbStats: [GetMySQLAllSessionAsyncResponseBody.Data.SessionData.DbStats]?

            public var maxActiveTime: Int64?

            public var sessionList: [GetMySQLAllSessionAsyncResponseBody.Data.SessionData.SessionList]?

            public var timeStamp: Int64?

            public var totalSessionCount: Int64?

            public var userStats: [GetMySQLAllSessionAsyncResponseBody.Data.SessionData.UserStats]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activeSessionCount != nil {
                    map["ActiveSessionCount"] = self.activeSessionCount!
                }
                if self.clientStats != nil {
                    var tmp : [Any] = []
                    for k in self.clientStats! {
                        tmp.append(k.toMap())
                    }
                    map["ClientStats"] = tmp
                }
                if self.dbStats != nil {
                    var tmp : [Any] = []
                    for k in self.dbStats! {
                        tmp.append(k.toMap())
                    }
                    map["DbStats"] = tmp
                }
                if self.maxActiveTime != nil {
                    map["MaxActiveTime"] = self.maxActiveTime!
                }
                if self.sessionList != nil {
                    var tmp : [Any] = []
                    for k in self.sessionList! {
                        tmp.append(k.toMap())
                    }
                    map["SessionList"] = tmp
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                if self.totalSessionCount != nil {
                    map["TotalSessionCount"] = self.totalSessionCount!
                }
                if self.userStats != nil {
                    var tmp : [Any] = []
                    for k in self.userStats! {
                        tmp.append(k.toMap())
                    }
                    map["UserStats"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActiveSessionCount") {
                    self.activeSessionCount = dict["ActiveSessionCount"] as! Int64
                }
                if dict.keys.contains("ClientStats") {
                    var tmp : [GetMySQLAllSessionAsyncResponseBody.Data.SessionData.ClientStats] = []
                    for v in dict["ClientStats"] as! [Any] {
                        var model = GetMySQLAllSessionAsyncResponseBody.Data.SessionData.ClientStats()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.clientStats = tmp
                }
                if dict.keys.contains("DbStats") {
                    var tmp : [GetMySQLAllSessionAsyncResponseBody.Data.SessionData.DbStats] = []
                    for v in dict["DbStats"] as! [Any] {
                        var model = GetMySQLAllSessionAsyncResponseBody.Data.SessionData.DbStats()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.dbStats = tmp
                }
                if dict.keys.contains("MaxActiveTime") {
                    self.maxActiveTime = dict["MaxActiveTime"] as! Int64
                }
                if dict.keys.contains("SessionList") {
                    var tmp : [GetMySQLAllSessionAsyncResponseBody.Data.SessionData.SessionList] = []
                    for v in dict["SessionList"] as! [Any] {
                        var model = GetMySQLAllSessionAsyncResponseBody.Data.SessionData.SessionList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.sessionList = tmp
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! Int64
                }
                if dict.keys.contains("TotalSessionCount") {
                    self.totalSessionCount = dict["TotalSessionCount"] as! Int64
                }
                if dict.keys.contains("UserStats") {
                    var tmp : [GetMySQLAllSessionAsyncResponseBody.Data.SessionData.UserStats] = []
                    for v in dict["UserStats"] as! [Any] {
                        var model = GetMySQLAllSessionAsyncResponseBody.Data.SessionData.UserStats()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.userStats = tmp
                }
            }
        }
        public var complete: Bool?

        public var fail: Bool?

        public var isFinish: Bool?

        public var resultId: String?

        public var sessionData: GetMySQLAllSessionAsyncResponseBody.Data.SessionData?

        public var state: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.sessionData?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complete != nil {
                map["Complete"] = self.complete!
            }
            if self.fail != nil {
                map["Fail"] = self.fail!
            }
            if self.isFinish != nil {
                map["IsFinish"] = self.isFinish!
            }
            if self.resultId != nil {
                map["ResultId"] = self.resultId!
            }
            if self.sessionData != nil {
                map["SessionData"] = self.sessionData?.toMap()
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Complete") {
                self.complete = dict["Complete"] as! Bool
            }
            if dict.keys.contains("Fail") {
                self.fail = dict["Fail"] as! Bool
            }
            if dict.keys.contains("IsFinish") {
                self.isFinish = dict["IsFinish"] as! Bool
            }
            if dict.keys.contains("ResultId") {
                self.resultId = dict["ResultId"] as! String
            }
            if dict.keys.contains("SessionData") {
                var model = GetMySQLAllSessionAsyncResponseBody.Data.SessionData()
                model.fromMap(dict["SessionData"] as! [String: Any])
                self.sessionData = model
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
        }
    }
    public var code: Int64?

    public var data: GetMySQLAllSessionAsyncResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = GetMySQLAllSessionAsyncResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetMySQLAllSessionAsyncResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMySQLAllSessionAsyncResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMySQLAllSessionAsyncResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPartitionsHeatmapRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceId: String?

    public var timeRange: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.timeRange != nil {
            map["TimeRange"] = self.timeRange!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsoleContext") {
            self.consoleContext = dict["ConsoleContext"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TimeRange") {
            self.timeRange = dict["TimeRange"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetPartitionsHeatmapResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetPartitionsHeatmapResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPartitionsHeatmapResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPartitionsHeatmapResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPfsMetricTrendsRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var metric: String?

    public var nodeId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.metric != nil {
            map["Metric"] = self.metric!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Metric") {
            self.metric = dict["Metric"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class GetPfsMetricTrendsResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var data: [String: [DataValue]]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [String: Any] = [:]
            for (k, v) in self.data! {
                var l1 : [Any] = []
                for k1 in v {
                    l1.append(k1.toMap())
                }
                tmp[k] = l1
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var tmp : [String: [DataValue]] = [:]
            for (k, v) in dict["Data"] as! [String: Any] {
                var l1 : [DataValue] = []
                for v1 in v as! [Any] {
                    var model = DataValue()
                    if v1 != nil {
                        model.fromMap(v1 as! [String: Any])
                    }
                    l1.append(model)
                }
                tmp[k] = l1
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetPfsMetricTrendsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPfsMetricTrendsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPfsMetricTrendsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPfsSqlSampleRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var nodeId: String?

    public var sqlId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("SqlId") {
            self.sqlId = dict["SqlId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class GetPfsSqlSampleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var createTmpDiskTables: Int32?

        public var createTmpTables: Int32?

        public var db: String?

        public var endEventId: Int32?

        public var errors: Int32?

        public var eventId: Int32?

        public var eventName: String?

        public var instanceId: String?

        public var latency: Double?

        public var lockLatency: Double?

        public var logicId: String?

        public var noGoodIndexUsed: Int32?

        public var noIndexUsed: Int32?

        public var nodeId: String?

        public var rowsAffected: Int32?

        public var rowsExamined: Int32?

        public var rowsSent: Int32?

        public var selectFullJoin: Int32?

        public var selectFullRangeJoin: Int32?

        public var selectRange: Int32?

        public var selectRangeCheck: Int32?

        public var selectScan: Int32?

        public var sortMergePasses: Int32?

        public var sortRange: Int32?

        public var sortRows: Int32?

        public var sortScan: Int32?

        public var sql: String?

        public var sqlId: String?

        public var threadId: Int32?

        public var timestamp: Int64?

        public var userId: String?

        public var warnings: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTmpDiskTables != nil {
                map["CreateTmpDiskTables"] = self.createTmpDiskTables!
            }
            if self.createTmpTables != nil {
                map["CreateTmpTables"] = self.createTmpTables!
            }
            if self.db != nil {
                map["Db"] = self.db!
            }
            if self.endEventId != nil {
                map["EndEventId"] = self.endEventId!
            }
            if self.errors != nil {
                map["Errors"] = self.errors!
            }
            if self.eventId != nil {
                map["EventId"] = self.eventId!
            }
            if self.eventName != nil {
                map["EventName"] = self.eventName!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.latency != nil {
                map["Latency"] = self.latency!
            }
            if self.lockLatency != nil {
                map["LockLatency"] = self.lockLatency!
            }
            if self.logicId != nil {
                map["LogicId"] = self.logicId!
            }
            if self.noGoodIndexUsed != nil {
                map["NoGoodIndexUsed"] = self.noGoodIndexUsed!
            }
            if self.noIndexUsed != nil {
                map["NoIndexUsed"] = self.noIndexUsed!
            }
            if self.nodeId != nil {
                map["NodeId"] = self.nodeId!
            }
            if self.rowsAffected != nil {
                map["RowsAffected"] = self.rowsAffected!
            }
            if self.rowsExamined != nil {
                map["RowsExamined"] = self.rowsExamined!
            }
            if self.rowsSent != nil {
                map["RowsSent"] = self.rowsSent!
            }
            if self.selectFullJoin != nil {
                map["SelectFullJoin"] = self.selectFullJoin!
            }
            if self.selectFullRangeJoin != nil {
                map["SelectFullRangeJoin"] = self.selectFullRangeJoin!
            }
            if self.selectRange != nil {
                map["SelectRange"] = self.selectRange!
            }
            if self.selectRangeCheck != nil {
                map["SelectRangeCheck"] = self.selectRangeCheck!
            }
            if self.selectScan != nil {
                map["SelectScan"] = self.selectScan!
            }
            if self.sortMergePasses != nil {
                map["SortMergePasses"] = self.sortMergePasses!
            }
            if self.sortRange != nil {
                map["SortRange"] = self.sortRange!
            }
            if self.sortRows != nil {
                map["SortRows"] = self.sortRows!
            }
            if self.sortScan != nil {
                map["SortScan"] = self.sortScan!
            }
            if self.sql != nil {
                map["Sql"] = self.sql!
            }
            if self.sqlId != nil {
                map["SqlId"] = self.sqlId!
            }
            if self.threadId != nil {
                map["ThreadId"] = self.threadId!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.warnings != nil {
                map["Warnings"] = self.warnings!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTmpDiskTables") {
                self.createTmpDiskTables = dict["CreateTmpDiskTables"] as! Int32
            }
            if dict.keys.contains("CreateTmpTables") {
                self.createTmpTables = dict["CreateTmpTables"] as! Int32
            }
            if dict.keys.contains("Db") {
                self.db = dict["Db"] as! String
            }
            if dict.keys.contains("EndEventId") {
                self.endEventId = dict["EndEventId"] as! Int32
            }
            if dict.keys.contains("Errors") {
                self.errors = dict["Errors"] as! Int32
            }
            if dict.keys.contains("EventId") {
                self.eventId = dict["EventId"] as! Int32
            }
            if dict.keys.contains("EventName") {
                self.eventName = dict["EventName"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Latency") {
                self.latency = dict["Latency"] as! Double
            }
            if dict.keys.contains("LockLatency") {
                self.lockLatency = dict["LockLatency"] as! Double
            }
            if dict.keys.contains("LogicId") {
                self.logicId = dict["LogicId"] as! String
            }
            if dict.keys.contains("NoGoodIndexUsed") {
                self.noGoodIndexUsed = dict["NoGoodIndexUsed"] as! Int32
            }
            if dict.keys.contains("NoIndexUsed") {
                self.noIndexUsed = dict["NoIndexUsed"] as! Int32
            }
            if dict.keys.contains("NodeId") {
                self.nodeId = dict["NodeId"] as! String
            }
            if dict.keys.contains("RowsAffected") {
                self.rowsAffected = dict["RowsAffected"] as! Int32
            }
            if dict.keys.contains("RowsExamined") {
                self.rowsExamined = dict["RowsExamined"] as! Int32
            }
            if dict.keys.contains("RowsSent") {
                self.rowsSent = dict["RowsSent"] as! Int32
            }
            if dict.keys.contains("SelectFullJoin") {
                self.selectFullJoin = dict["SelectFullJoin"] as! Int32
            }
            if dict.keys.contains("SelectFullRangeJoin") {
                self.selectFullRangeJoin = dict["SelectFullRangeJoin"] as! Int32
            }
            if dict.keys.contains("SelectRange") {
                self.selectRange = dict["SelectRange"] as! Int32
            }
            if dict.keys.contains("SelectRangeCheck") {
                self.selectRangeCheck = dict["SelectRangeCheck"] as! Int32
            }
            if dict.keys.contains("SelectScan") {
                self.selectScan = dict["SelectScan"] as! Int32
            }
            if dict.keys.contains("SortMergePasses") {
                self.sortMergePasses = dict["SortMergePasses"] as! Int32
            }
            if dict.keys.contains("SortRange") {
                self.sortRange = dict["SortRange"] as! Int32
            }
            if dict.keys.contains("SortRows") {
                self.sortRows = dict["SortRows"] as! Int32
            }
            if dict.keys.contains("SortScan") {
                self.sortScan = dict["SortScan"] as! Int32
            }
            if dict.keys.contains("Sql") {
                self.sql = dict["Sql"] as! String
            }
            if dict.keys.contains("SqlId") {
                self.sqlId = dict["SqlId"] as! String
            }
            if dict.keys.contains("ThreadId") {
                self.threadId = dict["ThreadId"] as! Int32
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("Warnings") {
                self.warnings = dict["Warnings"] as! Int32
            }
        }
    }
    public var code: Int64?

    public var data: [GetPfsSqlSampleResponseBody.Data]?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var tmp : [GetPfsSqlSampleResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = GetPfsSqlSampleResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetPfsSqlSampleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPfsSqlSampleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPfsSqlSampleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetPfsSqlSummariesRequest : Tea.TeaModel {
    public var asc: Bool?

    public var endTime: Int64?

    public var instanceId: String?

    public var keywords: String?

    public var nodeId: String?

    public var orderBy: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var sqlId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asc != nil {
            map["Asc"] = self.asc!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.keywords != nil {
            map["Keywords"] = self.keywords!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Asc") {
            self.asc = dict["Asc"] as! Bool
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Keywords") {
            self.keywords = dict["Keywords"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SqlId") {
            self.sqlId = dict["SqlId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class GetPfsSqlSummariesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var avgLatency: Double?

            public var count: Int64?

            public var countRate: Double?

            public var cpuRate: Double?

            public var cpuTime: Double?

            public var dataReadTime: Double?

            public var dataReads: Int32?

            public var dataWriteTime: Double?

            public var dataWrites: Int32?

            public var db: String?

            public var elapsedTime: Double?

            public var errCount: Int64?

            public var firstTime: Int64?

            public var fullScan: Bool?

            public var id: Int64?

            public var instanceId: String?

            public var lastTime: Int64?

            public var lockLatencyAvg: Double?

            public var logicId: Int64?

            public var logicReads: Int64?

            public var maxLatency: Double?

            public var mutexSpins: Int32?

            public var mutexWaits: Int32?

            public var nodeId: String?

            public var physicalAsyncReads: Int64?

            public var physicalReads: Int64?

            public var psql: String?

            public var redoWrites: Int64?

            public var rowsAffected: Int64?

            public var rowsAffectedAvg: Double?

            public var rowsExamined: Int64?

            public var rowsExaminedAvg: Double?

            public var rowsSendAvg: Double?

            public var rowsSent: Int64?

            public var rowsSentAvg: Double?

            public var rowsSorted: Int64?

            public var rtRate: Double?

            public var rwlockOsWaits: Int32?

            public var rwlockSpinRounds: Int32?

            public var rwlockSpinWaits: Int32?

            public var selectFullJoinAvg: Double?

            public var selectFullRangeJoinAvg: Double?

            public var selectRangeAvg: Double?

            public var selectScanAvg: Double?

            public var semisyncDelayTime: Double?

            public var serverLockTime: Double?

            public var sortMergePasses: Int64?

            public var sortRangeAvg: Double?

            public var sortRowsAvg: Double?

            public var sortScanAvg: Double?

            public var sqlId: String?

            public var sqlType: String?

            public var tables: [String]?

            public var timerWaitAvg: Double?

            public var timestamp: Int64?

            public var tmpDiskTables: Int64?

            public var tmpDiskTablesAvg: Double?

            public var tmpTables: Int64?

            public var tmpTablesAvg: Double?

            public var totalLatency: Double?

            public var transactionLockTime: Double?

            public var userId: String?

            public var warnCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgLatency != nil {
                    map["AvgLatency"] = self.avgLatency!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.countRate != nil {
                    map["CountRate"] = self.countRate!
                }
                if self.cpuRate != nil {
                    map["CpuRate"] = self.cpuRate!
                }
                if self.cpuTime != nil {
                    map["CpuTime"] = self.cpuTime!
                }
                if self.dataReadTime != nil {
                    map["DataReadTime"] = self.dataReadTime!
                }
                if self.dataReads != nil {
                    map["DataReads"] = self.dataReads!
                }
                if self.dataWriteTime != nil {
                    map["DataWriteTime"] = self.dataWriteTime!
                }
                if self.dataWrites != nil {
                    map["DataWrites"] = self.dataWrites!
                }
                if self.db != nil {
                    map["Db"] = self.db!
                }
                if self.elapsedTime != nil {
                    map["ElapsedTime"] = self.elapsedTime!
                }
                if self.errCount != nil {
                    map["ErrCount"] = self.errCount!
                }
                if self.firstTime != nil {
                    map["FirstTime"] = self.firstTime!
                }
                if self.fullScan != nil {
                    map["FullScan"] = self.fullScan!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.lastTime != nil {
                    map["LastTime"] = self.lastTime!
                }
                if self.lockLatencyAvg != nil {
                    map["LockLatencyAvg"] = self.lockLatencyAvg!
                }
                if self.logicId != nil {
                    map["LogicId"] = self.logicId!
                }
                if self.logicReads != nil {
                    map["LogicReads"] = self.logicReads!
                }
                if self.maxLatency != nil {
                    map["MaxLatency"] = self.maxLatency!
                }
                if self.mutexSpins != nil {
                    map["MutexSpins"] = self.mutexSpins!
                }
                if self.mutexWaits != nil {
                    map["MutexWaits"] = self.mutexWaits!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.physicalAsyncReads != nil {
                    map["PhysicalAsyncReads"] = self.physicalAsyncReads!
                }
                if self.physicalReads != nil {
                    map["PhysicalReads"] = self.physicalReads!
                }
                if self.psql != nil {
                    map["Psql"] = self.psql!
                }
                if self.redoWrites != nil {
                    map["RedoWrites"] = self.redoWrites!
                }
                if self.rowsAffected != nil {
                    map["RowsAffected"] = self.rowsAffected!
                }
                if self.rowsAffectedAvg != nil {
                    map["RowsAffectedAvg"] = self.rowsAffectedAvg!
                }
                if self.rowsExamined != nil {
                    map["RowsExamined"] = self.rowsExamined!
                }
                if self.rowsExaminedAvg != nil {
                    map["RowsExaminedAvg"] = self.rowsExaminedAvg!
                }
                if self.rowsSendAvg != nil {
                    map["RowsSendAvg"] = self.rowsSendAvg!
                }
                if self.rowsSent != nil {
                    map["RowsSent"] = self.rowsSent!
                }
                if self.rowsSentAvg != nil {
                    map["RowsSentAvg"] = self.rowsSentAvg!
                }
                if self.rowsSorted != nil {
                    map["RowsSorted"] = self.rowsSorted!
                }
                if self.rtRate != nil {
                    map["RtRate"] = self.rtRate!
                }
                if self.rwlockOsWaits != nil {
                    map["RwlockOsWaits"] = self.rwlockOsWaits!
                }
                if self.rwlockSpinRounds != nil {
                    map["RwlockSpinRounds"] = self.rwlockSpinRounds!
                }
                if self.rwlockSpinWaits != nil {
                    map["RwlockSpinWaits"] = self.rwlockSpinWaits!
                }
                if self.selectFullJoinAvg != nil {
                    map["SelectFullJoinAvg"] = self.selectFullJoinAvg!
                }
                if self.selectFullRangeJoinAvg != nil {
                    map["SelectFullRangeJoinAvg"] = self.selectFullRangeJoinAvg!
                }
                if self.selectRangeAvg != nil {
                    map["SelectRangeAvg"] = self.selectRangeAvg!
                }
                if self.selectScanAvg != nil {
                    map["SelectScanAvg"] = self.selectScanAvg!
                }
                if self.semisyncDelayTime != nil {
                    map["SemisyncDelayTime"] = self.semisyncDelayTime!
                }
                if self.serverLockTime != nil {
                    map["ServerLockTime"] = self.serverLockTime!
                }
                if self.sortMergePasses != nil {
                    map["SortMergePasses"] = self.sortMergePasses!
                }
                if self.sortRangeAvg != nil {
                    map["SortRangeAvg"] = self.sortRangeAvg!
                }
                if self.sortRowsAvg != nil {
                    map["SortRowsAvg"] = self.sortRowsAvg!
                }
                if self.sortScanAvg != nil {
                    map["SortScanAvg"] = self.sortScanAvg!
                }
                if self.sqlId != nil {
                    map["SqlId"] = self.sqlId!
                }
                if self.sqlType != nil {
                    map["SqlType"] = self.sqlType!
                }
                if self.tables != nil {
                    map["Tables"] = self.tables!
                }
                if self.timerWaitAvg != nil {
                    map["TimerWaitAvg"] = self.timerWaitAvg!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.tmpDiskTables != nil {
                    map["TmpDiskTables"] = self.tmpDiskTables!
                }
                if self.tmpDiskTablesAvg != nil {
                    map["TmpDiskTablesAvg"] = self.tmpDiskTablesAvg!
                }
                if self.tmpTables != nil {
                    map["TmpTables"] = self.tmpTables!
                }
                if self.tmpTablesAvg != nil {
                    map["TmpTablesAvg"] = self.tmpTablesAvg!
                }
                if self.totalLatency != nil {
                    map["TotalLatency"] = self.totalLatency!
                }
                if self.transactionLockTime != nil {
                    map["TransactionLockTime"] = self.transactionLockTime!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.warnCount != nil {
                    map["WarnCount"] = self.warnCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvgLatency") {
                    self.avgLatency = dict["AvgLatency"] as! Double
                }
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
                if dict.keys.contains("CountRate") {
                    self.countRate = dict["CountRate"] as! Double
                }
                if dict.keys.contains("CpuRate") {
                    self.cpuRate = dict["CpuRate"] as! Double
                }
                if dict.keys.contains("CpuTime") {
                    self.cpuTime = dict["CpuTime"] as! Double
                }
                if dict.keys.contains("DataReadTime") {
                    self.dataReadTime = dict["DataReadTime"] as! Double
                }
                if dict.keys.contains("DataReads") {
                    self.dataReads = dict["DataReads"] as! Int32
                }
                if dict.keys.contains("DataWriteTime") {
                    self.dataWriteTime = dict["DataWriteTime"] as! Double
                }
                if dict.keys.contains("DataWrites") {
                    self.dataWrites = dict["DataWrites"] as! Int32
                }
                if dict.keys.contains("Db") {
                    self.db = dict["Db"] as! String
                }
                if dict.keys.contains("ElapsedTime") {
                    self.elapsedTime = dict["ElapsedTime"] as! Double
                }
                if dict.keys.contains("ErrCount") {
                    self.errCount = dict["ErrCount"] as! Int64
                }
                if dict.keys.contains("FirstTime") {
                    self.firstTime = dict["FirstTime"] as! Int64
                }
                if dict.keys.contains("FullScan") {
                    self.fullScan = dict["FullScan"] as! Bool
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("LastTime") {
                    self.lastTime = dict["LastTime"] as! Int64
                }
                if dict.keys.contains("LockLatencyAvg") {
                    self.lockLatencyAvg = dict["LockLatencyAvg"] as! Double
                }
                if dict.keys.contains("LogicId") {
                    self.logicId = dict["LogicId"] as! Int64
                }
                if dict.keys.contains("LogicReads") {
                    self.logicReads = dict["LogicReads"] as! Int64
                }
                if dict.keys.contains("MaxLatency") {
                    self.maxLatency = dict["MaxLatency"] as! Double
                }
                if dict.keys.contains("MutexSpins") {
                    self.mutexSpins = dict["MutexSpins"] as! Int32
                }
                if dict.keys.contains("MutexWaits") {
                    self.mutexWaits = dict["MutexWaits"] as! Int32
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! String
                }
                if dict.keys.contains("PhysicalAsyncReads") {
                    self.physicalAsyncReads = dict["PhysicalAsyncReads"] as! Int64
                }
                if dict.keys.contains("PhysicalReads") {
                    self.physicalReads = dict["PhysicalReads"] as! Int64
                }
                if dict.keys.contains("Psql") {
                    self.psql = dict["Psql"] as! String
                }
                if dict.keys.contains("RedoWrites") {
                    self.redoWrites = dict["RedoWrites"] as! Int64
                }
                if dict.keys.contains("RowsAffected") {
                    self.rowsAffected = dict["RowsAffected"] as! Int64
                }
                if dict.keys.contains("RowsAffectedAvg") {
                    self.rowsAffectedAvg = dict["RowsAffectedAvg"] as! Double
                }
                if dict.keys.contains("RowsExamined") {
                    self.rowsExamined = dict["RowsExamined"] as! Int64
                }
                if dict.keys.contains("RowsExaminedAvg") {
                    self.rowsExaminedAvg = dict["RowsExaminedAvg"] as! Double
                }
                if dict.keys.contains("RowsSendAvg") {
                    self.rowsSendAvg = dict["RowsSendAvg"] as! Double
                }
                if dict.keys.contains("RowsSent") {
                    self.rowsSent = dict["RowsSent"] as! Int64
                }
                if dict.keys.contains("RowsSentAvg") {
                    self.rowsSentAvg = dict["RowsSentAvg"] as! Double
                }
                if dict.keys.contains("RowsSorted") {
                    self.rowsSorted = dict["RowsSorted"] as! Int64
                }
                if dict.keys.contains("RtRate") {
                    self.rtRate = dict["RtRate"] as! Double
                }
                if dict.keys.contains("RwlockOsWaits") {
                    self.rwlockOsWaits = dict["RwlockOsWaits"] as! Int32
                }
                if dict.keys.contains("RwlockSpinRounds") {
                    self.rwlockSpinRounds = dict["RwlockSpinRounds"] as! Int32
                }
                if dict.keys.contains("RwlockSpinWaits") {
                    self.rwlockSpinWaits = dict["RwlockSpinWaits"] as! Int32
                }
                if dict.keys.contains("SelectFullJoinAvg") {
                    self.selectFullJoinAvg = dict["SelectFullJoinAvg"] as! Double
                }
                if dict.keys.contains("SelectFullRangeJoinAvg") {
                    self.selectFullRangeJoinAvg = dict["SelectFullRangeJoinAvg"] as! Double
                }
                if dict.keys.contains("SelectRangeAvg") {
                    self.selectRangeAvg = dict["SelectRangeAvg"] as! Double
                }
                if dict.keys.contains("SelectScanAvg") {
                    self.selectScanAvg = dict["SelectScanAvg"] as! Double
                }
                if dict.keys.contains("SemisyncDelayTime") {
                    self.semisyncDelayTime = dict["SemisyncDelayTime"] as! Double
                }
                if dict.keys.contains("ServerLockTime") {
                    self.serverLockTime = dict["ServerLockTime"] as! Double
                }
                if dict.keys.contains("SortMergePasses") {
                    self.sortMergePasses = dict["SortMergePasses"] as! Int64
                }
                if dict.keys.contains("SortRangeAvg") {
                    self.sortRangeAvg = dict["SortRangeAvg"] as! Double
                }
                if dict.keys.contains("SortRowsAvg") {
                    self.sortRowsAvg = dict["SortRowsAvg"] as! Double
                }
                if dict.keys.contains("SortScanAvg") {
                    self.sortScanAvg = dict["SortScanAvg"] as! Double
                }
                if dict.keys.contains("SqlId") {
                    self.sqlId = dict["SqlId"] as! String
                }
                if dict.keys.contains("SqlType") {
                    self.sqlType = dict["SqlType"] as! String
                }
                if dict.keys.contains("Tables") {
                    self.tables = dict["Tables"] as! [String]
                }
                if dict.keys.contains("TimerWaitAvg") {
                    self.timerWaitAvg = dict["TimerWaitAvg"] as! Double
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
                if dict.keys.contains("TmpDiskTables") {
                    self.tmpDiskTables = dict["TmpDiskTables"] as! Int64
                }
                if dict.keys.contains("TmpDiskTablesAvg") {
                    self.tmpDiskTablesAvg = dict["TmpDiskTablesAvg"] as! Double
                }
                if dict.keys.contains("TmpTables") {
                    self.tmpTables = dict["TmpTables"] as! Int64
                }
                if dict.keys.contains("TmpTablesAvg") {
                    self.tmpTablesAvg = dict["TmpTablesAvg"] as! Double
                }
                if dict.keys.contains("TotalLatency") {
                    self.totalLatency = dict["TotalLatency"] as! Double
                }
                if dict.keys.contains("TransactionLockTime") {
                    self.transactionLockTime = dict["TransactionLockTime"] as! Double
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("WarnCount") {
                    self.warnCount = dict["WarnCount"] as! Int64
                }
            }
        }
        public var extra: Any?

        public var list: [GetPfsSqlSummariesResponseBody.Data.List]?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extra") {
                self.extra = dict["Extra"] as! Any
            }
            if dict.keys.contains("List") {
                var tmp : [GetPfsSqlSummariesResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetPfsSqlSummariesResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: Int64?

    public var data: GetPfsSqlSummariesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = GetPfsSqlSummariesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetPfsSqlSummariesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPfsSqlSummariesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetPfsSqlSummariesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetQueryOptimizeDataStatsRequest : Tea.TeaModel {
    public var asc: String?

    public var dbNames: String?

    public var engine: String?

    public var instanceIds: String?

    public var keywords: String?

    public var logicalOperator: String?

    public var onlyOptimizedSql: String?

    public var orderBy: String?

    public var pageNo: String?

    public var pageSize: String?

    public var region: String?

    public var rules: String?

    public var sqlIds: String?

    public var tagNames: String?

    public var time: String?

    public var user: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asc != nil {
            map["Asc"] = self.asc!
        }
        if self.dbNames != nil {
            map["DbNames"] = self.dbNames!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.keywords != nil {
            map["Keywords"] = self.keywords!
        }
        if self.logicalOperator != nil {
            map["LogicalOperator"] = self.logicalOperator!
        }
        if self.onlyOptimizedSql != nil {
            map["OnlyOptimizedSql"] = self.onlyOptimizedSql!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.rules != nil {
            map["Rules"] = self.rules!
        }
        if self.sqlIds != nil {
            map["SqlIds"] = self.sqlIds!
        }
        if self.tagNames != nil {
            map["TagNames"] = self.tagNames!
        }
        if self.time != nil {
            map["Time"] = self.time!
        }
        if self.user != nil {
            map["User"] = self.user!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Asc") {
            self.asc = dict["Asc"] as! String
        }
        if dict.keys.contains("DbNames") {
            self.dbNames = dict["DbNames"] as! String
        }
        if dict.keys.contains("Engine") {
            self.engine = dict["Engine"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("Keywords") {
            self.keywords = dict["Keywords"] as! String
        }
        if dict.keys.contains("LogicalOperator") {
            self.logicalOperator = dict["LogicalOperator"] as! String
        }
        if dict.keys.contains("OnlyOptimizedSql") {
            self.onlyOptimizedSql = dict["OnlyOptimizedSql"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Rules") {
            self.rules = dict["Rules"] as! String
        }
        if dict.keys.contains("SqlIds") {
            self.sqlIds = dict["SqlIds"] as! String
        }
        if dict.keys.contains("TagNames") {
            self.tagNames = dict["TagNames"] as! String
        }
        if dict.keys.contains("Time") {
            self.time = dict["Time"] as! String
        }
        if dict.keys.contains("User") {
            self.user = dict["User"] as! String
        }
    }
}

public class GetQueryOptimizeDataStatsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class RuleList : Tea.TeaModel {
                public var name: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var avgLockTime: Double?

            public var avgQueryTime: Double?

            public var avgRowsAffected: Double?

            public var avgRowsExamined: Double?

            public var avgRowsSent: Double?

            public var count: Int32?

            public var dbname: String?

            public var instanceId: String?

            public var maxLockTime: Double?

            public var maxQueryTime: Double?

            public var maxRowsAffected: Int64?

            public var maxRowsExamined: Int64?

            public var maxRowsSent: Int64?

            public var psql: String?

            public var ruleList: [GetQueryOptimizeDataStatsResponseBody.Data.List.RuleList]?

            public var sqlId: String?

            public var sqlSample: String?

            public var sqlType: String?

            public var user: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avgLockTime != nil {
                    map["AvgLockTime"] = self.avgLockTime!
                }
                if self.avgQueryTime != nil {
                    map["AvgQueryTime"] = self.avgQueryTime!
                }
                if self.avgRowsAffected != nil {
                    map["AvgRowsAffected"] = self.avgRowsAffected!
                }
                if self.avgRowsExamined != nil {
                    map["AvgRowsExamined"] = self.avgRowsExamined!
                }
                if self.avgRowsSent != nil {
                    map["AvgRowsSent"] = self.avgRowsSent!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.dbname != nil {
                    map["Dbname"] = self.dbname!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.maxLockTime != nil {
                    map["MaxLockTime"] = self.maxLockTime!
                }
                if self.maxQueryTime != nil {
                    map["MaxQueryTime"] = self.maxQueryTime!
                }
                if self.maxRowsAffected != nil {
                    map["MaxRowsAffected"] = self.maxRowsAffected!
                }
                if self.maxRowsExamined != nil {
                    map["MaxRowsExamined"] = self.maxRowsExamined!
                }
                if self.maxRowsSent != nil {
                    map["MaxRowsSent"] = self.maxRowsSent!
                }
                if self.psql != nil {
                    map["Psql"] = self.psql!
                }
                if self.ruleList != nil {
                    var tmp : [Any] = []
                    for k in self.ruleList! {
                        tmp.append(k.toMap())
                    }
                    map["RuleList"] = tmp
                }
                if self.sqlId != nil {
                    map["SqlId"] = self.sqlId!
                }
                if self.sqlSample != nil {
                    map["SqlSample"] = self.sqlSample!
                }
                if self.sqlType != nil {
                    map["SqlType"] = self.sqlType!
                }
                if self.user != nil {
                    map["User"] = self.user!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvgLockTime") {
                    self.avgLockTime = dict["AvgLockTime"] as! Double
                }
                if dict.keys.contains("AvgQueryTime") {
                    self.avgQueryTime = dict["AvgQueryTime"] as! Double
                }
                if dict.keys.contains("AvgRowsAffected") {
                    self.avgRowsAffected = dict["AvgRowsAffected"] as! Double
                }
                if dict.keys.contains("AvgRowsExamined") {
                    self.avgRowsExamined = dict["AvgRowsExamined"] as! Double
                }
                if dict.keys.contains("AvgRowsSent") {
                    self.avgRowsSent = dict["AvgRowsSent"] as! Double
                }
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int32
                }
                if dict.keys.contains("Dbname") {
                    self.dbname = dict["Dbname"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("MaxLockTime") {
                    self.maxLockTime = dict["MaxLockTime"] as! Double
                }
                if dict.keys.contains("MaxQueryTime") {
                    self.maxQueryTime = dict["MaxQueryTime"] as! Double
                }
                if dict.keys.contains("MaxRowsAffected") {
                    self.maxRowsAffected = dict["MaxRowsAffected"] as! Int64
                }
                if dict.keys.contains("MaxRowsExamined") {
                    self.maxRowsExamined = dict["MaxRowsExamined"] as! Int64
                }
                if dict.keys.contains("MaxRowsSent") {
                    self.maxRowsSent = dict["MaxRowsSent"] as! Int64
                }
                if dict.keys.contains("Psql") {
                    self.psql = dict["Psql"] as! String
                }
                if dict.keys.contains("RuleList") {
                    var tmp : [GetQueryOptimizeDataStatsResponseBody.Data.List.RuleList] = []
                    for v in dict["RuleList"] as! [Any] {
                        var model = GetQueryOptimizeDataStatsResponseBody.Data.List.RuleList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ruleList = tmp
                }
                if dict.keys.contains("SqlId") {
                    self.sqlId = dict["SqlId"] as! String
                }
                if dict.keys.contains("SqlSample") {
                    self.sqlSample = dict["SqlSample"] as! String
                }
                if dict.keys.contains("SqlType") {
                    self.sqlType = dict["SqlType"] as! String
                }
                if dict.keys.contains("User") {
                    self.user = dict["User"] as! String
                }
            }
        }
        public var extra: String?

        public var list: [GetQueryOptimizeDataStatsResponseBody.Data.List]?

        public var pageNo: Int32?

        public var pageSize: Int32?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extra") {
                self.extra = dict["Extra"] as! String
            }
            if dict.keys.contains("List") {
                var tmp : [GetQueryOptimizeDataStatsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetQueryOptimizeDataStatsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetQueryOptimizeDataStatsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetQueryOptimizeDataStatsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetQueryOptimizeDataStatsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQueryOptimizeDataStatsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetQueryOptimizeDataStatsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetQueryOptimizeDataTopRequest : Tea.TeaModel {
    public var engine: String?

    public var instanceIds: String?

    public var region: String?

    public var tagNames: String?

    public var time: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.tagNames != nil {
            map["TagNames"] = self.tagNames!
        }
        if self.time != nil {
            map["Time"] = self.time!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Engine") {
            self.engine = dict["Engine"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("TagNames") {
            self.tagNames = dict["TagNames"] as! String
        }
        if dict.keys.contains("Time") {
            self.time = dict["Time"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class GetQueryOptimizeDataTopResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var instanceId: String?

            public var type: String?

            public var value: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! Double
                }
            }
        }
        public var extra: String?

        public var list: [GetQueryOptimizeDataTopResponseBody.Data.List]?

        public var pageNo: Int32?

        public var pageSize: Int32?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extra") {
                self.extra = dict["Extra"] as! String
            }
            if dict.keys.contains("List") {
                var tmp : [GetQueryOptimizeDataTopResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetQueryOptimizeDataTopResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetQueryOptimizeDataTopResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetQueryOptimizeDataTopResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetQueryOptimizeDataTopResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQueryOptimizeDataTopResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetQueryOptimizeDataTopResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetQueryOptimizeDataTrendRequest : Tea.TeaModel {
    public var end: String?

    public var engine: String?

    public var instanceIds: String?

    public var region: String?

    public var start: String?

    public var tagNames: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        if self.tagNames != nil {
            map["TagNames"] = self.tagNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("End") {
            self.end = dict["End"] as! String
        }
        if dict.keys.contains("Engine") {
            self.engine = dict["Engine"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Start") {
            self.start = dict["Start"] as! String
        }
        if dict.keys.contains("TagNames") {
            self.tagNames = dict["TagNames"] as! String
        }
    }
}

public class GetQueryOptimizeDataTrendResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var kpi: String?

            public var timestamp: Int64?

            public var value: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.kpi != nil {
                    map["Kpi"] = self.kpi!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Kpi") {
                    self.kpi = dict["Kpi"] as! String
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! Double
                }
            }
        }
        public var extra: String?

        public var list: [GetQueryOptimizeDataTrendResponseBody.Data.List]?

        public var pageNo: Int32?

        public var pageSize: Int32?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extra") {
                self.extra = dict["Extra"] as! String
            }
            if dict.keys.contains("List") {
                var tmp : [GetQueryOptimizeDataTrendResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetQueryOptimizeDataTrendResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetQueryOptimizeDataTrendResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetQueryOptimizeDataTrendResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetQueryOptimizeDataTrendResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQueryOptimizeDataTrendResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetQueryOptimizeDataTrendResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetQueryOptimizeExecErrorSampleRequest : Tea.TeaModel {
    public var engine: String?

    public var instanceId: String?

    public var sqlId: String?

    public var time: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        if self.time != nil {
            map["Time"] = self.time!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Engine") {
            self.engine = dict["Engine"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SqlId") {
            self.sqlId = dict["SqlId"] as! String
        }
        if dict.keys.contains("Time") {
            self.time = dict["Time"] as! String
        }
    }
}

public class GetQueryOptimizeExecErrorSampleResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var dbname: String?

            public var errorCode: String?

            public var origHost: String?

            public var sqlId: String?

            public var sqlText: String?

            public var timestamp: Int64?

            public var user: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbname != nil {
                    map["Dbname"] = self.dbname!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.origHost != nil {
                    map["OrigHost"] = self.origHost!
                }
                if self.sqlId != nil {
                    map["SqlId"] = self.sqlId!
                }
                if self.sqlText != nil {
                    map["SqlText"] = self.sqlText!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.user != nil {
                    map["User"] = self.user!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Dbname") {
                    self.dbname = dict["Dbname"] as! String
                }
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("OrigHost") {
                    self.origHost = dict["OrigHost"] as! String
                }
                if dict.keys.contains("SqlId") {
                    self.sqlId = dict["SqlId"] as! String
                }
                if dict.keys.contains("SqlText") {
                    self.sqlText = dict["SqlText"] as! String
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
                if dict.keys.contains("User") {
                    self.user = dict["User"] as! String
                }
            }
        }
        public var extra: String?

        public var list: [GetQueryOptimizeExecErrorSampleResponseBody.Data.List]?

        public var pageNo: Int32?

        public var pageSize: Int32?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extra") {
                self.extra = dict["Extra"] as! String
            }
            if dict.keys.contains("List") {
                var tmp : [GetQueryOptimizeExecErrorSampleResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetQueryOptimizeExecErrorSampleResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetQueryOptimizeExecErrorSampleResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetQueryOptimizeExecErrorSampleResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetQueryOptimizeExecErrorSampleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQueryOptimizeExecErrorSampleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetQueryOptimizeExecErrorSampleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetQueryOptimizeExecErrorStatsRequest : Tea.TeaModel {
    public var asc: String?

    public var dbNames: String?

    public var engine: String?

    public var instanceIds: String?

    public var keywords: String?

    public var logicalOperator: String?

    public var orderBy: String?

    public var pageNo: String?

    public var pageSize: String?

    public var region: String?

    public var time: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asc != nil {
            map["Asc"] = self.asc!
        }
        if self.dbNames != nil {
            map["DbNames"] = self.dbNames!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.keywords != nil {
            map["Keywords"] = self.keywords!
        }
        if self.logicalOperator != nil {
            map["LogicalOperator"] = self.logicalOperator!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.time != nil {
            map["Time"] = self.time!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Asc") {
            self.asc = dict["Asc"] as! String
        }
        if dict.keys.contains("DbNames") {
            self.dbNames = dict["DbNames"] as! String
        }
        if dict.keys.contains("Engine") {
            self.engine = dict["Engine"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("Keywords") {
            self.keywords = dict["Keywords"] as! String
        }
        if dict.keys.contains("LogicalOperator") {
            self.logicalOperator = dict["LogicalOperator"] as! String
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Time") {
            self.time = dict["Time"] as! String
        }
    }
}

public class GetQueryOptimizeExecErrorStatsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var dbname: String?

            public var errorCode: String?

            public var errorCount: Int64?

            public var instanceId: String?

            public var instanceName: String?

            public var sqlId: String?

            public var sqlText: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dbname != nil {
                    map["Dbname"] = self.dbname!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorCount != nil {
                    map["ErrorCount"] = self.errorCount!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.sqlId != nil {
                    map["SqlId"] = self.sqlId!
                }
                if self.sqlText != nil {
                    map["SqlText"] = self.sqlText!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Dbname") {
                    self.dbname = dict["Dbname"] as! String
                }
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorCount") {
                    self.errorCount = dict["ErrorCount"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("SqlId") {
                    self.sqlId = dict["SqlId"] as! String
                }
                if dict.keys.contains("SqlText") {
                    self.sqlText = dict["SqlText"] as! String
                }
            }
        }
        public var extra: String?

        public var list: [GetQueryOptimizeExecErrorStatsResponseBody.Data.List]?

        public var pageNo: Int32?

        public var pageSize: Int32?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extra") {
                self.extra = dict["Extra"] as! String
            }
            if dict.keys.contains("List") {
                var tmp : [GetQueryOptimizeExecErrorStatsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetQueryOptimizeExecErrorStatsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetQueryOptimizeExecErrorStatsResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetQueryOptimizeExecErrorStatsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetQueryOptimizeExecErrorStatsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQueryOptimizeExecErrorStatsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetQueryOptimizeExecErrorStatsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetQueryOptimizeRuleListRequest : Tea.TeaModel {
    public var engine: String?

    public var instanceIds: String?

    public var region: String?

    public var tagNames: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.tagNames != nil {
            map["TagNames"] = self.tagNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Engine") {
            self.engine = dict["Engine"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("TagNames") {
            self.tagNames = dict["TagNames"] as! String
        }
    }
}

public class GetQueryOptimizeRuleListResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var name: String?

            public var ruleId: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RuleId") {
                    self.ruleId = dict["RuleId"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var extra: String?

        public var list: [GetQueryOptimizeRuleListResponseBody.Data.List]?

        public var pageNo: Int32?

        public var pageSize: Int32?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extra") {
                self.extra = dict["Extra"] as! String
            }
            if dict.keys.contains("List") {
                var tmp : [GetQueryOptimizeRuleListResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetQueryOptimizeRuleListResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetQueryOptimizeRuleListResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetQueryOptimizeRuleListResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetQueryOptimizeRuleListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQueryOptimizeRuleListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetQueryOptimizeRuleListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetQueryOptimizeShareUrlRequest : Tea.TeaModel {
    public var asc: Bool?

    public var dbNames: String?

    public var engine: String?

    public var instanceIds: String?

    public var keywords: String?

    public var logicalOperator: String?

    public var onlyOptimizedSql: Bool?

    public var orderBy: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var region: String?

    public var rules: String?

    public var sqlIds: String?

    public var tagNames: String?

    public var time: Int64?

    public var user: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.asc != nil {
            map["Asc"] = self.asc!
        }
        if self.dbNames != nil {
            map["DbNames"] = self.dbNames!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.keywords != nil {
            map["Keywords"] = self.keywords!
        }
        if self.logicalOperator != nil {
            map["LogicalOperator"] = self.logicalOperator!
        }
        if self.onlyOptimizedSql != nil {
            map["OnlyOptimizedSql"] = self.onlyOptimizedSql!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.rules != nil {
            map["Rules"] = self.rules!
        }
        if self.sqlIds != nil {
            map["SqlIds"] = self.sqlIds!
        }
        if self.tagNames != nil {
            map["TagNames"] = self.tagNames!
        }
        if self.time != nil {
            map["Time"] = self.time!
        }
        if self.user != nil {
            map["User"] = self.user!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Asc") {
            self.asc = dict["Asc"] as! Bool
        }
        if dict.keys.contains("DbNames") {
            self.dbNames = dict["DbNames"] as! String
        }
        if dict.keys.contains("Engine") {
            self.engine = dict["Engine"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("Keywords") {
            self.keywords = dict["Keywords"] as! String
        }
        if dict.keys.contains("LogicalOperator") {
            self.logicalOperator = dict["LogicalOperator"] as! String
        }
        if dict.keys.contains("OnlyOptimizedSql") {
            self.onlyOptimizedSql = dict["OnlyOptimizedSql"] as! Bool
        }
        if dict.keys.contains("OrderBy") {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("Rules") {
            self.rules = dict["Rules"] as! String
        }
        if dict.keys.contains("SqlIds") {
            self.sqlIds = dict["SqlIds"] as! String
        }
        if dict.keys.contains("TagNames") {
            self.tagNames = dict["TagNames"] as! String
        }
        if dict.keys.contains("Time") {
            self.time = dict["Time"] as! Int64
        }
        if dict.keys.contains("User") {
            self.user = dict["User"] as! String
        }
    }
}

public class GetQueryOptimizeShareUrlResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetQueryOptimizeShareUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQueryOptimizeShareUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetQueryOptimizeShareUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetQueryOptimizeSolutionRequest : Tea.TeaModel {
    public var engine: String?

    public var instanceId: String?

    public var ruleIds: String?

    public var sqlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ruleIds != nil {
            map["RuleIds"] = self.ruleIds!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Engine") {
            self.engine = dict["Engine"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RuleIds") {
            self.ruleIds = dict["RuleIds"] as! String
        }
        if dict.keys.contains("SqlId") {
            self.sqlId = dict["SqlId"] as! String
        }
    }
}

public class GetQueryOptimizeSolutionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var level: String?

            public var ruleId: String?

            public var solution: String?

            public var solutionExt: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.level != nil {
                    map["Level"] = self.level!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                if self.solution != nil {
                    map["Solution"] = self.solution!
                }
                if self.solutionExt != nil {
                    map["SolutionExt"] = self.solutionExt!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Level") {
                    self.level = dict["Level"] as! String
                }
                if dict.keys.contains("RuleId") {
                    self.ruleId = dict["RuleId"] as! String
                }
                if dict.keys.contains("Solution") {
                    self.solution = dict["Solution"] as! String
                }
                if dict.keys.contains("SolutionExt") {
                    self.solutionExt = dict["SolutionExt"] as! String
                }
            }
        }
        public var extra: String?

        public var list: [GetQueryOptimizeSolutionResponseBody.Data.List]?

        public var pageNo: Int32?

        public var pageSize: Int32?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["Extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNo != nil {
                map["PageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extra") {
                self.extra = dict["Extra"] as! String
            }
            if dict.keys.contains("List") {
                var tmp : [GetQueryOptimizeSolutionResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = GetQueryOptimizeSolutionResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNo") {
                self.pageNo = dict["PageNo"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetQueryOptimizeSolutionResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetQueryOptimizeSolutionResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetQueryOptimizeSolutionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQueryOptimizeSolutionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetQueryOptimizeSolutionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetQueryOptimizeTagRequest : Tea.TeaModel {
    public var engine: String?

    public var instanceId: String?

    public var sqlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Engine") {
            self.engine = dict["Engine"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SqlId") {
            self.sqlId = dict["SqlId"] as! String
        }
    }
}

public class GetQueryOptimizeTagResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var comments: String?

        public var sqlId: String?

        public var tags: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comments != nil {
                map["Comments"] = self.comments!
            }
            if self.sqlId != nil {
                map["SqlId"] = self.sqlId!
            }
            if self.tags != nil {
                map["Tags"] = self.tags!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Comments") {
                self.comments = dict["Comments"] as! String
            }
            if dict.keys.contains("SqlId") {
                self.sqlId = dict["SqlId"] as! String
            }
            if dict.keys.contains("Tags") {
                self.tags = dict["Tags"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetQueryOptimizeTagResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetQueryOptimizeTagResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetQueryOptimizeTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetQueryOptimizeTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetQueryOptimizeTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRedisAllSessionRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsoleContext") {
            self.consoleContext = dict["ConsoleContext"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetRedisAllSessionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Sessions : Tea.TeaModel {
            public var addr: String?

            public var age: String?

            public var client: String?

            public var clientDesc: String?

            public var cmd: String?

            public var db: Int64?

            public var events: String?

            public var fd: Int64?

            public var flags: String?

            public var id: Int64?

            public var idle: Int64?

            public var multi: Int64?

            public var name: String?

            public var nodeId: String?

            public var obl: Int64?

            public var oll: Int64?

            public var omem: Int64?

            public var psub: Int64?

            public var qbuf: Int64?

            public var qbufFree: Int64?

            public var sub: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addr != nil {
                    map["Addr"] = self.addr!
                }
                if self.age != nil {
                    map["Age"] = self.age!
                }
                if self.client != nil {
                    map["Client"] = self.client!
                }
                if self.clientDesc != nil {
                    map["ClientDesc"] = self.clientDesc!
                }
                if self.cmd != nil {
                    map["Cmd"] = self.cmd!
                }
                if self.db != nil {
                    map["Db"] = self.db!
                }
                if self.events != nil {
                    map["Events"] = self.events!
                }
                if self.fd != nil {
                    map["Fd"] = self.fd!
                }
                if self.flags != nil {
                    map["Flags"] = self.flags!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.idle != nil {
                    map["Idle"] = self.idle!
                }
                if self.multi != nil {
                    map["Multi"] = self.multi!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.obl != nil {
                    map["Obl"] = self.obl!
                }
                if self.oll != nil {
                    map["Oll"] = self.oll!
                }
                if self.omem != nil {
                    map["Omem"] = self.omem!
                }
                if self.psub != nil {
                    map["Psub"] = self.psub!
                }
                if self.qbuf != nil {
                    map["Qbuf"] = self.qbuf!
                }
                if self.qbufFree != nil {
                    map["QbufFree"] = self.qbufFree!
                }
                if self.sub != nil {
                    map["Sub"] = self.sub!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Addr") {
                    self.addr = dict["Addr"] as! String
                }
                if dict.keys.contains("Age") {
                    self.age = dict["Age"] as! String
                }
                if dict.keys.contains("Client") {
                    self.client = dict["Client"] as! String
                }
                if dict.keys.contains("ClientDesc") {
                    self.clientDesc = dict["ClientDesc"] as! String
                }
                if dict.keys.contains("Cmd") {
                    self.cmd = dict["Cmd"] as! String
                }
                if dict.keys.contains("Db") {
                    self.db = dict["Db"] as! Int64
                }
                if dict.keys.contains("Events") {
                    self.events = dict["Events"] as! String
                }
                if dict.keys.contains("Fd") {
                    self.fd = dict["Fd"] as! Int64
                }
                if dict.keys.contains("Flags") {
                    self.flags = dict["Flags"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("Idle") {
                    self.idle = dict["Idle"] as! Int64
                }
                if dict.keys.contains("Multi") {
                    self.multi = dict["Multi"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! String
                }
                if dict.keys.contains("Obl") {
                    self.obl = dict["Obl"] as! Int64
                }
                if dict.keys.contains("Oll") {
                    self.oll = dict["Oll"] as! Int64
                }
                if dict.keys.contains("Omem") {
                    self.omem = dict["Omem"] as! Int64
                }
                if dict.keys.contains("Psub") {
                    self.psub = dict["Psub"] as! Int64
                }
                if dict.keys.contains("Qbuf") {
                    self.qbuf = dict["Qbuf"] as! Int64
                }
                if dict.keys.contains("QbufFree") {
                    self.qbufFree = dict["QbufFree"] as! Int64
                }
                if dict.keys.contains("Sub") {
                    self.sub = dict["Sub"] as! Int64
                }
            }
        }
        public class SourceStats : Tea.TeaModel {
            public var count: String?

            public var ids: [Int64]?

            public var key: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.count != nil {
                    map["Count"] = self.count!
                }
                if self.ids != nil {
                    map["Ids"] = self.ids!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! String
                }
                if dict.keys.contains("Ids") {
                    self.ids = dict["Ids"] as! [Int64]
                }
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
            }
        }
        public var sessions: [GetRedisAllSessionResponseBody.Data.Sessions]?

        public var sourceStats: [GetRedisAllSessionResponseBody.Data.SourceStats]?

        public var timestamp: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sessions != nil {
                var tmp : [Any] = []
                for k in self.sessions! {
                    tmp.append(k.toMap())
                }
                map["Sessions"] = tmp
            }
            if self.sourceStats != nil {
                var tmp : [Any] = []
                for k in self.sourceStats! {
                    tmp.append(k.toMap())
                }
                map["SourceStats"] = tmp
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Sessions") {
                var tmp : [GetRedisAllSessionResponseBody.Data.Sessions] = []
                for v in dict["Sessions"] as! [Any] {
                    var model = GetRedisAllSessionResponseBody.Data.Sessions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sessions = tmp
            }
            if dict.keys.contains("SourceStats") {
                var tmp : [GetRedisAllSessionResponseBody.Data.SourceStats] = []
                for v in dict["SourceStats"] as! [Any] {
                    var model = GetRedisAllSessionResponseBody.Data.SourceStats()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.sourceStats = tmp
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: Int64?

    public var data: GetRedisAllSessionResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = GetRedisAllSessionResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetRedisAllSessionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRedisAllSessionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRedisAllSessionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRequestDiagnosisPageRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var nodeId: String?

    public var pageNo: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class GetRequestDiagnosisPageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var accountId: String?

            public var dbSchema: String?

            public var engine: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public var messageId: String?

            public var param: String?

            public var result: String?

            public var sqlId: String?

            public var state: Int32?

            public var uuid: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["accountId"] = self.accountId!
                }
                if self.dbSchema != nil {
                    map["dbSchema"] = self.dbSchema!
                }
                if self.engine != nil {
                    map["engine"] = self.engine!
                }
                if self.gmtCreate != nil {
                    map["gmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["gmtModified"] = self.gmtModified!
                }
                if self.messageId != nil {
                    map["messageId"] = self.messageId!
                }
                if self.param != nil {
                    map["param"] = self.param!
                }
                if self.result != nil {
                    map["result"] = self.result!
                }
                if self.sqlId != nil {
                    map["sqlId"] = self.sqlId!
                }
                if self.state != nil {
                    map["state"] = self.state!
                }
                if self.uuid != nil {
                    map["uuid"] = self.uuid!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("accountId") {
                    self.accountId = dict["accountId"] as! String
                }
                if dict.keys.contains("dbSchema") {
                    self.dbSchema = dict["dbSchema"] as! String
                }
                if dict.keys.contains("engine") {
                    self.engine = dict["engine"] as! String
                }
                if dict.keys.contains("gmtCreate") {
                    self.gmtCreate = dict["gmtCreate"] as! String
                }
                if dict.keys.contains("gmtModified") {
                    self.gmtModified = dict["gmtModified"] as! String
                }
                if dict.keys.contains("messageId") {
                    self.messageId = dict["messageId"] as! String
                }
                if dict.keys.contains("param") {
                    self.param = dict["param"] as! String
                }
                if dict.keys.contains("result") {
                    self.result = dict["result"] as! String
                }
                if dict.keys.contains("sqlId") {
                    self.sqlId = dict["sqlId"] as! String
                }
                if dict.keys.contains("state") {
                    self.state = dict["state"] as! Int32
                }
                if dict.keys.contains("uuid") {
                    self.uuid = dict["uuid"] as! String
                }
            }
        }
        public var extra: String?

        public var list: [GetRequestDiagnosisPageResponseBody.Data.List]?

        public var pageNo: Int64?

        public var pageSize: Int64?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extra != nil {
                map["extra"] = self.extra!
            }
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["list"] = tmp
            }
            if self.pageNo != nil {
                map["pageNo"] = self.pageNo!
            }
            if self.pageSize != nil {
                map["pageSize"] = self.pageSize!
            }
            if self.total != nil {
                map["total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("extra") {
                self.extra = dict["extra"] as! String
            }
            if dict.keys.contains("list") {
                var tmp : [GetRequestDiagnosisPageResponseBody.Data.List] = []
                for v in dict["list"] as! [Any] {
                    var model = GetRequestDiagnosisPageResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("pageNo") {
                self.pageNo = dict["pageNo"] as! Int64
            }
            if dict.keys.contains("pageSize") {
                self.pageSize = dict["pageSize"] as! Int64
            }
            if dict.keys.contains("total") {
                self.total = dict["total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetRequestDiagnosisPageResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetRequestDiagnosisPageResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetRequestDiagnosisPageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRequestDiagnosisPageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRequestDiagnosisPageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRequestDiagnosisResultRequest : Tea.TeaModel {
    public var instanceId: String?

    public var messageId: String?

    public var nodeId: String?

    public var source: String?

    public var sqlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.messageId != nil {
            map["MessageId"] = self.messageId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.sqlId != nil {
            map["SqlId"] = self.sqlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MessageId") {
            self.messageId = dict["MessageId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("SqlId") {
            self.sqlId = dict["SqlId"] as! String
        }
    }
}

public class GetRequestDiagnosisResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var accountId: String?

        public var dbSchema: String?

        public var engine: String?

        public var gmtCreate: String?

        public var gmtModified: String?

        public var messageId: String?

        public var param: String?

        public var result: String?

        public var sqlId: String?

        public var state: Int32?

        public var uuid: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["accountId"] = self.accountId!
            }
            if self.dbSchema != nil {
                map["dbSchema"] = self.dbSchema!
            }
            if self.engine != nil {
                map["engine"] = self.engine!
            }
            if self.gmtCreate != nil {
                map["gmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["gmtModified"] = self.gmtModified!
            }
            if self.messageId != nil {
                map["messageId"] = self.messageId!
            }
            if self.param != nil {
                map["param"] = self.param!
            }
            if self.result != nil {
                map["result"] = self.result!
            }
            if self.sqlId != nil {
                map["sqlId"] = self.sqlId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.uuid != nil {
                map["uuid"] = self.uuid!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("accountId") {
                self.accountId = dict["accountId"] as! String
            }
            if dict.keys.contains("dbSchema") {
                self.dbSchema = dict["dbSchema"] as! String
            }
            if dict.keys.contains("engine") {
                self.engine = dict["engine"] as! String
            }
            if dict.keys.contains("gmtCreate") {
                self.gmtCreate = dict["gmtCreate"] as! String
            }
            if dict.keys.contains("gmtModified") {
                self.gmtModified = dict["gmtModified"] as! String
            }
            if dict.keys.contains("messageId") {
                self.messageId = dict["messageId"] as! String
            }
            if dict.keys.contains("param") {
                self.param = dict["param"] as! String
            }
            if dict.keys.contains("result") {
                self.result = dict["result"] as! String
            }
            if dict.keys.contains("sqlId") {
                self.sqlId = dict["sqlId"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! Int32
            }
            if dict.keys.contains("uuid") {
                self.uuid = dict["uuid"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetRequestDiagnosisResultResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetRequestDiagnosisResultResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetRequestDiagnosisResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRequestDiagnosisResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRequestDiagnosisResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRunningSqlConcurrencyControlRulesRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceId: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsoleContext") {
            self.consoleContext = dict["ConsoleContext"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class GetRunningSqlConcurrencyControlRulesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class RunningRules : Tea.TeaModel {
                public var concurrencyControlTime: Int64?

                public var instanceId: String?

                public var itemId: Int64?

                public var keywordsHash: String?

                public var maxConcurrency: String?

                public var sqlKeywords: String?

                public var sqlType: String?

                public var startTime: Int64?

                public var status: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.concurrencyControlTime != nil {
                        map["ConcurrencyControlTime"] = self.concurrencyControlTime!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.itemId != nil {
                        map["ItemId"] = self.itemId!
                    }
                    if self.keywordsHash != nil {
                        map["KeywordsHash"] = self.keywordsHash!
                    }
                    if self.maxConcurrency != nil {
                        map["MaxConcurrency"] = self.maxConcurrency!
                    }
                    if self.sqlKeywords != nil {
                        map["SqlKeywords"] = self.sqlKeywords!
                    }
                    if self.sqlType != nil {
                        map["SqlType"] = self.sqlType!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConcurrencyControlTime") {
                        self.concurrencyControlTime = dict["ConcurrencyControlTime"] as! Int64
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("ItemId") {
                        self.itemId = dict["ItemId"] as! Int64
                    }
                    if dict.keys.contains("KeywordsHash") {
                        self.keywordsHash = dict["KeywordsHash"] as! String
                    }
                    if dict.keys.contains("MaxConcurrency") {
                        self.maxConcurrency = dict["MaxConcurrency"] as! String
                    }
                    if dict.keys.contains("SqlKeywords") {
                        self.sqlKeywords = dict["SqlKeywords"] as! String
                    }
                    if dict.keys.contains("SqlType") {
                        self.sqlType = dict["SqlType"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! Int64
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var runningRules: [GetRunningSqlConcurrencyControlRulesResponseBody.Data.List.RunningRules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.runningRules != nil {
                    var tmp : [Any] = []
                    for k in self.runningRules! {
                        tmp.append(k.toMap())
                    }
                    map["runningRules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("runningRules") {
                    var tmp : [GetRunningSqlConcurrencyControlRulesResponseBody.Data.List.RunningRules] = []
                    for v in dict["runningRules"] as! [Any] {
                        var model = GetRunningSqlConcurrencyControlRulesResponseBody.Data.List.RunningRules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.runningRules = tmp
                }
            }
        }
        public var list: GetRunningSqlConcurrencyControlRulesResponseBody.Data.List?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.list?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                map["List"] = self.list?.toMap()
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var model = GetRunningSqlConcurrencyControlRulesResponseBody.Data.List()
                model.fromMap(dict["List"] as! [String: Any])
                self.list = model
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetRunningSqlConcurrencyControlRulesResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetRunningSqlConcurrencyControlRulesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetRunningSqlConcurrencyControlRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRunningSqlConcurrencyControlRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRunningSqlConcurrencyControlRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSqlConcurrencyControlKeywordsFromSqlTextRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceId: String?

    public var sqlText: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.sqlText != nil {
            map["SqlText"] = self.sqlText!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsoleContext") {
            self.consoleContext = dict["ConsoleContext"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SqlText") {
            self.sqlText = dict["SqlText"] as! String
        }
    }
}

public class GetSqlConcurrencyControlKeywordsFromSqlTextResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetSqlConcurrencyControlKeywordsFromSqlTextResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSqlConcurrencyControlKeywordsFromSqlTextResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSqlConcurrencyControlKeywordsFromSqlTextResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSqlConcurrencyControlRulesHistoryRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceId: String?

    public var pageNo: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNo != nil {
            map["PageNo"] = self.pageNo!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsoleContext") {
            self.consoleContext = dict["ConsoleContext"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNo") {
            self.pageNo = dict["PageNo"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
    }
}

public class GetSqlConcurrencyControlRulesHistoryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class Rules : Tea.TeaModel {
                public var concurrencyControlTime: Int64?

                public var instanceId: String?

                public var itemId: Int64?

                public var keywordsHash: String?

                public var maxConcurrency: Int64?

                public var sqlKeywords: String?

                public var sqlType: String?

                public var startTime: Int64?

                public var status: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.concurrencyControlTime != nil {
                        map["ConcurrencyControlTime"] = self.concurrencyControlTime!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.itemId != nil {
                        map["ItemId"] = self.itemId!
                    }
                    if self.keywordsHash != nil {
                        map["KeywordsHash"] = self.keywordsHash!
                    }
                    if self.maxConcurrency != nil {
                        map["MaxConcurrency"] = self.maxConcurrency!
                    }
                    if self.sqlKeywords != nil {
                        map["SqlKeywords"] = self.sqlKeywords!
                    }
                    if self.sqlType != nil {
                        map["SqlType"] = self.sqlType!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConcurrencyControlTime") {
                        self.concurrencyControlTime = dict["ConcurrencyControlTime"] as! Int64
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("ItemId") {
                        self.itemId = dict["ItemId"] as! Int64
                    }
                    if dict.keys.contains("KeywordsHash") {
                        self.keywordsHash = dict["KeywordsHash"] as! String
                    }
                    if dict.keys.contains("MaxConcurrency") {
                        self.maxConcurrency = dict["MaxConcurrency"] as! Int64
                    }
                    if dict.keys.contains("SqlKeywords") {
                        self.sqlKeywords = dict["SqlKeywords"] as! String
                    }
                    if dict.keys.contains("SqlType") {
                        self.sqlType = dict["SqlType"] as! String
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! Int64
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var rules: [GetSqlConcurrencyControlRulesHistoryResponseBody.Data.List.Rules]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.rules != nil {
                    var tmp : [Any] = []
                    for k in self.rules! {
                        tmp.append(k.toMap())
                    }
                    map["rules"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("rules") {
                    var tmp : [GetSqlConcurrencyControlRulesHistoryResponseBody.Data.List.Rules] = []
                    for v in dict["rules"] as! [Any] {
                        var model = GetSqlConcurrencyControlRulesHistoryResponseBody.Data.List.Rules()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.rules = tmp
                }
            }
        }
        public var list: GetSqlConcurrencyControlRulesHistoryResponseBody.Data.List?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.list?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                map["List"] = self.list?.toMap()
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var model = GetSqlConcurrencyControlRulesHistoryResponseBody.Data.List()
                model.fromMap(dict["List"] as! [String: Any])
                self.list = model
            }
            if dict.keys.contains("Total") {
                self.total = dict["Total"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetSqlConcurrencyControlRulesHistoryResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetSqlConcurrencyControlRulesHistoryResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetSqlConcurrencyControlRulesHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSqlConcurrencyControlRulesHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSqlConcurrencyControlRulesHistoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSqlOptimizeAdviceRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var endDt: String?

    public var engine: String?

    public var instanceIds: String?

    public var region: String?

    public var startDt: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.endDt != nil {
            map["EndDt"] = self.endDt!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.region != nil {
            map["Region"] = self.region!
        }
        if self.startDt != nil {
            map["StartDt"] = self.startDt!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsoleContext") {
            self.consoleContext = dict["ConsoleContext"] as! String
        }
        if dict.keys.contains("EndDt") {
            self.endDt = dict["EndDt"] as! String
        }
        if dict.keys.contains("Engine") {
            self.engine = dict["Engine"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("Region") {
            self.region = dict["Region"] as! String
        }
        if dict.keys.contains("StartDt") {
            self.startDt = dict["StartDt"] as! String
        }
    }
}

public class GetSqlOptimizeAdviceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var createTime: String?

        public var downloadUrl: String?

        public var expireTime: String?

        public var status: String?

        public var statusCode: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.downloadUrl != nil {
                map["DownloadUrl"] = self.downloadUrl!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.statusCode != nil {
                map["StatusCode"] = self.statusCode!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreateTime") {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("DownloadUrl") {
                self.downloadUrl = dict["DownloadUrl"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StatusCode") {
                self.statusCode = dict["StatusCode"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetSqlOptimizeAdviceResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetSqlOptimizeAdviceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class GetSqlOptimizeAdviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSqlOptimizeAdviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSqlOptimizeAdviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetStorageAnalysisResultRequest : Tea.TeaModel {
    public var instanceId: String?

    public var nodeId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeId != nil {
            map["NodeId"] = self.nodeId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeId") {
            self.nodeId = dict["NodeId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class GetStorageAnalysisResultResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class StorageAnalysisResult : Tea.TeaModel {
            public class NeedOptimizeItemList : Tea.TeaModel {
                public var associatedData: String?

                public var dbName: String?

                public var optimizeAdvice: String?

                public var optimizeItemName: String?

                public var tableName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.associatedData != nil {
                        map["AssociatedData"] = self.associatedData!
                    }
                    if self.dbName != nil {
                        map["DbName"] = self.dbName!
                    }
                    if self.optimizeAdvice != nil {
                        map["OptimizeAdvice"] = self.optimizeAdvice!
                    }
                    if self.optimizeItemName != nil {
                        map["OptimizeItemName"] = self.optimizeItemName!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AssociatedData") {
                        self.associatedData = dict["AssociatedData"] as! String
                    }
                    if dict.keys.contains("DbName") {
                        self.dbName = dict["DbName"] as! String
                    }
                    if dict.keys.contains("OptimizeAdvice") {
                        self.optimizeAdvice = dict["OptimizeAdvice"] as! String
                    }
                    if dict.keys.contains("OptimizeItemName") {
                        self.optimizeItemName = dict["OptimizeItemName"] as! String
                    }
                    if dict.keys.contains("TableName") {
                        self.tableName = dict["TableName"] as! String
                    }
                }
            }
            public class TableStats : Tea.TeaModel {
                public var avgRowLength: Int64?

                public var dataFree: Int64?

                public var dataSize: Int64?

                public var dbName: String?

                public var engine: String?

                public var fragmentSize: Int64?

                public var indexSize: Int64?

                public var phyTotalSize: Int64?

                public var physicalFileSize: Int64?

                public var tableName: String?

                public var tableRows: Int64?

                public var tableType: String?

                public var totalSize: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.avgRowLength != nil {
                        map["AvgRowLength"] = self.avgRowLength!
                    }
                    if self.dataFree != nil {
                        map["DataFree"] = self.dataFree!
                    }
                    if self.dataSize != nil {
                        map["DataSize"] = self.dataSize!
                    }
                    if self.dbName != nil {
                        map["DbName"] = self.dbName!
                    }
                    if self.engine != nil {
                        map["Engine"] = self.engine!
                    }
                    if self.fragmentSize != nil {
                        map["FragmentSize"] = self.fragmentSize!
                    }
                    if self.indexSize != nil {
                        map["IndexSize"] = self.indexSize!
                    }
                    if self.phyTotalSize != nil {
                        map["PhyTotalSize"] = self.phyTotalSize!
                    }
                    if self.physicalFileSize != nil {
                        map["PhysicalFileSize"] = self.physicalFileSize!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    if self.tableRows != nil {
                        map["TableRows"] = self.tableRows!
                    }
                    if self.tableType != nil {
                        map["TableType"] = self.tableType!
                    }
                    if self.totalSize != nil {
                        map["TotalSize"] = self.totalSize!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvgRowLength") {
                        self.avgRowLength = dict["AvgRowLength"] as! Int64
                    }
                    if dict.keys.contains("DataFree") {
                        self.dataFree = dict["DataFree"] as! Int64
                    }
                    if dict.keys.contains("DataSize") {
                        self.dataSize = dict["DataSize"] as! Int64
                    }
                    if dict.keys.contains("DbName") {
                        self.dbName = dict["DbName"] as! String
                    }
                    if dict.keys.contains("Engine") {
                        self.engine = dict["Engine"] as! String
                    }
                    if dict.keys.contains("FragmentSize") {
                        self.fragmentSize = dict["FragmentSize"] as! Int64
                    }
                    if dict.keys.contains("IndexSize") {
                        self.indexSize = dict["IndexSize"] as! Int64
                    }
                    if dict.keys.contains("PhyTotalSize") {
                        self.phyTotalSize = dict["PhyTotalSize"] as! Int64
                    }
                    if dict.keys.contains("PhysicalFileSize") {
                        self.physicalFileSize = dict["PhysicalFileSize"] as! Int64
                    }
                    if dict.keys.contains("TableName") {
                        self.tableName = dict["TableName"] as! String
                    }
                    if dict.keys.contains("TableRows") {
                        self.tableRows = dict["TableRows"] as! Int64
                    }
                    if dict.keys.contains("TableType") {
                        self.tableType = dict["TableType"] as! String
                    }
                    if dict.keys.contains("TotalSize") {
                        self.totalSize = dict["TotalSize"] as! Int64
                    }
                }
            }
            public var analysisErrorType: String?

            public var analysisSuccess: Bool?

            public var dailyIncrement: Int64?

            public var estimateAvailableDays: Int64?

            public var needOptimizeItemList: [GetStorageAnalysisResultResponseBody.Data.StorageAnalysisResult.NeedOptimizeItemList]?

            public var tableStats: [GetStorageAnalysisResultResponseBody.Data.StorageAnalysisResult.TableStats]?

            public var totalFreeStorageSize: Int64?

            public var totalStorageSize: Int64?

            public var totalUsedStorageSize: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.analysisErrorType != nil {
                    map["AnalysisErrorType"] = self.analysisErrorType!
                }
                if self.analysisSuccess != nil {
                    map["AnalysisSuccess"] = self.analysisSuccess!
                }
                if self.dailyIncrement != nil {
                    map["DailyIncrement"] = self.dailyIncrement!
                }
                if self.estimateAvailableDays != nil {
                    map["EstimateAvailableDays"] = self.estimateAvailableDays!
                }
                if self.needOptimizeItemList != nil {
                    var tmp : [Any] = []
                    for k in self.needOptimizeItemList! {
                        tmp.append(k.toMap())
                    }
                    map["NeedOptimizeItemList"] = tmp
                }
                if self.tableStats != nil {
                    var tmp : [Any] = []
                    for k in self.tableStats! {
                        tmp.append(k.toMap())
                    }
                    map["TableStats"] = tmp
                }
                if self.totalFreeStorageSize != nil {
                    map["TotalFreeStorageSize"] = self.totalFreeStorageSize!
                }
                if self.totalStorageSize != nil {
                    map["TotalStorageSize"] = self.totalStorageSize!
                }
                if self.totalUsedStorageSize != nil {
                    map["TotalUsedStorageSize"] = self.totalUsedStorageSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AnalysisErrorType") {
                    self.analysisErrorType = dict["AnalysisErrorType"] as! String
                }
                if dict.keys.contains("AnalysisSuccess") {
                    self.analysisSuccess = dict["AnalysisSuccess"] as! Bool
                }
                if dict.keys.contains("DailyIncrement") {
                    self.dailyIncrement = dict["DailyIncrement"] as! Int64
                }
                if dict.keys.contains("EstimateAvailableDays") {
                    self.estimateAvailableDays = dict["EstimateAvailableDays"] as! Int64
                }
                if dict.keys.contains("NeedOptimizeItemList") {
                    var tmp : [GetStorageAnalysisResultResponseBody.Data.StorageAnalysisResult.NeedOptimizeItemList] = []
                    for v in dict["NeedOptimizeItemList"] as! [Any] {
                        var model = GetStorageAnalysisResultResponseBody.Data.StorageAnalysisResult.NeedOptimizeItemList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.needOptimizeItemList = tmp
                }
                if dict.keys.contains("TableStats") {
                    var tmp : [GetStorageAnalysisResultResponseBody.Data.StorageAnalysisResult.TableStats] = []
                    for v in dict["TableStats"] as! [Any] {
                        var model = GetStorageAnalysisResultResponseBody.Data.StorageAnalysisResult.TableStats()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tableStats = tmp
                }
                if dict.keys.contains("TotalFreeStorageSize") {
                    self.totalFreeStorageSize = dict["TotalFreeStorageSize"] as! Int64
                }
                if dict.keys.contains("TotalStorageSize") {
                    self.totalStorageSize = dict["TotalStorageSize"] as! Int64
                }
                if dict.keys.contains("TotalUsedStorageSize") {
                    self.totalUsedStorageSize = dict["TotalUsedStorageSize"] as! Int64
                }
            }
        }
        public var analyzedDbCount: Int64?

        public var storageAnalysisResult: GetStorageAnalysisResultResponseBody.Data.StorageAnalysisResult?

        public var taskFinish: Bool?

        public var taskId: String?

        public var taskProgress: Int64?

        public var taskState: String?

        public var taskSuccess: Bool?

        public var totalDbCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.storageAnalysisResult?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.analyzedDbCount != nil {
                map["AnalyzedDbCount"] = self.analyzedDbCount!
            }
            if self.storageAnalysisResult != nil {
                map["StorageAnalysisResult"] = self.storageAnalysisResult?.toMap()
            }
            if self.taskFinish != nil {
                map["TaskFinish"] = self.taskFinish!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskProgress != nil {
                map["TaskProgress"] = self.taskProgress!
            }
            if self.taskState != nil {
                map["TaskState"] = self.taskState!
            }
            if self.taskSuccess != nil {
                map["TaskSuccess"] = self.taskSuccess!
            }
            if self.totalDbCount != nil {
                map["TotalDbCount"] = self.totalDbCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AnalyzedDbCount") {
                self.analyzedDbCount = dict["AnalyzedDbCount"] as! Int64
            }
            if dict.keys.contains("StorageAnalysisResult") {
                var model = GetStorageAnalysisResultResponseBody.Data.StorageAnalysisResult()
                model.fromMap(dict["StorageAnalysisResult"] as! [String: Any])
                self.storageAnalysisResult = model
            }
            if dict.keys.contains("TaskFinish") {
                self.taskFinish = dict["TaskFinish"] as! Bool
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskProgress") {
                self.taskProgress = dict["TaskProgress"] as! Int64
            }
            if dict.keys.contains("TaskState") {
                self.taskState = dict["TaskState"] as! String
            }
            if dict.keys.contains("TaskSuccess") {
                self.taskSuccess = dict["TaskSuccess"] as! Bool
            }
            if dict.keys.contains("TotalDbCount") {
                self.totalDbCount = dict["TotalDbCount"] as! Int64
            }
        }
    }
    public var code: Int64?

    public var data: GetStorageAnalysisResultResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = GetStorageAnalysisResultResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetStorageAnalysisResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetStorageAnalysisResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetStorageAnalysisResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class KillInstanceAllSessionRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsoleContext") {
            self.consoleContext = dict["ConsoleContext"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class KillInstanceAllSessionResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class KillInstanceAllSessionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: KillInstanceAllSessionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = KillInstanceAllSessionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAutoScalingConfigRequest : Tea.TeaModel {
    public class Bandwidth : Tea.TeaModel {
        public var apply: Bool?

        public var bandwidthUsageLowerThreshold: Int32?

        public var bandwidthUsageUpperThreshold: Int32?

        public var downgrade: Bool?

        public var observationWindowSize: String?

        public var upgrade: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apply != nil {
                map["Apply"] = self.apply!
            }
            if self.bandwidthUsageLowerThreshold != nil {
                map["BandwidthUsageLowerThreshold"] = self.bandwidthUsageLowerThreshold!
            }
            if self.bandwidthUsageUpperThreshold != nil {
                map["BandwidthUsageUpperThreshold"] = self.bandwidthUsageUpperThreshold!
            }
            if self.downgrade != nil {
                map["Downgrade"] = self.downgrade!
            }
            if self.observationWindowSize != nil {
                map["ObservationWindowSize"] = self.observationWindowSize!
            }
            if self.upgrade != nil {
                map["Upgrade"] = self.upgrade!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Apply") {
                self.apply = dict["Apply"] as! Bool
            }
            if dict.keys.contains("BandwidthUsageLowerThreshold") {
                self.bandwidthUsageLowerThreshold = dict["BandwidthUsageLowerThreshold"] as! Int32
            }
            if dict.keys.contains("BandwidthUsageUpperThreshold") {
                self.bandwidthUsageUpperThreshold = dict["BandwidthUsageUpperThreshold"] as! Int32
            }
            if dict.keys.contains("Downgrade") {
                self.downgrade = dict["Downgrade"] as! Bool
            }
            if dict.keys.contains("ObservationWindowSize") {
                self.observationWindowSize = dict["ObservationWindowSize"] as! String
            }
            if dict.keys.contains("Upgrade") {
                self.upgrade = dict["Upgrade"] as! Bool
            }
        }
    }
    public class Resource : Tea.TeaModel {
        public var apply: Bool?

        public var cpuUsageUpperThreshold: Int32?

        public var downgradeObservationWindowSize: String?

        public var enable: Bool?

        public var upgradeObservationWindowSize: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apply != nil {
                map["Apply"] = self.apply!
            }
            if self.cpuUsageUpperThreshold != nil {
                map["CpuUsageUpperThreshold"] = self.cpuUsageUpperThreshold!
            }
            if self.downgradeObservationWindowSize != nil {
                map["DowngradeObservationWindowSize"] = self.downgradeObservationWindowSize!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.upgradeObservationWindowSize != nil {
                map["UpgradeObservationWindowSize"] = self.upgradeObservationWindowSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Apply") {
                self.apply = dict["Apply"] as! Bool
            }
            if dict.keys.contains("CpuUsageUpperThreshold") {
                self.cpuUsageUpperThreshold = dict["CpuUsageUpperThreshold"] as! Int32
            }
            if dict.keys.contains("DowngradeObservationWindowSize") {
                self.downgradeObservationWindowSize = dict["DowngradeObservationWindowSize"] as! String
            }
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("UpgradeObservationWindowSize") {
                self.upgradeObservationWindowSize = dict["UpgradeObservationWindowSize"] as! String
            }
        }
    }
    public class Shard : Tea.TeaModel {
        public var apply: Bool?

        public var downgrade: Bool?

        public var downgradeObservationWindowSize: String?

        public var maxShards: Int32?

        public var memUsageLowerThreshold: Int32?

        public var memUsageUpperThreshold: Int32?

        public var minShards: Int32?

        public var upgrade: Bool?

        public var upgradeObservationWindowSize: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apply != nil {
                map["Apply"] = self.apply!
            }
            if self.downgrade != nil {
                map["Downgrade"] = self.downgrade!
            }
            if self.downgradeObservationWindowSize != nil {
                map["DowngradeObservationWindowSize"] = self.downgradeObservationWindowSize!
            }
            if self.maxShards != nil {
                map["MaxShards"] = self.maxShards!
            }
            if self.memUsageLowerThreshold != nil {
                map["MemUsageLowerThreshold"] = self.memUsageLowerThreshold!
            }
            if self.memUsageUpperThreshold != nil {
                map["MemUsageUpperThreshold"] = self.memUsageUpperThreshold!
            }
            if self.minShards != nil {
                map["MinShards"] = self.minShards!
            }
            if self.upgrade != nil {
                map["Upgrade"] = self.upgrade!
            }
            if self.upgradeObservationWindowSize != nil {
                map["UpgradeObservationWindowSize"] = self.upgradeObservationWindowSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Apply") {
                self.apply = dict["Apply"] as! Bool
            }
            if dict.keys.contains("Downgrade") {
                self.downgrade = dict["Downgrade"] as! Bool
            }
            if dict.keys.contains("DowngradeObservationWindowSize") {
                self.downgradeObservationWindowSize = dict["DowngradeObservationWindowSize"] as! String
            }
            if dict.keys.contains("MaxShards") {
                self.maxShards = dict["MaxShards"] as! Int32
            }
            if dict.keys.contains("MemUsageLowerThreshold") {
                self.memUsageLowerThreshold = dict["MemUsageLowerThreshold"] as! Int32
            }
            if dict.keys.contains("MemUsageUpperThreshold") {
                self.memUsageUpperThreshold = dict["MemUsageUpperThreshold"] as! Int32
            }
            if dict.keys.contains("MinShards") {
                self.minShards = dict["MinShards"] as! Int32
            }
            if dict.keys.contains("Upgrade") {
                self.upgrade = dict["Upgrade"] as! Bool
            }
            if dict.keys.contains("UpgradeObservationWindowSize") {
                self.upgradeObservationWindowSize = dict["UpgradeObservationWindowSize"] as! String
            }
        }
    }
    public class Spec : Tea.TeaModel {
        public var apply: Bool?

        public var coolDownTime: String?

        public var cpuUsageUpperThreshold: Int32?

        public var downgrade: Bool?

        public var maxReadOnlyNodes: Int32?

        public var maxSpec: String?

        public var memUsageUpperThreshold: Int32?

        public var observationWindowSize: String?

        public var upgrade: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apply != nil {
                map["Apply"] = self.apply!
            }
            if self.coolDownTime != nil {
                map["CoolDownTime"] = self.coolDownTime!
            }
            if self.cpuUsageUpperThreshold != nil {
                map["CpuUsageUpperThreshold"] = self.cpuUsageUpperThreshold!
            }
            if self.downgrade != nil {
                map["Downgrade"] = self.downgrade!
            }
            if self.maxReadOnlyNodes != nil {
                map["MaxReadOnlyNodes"] = self.maxReadOnlyNodes!
            }
            if self.maxSpec != nil {
                map["MaxSpec"] = self.maxSpec!
            }
            if self.memUsageUpperThreshold != nil {
                map["MemUsageUpperThreshold"] = self.memUsageUpperThreshold!
            }
            if self.observationWindowSize != nil {
                map["ObservationWindowSize"] = self.observationWindowSize!
            }
            if self.upgrade != nil {
                map["Upgrade"] = self.upgrade!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Apply") {
                self.apply = dict["Apply"] as! Bool
            }
            if dict.keys.contains("CoolDownTime") {
                self.coolDownTime = dict["CoolDownTime"] as! String
            }
            if dict.keys.contains("CpuUsageUpperThreshold") {
                self.cpuUsageUpperThreshold = dict["CpuUsageUpperThreshold"] as! Int32
            }
            if dict.keys.contains("Downgrade") {
                self.downgrade = dict["Downgrade"] as! Bool
            }
            if dict.keys.contains("MaxReadOnlyNodes") {
                self.maxReadOnlyNodes = dict["MaxReadOnlyNodes"] as! Int32
            }
            if dict.keys.contains("MaxSpec") {
                self.maxSpec = dict["MaxSpec"] as! String
            }
            if dict.keys.contains("MemUsageUpperThreshold") {
                self.memUsageUpperThreshold = dict["MemUsageUpperThreshold"] as! Int32
            }
            if dict.keys.contains("ObservationWindowSize") {
                self.observationWindowSize = dict["ObservationWindowSize"] as! String
            }
            if dict.keys.contains("Upgrade") {
                self.upgrade = dict["Upgrade"] as! Bool
            }
        }
    }
    public class Storage : Tea.TeaModel {
        public var apply: Bool?

        public var diskUsageUpperThreshold: Int32?

        public var maxStorage: Int32?

        public var upgrade: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apply != nil {
                map["Apply"] = self.apply!
            }
            if self.diskUsageUpperThreshold != nil {
                map["DiskUsageUpperThreshold"] = self.diskUsageUpperThreshold!
            }
            if self.maxStorage != nil {
                map["MaxStorage"] = self.maxStorage!
            }
            if self.upgrade != nil {
                map["Upgrade"] = self.upgrade!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Apply") {
                self.apply = dict["Apply"] as! Bool
            }
            if dict.keys.contains("DiskUsageUpperThreshold") {
                self.diskUsageUpperThreshold = dict["DiskUsageUpperThreshold"] as! Int32
            }
            if dict.keys.contains("MaxStorage") {
                self.maxStorage = dict["MaxStorage"] as! Int32
            }
            if dict.keys.contains("Upgrade") {
                self.upgrade = dict["Upgrade"] as! Bool
            }
        }
    }
    public var bandwidth: ModifyAutoScalingConfigRequest.Bandwidth?

    public var instanceId: String?

    public var resource: ModifyAutoScalingConfigRequest.Resource?

    public var shard: ModifyAutoScalingConfigRequest.Shard?

    public var spec: ModifyAutoScalingConfigRequest.Spec?

    public var storage: ModifyAutoScalingConfigRequest.Storage?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bandwidth?.validate()
        try self.resource?.validate()
        try self.shard?.validate()
        try self.spec?.validate()
        try self.storage?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth?.toMap()
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.resource != nil {
            map["Resource"] = self.resource?.toMap()
        }
        if self.shard != nil {
            map["Shard"] = self.shard?.toMap()
        }
        if self.spec != nil {
            map["Spec"] = self.spec?.toMap()
        }
        if self.storage != nil {
            map["Storage"] = self.storage?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") {
            var model = ModifyAutoScalingConfigRequest.Bandwidth()
            model.fromMap(dict["Bandwidth"] as! [String: Any])
            self.bandwidth = model
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Resource") {
            var model = ModifyAutoScalingConfigRequest.Resource()
            model.fromMap(dict["Resource"] as! [String: Any])
            self.resource = model
        }
        if dict.keys.contains("Shard") {
            var model = ModifyAutoScalingConfigRequest.Shard()
            model.fromMap(dict["Shard"] as! [String: Any])
            self.shard = model
        }
        if dict.keys.contains("Spec") {
            var model = ModifyAutoScalingConfigRequest.Spec()
            model.fromMap(dict["Spec"] as! [String: Any])
            self.spec = model
        }
        if dict.keys.contains("Storage") {
            var model = ModifyAutoScalingConfigRequest.Storage()
            model.fromMap(dict["Storage"] as! [String: Any])
            self.storage = model
        }
    }
}

public class ModifyAutoScalingConfigResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ModifyAutoScalingConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAutoScalingConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyAutoScalingConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySqlLogConfigRequest : Tea.TeaModel {
    public class Filters : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var enable: Bool?

    public var filters: [ModifySqlLogConfigRequest.Filters]?

    public var hotRetention: Int32?

    public var instanceId: String?

    public var requestEnable: Bool?

    public var retention: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.filters != nil {
            var tmp : [Any] = []
            for k in self.filters! {
                tmp.append(k.toMap())
            }
            map["Filters"] = tmp
        }
        if self.hotRetention != nil {
            map["HotRetention"] = self.hotRetention!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestEnable != nil {
            map["RequestEnable"] = self.requestEnable!
        }
        if self.retention != nil {
            map["Retention"] = self.retention!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Enable") {
            self.enable = dict["Enable"] as! Bool
        }
        if dict.keys.contains("Filters") {
            var tmp : [ModifySqlLogConfigRequest.Filters] = []
            for v in dict["Filters"] as! [Any] {
                var model = ModifySqlLogConfigRequest.Filters()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filters = tmp
        }
        if dict.keys.contains("HotRetention") {
            self.hotRetention = dict["HotRetention"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestEnable") {
            self.requestEnable = dict["RequestEnable"] as! Bool
        }
        if dict.keys.contains("Retention") {
            self.retention = dict["Retention"] as! Int32
        }
    }
}

public class ModifySqlLogConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var coldEnable: Bool?

        public var coldRetention: Int32?

        public var coldStartTime: Int64?

        public var collectorVersion: String?

        public var hotEnable: Bool?

        public var hotRetention: Int32?

        public var hotStartTime: Int64?

        public var logFilter: String?

        public var requestEnable: Bool?

        public var requestStartTime: Int64?

        public var requestStopTime: Int64?

        public var retention: Int32?

        public var sqlLogEnable: Bool?

        public var sqlLogState: String?

        public var sqlLogVisibleTime: Int64?

        public var supportVersion: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.coldEnable != nil {
                map["ColdEnable"] = self.coldEnable!
            }
            if self.coldRetention != nil {
                map["ColdRetention"] = self.coldRetention!
            }
            if self.coldStartTime != nil {
                map["ColdStartTime"] = self.coldStartTime!
            }
            if self.collectorVersion != nil {
                map["CollectorVersion"] = self.collectorVersion!
            }
            if self.hotEnable != nil {
                map["HotEnable"] = self.hotEnable!
            }
            if self.hotRetention != nil {
                map["HotRetention"] = self.hotRetention!
            }
            if self.hotStartTime != nil {
                map["HotStartTime"] = self.hotStartTime!
            }
            if self.logFilter != nil {
                map["LogFilter"] = self.logFilter!
            }
            if self.requestEnable != nil {
                map["RequestEnable"] = self.requestEnable!
            }
            if self.requestStartTime != nil {
                map["RequestStartTime"] = self.requestStartTime!
            }
            if self.requestStopTime != nil {
                map["RequestStopTime"] = self.requestStopTime!
            }
            if self.retention != nil {
                map["Retention"] = self.retention!
            }
            if self.sqlLogEnable != nil {
                map["SqlLogEnable"] = self.sqlLogEnable!
            }
            if self.sqlLogState != nil {
                map["SqlLogState"] = self.sqlLogState!
            }
            if self.sqlLogVisibleTime != nil {
                map["SqlLogVisibleTime"] = self.sqlLogVisibleTime!
            }
            if self.supportVersion != nil {
                map["SupportVersion"] = self.supportVersion!
            }
            if self.version != nil {
                map["Version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ColdEnable") {
                self.coldEnable = dict["ColdEnable"] as! Bool
            }
            if dict.keys.contains("ColdRetention") {
                self.coldRetention = dict["ColdRetention"] as! Int32
            }
            if dict.keys.contains("ColdStartTime") {
                self.coldStartTime = dict["ColdStartTime"] as! Int64
            }
            if dict.keys.contains("CollectorVersion") {
                self.collectorVersion = dict["CollectorVersion"] as! String
            }
            if dict.keys.contains("HotEnable") {
                self.hotEnable = dict["HotEnable"] as! Bool
            }
            if dict.keys.contains("HotRetention") {
                self.hotRetention = dict["HotRetention"] as! Int32
            }
            if dict.keys.contains("HotStartTime") {
                self.hotStartTime = dict["HotStartTime"] as! Int64
            }
            if dict.keys.contains("LogFilter") {
                self.logFilter = dict["LogFilter"] as! String
            }
            if dict.keys.contains("RequestEnable") {
                self.requestEnable = dict["RequestEnable"] as! Bool
            }
            if dict.keys.contains("RequestStartTime") {
                self.requestStartTime = dict["RequestStartTime"] as! Int64
            }
            if dict.keys.contains("RequestStopTime") {
                self.requestStopTime = dict["RequestStopTime"] as! Int64
            }
            if dict.keys.contains("Retention") {
                self.retention = dict["Retention"] as! Int32
            }
            if dict.keys.contains("SqlLogEnable") {
                self.sqlLogEnable = dict["SqlLogEnable"] as! Bool
            }
            if dict.keys.contains("SqlLogState") {
                self.sqlLogState = dict["SqlLogState"] as! String
            }
            if dict.keys.contains("SqlLogVisibleTime") {
                self.sqlLogVisibleTime = dict["SqlLogVisibleTime"] as! Int64
            }
            if dict.keys.contains("SupportVersion") {
                self.supportVersion = dict["SupportVersion"] as! String
            }
            if dict.keys.contains("Version") {
                self.version = dict["Version"] as! String
            }
        }
    }
    public var code: String?

    public var data: ModifySqlLogConfigResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ModifySqlLogConfigResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class ModifySqlLogConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySqlLogConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySqlLogConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RunCloudBenchTaskRequest : Tea.TeaModel {
    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class RunCloudBenchTaskResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class PreCheckItem : Tea.TeaModel {
            public var code: Int32?

            public var details: String?

            public var message: String?

            public var name: String?

            public var order: Int32?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.details != nil {
                    map["Details"] = self.details!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.order != nil {
                    map["Order"] = self.order!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! Int32
                }
                if dict.keys.contains("Details") {
                    self.details = dict["Details"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Order") {
                    self.order = dict["Order"] as! Int32
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var preCheckItem: [RunCloudBenchTaskResponseBody.Data.PreCheckItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.preCheckItem != nil {
                var tmp : [Any] = []
                for k in self.preCheckItem! {
                    tmp.append(k.toMap())
                }
                map["PreCheckItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PreCheckItem") {
                var tmp : [RunCloudBenchTaskResponseBody.Data.PreCheckItem] = []
                for v in dict["PreCheckItem"] as! [Any] {
                    var model = RunCloudBenchTaskResponseBody.Data.PreCheckItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.preCheckItem = tmp
            }
        }
    }
    public var code: String?

    public var data: RunCloudBenchTaskResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = RunCloudBenchTaskResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class RunCloudBenchTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunCloudBenchTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RunCloudBenchTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SetEventSubscriptionRequest : Tea.TeaModel {
    public var active: String?

    public var channelType: String?

    public var contactGroupName: String?

    public var contactName: String?

    public var dispatchRule: String?

    public var eventContext: String?

    public var instanceId: String?

    public var lang: String?

    public var level: String?

    public var minInterval: String?

    public var severity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.active != nil {
            map["Active"] = self.active!
        }
        if self.channelType != nil {
            map["ChannelType"] = self.channelType!
        }
        if self.contactGroupName != nil {
            map["ContactGroupName"] = self.contactGroupName!
        }
        if self.contactName != nil {
            map["ContactName"] = self.contactName!
        }
        if self.dispatchRule != nil {
            map["DispatchRule"] = self.dispatchRule!
        }
        if self.eventContext != nil {
            map["EventContext"] = self.eventContext!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.level != nil {
            map["Level"] = self.level!
        }
        if self.minInterval != nil {
            map["MinInterval"] = self.minInterval!
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Active") {
            self.active = dict["Active"] as! String
        }
        if dict.keys.contains("ChannelType") {
            self.channelType = dict["ChannelType"] as! String
        }
        if dict.keys.contains("ContactGroupName") {
            self.contactGroupName = dict["ContactGroupName"] as! String
        }
        if dict.keys.contains("ContactName") {
            self.contactName = dict["ContactName"] as! String
        }
        if dict.keys.contains("DispatchRule") {
            self.dispatchRule = dict["DispatchRule"] as! String
        }
        if dict.keys.contains("EventContext") {
            self.eventContext = dict["EventContext"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Lang") {
            self.lang = dict["Lang"] as! String
        }
        if dict.keys.contains("Level") {
            self.level = dict["Level"] as! String
        }
        if dict.keys.contains("MinInterval") {
            self.minInterval = dict["MinInterval"] as! String
        }
        if dict.keys.contains("Severity") {
            self.severity = dict["Severity"] as! String
        }
    }
}

public class SetEventSubscriptionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var active: Int32?

        public var channelType: String?

        public var contactGroupName: String?

        public var contactName: String?

        public var eventContext: String?

        public var instanceId: String?

        public var lang: String?

        public var level: String?

        public var minInterval: Int32?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.active != nil {
                map["active"] = self.active!
            }
            if self.channelType != nil {
                map["channelType"] = self.channelType!
            }
            if self.contactGroupName != nil {
                map["contactGroupName"] = self.contactGroupName!
            }
            if self.contactName != nil {
                map["contactName"] = self.contactName!
            }
            if self.eventContext != nil {
                map["eventContext"] = self.eventContext!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.lang != nil {
                map["lang"] = self.lang!
            }
            if self.level != nil {
                map["level"] = self.level!
            }
            if self.minInterval != nil {
                map["minInterval"] = self.minInterval!
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("active") {
                self.active = dict["active"] as! Int32
            }
            if dict.keys.contains("channelType") {
                self.channelType = dict["channelType"] as! String
            }
            if dict.keys.contains("contactGroupName") {
                self.contactGroupName = dict["contactGroupName"] as! String
            }
            if dict.keys.contains("contactName") {
                self.contactName = dict["contactName"] as! String
            }
            if dict.keys.contains("eventContext") {
                self.eventContext = dict["eventContext"] as! String
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("lang") {
                self.lang = dict["lang"] as! String
            }
            if dict.keys.contains("level") {
                self.level = dict["level"] as! String
            }
            if dict.keys.contains("minInterval") {
                self.minInterval = dict["minInterval"] as! Int32
            }
            if dict.keys.contains("userId") {
                self.userId = dict["userId"] as! String
            }
        }
    }
    public var code: String?

    public var data: SetEventSubscriptionResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = SetEventSubscriptionResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class SetEventSubscriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetEventSubscriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SetEventSubscriptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAutoResourceOptimizeRulesAsyncRequest : Tea.TeaModel {
    public var consoleContext: String?

    public var instanceIds: String?

    public var resultId: String?

    public var tableFragmentationRatio: Double?

    public var tableSpaceSize: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.resultId != nil {
            map["ResultId"] = self.resultId!
        }
        if self.tableFragmentationRatio != nil {
            map["TableFragmentationRatio"] = self.tableFragmentationRatio!
        }
        if self.tableSpaceSize != nil {
            map["TableSpaceSize"] = self.tableSpaceSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsoleContext") {
            self.consoleContext = dict["ConsoleContext"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("ResultId") {
            self.resultId = dict["ResultId"] as! String
        }
        if dict.keys.contains("TableFragmentationRatio") {
            self.tableFragmentationRatio = dict["TableFragmentationRatio"] as! Double
        }
        if dict.keys.contains("TableSpaceSize") {
            self.tableSpaceSize = dict["TableSpaceSize"] as! Double
        }
    }
}

public class UpdateAutoResourceOptimizeRulesAsyncResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ConfigResponse : Tea.TeaModel {
            public class ConfigFailInstanceList : Tea.TeaModel {
                public var configSuccess: Bool?

                public var errorMessage: String?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.configSuccess != nil {
                        map["ConfigSuccess"] = self.configSuccess!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConfigSuccess") {
                        self.configSuccess = dict["ConfigSuccess"] as! Bool
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                }
            }
            public class ConfigSuccessInstanceList : Tea.TeaModel {
                public var configSuccess: Bool?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.configSuccess != nil {
                        map["ConfigSuccess"] = self.configSuccess!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConfigSuccess") {
                        self.configSuccess = dict["ConfigSuccess"] as! Bool
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                }
            }
            public var configFailInstanceCount: Int64?

            public var configFailInstanceList: [UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data.ConfigResponse.ConfigFailInstanceList]?

            public var configSuccessInstanceCount: Int64?

            public var configSuccessInstanceList: [UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data.ConfigResponse.ConfigSuccessInstanceList]?

            public var totalInstanceCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configFailInstanceCount != nil {
                    map["ConfigFailInstanceCount"] = self.configFailInstanceCount!
                }
                if self.configFailInstanceList != nil {
                    var tmp : [Any] = []
                    for k in self.configFailInstanceList! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigFailInstanceList"] = tmp
                }
                if self.configSuccessInstanceCount != nil {
                    map["ConfigSuccessInstanceCount"] = self.configSuccessInstanceCount!
                }
                if self.configSuccessInstanceList != nil {
                    var tmp : [Any] = []
                    for k in self.configSuccessInstanceList! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigSuccessInstanceList"] = tmp
                }
                if self.totalInstanceCount != nil {
                    map["TotalInstanceCount"] = self.totalInstanceCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigFailInstanceCount") {
                    self.configFailInstanceCount = dict["ConfigFailInstanceCount"] as! Int64
                }
                if dict.keys.contains("ConfigFailInstanceList") {
                    var tmp : [UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data.ConfigResponse.ConfigFailInstanceList] = []
                    for v in dict["ConfigFailInstanceList"] as! [Any] {
                        var model = UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data.ConfigResponse.ConfigFailInstanceList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.configFailInstanceList = tmp
                }
                if dict.keys.contains("ConfigSuccessInstanceCount") {
                    self.configSuccessInstanceCount = dict["ConfigSuccessInstanceCount"] as! Int64
                }
                if dict.keys.contains("ConfigSuccessInstanceList") {
                    var tmp : [UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data.ConfigResponse.ConfigSuccessInstanceList] = []
                    for v in dict["ConfigSuccessInstanceList"] as! [Any] {
                        var model = UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data.ConfigResponse.ConfigSuccessInstanceList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.configSuccessInstanceList = tmp
                }
                if dict.keys.contains("TotalInstanceCount") {
                    self.totalInstanceCount = dict["TotalInstanceCount"] as! Int64
                }
            }
        }
        public var complete: Bool?

        public var configResponse: UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data.ConfigResponse?

        public var fail: Bool?

        public var isFinish: Bool?

        public var resultId: String?

        public var state: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.configResponse?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complete != nil {
                map["Complete"] = self.complete!
            }
            if self.configResponse != nil {
                map["ConfigResponse"] = self.configResponse?.toMap()
            }
            if self.fail != nil {
                map["Fail"] = self.fail!
            }
            if self.isFinish != nil {
                map["IsFinish"] = self.isFinish!
            }
            if self.resultId != nil {
                map["ResultId"] = self.resultId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Complete") {
                self.complete = dict["Complete"] as! Bool
            }
            if dict.keys.contains("ConfigResponse") {
                var model = UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data.ConfigResponse()
                model.fromMap(dict["ConfigResponse"] as! [String: Any])
                self.configResponse = model
            }
            if dict.keys.contains("Fail") {
                self.fail = dict["Fail"] as! Bool
            }
            if dict.keys.contains("IsFinish") {
                self.isFinish = dict["IsFinish"] as! Bool
            }
            if dict.keys.contains("ResultId") {
                self.resultId = dict["ResultId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
        }
    }
    public var code: Int64?

    public var data: UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = UpdateAutoResourceOptimizeRulesAsyncResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateAutoResourceOptimizeRulesAsyncResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAutoResourceOptimizeRulesAsyncResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAutoResourceOptimizeRulesAsyncResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAutoSqlOptimizeStatusRequest : Tea.TeaModel {
    public var instances: String?

    public var status: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            map["Instances"] = self.instances!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") {
            self.instances = dict["Instances"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! Int32
        }
    }
}

public class UpdateAutoSqlOptimizeStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var errorCode: String?

        public var errorMsg: String?

        public var success: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.errorCode != nil {
                map["ErrorCode"] = self.errorCode!
            }
            if self.errorMsg != nil {
                map["ErrorMsg"] = self.errorMsg!
            }
            if self.success != nil {
                map["Success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ErrorCode") {
                self.errorCode = dict["ErrorCode"] as! String
            }
            if dict.keys.contains("ErrorMsg") {
                self.errorMsg = dict["ErrorMsg"] as! String
            }
            if dict.keys.contains("Success") {
                self.success = dict["Success"] as! String
            }
        }
    }
    public var code: String?

    public var data: UpdateAutoSqlOptimizeStatusResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = UpdateAutoSqlOptimizeStatusResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! String
        }
    }
}

public class UpdateAutoSqlOptimizeStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAutoSqlOptimizeStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAutoSqlOptimizeStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAutoThrottleRulesAsyncRequest : Tea.TeaModel {
    public var abnormalDuration: Double?

    public var activeSessions: Int64?

    public var allowThrottleEndTime: String?

    public var allowThrottleStartTime: String?

    public var autoKillSession: Bool?

    public var consoleContext: String?

    public var cpuSessionRelation: String?

    public var cpuUsage: Double?

    public var instanceIds: String?

    public var maxThrottleTime: Double?

    public var resultId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.abnormalDuration != nil {
            map["AbnormalDuration"] = self.abnormalDuration!
        }
        if self.activeSessions != nil {
            map["ActiveSessions"] = self.activeSessions!
        }
        if self.allowThrottleEndTime != nil {
            map["AllowThrottleEndTime"] = self.allowThrottleEndTime!
        }
        if self.allowThrottleStartTime != nil {
            map["AllowThrottleStartTime"] = self.allowThrottleStartTime!
        }
        if self.autoKillSession != nil {
            map["AutoKillSession"] = self.autoKillSession!
        }
        if self.consoleContext != nil {
            map["ConsoleContext"] = self.consoleContext!
        }
        if self.cpuSessionRelation != nil {
            map["CpuSessionRelation"] = self.cpuSessionRelation!
        }
        if self.cpuUsage != nil {
            map["CpuUsage"] = self.cpuUsage!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.maxThrottleTime != nil {
            map["MaxThrottleTime"] = self.maxThrottleTime!
        }
        if self.resultId != nil {
            map["ResultId"] = self.resultId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AbnormalDuration") {
            self.abnormalDuration = dict["AbnormalDuration"] as! Double
        }
        if dict.keys.contains("ActiveSessions") {
            self.activeSessions = dict["ActiveSessions"] as! Int64
        }
        if dict.keys.contains("AllowThrottleEndTime") {
            self.allowThrottleEndTime = dict["AllowThrottleEndTime"] as! String
        }
        if dict.keys.contains("AllowThrottleStartTime") {
            self.allowThrottleStartTime = dict["AllowThrottleStartTime"] as! String
        }
        if dict.keys.contains("AutoKillSession") {
            self.autoKillSession = dict["AutoKillSession"] as! Bool
        }
        if dict.keys.contains("ConsoleContext") {
            self.consoleContext = dict["ConsoleContext"] as! String
        }
        if dict.keys.contains("CpuSessionRelation") {
            self.cpuSessionRelation = dict["CpuSessionRelation"] as! String
        }
        if dict.keys.contains("CpuUsage") {
            self.cpuUsage = dict["CpuUsage"] as! Double
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("MaxThrottleTime") {
            self.maxThrottleTime = dict["MaxThrottleTime"] as! Double
        }
        if dict.keys.contains("ResultId") {
            self.resultId = dict["ResultId"] as! String
        }
    }
}

public class UpdateAutoThrottleRulesAsyncResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ConfigResponse : Tea.TeaModel {
            public class ConfigFailInstanceList : Tea.TeaModel {
                public var configSuccess: Bool?

                public var errorMessage: String?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.configSuccess != nil {
                        map["ConfigSuccess"] = self.configSuccess!
                    }
                    if self.errorMessage != nil {
                        map["ErrorMessage"] = self.errorMessage!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConfigSuccess") {
                        self.configSuccess = dict["ConfigSuccess"] as! Bool
                    }
                    if dict.keys.contains("ErrorMessage") {
                        self.errorMessage = dict["ErrorMessage"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                }
            }
            public class ConfigSuccessInstanceList : Tea.TeaModel {
                public var configSuccess: Bool?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.configSuccess != nil {
                        map["ConfigSuccess"] = self.configSuccess!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConfigSuccess") {
                        self.configSuccess = dict["ConfigSuccess"] as! Bool
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                }
            }
            public var configFailInstanceCount: Int64?

            public var configFailInstanceList: [UpdateAutoThrottleRulesAsyncResponseBody.Data.ConfigResponse.ConfigFailInstanceList]?

            public var configSuccessInstanceCount: Int64?

            public var configSuccessInstanceList: [UpdateAutoThrottleRulesAsyncResponseBody.Data.ConfigResponse.ConfigSuccessInstanceList]?

            public var totalInstanceCount: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configFailInstanceCount != nil {
                    map["ConfigFailInstanceCount"] = self.configFailInstanceCount!
                }
                if self.configFailInstanceList != nil {
                    var tmp : [Any] = []
                    for k in self.configFailInstanceList! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigFailInstanceList"] = tmp
                }
                if self.configSuccessInstanceCount != nil {
                    map["ConfigSuccessInstanceCount"] = self.configSuccessInstanceCount!
                }
                if self.configSuccessInstanceList != nil {
                    var tmp : [Any] = []
                    for k in self.configSuccessInstanceList! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigSuccessInstanceList"] = tmp
                }
                if self.totalInstanceCount != nil {
                    map["TotalInstanceCount"] = self.totalInstanceCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigFailInstanceCount") {
                    self.configFailInstanceCount = dict["ConfigFailInstanceCount"] as! Int64
                }
                if dict.keys.contains("ConfigFailInstanceList") {
                    var tmp : [UpdateAutoThrottleRulesAsyncResponseBody.Data.ConfigResponse.ConfigFailInstanceList] = []
                    for v in dict["ConfigFailInstanceList"] as! [Any] {
                        var model = UpdateAutoThrottleRulesAsyncResponseBody.Data.ConfigResponse.ConfigFailInstanceList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.configFailInstanceList = tmp
                }
                if dict.keys.contains("ConfigSuccessInstanceCount") {
                    self.configSuccessInstanceCount = dict["ConfigSuccessInstanceCount"] as! Int64
                }
                if dict.keys.contains("ConfigSuccessInstanceList") {
                    var tmp : [UpdateAutoThrottleRulesAsyncResponseBody.Data.ConfigResponse.ConfigSuccessInstanceList] = []
                    for v in dict["ConfigSuccessInstanceList"] as! [Any] {
                        var model = UpdateAutoThrottleRulesAsyncResponseBody.Data.ConfigResponse.ConfigSuccessInstanceList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.configSuccessInstanceList = tmp
                }
                if dict.keys.contains("TotalInstanceCount") {
                    self.totalInstanceCount = dict["TotalInstanceCount"] as! Int64
                }
            }
        }
        public var complete: Bool?

        public var configResponse: UpdateAutoThrottleRulesAsyncResponseBody.Data.ConfigResponse?

        public var fail: Bool?

        public var isFinish: Bool?

        public var resultId: String?

        public var state: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.configResponse?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.complete != nil {
                map["Complete"] = self.complete!
            }
            if self.configResponse != nil {
                map["ConfigResponse"] = self.configResponse?.toMap()
            }
            if self.fail != nil {
                map["Fail"] = self.fail!
            }
            if self.isFinish != nil {
                map["IsFinish"] = self.isFinish!
            }
            if self.resultId != nil {
                map["ResultId"] = self.resultId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.timestamp != nil {
                map["Timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Complete") {
                self.complete = dict["Complete"] as! Bool
            }
            if dict.keys.contains("ConfigResponse") {
                var model = UpdateAutoThrottleRulesAsyncResponseBody.Data.ConfigResponse()
                model.fromMap(dict["ConfigResponse"] as! [String: Any])
                self.configResponse = model
            }
            if dict.keys.contains("Fail") {
                self.fail = dict["Fail"] as! Bool
            }
            if dict.keys.contains("IsFinish") {
                self.isFinish = dict["IsFinish"] as! Bool
            }
            if dict.keys.contains("ResultId") {
                self.resultId = dict["ResultId"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Timestamp") {
                self.timestamp = dict["Timestamp"] as! Int64
            }
        }
    }
    public var code: Int64?

    public var data: UpdateAutoThrottleRulesAsyncResponseBody.Data?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! Int64
        }
        if dict.keys.contains("Data") {
            var model = UpdateAutoThrottleRulesAsyncResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class UpdateAutoThrottleRulesAsyncResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAutoThrottleRulesAsyncResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAutoThrottleRulesAsyncResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
